{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/vexo/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/vexo/source/js/qrious.js","path":"js/qrious.js","modified":1,"renderable":1},{"_id":"themes/vexo/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/catalog.png","path":"css/images/catalog.png","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/escheres.png","path":"css/images/escheres.png","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/favi.png","path":"css/images/favi.png","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/logo.png","path":"css/images/logo.png","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/menu.png","path":"css/images/menu.png","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/images/top.png","path":"css/images/top.png","modified":1,"renderable":1},{"_id":"themes/vexo/source/css/plugins/gitment.css","path":"css/plugins/gitment.css","modified":1,"renderable":1},{"_id":"themes/vexo/source/fonts/SourceSansPro.ttf","path":"fonts/SourceSansPro.ttf","modified":1,"renderable":1},{"_id":"themes/vexo/source/js/gitment.js","path":"js/gitment.js","modified":1,"renderable":1},{"_id":"themes/vexo/source/fonts/NanumSquare/NanumSquareRegular.woff2","path":"fonts/NanumSquare/NanumSquareRegular.woff2","modified":1,"renderable":1},{"_id":"themes/vexo/source/fonts/NanumSquare/NanumSquareBold.woff2","path":"fonts/NanumSquare/NanumSquareBold.woff2","modified":1,"renderable":1},{"_id":"themes/vexo/source/fonts/NanumSquare/NanumSquareExtraBold.woff2","path":"fonts/NanumSquare/NanumSquareExtraBold.woff2","modified":1,"renderable":1},{"_id":"themes/vexo/source/fonts/NanumSquare/NanumSquareLight.woff2","path":"fonts/NanumSquare/NanumSquareLight.woff2","modified":1,"renderable":1},{"_id":"themes/vexo/source/fonts/NanumSquare/NanumSquareBold.woff","path":"fonts/NanumSquare/NanumSquareBold.woff","modified":1,"renderable":1},{"_id":"themes/vexo/source/fonts/NanumSquare/NanumSquareExtraBold.woff","path":"fonts/NanumSquare/NanumSquareExtraBold.woff","modified":1,"renderable":1},{"_id":"themes/vexo/source/fonts/NanumSquare/NanumSquareLight.woff","path":"fonts/NanumSquare/NanumSquareLight.woff","modified":1,"renderable":1},{"_id":"themes/vexo/source/fonts/NanumSquare/NanumSquareRegular.woff","path":"fonts/NanumSquare/NanumSquareRegular.woff","modified":1,"renderable":1},{"_id":"themes/vexo/source/fonts/NanumSquare/NanumSquareBold.eot","path":"fonts/NanumSquare/NanumSquareBold.eot","modified":1,"renderable":1},{"_id":"themes/vexo/source/fonts/NanumSquare/NanumSquareBold.ttf","path":"fonts/NanumSquare/NanumSquareBold.ttf","modified":1,"renderable":1},{"_id":"themes/vexo/source/fonts/NanumSquare/NanumSquareExtraBold.eot","path":"fonts/NanumSquare/NanumSquareExtraBold.eot","modified":1,"renderable":1},{"_id":"themes/vexo/source/fonts/NanumSquare/NanumSquareExtraBold.ttf","path":"fonts/NanumSquare/NanumSquareExtraBold.ttf","modified":1,"renderable":1},{"_id":"themes/vexo/source/fonts/NanumSquare/NanumSquareLight.eot","path":"fonts/NanumSquare/NanumSquareLight.eot","modified":1,"renderable":1},{"_id":"themes/vexo/source/fonts/NanumSquare/NanumSquareLight.ttf","path":"fonts/NanumSquare/NanumSquareLight.ttf","modified":1,"renderable":1},{"_id":"themes/vexo/source/fonts/NanumSquare/NanumSquareRegular.eot","path":"fonts/NanumSquare/NanumSquareRegular.eot","modified":1,"renderable":1},{"_id":"themes/vexo/source/fonts/NanumSquare/NanumSquareRegular.ttf","path":"fonts/NanumSquare/NanumSquareRegular.ttf","modified":1,"renderable":1}],"Cache":[{"_id":"themes/vexo/.gitignore","hash":"37fb9fd49e7f944716efd3284a6bf55adb6dd0c2","modified":1510848145047},{"_id":"source/.DS_Store","hash":"afd2e04b644c4260029d64c3b473a783632832f0","modified":1506932528000},{"_id":"themes/vexo/.travis.yml","hash":"cc482f06f4ea6962058f2548dcb814b954876e76","modified":1510848145048},{"_id":"themes/vexo/LICENSE","hash":"3e135cd69c0e02c0a49dd43d571f600223cc61d1","modified":1510848145048},{"_id":"themes/vexo/.DS_Store","hash":"4c577c60e2ee4ccd33e8151d38869af6b1b1a5e7","modified":1511241159274},{"_id":"themes/vexo/_config.yml","hash":"523865afb5341b20e4282e0b82ca8a0493da2d9d","modified":1511256015848},{"_id":"themes/vexo/README.md","hash":"036ddc66e868b93411a15ed3fd5ed5e9101045a5","modified":1510848145048},{"_id":"themes/vexo/lint.sh","hash":"f580302e4aa9ccfb95a253851da6501d145613fe","modified":1510848145055},{"_id":"themes/vexo/package.json","hash":"8852c5a394ac59d219e5bbbcee10d573d33e1fc6","modified":1510848145055},{"_id":"source/_posts/.DS_Store","hash":"c08f91ea02019bc5002979dd8622f8b08f7c7b3f","modified":1505975083000},{"_id":"source/about/index.md","hash":"68c8af0453deca5f6b03eb18ee6f89fb0c1f1f75","modified":1510907519218},{"_id":"source/project/index.md","hash":"b8f5482c157514bd2df4ce8a4e4d01a957497924","modified":1510907519219},{"_id":"source/tags/index.md","hash":"80a15f1b5daff22b04849109e976bc91a410b83e","modified":1510907519220},{"_id":"themes/vexo/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1510848145040},{"_id":"themes/vexo/.git/config","hash":"9cf891bec062e2138910d9c40051c4d656da1345","modified":1510848145042},{"_id":"themes/vexo/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1510848142735},{"_id":"themes/vexo/.git/index","hash":"2e36dd8ed90d83ddce274c0cdc57c1da9869d122","modified":1510848160157},{"_id":"themes/vexo/.git/packed-refs","hash":"70c0fc021644054c2ea5b2d2bd4b5d753f31ac90","modified":1510848145038},{"_id":"themes/vexo/_source/.DS_Store","hash":"a95a086c7c233e2143b13a8584a2be64d29f9a6a","modified":1510911484314},{"_id":"themes/vexo/source/.DS_Store","hash":"71e28d269c19b0ce2acaf71c7ec6516afa1579b6","modified":1511246012042},{"_id":"source/_posts/GIT/01.git-connect-github.md","hash":"5e0bc893d05745b5dfb4154512d30a4260017398","modified":1510910657117},{"_id":"source/_posts/GIT/.DS_Store","hash":"8a18464894f6c57202a3fd1a2116b169e69d0379","modified":1505977309000},{"_id":"source/_posts/GIT/03.inner.md","hash":"402155620fae601859108445aa90087ff34fc8ff","modified":1511785261237},{"_id":"source/_posts/GIT/02.diffrence-branch-command.md","hash":"46d0213f3b20acb670686dc8faa11d4e966b7041","modified":1510910661216},{"_id":"source/_posts/React/01.basic.md","hash":"a732f8396cac19c2f3f32784951c482fa7c56ea5","modified":1511259040591},{"_id":"source/_posts/Log/01.dada-log-01.md","hash":"13ac199f46a76746dee71fbfe68ab2859192b179","modified":1510848791788},{"_id":"source/_posts/Javascript/01.Object.md","hash":"9e59d574c59bb70762d657e7eb0e1f170cb2b18d","modified":1505973179000},{"_id":"source/_posts/Javascript/.DS_Store","hash":"ed1cc58dc9309d1f13b169fa75ef4575c2fab074","modified":1505975017000},{"_id":"source/_posts/Javascript/02.Prototype.md","hash":"34e9dbade69a07747a4420f196a42c86a9779edb","modified":1505973183000},{"_id":"source/_posts/Javascript/03.Closure.md","hash":"b5b99ae65a452a85237e181cf7ddc4d9298db0ea","modified":1505973175000},{"_id":"source/_posts/Javascript/04.Async,EventLoop.md","hash":"5ea67135a9f8db5f63aa8c42300b730cef78919c","modified":1505973163000},{"_id":"source/_posts/SCSS/02.extensions.md","hash":"be931e00dbdda38454c190fd6026bf0649fa6fd3","modified":1505974948000},{"_id":"source/_posts/SCSS/03.sassScript.md","hash":"0c4fd09bd8d4f8db543c80b68afdc4a398e2fa59","modified":1505974942000},{"_id":"source/_posts/nodejs/00.POST VS PUT.md","hash":"8f2face9cbbb0182fc3ef28136b8252ec13c903a","modified":1505974006000},{"_id":"source/_posts/nodejs/.DS_Store","hash":"bd39620e1318d676032a4e0d843b395f40852c5e","modified":1505975072000},{"_id":"source/_posts/nodejs/02.http.md","hash":"faecc95406b96a9312f5ce25a8bdd1205d48ebcd","modified":1505974021000},{"_id":"source/_posts/nodejs/01.basic.md","hash":"9f0e0e99e7cb5aa0f5befea9045f0e5e60562bbc","modified":1505974022000},{"_id":"source/_posts/nodejs/04.Template Language.md","hash":"6b1f0d4c9ee2906ee4a3a6d204c044a1d660c704","modified":1505974018000},{"_id":"source/_posts/nodejs/03.Middleware.md","hash":"5411bc59d16e2c839dbac8e8e1f178721a443858","modified":1505974021000},{"_id":"source/_posts/nodejs/05.Web form.md","hash":"4be292c3bdd4c583416bf85cafd86b8b82c258f4","modified":1505974017000},{"_id":"source/_posts/nodejs/06.service development.md","hash":"1310b39efa6fde504c7d2b73132c579e8f019644","modified":1505974015000},{"_id":"source/_posts/nodejs/08.cookie.md","hash":"af0ad00901c251f395a6e21c3777772e169a319c","modified":1505974011000},{"_id":"source/_posts/nodejs/07.Express Middleware.md","hash":"41d696091cf70feea9cd2a0f700fe4420a41422f","modified":1505974013000},{"_id":"source/_posts/nodejs/09.session.md","hash":"ea104a5bdc67aef234a8485aeab6ad02e5182f6e","modified":1511785485000},{"_id":"source/_posts/nodejs/10.how-to-uninstall-node.md","hash":"c26d17ea5ce583c65954d668d901e3731678bcbb","modified":1511789483446},{"_id":"themes/vexo/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1510848142735},{"_id":"themes/vexo/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1510848142738},{"_id":"themes/vexo/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1510848142736},{"_id":"themes/vexo/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1510848142739},{"_id":"themes/vexo/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1510848142740},{"_id":"themes/vexo/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1510848142737},{"_id":"themes/vexo/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1510848142740},{"_id":"themes/vexo/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1510848142736},{"_id":"themes/vexo/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1510848142738},{"_id":"themes/vexo/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1510848142739},{"_id":"themes/vexo/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1510848142741},{"_id":"themes/vexo/.git/layout/about.ejs","hash":"4ce0291c40cbe834b684839c0ffb35a5090c0236","modified":1510848145053},{"_id":"themes/vexo/.git/layout/archive.ejs","hash":"c93652117499442137139b90cc73bb0e46cf8580","modified":1510904451056},{"_id":"themes/vexo/.git/layout/index.ejs","hash":"9f12f5928d68d4d68175b825e18f89f3b0dfdb69","modified":1510848145053},{"_id":"themes/vexo/.git/layout/layout.ejs","hash":"a7b8f1debdca12d667ecd1bcc3d4bc6e13a23d7b","modified":1510848145054},{"_id":"themes/vexo/.git/layout/page.ejs","hash":"b63099f996aaf4d20d6d7641d598c1662d73ee6b","modified":1510906792027},{"_id":"themes/vexo/.git/layout/project.ejs","hash":"04df1c405227e4e34e3ec214d82a825a731af695","modified":1510911209277},{"_id":"themes/vexo/.git/layout/tags.ejs","hash":"2a56301bd0d304797d904ccf6c15a7f857d0ba5e","modified":1510907257988},{"_id":"themes/vexo/.git/logs/HEAD","hash":"43f22333a1aae14bfcfebe1c0fb59988efa51798","modified":1510848145041},{"_id":"themes/vexo/_source/about/index.md","hash":"68c8af0453deca5f6b03eb18ee6f89fb0c1f1f75","modified":1510848145049},{"_id":"themes/vexo/_source/project/index.md","hash":"b8f5482c157514bd2df4ce8a4e4d01a957497924","modified":1510848145049},{"_id":"themes/vexo/_source/tags/index.md","hash":"80a15f1b5daff22b04849109e976bc91a410b83e","modified":1510848145049},{"_id":"themes/vexo/source/css/.DS_Store","hash":"23126d64f7d6471364b59b377f2a797e71698b3a","modified":1510908199709},{"_id":"themes/vexo/source/css/_config.styl","hash":"f24b702d87637aa25691804816891f3553f5e47b","modified":1511257277120},{"_id":"themes/vexo/source/css/_mixins.styl","hash":"42100c532b90e226144cc7626719a690810f4853","modified":1511247370542},{"_id":"themes/vexo/source/css/style.styl","hash":"a62c9288538cec839f4b8eb5fe50c7d0f1e7daea","modified":1511255708890},{"_id":"themes/vexo/source/fonts/.DS_Store","hash":"6bb9b4db41d993e4cadb3cd8daf9e583ebb77409","modified":1511246014750},{"_id":"themes/vexo/source/js/qrious.js","hash":"a9271e81e2ac6a692b1c133811afa33f0f3d7dc5","modified":1510848145065},{"_id":"themes/vexo/source/js/script.js","hash":"a7ccb828384adcc90f4758bd6de7650223f37978","modified":1510848145066},{"_id":"themes/vexo/.git/layout/_partial/archive.ejs","hash":"9abbf14034d581569c0b6c992fe22035cb5306b3","modified":1510848145050},{"_id":"themes/vexo/.git/layout/_partial/catalog.ejs","hash":"0352ce39c28074dcfc3bd6416680195eeb384fd1","modified":1510848145050},{"_id":"themes/vexo/.git/layout/_partial/footer.ejs","hash":"6032a4dcc6224ad916b7898d54e91552c17396ce","modified":1510848145051},{"_id":"themes/vexo/.git/layout/_partial/head.ejs","hash":"9c2cb91d07c78657eb6723a1629fee96dc5b2176","modified":1510909012826},{"_id":"themes/vexo/.git/layout/_partial/header.ejs","hash":"8424e2add3865d1be1ec2efa11dbfb8f4bed6d18","modified":1510913662866},{"_id":"themes/vexo/.git/layout/_partial/pager.ejs","hash":"3a1b9680fbfa3baa76933c7c17216996381ad241","modified":1510848145052},{"_id":"themes/vexo/.git/layout/_partial/tag.ejs","hash":"5d2a2c3f8ca7000945ab426a0c6939421974b224","modified":1510848145052},{"_id":"themes/vexo/.git/layout/_partial/top.ejs","hash":"f09dea486246a580213005b21d4b38810dd16fb3","modified":1510848145052},{"_id":"themes/vexo/.git/refs/heads/master","hash":"394c051453774fa332214f5e331a410bc6f82aad","modified":1510848145041},{"_id":"themes/vexo/.git/objects/pack/pack-bd722b8febb8edb9418a5bd62f05332a39481dd8.idx","hash":"1bb5dc79a8afcf9df1cde40c73ab49ee78a5d355","modified":1510848145025},{"_id":"themes/vexo/source/css/_partial/about.styl","hash":"e4a9bffe9c44c3179c021e2d924386ff9f758399","modified":1510848145056},{"_id":"themes/vexo/source/css/_partial/archive.styl","hash":"e80ddf26f2af3523632afeabd57f81592537985a","modified":1510848145057},{"_id":"themes/vexo/source/css/_partial/catalog.styl","hash":"088ddea7aa1b00c28289c401862f09d4897356dc","modified":1510848145057},{"_id":"themes/vexo/source/css/_partial/footer.styl","hash":"970b6fd3d05834926c69724934b798dd5a1472e6","modified":1510848145057},{"_id":"themes/vexo/source/css/_partial/header.styl","hash":"607fe12042925f19b88110d4d0da9d45cef2c04b","modified":1510909437000},{"_id":"themes/vexo/source/css/_partial/markdown.styl","hash":"5922b3005661a4cca4a3e21095289c91ab170a33","modified":1511256829306},{"_id":"themes/vexo/source/css/_partial/pager.styl","hash":"888384c67429c7568aa38b5ebe5acae3cc4de367","modified":1510848145058},{"_id":"themes/vexo/source/css/_partial/project.styl","hash":"e9b6faadf4852bce3a4141cba0a102a7afb81e9f","modified":1510848145058},{"_id":"themes/vexo/source/css/_partial/tags.styl","hash":"5198a7f7c221341138ae5c65185e86b6e13e8e26","modified":1510848145059},{"_id":"themes/vexo/source/css/images/catalog.png","hash":"541d20dd600fc2c9230329ceb6885d86e6c151dd","modified":1510848145060},{"_id":"themes/vexo/source/css/images/escheres.png","hash":"55deece3236dcc2fb44c28dec3e8bacbb7b46542","modified":1510848145060},{"_id":"themes/vexo/source/css/images/.DS_Store","hash":"5f4fb4c1dfde4851d65fe58cc1f2990a2ab4460c","modified":1510914458989},{"_id":"themes/vexo/source/css/images/favi.png","hash":"b12277398532f45a7591bfb0b2950fe18e5ce27f","modified":1510911382745},{"_id":"themes/vexo/source/css/images/logo.png","hash":"a88866ae9828e56b47ad62cf8a7273ea53cd6724","modified":1510913684680},{"_id":"themes/vexo/source/css/images/menu.png","hash":"bdaa35eb1ed119caeb934e15a05b9f4a5396d957","modified":1510848145060},{"_id":"themes/vexo/source/css/images/top.png","hash":"611a257907474ca02828319f81b006c1d818bb84","modified":1510848145061},{"_id":"themes/vexo/source/css/plugins/gitment.css","hash":"541ff18d7f3542b5663dc6aad06d43e135332b71","modified":1510848145062},{"_id":"themes/vexo/source/fonts/SourceSansPro.ttf","hash":"1e9f0372c269da205fdbac8cf27cb9cf59f6ad45","modified":1510848145064},{"_id":"themes/vexo/source/js/gitment.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1510848145065},{"_id":"themes/vexo/.git/logs/refs/heads/master","hash":"43f22333a1aae14bfcfebe1c0fb59988efa51798","modified":1510848145041},{"_id":"themes/vexo/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1510848145039},{"_id":"themes/vexo/source/fonts/NanumSquare/NanumSquareRegular.woff2","hash":"5d488bdc90e048c500fcaa9f155bb03e453120e7","modified":1511243158187},{"_id":"themes/vexo/source/fonts/NanumSquare/NanumSquareBold.woff2","hash":"956331530c67e2af54e4fb028a3647e72a0d171c","modified":1511243150777},{"_id":"themes/vexo/source/fonts/NanumSquare/NanumSquareExtraBold.woff2","hash":"a048f5b82f3ae1ce4f00fcbe8a517a362f38c629","modified":1511243152652},{"_id":"themes/vexo/source/fonts/NanumSquare/NanumSquareLight.woff2","hash":"516a8e73679286543a48e3171a97972c2df255e8","modified":1511243155056},{"_id":"themes/vexo/.git/logs/refs/remotes/origin/HEAD","hash":"43f22333a1aae14bfcfebe1c0fb59988efa51798","modified":1510848145039},{"_id":"themes/vexo/.git/objects/pack/pack-bd722b8febb8edb9418a5bd62f05332a39481dd8.pack","hash":"3c730e2171b94548ea4398d607e189d653a14689","modified":1510848145024},{"_id":"themes/vexo/source/fonts/NanumSquare/NanumSquareBold.woff","hash":"230d39e63f31c6882a70c13e464da927bd782fe8","modified":1511243139770},{"_id":"themes/vexo/source/fonts/NanumSquare/NanumSquareExtraBold.woff","hash":"3ec35935ccdf7547f5b802b0b283bfbb5983f3c3","modified":1511243151769},{"_id":"themes/vexo/source/fonts/NanumSquare/NanumSquareLight.woff","hash":"d04a590aa46b6cd18d814d836e108bb6340dc191","modified":1511243154247},{"_id":"themes/vexo/source/fonts/NanumSquare/NanumSquareRegular.woff","hash":"439c3fe9185eb8af82931fe1b7dbea1f83921c7d","modified":1511243156178},{"_id":"themes/vexo/source/fonts/NanumSquare/NanumSquareBold.eot","hash":"1aa012372b531e9483f2c91ee3c2818f267d955d","modified":1511243136944},{"_id":"themes/vexo/source/fonts/NanumSquare/NanumSquareBold.ttf","hash":"8987ee230c6f11d1b1475422de16a173b1225171","modified":1466652610000},{"_id":"themes/vexo/source/fonts/NanumSquare/NanumSquareExtraBold.eot","hash":"118ab9478527b696b6c23a12fe012b70b66a8dd7","modified":1511243147503},{"_id":"themes/vexo/source/fonts/NanumSquare/NanumSquareExtraBold.ttf","hash":"757cdae4e4a80d08f9901c42e7c555cc0a012475","modified":1466652620000},{"_id":"themes/vexo/source/fonts/NanumSquare/NanumSquareLight.eot","hash":"e2a70161278e1b1026a52882d84896a57cef62d5","modified":1511243153434},{"_id":"themes/vexo/source/fonts/NanumSquare/NanumSquareLight.ttf","hash":"a45331545555c353ecfdb9b117e7ffee947d5ad4","modified":1466652594000},{"_id":"themes/vexo/source/fonts/NanumSquare/NanumSquareRegular.eot","hash":"84fa6e57261c32d04469a9cfda259b16c57d0c37","modified":1511243157142},{"_id":"themes/vexo/source/fonts/NanumSquare/NanumSquareRegular.ttf","hash":"1afd6f8457b0195144f2fc8852f97370415bb229","modified":1466652602000},{"_id":"public/css/images/catalog.png","hash":"e54989716d7125e336dfa47c1a5af56b47cddd14","modified":1511789569107},{"_id":"public/css/images/escheres.png","hash":"6ec5c325f34f988371359ee7d6d0346cd93f24fe","modified":1511789569108},{"_id":"public/css/images/favi.png","hash":"68edd1b45cf5b994985ecba7c12ab0121706a110","modified":1511789574269},{"_id":"public/css/images/logo.png","hash":"8235e35020ecb11f4ec6c732ccc351bf0521253c","modified":1511789574272},{"_id":"public/css/images/menu.png","hash":"8e8ea2d315761e1fa69848c7706220495256e4ed","modified":1511789574291},{"_id":"public/css/images/top.png","hash":"31edee92b4512028581f4d1855221d443ac38e6a","modified":1511789574291},{"_id":"public/feed.xml","hash":"71044f78e50c1f9df64cac8caf83e0817227face","modified":1511789574292},{"_id":"public/content.json","hash":"0f764d8db4e900742673a1bbd5da048a4fad8db9","modified":1511789574292},{"_id":"public/post-sitemap.xml","hash":"c9396336ef284ecc2e320e9eb432ae70b316b721","modified":1511789574292},{"_id":"public/page-sitemap.xml","hash":"c2ccc5f83c43df6b4b9074481349fe2d904079bb","modified":1511789574293},{"_id":"public/category-sitemap.xml","hash":"06aa70554c669c2a1db5e16d7175996be7a0aff2","modified":1511789574294},{"_id":"public/tag-sitemap.xml","hash":"80655295ed92bcbfb80093013e706ce05d5ee436","modified":1511789574294},{"_id":"public/sitemap.xsl","hash":"4321fa69dc1b8811d32b7a1478e5603e038cea1a","modified":1511789574294},{"_id":"public/sitemap.xml","hash":"9f734cba54dfcda8e72de57c7a780a3fb931ec59","modified":1511789574294},{"_id":"public/project/index.html","hash":"a22bc9fd5b2e84d2ea06f6ece5168aa9fceb262a","modified":1511789574321},{"_id":"public/about/index.html","hash":"226531bc5d137cb159450b75419934c4846f17d0","modified":1511789574321},{"_id":"public/tags/index.html","hash":"ee832795fbac99e512f3304d5c02ab7c02266b62","modified":1511789574321},{"_id":"public/2017/Nodejs/nodejs/10.how-to-uninstall-node/index.html","hash":"8e97d168ce63972b4afa6215f7885ff9105c6970","modified":1511789574322},{"_id":"public/2017/Git/GIT/02.diffrence-branch-command/index.html","hash":"f24d0a6e4d2d327e36c4bc312166c074fb01fd65","modified":1511789574322},{"_id":"public/2017/Nodejs/nodejs/00.POST VS PUT/index.html","hash":"4d6d521b133d46b7adbe506c7c1fd93007b1aca7","modified":1511789574322},{"_id":"public/archives/index.html","hash":"10ce875cb86e0f83ed25ca68cfd28fd30705db7d","modified":1511789574322},{"_id":"public/archives/page/2/index.html","hash":"a26d2eb0a7900fb178776d1e800417f1b957acd2","modified":1511789574322},{"_id":"public/archives/page/3/index.html","hash":"5efd048fedf1af3970e8e5b54c2e1b11ad0c3313","modified":1511789574322},{"_id":"public/archives/page/4/index.html","hash":"bfb47bef4a7b497d0e57c43869721e8a4d9e40be","modified":1511789574322},{"_id":"public/archives/page/6/index.html","hash":"a0db8ef918c6b75ef0c973407a9026c1f1570303","modified":1511789574322},{"_id":"public/archives/page/5/index.html","hash":"55e504da66299b2916f2eab4a196df812e29987d","modified":1511789574322},{"_id":"public/archives/2017/index.html","hash":"a0baa6b65551b4695356fa5447824a2855d0d58a","modified":1511789574331},{"_id":"public/archives/2017/page/2/index.html","hash":"8b91461b67d78a658378c7628743406b932c9f98","modified":1511789574331},{"_id":"public/archives/2017/page/3/index.html","hash":"8bbdd6f27a64c030b8c55b5cfc876ad2c349d86f","modified":1511789574333},{"_id":"public/archives/2017/page/4/index.html","hash":"91348f9ed0a3695a8e41141f723a9f4e69336e05","modified":1511789574334},{"_id":"public/archives/2017/page/5/index.html","hash":"c20a8452270d735cf3599f75a1e07ae34d5e3433","modified":1511789574335},{"_id":"public/archives/2017/page/6/index.html","hash":"91ef812c38a51d5e473e9a5d3c3d745d0cdb1ffa","modified":1511789574335},{"_id":"public/archives/2017/08/index.html","hash":"02744f86f35ad6763bdb3834490338d3ea8fda4b","modified":1511789574336},{"_id":"public/archives/2017/08/page/2/index.html","hash":"be2093b700563f66554eac96eaddb54ef25245d8","modified":1511789574336},{"_id":"public/archives/2017/08/page/3/index.html","hash":"5d4e7c76662d817a4e41dcd3316ee984fdf6f9c0","modified":1511789574336},{"_id":"public/archives/2017/08/page/4/index.html","hash":"b21ecfa9a1656d947bbcfd183bbef765c1400f6e","modified":1511789574337},{"_id":"public/archives/2017/09/index.html","hash":"2c6c9ff8d9c3e2fc7af51026bc7e8a0da3f76176","modified":1511789574337},{"_id":"public/archives/2017/09/page/2/index.html","hash":"ddb1ffa650a6cb9957cc26f8a8ad716d8bc7c8d1","modified":1511789574337},{"_id":"public/archives/2017/10/index.html","hash":"e3bbf34fac4212490d1e85bfeaed79e30d40609e","modified":1511789574337},{"_id":"public/archives/2017/11/index.html","hash":"5ae520f1f3eefc13275229a25c7f97533dde130f","modified":1511789574337},{"_id":"public/categories/Git/index.html","hash":"39bdff57a6901087b6590a5e8e4645459797c80c","modified":1511789574337},{"_id":"public/categories/React/index.html","hash":"da50127385fd9884a399edb0e3bb5e2a592b9d61","modified":1511789574337},{"_id":"public/categories/Log/index.html","hash":"67fd89cd107741ac3ab058824f0fb920cb24a0c6","modified":1511789574338},{"_id":"public/categories/Javascript/index.html","hash":"d053e464d616eddaffdeada00f24faf96015d7cd","modified":1511789574338},{"_id":"public/categories/Sass/index.html","hash":"430323692797658b86ba4e1e05a30b730f18d5d4","modified":1511789574338},{"_id":"public/categories/Nodejs/index.html","hash":"f73c5ab1cddc5edad2d8de0948ab617bb896ada0","modified":1511789574338},{"_id":"public/categories/Nodejs/page/2/index.html","hash":"799c88166953c968687bd8253bf261c56dace95e","modified":1511789574338},{"_id":"public/categories/Nodejs/page/3/index.html","hash":"cac29c4ad0616455e0be2ff4b4ad152c97ec440f","modified":1511789574338},{"_id":"public/index.html","hash":"f836e5aa059d44afe694fccc914119918fc81016","modified":1511789574339},{"_id":"public/page/2/index.html","hash":"febf2084578a30734fb92e02fe8a4d73ba52ebdc","modified":1511789574339},{"_id":"public/page/3/index.html","hash":"86e4fe1a0b03a3a47ea8d719c0792ad312c8cabd","modified":1511789574339},{"_id":"public/page/4/index.html","hash":"929a01bea9f9aec1e0fd61f3b80ba5ecd1430336","modified":1511789574339},{"_id":"public/page/5/index.html","hash":"14229c452edc170239c587d171093d81f67400c7","modified":1511789574339},{"_id":"public/page/6/index.html","hash":"385f04658277087fd1c7395a87c9e29b5270a8c4","modified":1511789574339},{"_id":"public/tags/github/index.html","hash":"8e44343bfd84fb516e499aa0b7ae9ea93eca8f85","modified":1511789574339},{"_id":"public/tags/git/index.html","hash":"e240fdc07076172c4535d15e57cba30ad3659e6a","modified":1511789574339},{"_id":"public/tags/remote/index.html","hash":"bf935c908915dd9b25ac2ff6689a905e3230dce6","modified":1511789574339},{"_id":"public/tags/prune/index.html","hash":"a65c22540371cb0c812801e3226b8d98c368040c","modified":1511789574340},{"_id":"public/tags/react/index.html","hash":"ec41416a8d5954bc8fea5493fcb3747291ddf7f5","modified":1511789574340},{"_id":"public/tags/semantic-ui-react/index.html","hash":"5a3c11d3d3283e8fa2c000368bec95fd4d101748","modified":1511789574340},{"_id":"public/tags/object/index.html","hash":"a3fd47f516d058f2a28733a69b40cee326ca1029","modified":1511789574340},{"_id":"public/tags/prototype/index.html","hash":"b68e30bb6a214ea56c99e23141d5e0cf2a69a3f0","modified":1511789574340},{"_id":"public/tags/closure/index.html","hash":"1259cfa39179b9695d8ca40d9748f8b9f5a76171","modified":1511789574340},{"_id":"public/tags/asynchronous/index.html","hash":"36e595df097b8b89d7af39183d1e3610d0f633a0","modified":1511789574340},{"_id":"public/tags/nesting/index.html","hash":"c73168f5496892b26ab39c6840729c22df731b48","modified":1511789574340},{"_id":"public/tags/sass-syntax/index.html","hash":"f172af56cac38f7844efa7ac3b3b55795b4a6d74","modified":1511789574341},{"_id":"public/tags/idempotent/index.html","hash":"925ffff3b053cb4080ea9a13b00a821a16e1c265","modified":1511789574341},{"_id":"public/tags/http/index.html","hash":"e66ed144dd8e7064adfd015e3525f13d6dc93266","modified":1511789574341},{"_id":"public/tags/nvm/index.html","hash":"4f1d3d83ebae299a2f235680af1f172dbf68e322","modified":1511789574341},{"_id":"public/tags/ejs/index.html","hash":"d744ea46e9b0b34f495dd92cce84a40c37797992","modified":1511789574341},{"_id":"public/tags/express/index.html","hash":"57938d77b8c48d8074354ac8fd5b981c2bdc67aa","modified":1511789574341},{"_id":"public/tags/webform/index.html","hash":"27df9ea0efd682db86ea0c078a696048b2b122f6","modified":1511789574341},{"_id":"public/tags/urlshortner/index.html","hash":"3d75f15a8a36677229eed862e449c64bd1e842d4","modified":1511789574341},{"_id":"public/tags/cookie/index.html","hash":"e8d6f3522a42544d3f4cb878b40173a84b7d75b3","modified":1511789574341},{"_id":"public/tags/middleware/index.html","hash":"1c1e7e35200f8fb0f53de66b786867abe630d942","modified":1511789574341},{"_id":"public/tags/session/index.html","hash":"27fe9dc4d2db0bd312030a8a7d793482ed404ccb","modified":1511789574342},{"_id":"public/tags/nodejs/index.html","hash":"29fe57c346e12ebbcad8e59d23189157f5cc5512","modified":1511789574342},{"_id":"public/tags/uninstall-node/index.html","hash":"c00b5516151bb476a3a05a351dd1b1eb33fa1cd9","modified":1511789574342},{"_id":"public/tags/how-to-uninstall-node/index.html","hash":"42c5ce7e8820c7486b5b2502462f432e909d74d2","modified":1511789574342},{"_id":"public/2017/Git/GIT/03.inner/index.html","hash":"8ef10abae18620b16ca7a1a7680918e1fe215820","modified":1511789574342},{"_id":"public/2017/Log/Log/01.dada-log-01/index.html","hash":"82afbe8f6683862e91bd78a45614e3e70e0f11b8","modified":1511789574342},{"_id":"public/2017/React/React/01.basic/index.html","hash":"b885a208a4469bfdf561e0619ca36eb03e0f24af","modified":1511789574342},{"_id":"public/2017/Nodejs/nodejs/09.session/index.html","hash":"87a9e047276af5b1a07a2b2924646bb3df616877","modified":1511789574342},{"_id":"public/2017/Nodejs/nodejs/08.cookie/index.html","hash":"87b0bba9e2ca9d5c8f7eeafbe7512cbd44fbee8c","modified":1511789574342},{"_id":"public/2017/Nodejs/nodejs/07.Express Middleware/index.html","hash":"5e4a401391c396589bfd10a8bb720b3deccb80da","modified":1511789574342},{"_id":"public/2017/Nodejs/nodejs/05.Web form/index.html","hash":"6f15cc0eec578aa8e4e4f4c2b14a315aeb7559bb","modified":1511789574343},{"_id":"public/2017/Nodejs/nodejs/06.service development/index.html","hash":"9243ab0041fe2b1ea993587f7ec5cef69b2f04ff","modified":1511789574343},{"_id":"public/2017/Git/GIT/01.git-connect-github/index.html","hash":"7a9d978a78ac0a353c3993b203c1dd7894d9201b","modified":1511789574343},{"_id":"public/2017/Nodejs/nodejs/04.Template Language/index.html","hash":"2c5a1d197ac4f60e9a21e570beaaf6c2914a8c12","modified":1511789574343},{"_id":"public/2017/Nodejs/nodejs/03.Middleware/index.html","hash":"e6369c0bc4df86623b8dc3e7807c1d5cc028b127","modified":1511789574343},{"_id":"public/2017/Nodejs/nodejs/02.http/index.html","hash":"8924ff61ca25684d0ace93894e2dd2ff2c48a809","modified":1511789574343},{"_id":"public/2017/Nodejs/nodejs/01.basic/index.html","hash":"de0dd20c2cb0da6e9ea522735239bacc02ea2f31","modified":1511789574343},{"_id":"public/2017/Javascript/Javascript/04.Async,EventLoop/index.html","hash":"eacbd65184320fa9099649fa388e753b4d882868","modified":1511789574343},{"_id":"public/2017/Javascript/Javascript/03.Closure/index.html","hash":"77504c018f54ddb0bcc72cb0d568cc4a1c2d1ea2","modified":1511789574343},{"_id":"public/2017/Sass/SCSS/02.extensions/index.html","hash":"4a4dddb15342030294a6f14e95b6dec35e1eb664","modified":1511789574343},{"_id":"public/2017/Sass/SCSS/03.sassScript/index.html","hash":"b383c1cd7768649ffe6d3df9800ee5a10d344368","modified":1511789574343},{"_id":"public/2017/Javascript/Javascript/02.Prototype/index.html","hash":"f38e9a2aa3082acf7f0196d56e2db54dc18d8f62","modified":1511789574344},{"_id":"public/2017/Javascript/Javascript/01.Object/index.html","hash":"66667742da1a48b0d8458e6d6f7962a88b6d145a","modified":1511789574344},{"_id":"public/js/script.js","hash":"ed10107a93b1b50dfb4822a63ff35bf2e2b05b9d","modified":1511789577572},{"_id":"public/css/style.css","hash":"0bb644ba12aff6b08c9da9a9ee192dc760cd1298","modified":1511789577572},{"_id":"public/js/qrious.js","hash":"4b348739f8b4ed87161d5bff94e7c4de81960056","modified":1511789577573},{"_id":"public/css/plugins/gitment.css","hash":"7572a17d5e4a5850438eae4c89fbf2a0fae47882","modified":1511789577573},{"_id":"public/js/gitment.js","hash":"30ada22a27231385a14153e8ff3e3b7ae4a89392","modified":1511789577573},{"_id":"public/fonts/SourceSansPro.ttf","hash":"1e9f0372c269da205fdbac8cf27cb9cf59f6ad45","modified":1511789577573},{"_id":"public/fonts/NanumSquare/NanumSquareRegular.woff2","hash":"5d488bdc90e048c500fcaa9f155bb03e453120e7","modified":1511789577573},{"_id":"public/fonts/NanumSquare/NanumSquareBold.woff2","hash":"956331530c67e2af54e4fb028a3647e72a0d171c","modified":1511789577590},{"_id":"public/fonts/NanumSquare/NanumSquareExtraBold.woff2","hash":"a048f5b82f3ae1ce4f00fcbe8a517a362f38c629","modified":1511789577590},{"_id":"public/fonts/NanumSquare/NanumSquareLight.woff2","hash":"516a8e73679286543a48e3171a97972c2df255e8","modified":1511789577590},{"_id":"public/fonts/NanumSquare/NanumSquareBold.woff","hash":"230d39e63f31c6882a70c13e464da927bd782fe8","modified":1511789577610},{"_id":"public/fonts/NanumSquare/NanumSquareExtraBold.woff","hash":"3ec35935ccdf7547f5b802b0b283bfbb5983f3c3","modified":1511789577610},{"_id":"public/fonts/NanumSquare/NanumSquareLight.woff","hash":"d04a590aa46b6cd18d814d836e108bb6340dc191","modified":1511789577611},{"_id":"public/fonts/NanumSquare/NanumSquareRegular.woff","hash":"439c3fe9185eb8af82931fe1b7dbea1f83921c7d","modified":1511789577611},{"_id":"public/fonts/NanumSquare/NanumSquareBold.eot","hash":"1aa012372b531e9483f2c91ee3c2818f267d955d","modified":1511789577686},{"_id":"public/fonts/NanumSquare/NanumSquareBold.ttf","hash":"8987ee230c6f11d1b1475422de16a173b1225171","modified":1511789577686},{"_id":"public/fonts/NanumSquare/NanumSquareExtraBold.eot","hash":"118ab9478527b696b6c23a12fe012b70b66a8dd7","modified":1511789577687},{"_id":"public/fonts/NanumSquare/NanumSquareExtraBold.ttf","hash":"757cdae4e4a80d08f9901c42e7c555cc0a012475","modified":1511789577688},{"_id":"public/fonts/NanumSquare/NanumSquareLight.eot","hash":"e2a70161278e1b1026a52882d84896a57cef62d5","modified":1511789577689},{"_id":"public/fonts/NanumSquare/NanumSquareLight.ttf","hash":"a45331545555c353ecfdb9b117e7ffee947d5ad4","modified":1511789577690},{"_id":"public/fonts/NanumSquare/NanumSquareRegular.ttf","hash":"1afd6f8457b0195144f2fc8852f97370415bb229","modified":1511789577697},{"_id":"public/fonts/NanumSquare/NanumSquareRegular.eot","hash":"84fa6e57261c32d04469a9cfda259b16c57d0c37","modified":1511789577712}],"Category":[{"name":"Git","_id":"cjai8h17o0005vb9qhga6hdan"},{"name":"React","_id":"cjai8h183000kvb9qps1vz8oe"},{"name":"Log","_id":"cjai8h186000qvb9qvx387cb0"},{"name":"Javascript","_id":"cjai8h18a000yvb9qk6kjbzwo"},{"name":"Sass","_id":"cjai8h18t001mvb9qnqe71blv"},{"name":"Nodejs","_id":"cjai8h18z001vvb9q7w11b51l"}],"Data":[],"Page":[{"title":"Project","layout":"project","_content":"","source":"project/index.md","raw":"---\ntitle: Project\nlayout: project\n---\n","date":"2017-11-17T08:31:59.219Z","updated":"2017-11-17T08:31:59.219Z","path":"project/index.html","comments":1,"_id":"cjai8h1670000vb9qof59pwhf","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"About","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: About\nlayout: about\n---","date":"2017-11-17T08:31:59.218Z","updated":"2017-11-17T08:31:59.218Z","path":"about/index.html","comments":1,"_id":"cjai8h1680001vb9q0mg7v5ww","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: Tags\nlayout: tags\n---\n","date":"2017-11-17T08:31:59.220Z","updated":"2017-11-17T08:31:59.220Z","path":"tags/index.html","comments":1,"_id":"cjai8h1690002vb9qvj3d6y3j","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"[Git] 로컬 저장소와 원격 저장소 연결하기","date":"2017-08-30T02:22:01.000Z","_content":"# 로컬 저장소를 github 저장소와 연결하기\n\n## 로컬 저장소 만들기\n\n### 1. 프로젝트 폴더 만들기\n\n우선 git 관리를 할 프로젝트 폴더를 적당한 디렉터리에 생성한다.  \n\n터미널에서 `cd 디렉터리` 명령어를 통해 원하는 디렉터리로 이동한다. `mkdir 폴더명`을 입력하면 현 위치에 새로운 폴더(디렉터리)를 만들어준다. (mkdir은 'make directory'이다.) `cd` 명령어를 이용해 새로 만들어진 폴더로 이동한다.\n\n```bash\n$ cd 이동할 디렉터리\n$ mkdir 생성할 폴더명\n$ cd 생성한 폴더명\n```\n\n아래 예제는 desktop 디렉터리로 이동한 후, gitTest라는 폴더를 생성하였다. 그리고나서 생성한 gitTest 폴더로 이동하였다. 터미널의 오른쪽에서 디렉터리가 이동되는 것을 확인할 수 있다.  \n\n![PC에 git 로컬 저장소 만들기](/images/1.png)\n\n<br>\n\n### 2. git init\n\n앞에서처럼 새로운 폴더를 만들고 git 저장소로 만든 후 프로젝트를 진행할수도 있지만, 기존에 진행하던 (git 저장소가 아니던) 프로젝트 폴더를 git 저장소로 만들 수도 있다.\n\n`git init` 명령어는 'git 관리를 하겠다'는 일종의 선언 같은 것이다. 이 명령어를 터미널에 입력하면 현 위치(디렉터리)에 `.git`이라는 폴더(하위 디렉터리)를 만든다.  \n![.git](/images/2.png)  \n\n.git 디렉터리에는 저장소에 필요한 뼈대 파일(Skeleton)이 들어 있다. 구조는 아래와 같다. \n\n![.git의 구조](/images/3.png)  \n\n`git init` 명령어를 적용하면 이제 이 디렉터리는 git에 의해 관리되는 워킹 디렉터리가 된다. 하지만 이 명령은 앞에서도 말했듯, 관리를 하겠다는 선언한 것일 뿐 이것 만으로는 어떠한 버전 관리도 이루어지지 않는다.  \n\n현재 gitTest폴더에 아무것도 없는 상태이므로 변경 사항을 만들기 위해 파일 하나를 생성한다. 예시로 new.txt 파일을 생성하였다. 만약 기존에 진행하던 프로젝트 폴더를 git 저장소로 추가하고 있다면 새 파일을 만드는 이 과정은 생략해도 무방하다.\n\n![프로젝트 파일 추가](/images/4.png)  \n\n\n### 3. git status\n\ngit은 워킹 디렉터리의 변경 사항(파일 또는 폴더의 수정/삭제/생성 등)을 감지할 수 있다. `git status` 명령어는 현재 git 관리 상태가 어떠한지를 보여준다.  \n\n```bash\n$ git status\n```\n\n![git status](/images/5.png)\n\n위 상황은 현재 new.txt라는 관리대상이 아닌 (untracked) 파일이 감지되었으며 커밋되지 않았고, stage에 올라가지 않은 상태임을 의미한다. 즉 기존에 git이 관리하던 대상(파일이나 폴더)이 아닌 것이 발견되었다는 것이다. 이는 앞에서 new.txt 파일을 새롭게 생성했던 것이 git에 의해 감지된 것이다.\n\n> 워킹 디렉토리의 모든 파일은 크게 Tracked(관리대상임)와 Untracked(관리대상이 아님)로 나눈다. Tracked 파일은 이미 스냅샷에 포함돼 있던 파일이다. Tracked 파일은 또 Unmodified(수정하지 않음)와 Modified(수정함) 그리고 Staged(커밋하면 저장소에 기록되는) 상태 중 하나이다. 그리고 나머지 파일은 모두 Untracked 파일이다. Untracked 파일은 워킹 디렉토리에 있는 모든 파일이 스냅샷에 포함돼 있는 것은 아니고 Staging Area에 있는 것도 아니다. 처음 저장소를 Clone하면 모든 파일은 Tracked이면서 Unmodified 상태가 된다. 파일을 Checkout하고 나서 아무것도 수정하지 않았기 때문에 그렇다.\n\n마지막 커밋 이후 아직 아무것도 수정하지 않은 상태에서 어떤 파일이 수정되면 Git은 그 즉시 파일을 Modified 상태로 인식한다. 그리고 이 수정한 파일을 Stage하고 Staged 상태인 파일을 커밋한다. 이 라이프사이클을 그림처럼 계속 반복한다.\n\n![파일의 라이프 사이클](https://git-scm.com/figures/18333fig0201-tn.png)\n\nstatus에 대한 더 자세한 내용은 [링크](https://git-scm.com/book/ko/v1/Git%EC%9D%98-%EA%B8%B0%EC%B4%88-%EC%88%98%EC%A0%95%ED%95%98%EA%B3%A0-%EC%A0%80%EC%9E%A5%EC%86%8C%EC%97%90-%EC%A0%80%EC%9E%A5%ED%95%98%EA%B8%B0)를 참고한다.\n\n\n## 4. git add\n\ncommit은 내 로컬 디렉터리에서 감지된 변경 사항을 확정하는 것이다. (HEAD에 반영한다고 말한다.) add는 변화가 감지된 파일들 중에서 git에 반영할(commit할) 후보를 선정하여 목록에 올리는 것이다. 메뉴얼에서는 'stage에 올린다'라고 표현한다.\n\n![출처: https://rogerdudler.github.io/git-guide/index.ko.html](/images/git-tree.png)\n\nadd는 특정 변화만 선택적으로 stage에 올릴 수도 있고, 변화 전체를 한꺼번에 올릴 수도 있다. 아래 예제는 변화된 파일 전체를 스테이지에 올리는 명령이다.\n\n```bash\n$ git add .\n```\n\n만약 여러 파일 중 하나의 파일만 선택적으로 stage에 올리고 싶다면 `.`대신 `파일명`을 입력하면 된다.\n\n```bash\n$ git add new.txt\n```\n\n![git add.](/images/6.png)\n\n<br>\n\n### 5. git commit\n\n이제 스테이지에 올린 변경 사항들을 commit 명령을 통해 저장한다. \n\n```bash\n$ git commit -m \"첫번째 버전\"\n```\n\n`-m`과 `\"\"`는 커밋 메시지를 추가하는 명령이다.  `\"\"`안에 메시지를 입력하면 된다.\n\n![git commit](/images/7.png)\n\n해석해보면 **master 브랜치에 2fb5223이라는 ID를 갖는 커밋 로그가 추가되었으며, 커밋 메시지는 '첫번째 버전'이다. 이 커밋으로 1개의 파일이 변화하였으며, 1줄의 삽입(+)이 있었다**라는 의미이다.\n\n<br>\n\n## 로컬 저장소를 github 저장소에 연결하기\n\n지금까지는 내 PC에서만 관리 가능한 로컬 저장소를 만들었다. 로컬 저장소만으로는 다른 이들과 프로젝트를 공유할 수 없기 때문에 공동 작업(협업)이 불가하다.\n\n따라서 협업이나 프로젝트의 공유를 위해서는 특정 서버에 git 저장소를 만들고, 서버를 통해 관리할 필요가 있다. 가장 많이 사용되는 github 홈페이지를 통해 git 원격 저장소를 생성할 수 있다.\n\n### 1. 계정 만들기\n\n[github.com](github.com)에 접속하여 계정을 생성하고 로그인한다.\n\n### 2. 원격 저장소 생성하기  \ngithub에 새 프로젝트를 생성하면 원격 저장소가 만들어진다. 아래 예제에서는 test라는 이름의 원격 저장소를 생성하였다.\n\n![github에 저장소 만들기](/images/8.png)  \n\nreadme.md는 저장소의 프로젝트에 대한 설명을 작성하는 용도로 흔히 사용된다. 지금은 있어도 되고, 없어도 크게 상관 없다.\n\n### 3. 로컬 저장소와 원격 저장소 연결하기\n\n지금까지는 로컬 저장소와 원격 저장소 별개로 존재할 뿐 아직 연결되지 않은 상태이다.\n\n### git remote\n\ngit remote는 리모트 저장소를 생성한다. 리모트 저장소란 인터넷이나 네트워크 어딘가에 있는 저장소를 말한다. remote 명령어를 통해 저장소를 추가하는 것은 **네트워크 어딘가에 있는 원격 저장소를 관리할 저장소로 등록하는 행위**이다. remote 명령은 아래와 같이 실행할 수 있다.\n\n```bash\n$ git remote add 단축이름 원격저장소url\n\n$ git remote\n\n$ git remote -v\n```\n\n첫번째 명령은 원격저장소를 내 리모트 저장소로 등록(추가)한다. 이때 저장소의 단축 이름을 직접 지정할 수 있다. 저장소명은 특별하지 않다면 origin을 사용하는 것이 일반적이다.\n\n`git remote` 명령은 내가 등록한 모든 리모트 저장소 목록을 설정한 단축 이름으로 보여준다.\n\n`git remote -v`는 단축 이름과 url을 함께 보여준다. \n\n![git remote](/images/git-remote.png)\n\n\n---\n`git clone`  \n\n사실 remote 명령을 생략하고 바로 clone 명령을 사용할 수도 있다. clone은 대상이 되는 원격 저장소를 통째로 나의 로컬 저장소(PC)에 복제해온다. 저장소를 clone하면 origin이라는 이름의 리모트 저장소가 자동으로 등록된다. 따라서 remote하는 과정을 생략하고 바로 `git clone 저장소url` 명령을 수행하여도 무방하다.\n\n---\n\n### 4. 로컬 저장소와 원격 저장소 동기화하기\n\n로컬 저장소와 원격 저장소를 동기화 즉, 같은 상태로 만들어주는 방법에는 두 가지가 있다. (사실 더 많지만 일단은 크게 두 가지만 다룬다.)\n\n### git push\n\npush 명령은 내 로컬 저장소의 확정 변경 사항(commit)을 원격 저장소에도 반영하는 것이다. \n\n```bash\n$ git push --set-upstream origin master\n```\n\n`--set-upstream`은 push할 리모트 저장소를 지정해준다. 위에서는 origin이라는 리모트 저장소의 master 브랜치에 push 명령을 내리겠다는 의미이다. `--set-upstream`은 한번만 지정해두면 새로운 저장소 브랜치를 set하기 전까지는 `git push` 입력만으로 간편하게 push 할 수 있다.\n\n---\n\n<remote + push 오류>  \nremote 후 바로 push하는 중 발생할 수 있는 오류 몇 가지를 소개한다!  아래와 같은 에러메시지를 만날 수 있다. \n\n```\n ! [rejected]        master -> master (non-fast-forward)\nerror: failed to push some refs to 'https://github.com/huusz/test.git'\n```\n\n![remote and push](/images/remote-and-push.png)  \n\n**rejected**: push가 거부되었다.  \n**master -> master**: 로컬 저장소의 master 브랜치의 변경 사항을 원격 저장소의 master 브랜치에 반영하려 하였는데,  \n**non-fast-forward**: 원격 저장소의 master 브랜치가 로컬 저장소의 버전보다 이전 버전이 아니다!  \n\n라는 의미이다.\n\n즉, 오류가 발생하게 된 원인은 github에서 새로운 프로젝트를 생성하면서 만들어진 원격 저장소에 함께 만들어진 readme.md 파일 때문이다. 더 정확히 말하면 readme.md 파일의 존재가 문제가 되는 것이 아니고, 원격 저장소에서 이루어진 readme.md를 추가하는 커밋이 로컬 저장소의 커밋 로그에 없기 때문이다.\n\npush 명령은 로컬 저장소의 commit 목록과 원격 저장소의 commit 목록을 비교한다. 그런 다음 원격 저장소의 마지막 commit id와 동일한 commit id를 가진 로컬 저장소의 commit 시점을 찾아낸 뒤, 원격 저장소의 마지막 커밋과 연결한다. 이제 무엇이 이해가 될 것이다. 원격 저장소의 첫번째이자 마지막 commit인 readme를 추가하는 commit이 원격 저장소에는 존재하지 않고, 따라서 현 상태에서는 둘을 연결할 수 없다.\n\n이 상황을 해결하는 방법은,\n\n1. 원격 저장소를 삭제하고 다시 만들거나, (물론 readme 파일 없이 만들어야 합니다. readme 파일을 함께 생성하면 자동으로 커밋이 생성되기 때문이다.)\n\n2. fetch나 pull 명령으로 원격 저장소의 마지막 커밋을 로컬 저장소 커밋 로그의 맨 앞으로 받아와야 한다.\n\n두 번째 방법으로 해결해본다.\n\n```bash\n$ git pull origin master\n```\n\n한번에 해결되면 좋겠지만, 안타깝게도 또다른 오류가 발생한다.\n\n```\nfetal: refusing to merge unrelated histories\n```\n\n![pull error](/images/pull-error.png)\n\n에러 내용은 원격 저장소의 master 브랜치에서 로컬 저장소의 FETCH_HEAD를 merge하는 것이 거부되었다. 커밋 히스토리가 서로 관련이 없다. 즉 서로 관련성이 없기 때문에 merge할 수 없다는 것이다. 뒤에서도 설명하겠지만, pull 명령은 fetch + merge 작업을 한번에 처리한다. 현 상황은 fetch는 되었지만, merge가 되지 않은 상태이다.\n\n기본적으로 merge는 원격 저장소와 로컬 저장소가 공통으로 가지고 있는 commit 지점이 존재해야 한다. 그 지점부터 병합을 시도하기 때문이다. 애초에 공통되는 commit 지점이 존재하지 않아 pull 명령도 사용할 수 없는 것이다. \n\n해결하기 앞서 상황을 이해하기 위해 간단하게 짚고 넘어갈 개념이 있다. pull과 fetch이다.\n\n* fetch는 리모트 저장소에 있는 내용을 가져오지만 자동으로 내 로컬 저장소에 merge하지 않는다. 원격 저장소의 내용을 확인만 하고 로컬에 병합(merge)하고 싶지는 않을 때 fetch를 사용한다.\n\nHEAD에는 가장 마지막에 행해진 commit 정보가 담긴다. 마찬가지로 `FETCH_HEAD`는 리모트 저장소의 가장 최신 commit 이력이 담기게 된다.\n\n`FETCH_HEAD`는 이름 없는 브랜치로 로컬에 가져오게 된다. 이 브랜치는 `FETCH_HEAD`로 checkout도 가능하다.\n\n* pull 명령은 리모트 저장소에 있는 내용을 가져올 뿐 아니라 자동으로 로컬 저장소에 merge한다. 즉, git pull은 git fetch + merge FETCH_HEAD인 셈이다.\n\n\n복잡하고 긴 설명 끝에 결론은 어쨌든 연결되는 **공통된 커밋 포인트가 없다**는 것이다. \n\n결국은 clone으로 원격 저장소를 복제해오는 것이 가장 간단하다.\n\n```\n$ git clone 저장소url\n```\n\n이렇게 하면 원격 저장소의 커밋이 내 로컬 저장소에 복사된다. 이후 add -> commit -> push를 통해 내 로컬 저장소에 있던 커밋 로그를 clone으로 불러온 커밋 로그 뒤에 merge할 수 있으며 이를 원격 저장소에도 반영할 수 있게 된다.\n\n> clone은 자동으로 로컬의 master 브랜치가 리모트 저장소의 master 브랜치를 추적하도록 한다. git pull 명령은 clone한 저장소에서 데이터를 가져오고 그 데이터를 자동으로 현재 작업하는 코드와 merge시킨다.\n\n---\nReference\n\n* [git-scm.com](https://git-scm.com/book/ko/v1/Git-%EB%B8%8C%EB%9E%9C%EC%B9%98-%EB%A6%AC%EB%AA%A8%ED%8A%B8-%EB%B8%8C%EB%9E%9C%EC%B9%98)  \n* [stack overflow](https://stackoverflow.com/questions/9237348/what-does-fetch-head-in-git-mean)  \n* [git tutorial - fetch](https://backlogtool.com/git-tutorial/kr/stepup/stepup3_2.html)\n\n","source":"_posts/GIT/01.git-connect-github.md","raw":"---\ntitle: '[Git] 로컬 저장소와 원격 저장소 연결하기'\ndate: 2017-08-30 11:22:01\ncategory: Git\ntags: \n  - github\n  - git\n  - remote\n---\n# 로컬 저장소를 github 저장소와 연결하기\n\n## 로컬 저장소 만들기\n\n### 1. 프로젝트 폴더 만들기\n\n우선 git 관리를 할 프로젝트 폴더를 적당한 디렉터리에 생성한다.  \n\n터미널에서 `cd 디렉터리` 명령어를 통해 원하는 디렉터리로 이동한다. `mkdir 폴더명`을 입력하면 현 위치에 새로운 폴더(디렉터리)를 만들어준다. (mkdir은 'make directory'이다.) `cd` 명령어를 이용해 새로 만들어진 폴더로 이동한다.\n\n```bash\n$ cd 이동할 디렉터리\n$ mkdir 생성할 폴더명\n$ cd 생성한 폴더명\n```\n\n아래 예제는 desktop 디렉터리로 이동한 후, gitTest라는 폴더를 생성하였다. 그리고나서 생성한 gitTest 폴더로 이동하였다. 터미널의 오른쪽에서 디렉터리가 이동되는 것을 확인할 수 있다.  \n\n![PC에 git 로컬 저장소 만들기](/images/1.png)\n\n<br>\n\n### 2. git init\n\n앞에서처럼 새로운 폴더를 만들고 git 저장소로 만든 후 프로젝트를 진행할수도 있지만, 기존에 진행하던 (git 저장소가 아니던) 프로젝트 폴더를 git 저장소로 만들 수도 있다.\n\n`git init` 명령어는 'git 관리를 하겠다'는 일종의 선언 같은 것이다. 이 명령어를 터미널에 입력하면 현 위치(디렉터리)에 `.git`이라는 폴더(하위 디렉터리)를 만든다.  \n![.git](/images/2.png)  \n\n.git 디렉터리에는 저장소에 필요한 뼈대 파일(Skeleton)이 들어 있다. 구조는 아래와 같다. \n\n![.git의 구조](/images/3.png)  \n\n`git init` 명령어를 적용하면 이제 이 디렉터리는 git에 의해 관리되는 워킹 디렉터리가 된다. 하지만 이 명령은 앞에서도 말했듯, 관리를 하겠다는 선언한 것일 뿐 이것 만으로는 어떠한 버전 관리도 이루어지지 않는다.  \n\n현재 gitTest폴더에 아무것도 없는 상태이므로 변경 사항을 만들기 위해 파일 하나를 생성한다. 예시로 new.txt 파일을 생성하였다. 만약 기존에 진행하던 프로젝트 폴더를 git 저장소로 추가하고 있다면 새 파일을 만드는 이 과정은 생략해도 무방하다.\n\n![프로젝트 파일 추가](/images/4.png)  \n\n\n### 3. git status\n\ngit은 워킹 디렉터리의 변경 사항(파일 또는 폴더의 수정/삭제/생성 등)을 감지할 수 있다. `git status` 명령어는 현재 git 관리 상태가 어떠한지를 보여준다.  \n\n```bash\n$ git status\n```\n\n![git status](/images/5.png)\n\n위 상황은 현재 new.txt라는 관리대상이 아닌 (untracked) 파일이 감지되었으며 커밋되지 않았고, stage에 올라가지 않은 상태임을 의미한다. 즉 기존에 git이 관리하던 대상(파일이나 폴더)이 아닌 것이 발견되었다는 것이다. 이는 앞에서 new.txt 파일을 새롭게 생성했던 것이 git에 의해 감지된 것이다.\n\n> 워킹 디렉토리의 모든 파일은 크게 Tracked(관리대상임)와 Untracked(관리대상이 아님)로 나눈다. Tracked 파일은 이미 스냅샷에 포함돼 있던 파일이다. Tracked 파일은 또 Unmodified(수정하지 않음)와 Modified(수정함) 그리고 Staged(커밋하면 저장소에 기록되는) 상태 중 하나이다. 그리고 나머지 파일은 모두 Untracked 파일이다. Untracked 파일은 워킹 디렉토리에 있는 모든 파일이 스냅샷에 포함돼 있는 것은 아니고 Staging Area에 있는 것도 아니다. 처음 저장소를 Clone하면 모든 파일은 Tracked이면서 Unmodified 상태가 된다. 파일을 Checkout하고 나서 아무것도 수정하지 않았기 때문에 그렇다.\n\n마지막 커밋 이후 아직 아무것도 수정하지 않은 상태에서 어떤 파일이 수정되면 Git은 그 즉시 파일을 Modified 상태로 인식한다. 그리고 이 수정한 파일을 Stage하고 Staged 상태인 파일을 커밋한다. 이 라이프사이클을 그림처럼 계속 반복한다.\n\n![파일의 라이프 사이클](https://git-scm.com/figures/18333fig0201-tn.png)\n\nstatus에 대한 더 자세한 내용은 [링크](https://git-scm.com/book/ko/v1/Git%EC%9D%98-%EA%B8%B0%EC%B4%88-%EC%88%98%EC%A0%95%ED%95%98%EA%B3%A0-%EC%A0%80%EC%9E%A5%EC%86%8C%EC%97%90-%EC%A0%80%EC%9E%A5%ED%95%98%EA%B8%B0)를 참고한다.\n\n\n## 4. git add\n\ncommit은 내 로컬 디렉터리에서 감지된 변경 사항을 확정하는 것이다. (HEAD에 반영한다고 말한다.) add는 변화가 감지된 파일들 중에서 git에 반영할(commit할) 후보를 선정하여 목록에 올리는 것이다. 메뉴얼에서는 'stage에 올린다'라고 표현한다.\n\n![출처: https://rogerdudler.github.io/git-guide/index.ko.html](/images/git-tree.png)\n\nadd는 특정 변화만 선택적으로 stage에 올릴 수도 있고, 변화 전체를 한꺼번에 올릴 수도 있다. 아래 예제는 변화된 파일 전체를 스테이지에 올리는 명령이다.\n\n```bash\n$ git add .\n```\n\n만약 여러 파일 중 하나의 파일만 선택적으로 stage에 올리고 싶다면 `.`대신 `파일명`을 입력하면 된다.\n\n```bash\n$ git add new.txt\n```\n\n![git add.](/images/6.png)\n\n<br>\n\n### 5. git commit\n\n이제 스테이지에 올린 변경 사항들을 commit 명령을 통해 저장한다. \n\n```bash\n$ git commit -m \"첫번째 버전\"\n```\n\n`-m`과 `\"\"`는 커밋 메시지를 추가하는 명령이다.  `\"\"`안에 메시지를 입력하면 된다.\n\n![git commit](/images/7.png)\n\n해석해보면 **master 브랜치에 2fb5223이라는 ID를 갖는 커밋 로그가 추가되었으며, 커밋 메시지는 '첫번째 버전'이다. 이 커밋으로 1개의 파일이 변화하였으며, 1줄의 삽입(+)이 있었다**라는 의미이다.\n\n<br>\n\n## 로컬 저장소를 github 저장소에 연결하기\n\n지금까지는 내 PC에서만 관리 가능한 로컬 저장소를 만들었다. 로컬 저장소만으로는 다른 이들과 프로젝트를 공유할 수 없기 때문에 공동 작업(협업)이 불가하다.\n\n따라서 협업이나 프로젝트의 공유를 위해서는 특정 서버에 git 저장소를 만들고, 서버를 통해 관리할 필요가 있다. 가장 많이 사용되는 github 홈페이지를 통해 git 원격 저장소를 생성할 수 있다.\n\n### 1. 계정 만들기\n\n[github.com](github.com)에 접속하여 계정을 생성하고 로그인한다.\n\n### 2. 원격 저장소 생성하기  \ngithub에 새 프로젝트를 생성하면 원격 저장소가 만들어진다. 아래 예제에서는 test라는 이름의 원격 저장소를 생성하였다.\n\n![github에 저장소 만들기](/images/8.png)  \n\nreadme.md는 저장소의 프로젝트에 대한 설명을 작성하는 용도로 흔히 사용된다. 지금은 있어도 되고, 없어도 크게 상관 없다.\n\n### 3. 로컬 저장소와 원격 저장소 연결하기\n\n지금까지는 로컬 저장소와 원격 저장소 별개로 존재할 뿐 아직 연결되지 않은 상태이다.\n\n### git remote\n\ngit remote는 리모트 저장소를 생성한다. 리모트 저장소란 인터넷이나 네트워크 어딘가에 있는 저장소를 말한다. remote 명령어를 통해 저장소를 추가하는 것은 **네트워크 어딘가에 있는 원격 저장소를 관리할 저장소로 등록하는 행위**이다. remote 명령은 아래와 같이 실행할 수 있다.\n\n```bash\n$ git remote add 단축이름 원격저장소url\n\n$ git remote\n\n$ git remote -v\n```\n\n첫번째 명령은 원격저장소를 내 리모트 저장소로 등록(추가)한다. 이때 저장소의 단축 이름을 직접 지정할 수 있다. 저장소명은 특별하지 않다면 origin을 사용하는 것이 일반적이다.\n\n`git remote` 명령은 내가 등록한 모든 리모트 저장소 목록을 설정한 단축 이름으로 보여준다.\n\n`git remote -v`는 단축 이름과 url을 함께 보여준다. \n\n![git remote](/images/git-remote.png)\n\n\n---\n`git clone`  \n\n사실 remote 명령을 생략하고 바로 clone 명령을 사용할 수도 있다. clone은 대상이 되는 원격 저장소를 통째로 나의 로컬 저장소(PC)에 복제해온다. 저장소를 clone하면 origin이라는 이름의 리모트 저장소가 자동으로 등록된다. 따라서 remote하는 과정을 생략하고 바로 `git clone 저장소url` 명령을 수행하여도 무방하다.\n\n---\n\n### 4. 로컬 저장소와 원격 저장소 동기화하기\n\n로컬 저장소와 원격 저장소를 동기화 즉, 같은 상태로 만들어주는 방법에는 두 가지가 있다. (사실 더 많지만 일단은 크게 두 가지만 다룬다.)\n\n### git push\n\npush 명령은 내 로컬 저장소의 확정 변경 사항(commit)을 원격 저장소에도 반영하는 것이다. \n\n```bash\n$ git push --set-upstream origin master\n```\n\n`--set-upstream`은 push할 리모트 저장소를 지정해준다. 위에서는 origin이라는 리모트 저장소의 master 브랜치에 push 명령을 내리겠다는 의미이다. `--set-upstream`은 한번만 지정해두면 새로운 저장소 브랜치를 set하기 전까지는 `git push` 입력만으로 간편하게 push 할 수 있다.\n\n---\n\n<remote + push 오류>  \nremote 후 바로 push하는 중 발생할 수 있는 오류 몇 가지를 소개한다!  아래와 같은 에러메시지를 만날 수 있다. \n\n```\n ! [rejected]        master -> master (non-fast-forward)\nerror: failed to push some refs to 'https://github.com/huusz/test.git'\n```\n\n![remote and push](/images/remote-and-push.png)  \n\n**rejected**: push가 거부되었다.  \n**master -> master**: 로컬 저장소의 master 브랜치의 변경 사항을 원격 저장소의 master 브랜치에 반영하려 하였는데,  \n**non-fast-forward**: 원격 저장소의 master 브랜치가 로컬 저장소의 버전보다 이전 버전이 아니다!  \n\n라는 의미이다.\n\n즉, 오류가 발생하게 된 원인은 github에서 새로운 프로젝트를 생성하면서 만들어진 원격 저장소에 함께 만들어진 readme.md 파일 때문이다. 더 정확히 말하면 readme.md 파일의 존재가 문제가 되는 것이 아니고, 원격 저장소에서 이루어진 readme.md를 추가하는 커밋이 로컬 저장소의 커밋 로그에 없기 때문이다.\n\npush 명령은 로컬 저장소의 commit 목록과 원격 저장소의 commit 목록을 비교한다. 그런 다음 원격 저장소의 마지막 commit id와 동일한 commit id를 가진 로컬 저장소의 commit 시점을 찾아낸 뒤, 원격 저장소의 마지막 커밋과 연결한다. 이제 무엇이 이해가 될 것이다. 원격 저장소의 첫번째이자 마지막 commit인 readme를 추가하는 commit이 원격 저장소에는 존재하지 않고, 따라서 현 상태에서는 둘을 연결할 수 없다.\n\n이 상황을 해결하는 방법은,\n\n1. 원격 저장소를 삭제하고 다시 만들거나, (물론 readme 파일 없이 만들어야 합니다. readme 파일을 함께 생성하면 자동으로 커밋이 생성되기 때문이다.)\n\n2. fetch나 pull 명령으로 원격 저장소의 마지막 커밋을 로컬 저장소 커밋 로그의 맨 앞으로 받아와야 한다.\n\n두 번째 방법으로 해결해본다.\n\n```bash\n$ git pull origin master\n```\n\n한번에 해결되면 좋겠지만, 안타깝게도 또다른 오류가 발생한다.\n\n```\nfetal: refusing to merge unrelated histories\n```\n\n![pull error](/images/pull-error.png)\n\n에러 내용은 원격 저장소의 master 브랜치에서 로컬 저장소의 FETCH_HEAD를 merge하는 것이 거부되었다. 커밋 히스토리가 서로 관련이 없다. 즉 서로 관련성이 없기 때문에 merge할 수 없다는 것이다. 뒤에서도 설명하겠지만, pull 명령은 fetch + merge 작업을 한번에 처리한다. 현 상황은 fetch는 되었지만, merge가 되지 않은 상태이다.\n\n기본적으로 merge는 원격 저장소와 로컬 저장소가 공통으로 가지고 있는 commit 지점이 존재해야 한다. 그 지점부터 병합을 시도하기 때문이다. 애초에 공통되는 commit 지점이 존재하지 않아 pull 명령도 사용할 수 없는 것이다. \n\n해결하기 앞서 상황을 이해하기 위해 간단하게 짚고 넘어갈 개념이 있다. pull과 fetch이다.\n\n* fetch는 리모트 저장소에 있는 내용을 가져오지만 자동으로 내 로컬 저장소에 merge하지 않는다. 원격 저장소의 내용을 확인만 하고 로컬에 병합(merge)하고 싶지는 않을 때 fetch를 사용한다.\n\nHEAD에는 가장 마지막에 행해진 commit 정보가 담긴다. 마찬가지로 `FETCH_HEAD`는 리모트 저장소의 가장 최신 commit 이력이 담기게 된다.\n\n`FETCH_HEAD`는 이름 없는 브랜치로 로컬에 가져오게 된다. 이 브랜치는 `FETCH_HEAD`로 checkout도 가능하다.\n\n* pull 명령은 리모트 저장소에 있는 내용을 가져올 뿐 아니라 자동으로 로컬 저장소에 merge한다. 즉, git pull은 git fetch + merge FETCH_HEAD인 셈이다.\n\n\n복잡하고 긴 설명 끝에 결론은 어쨌든 연결되는 **공통된 커밋 포인트가 없다**는 것이다. \n\n결국은 clone으로 원격 저장소를 복제해오는 것이 가장 간단하다.\n\n```\n$ git clone 저장소url\n```\n\n이렇게 하면 원격 저장소의 커밋이 내 로컬 저장소에 복사된다. 이후 add -> commit -> push를 통해 내 로컬 저장소에 있던 커밋 로그를 clone으로 불러온 커밋 로그 뒤에 merge할 수 있으며 이를 원격 저장소에도 반영할 수 있게 된다.\n\n> clone은 자동으로 로컬의 master 브랜치가 리모트 저장소의 master 브랜치를 추적하도록 한다. git pull 명령은 clone한 저장소에서 데이터를 가져오고 그 데이터를 자동으로 현재 작업하는 코드와 merge시킨다.\n\n---\nReference\n\n* [git-scm.com](https://git-scm.com/book/ko/v1/Git-%EB%B8%8C%EB%9E%9C%EC%B9%98-%EB%A6%AC%EB%AA%A8%ED%8A%B8-%EB%B8%8C%EB%9E%9C%EC%B9%98)  \n* [stack overflow](https://stackoverflow.com/questions/9237348/what-does-fetch-head-in-git-mean)  \n* [git tutorial - fetch](https://backlogtool.com/git-tutorial/kr/stepup/stepup3_2.html)\n\n","slug":"GIT/01.git-connect-github","published":1,"updated":"2017-11-17T09:24:17.117Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjai8h17g0003vb9qm6jfelfq","content":"<h1 id=\"로컬-저장소를-github-저장소와-연결하기\"><a href=\"#로컬-저장소를-github-저장소와-연결하기\" class=\"headerlink\" title=\"로컬 저장소를 github 저장소와 연결하기\"></a>로컬 저장소를 github 저장소와 연결하기</h1><h2 id=\"로컬-저장소-만들기\"><a href=\"#로컬-저장소-만들기\" class=\"headerlink\" title=\"로컬 저장소 만들기\"></a>로컬 저장소 만들기</h2><h3 id=\"1-프로젝트-폴더-만들기\"><a href=\"#1-프로젝트-폴더-만들기\" class=\"headerlink\" title=\"1. 프로젝트 폴더 만들기\"></a>1. 프로젝트 폴더 만들기</h3><p>우선 git 관리를 할 프로젝트 폴더를 적당한 디렉터리에 생성한다.</p><p>터미널에서 <code>cd 디렉터리</code> 명령어를 통해 원하는 디렉터리로 이동한다. <code>mkdir 폴더명</code>을 입력하면 현 위치에 새로운 폴더(디렉터리)를 만들어준다. (mkdir은 ‘make directory’이다.) <code>cd</code> 명령어를 이용해 새로 만들어진 폴더로 이동한다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ <span class=\"built_in\">cd</span> 이동할 디렉터리</div><div class=\"line\">$ mkdir 생성할 폴더명</div><div class=\"line\">$ <span class=\"built_in\">cd</span> 생성한 폴더명</div></pre></td></tr></table></figure><p>아래 예제는 desktop 디렉터리로 이동한 후, gitTest라는 폴더를 생성하였다. 그리고나서 생성한 gitTest 폴더로 이동하였다. 터미널의 오른쪽에서 디렉터리가 이동되는 것을 확인할 수 있다.</p><p><img src=\"/images/1.png\" alt=\"PC에 git 로컬 저장소 만들기\"></p><p><br></p><h3 id=\"2-git-init\"><a href=\"#2-git-init\" class=\"headerlink\" title=\"2. git init\"></a>2. git init</h3><p>앞에서처럼 새로운 폴더를 만들고 git 저장소로 만든 후 프로젝트를 진행할수도 있지만, 기존에 진행하던 (git 저장소가 아니던) 프로젝트 폴더를 git 저장소로 만들 수도 있다.</p><p><code>git init</code> 명령어는 ‘git 관리를 하겠다’는 일종의 선언 같은 것이다. 이 명령어를 터미널에 입력하면 현 위치(디렉터리)에 <code>.git</code>이라는 폴더(하위 디렉터리)를 만든다.<br><img src=\"/images/2.png\" alt=\".git\"></p><p>.git 디렉터리에는 저장소에 필요한 뼈대 파일(Skeleton)이 들어 있다. 구조는 아래와 같다.</p><p><img src=\"/images/3.png\" alt=\".git의 구조\"></p><p><code>git init</code> 명령어를 적용하면 이제 이 디렉터리는 git에 의해 관리되는 워킹 디렉터리가 된다. 하지만 이 명령은 앞에서도 말했듯, 관리를 하겠다는 선언한 것일 뿐 이것 만으로는 어떠한 버전 관리도 이루어지지 않는다.</p><p>현재 gitTest폴더에 아무것도 없는 상태이므로 변경 사항을 만들기 위해 파일 하나를 생성한다. 예시로 new.txt 파일을 생성하였다. 만약 기존에 진행하던 프로젝트 폴더를 git 저장소로 추가하고 있다면 새 파일을 만드는 이 과정은 생략해도 무방하다.</p><p><img src=\"/images/4.png\" alt=\"프로젝트 파일 추가\"></p><h3 id=\"3-git-status\"><a href=\"#3-git-status\" class=\"headerlink\" title=\"3. git status\"></a>3. git status</h3><p>git은 워킹 디렉터리의 변경 사항(파일 또는 폴더의 수정/삭제/생성 등)을 감지할 수 있다. <code>git status</code> 명령어는 현재 git 관리 상태가 어떠한지를 보여준다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git status</div></pre></td></tr></table></figure><p><img src=\"/images/5.png\" alt=\"git status\"></p><p>위 상황은 현재 new.txt라는 관리대상이 아닌 (untracked) 파일이 감지되었으며 커밋되지 않았고, stage에 올라가지 않은 상태임을 의미한다. 즉 기존에 git이 관리하던 대상(파일이나 폴더)이 아닌 것이 발견되었다는 것이다. 이는 앞에서 new.txt 파일을 새롭게 생성했던 것이 git에 의해 감지된 것이다.</p><blockquote><p>워킹 디렉토리의 모든 파일은 크게 Tracked(관리대상임)와 Untracked(관리대상이 아님)로 나눈다. Tracked 파일은 이미 스냅샷에 포함돼 있던 파일이다. Tracked 파일은 또 Unmodified(수정하지 않음)와 Modified(수정함) 그리고 Staged(커밋하면 저장소에 기록되는) 상태 중 하나이다. 그리고 나머지 파일은 모두 Untracked 파일이다. Untracked 파일은 워킹 디렉토리에 있는 모든 파일이 스냅샷에 포함돼 있는 것은 아니고 Staging Area에 있는 것도 아니다. 처음 저장소를 Clone하면 모든 파일은 Tracked이면서 Unmodified 상태가 된다. 파일을 Checkout하고 나서 아무것도 수정하지 않았기 때문에 그렇다.</p></blockquote><p>마지막 커밋 이후 아직 아무것도 수정하지 않은 상태에서 어떤 파일이 수정되면 Git은 그 즉시 파일을 Modified 상태로 인식한다. 그리고 이 수정한 파일을 Stage하고 Staged 상태인 파일을 커밋한다. 이 라이프사이클을 그림처럼 계속 반복한다.</p><p><img src=\"https://git-scm.com/figures/18333fig0201-tn.png\" alt=\"파일의 라이프 사이클\"></p><p>status에 대한 더 자세한 내용은 <a href=\"https://git-scm.com/book/ko/v1/Git%EC%9D%98-%EA%B8%B0%EC%B4%88-%EC%88%98%EC%A0%95%ED%95%98%EA%B3%A0-%EC%A0%80%EC%9E%A5%EC%86%8C%EC%97%90-%EC%A0%80%EC%9E%A5%ED%95%98%EA%B8%B0\" target=\"_blank\" rel=\"external\">링크</a>를 참고한다.</p><h2 id=\"4-git-add\"><a href=\"#4-git-add\" class=\"headerlink\" title=\"4. git add\"></a>4. git add</h2><p>commit은 내 로컬 디렉터리에서 감지된 변경 사항을 확정하는 것이다. (HEAD에 반영한다고 말한다.) add는 변화가 감지된 파일들 중에서 git에 반영할(commit할) 후보를 선정하여 목록에 올리는 것이다. 메뉴얼에서는 ‘stage에 올린다’라고 표현한다.</p><p><img src=\"/images/git-tree.png\" alt=\"출처: https://rogerdudler.github.io/git-guide/index.ko.html\"></p><p>add는 특정 변화만 선택적으로 stage에 올릴 수도 있고, 변화 전체를 한꺼번에 올릴 수도 있다. 아래 예제는 변화된 파일 전체를 스테이지에 올리는 명령이다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git add .</div></pre></td></tr></table></figure><p>만약 여러 파일 중 하나의 파일만 선택적으로 stage에 올리고 싶다면 <code>.</code>대신 <code>파일명</code>을 입력하면 된다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git add new.txt</div></pre></td></tr></table></figure><p><img src=\"/images/6.png\" alt=\"git add.\"></p><p><br></p><h3 id=\"5-git-commit\"><a href=\"#5-git-commit\" class=\"headerlink\" title=\"5. git commit\"></a>5. git commit</h3><p>이제 스테이지에 올린 변경 사항들을 commit 명령을 통해 저장한다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git commit -m <span class=\"string\">\"첫번째 버전\"</span></div></pre></td></tr></table></figure><p><code>-m</code>과 <code>&quot;&quot;</code>는 커밋 메시지를 추가하는 명령이다. <code>&quot;&quot;</code>안에 메시지를 입력하면 된다.</p><p><img src=\"/images/7.png\" alt=\"git commit\"></p><p>해석해보면 <strong>master 브랜치에 2fb5223이라는 ID를 갖는 커밋 로그가 추가되었으며, 커밋 메시지는 ‘첫번째 버전’이다. 이 커밋으로 1개의 파일이 변화하였으며, 1줄의 삽입(+)이 있었다</strong>라는 의미이다.</p><p><br></p><h2 id=\"로컬-저장소를-github-저장소에-연결하기\"><a href=\"#로컬-저장소를-github-저장소에-연결하기\" class=\"headerlink\" title=\"로컬 저장소를 github 저장소에 연결하기\"></a>로컬 저장소를 github 저장소에 연결하기</h2><p>지금까지는 내 PC에서만 관리 가능한 로컬 저장소를 만들었다. 로컬 저장소만으로는 다른 이들과 프로젝트를 공유할 수 없기 때문에 공동 작업(협업)이 불가하다.</p><p>따라서 협업이나 프로젝트의 공유를 위해서는 특정 서버에 git 저장소를 만들고, 서버를 통해 관리할 필요가 있다. 가장 많이 사용되는 github 홈페이지를 통해 git 원격 저장소를 생성할 수 있다.</p><h3 id=\"1-계정-만들기\"><a href=\"#1-계정-만들기\" class=\"headerlink\" title=\"1. 계정 만들기\"></a>1. 계정 만들기</h3><p><a href=\"github.com\">github.com</a>에 접속하여 계정을 생성하고 로그인한다.</p><h3 id=\"2-원격-저장소-생성하기\"><a href=\"#2-원격-저장소-생성하기\" class=\"headerlink\" title=\"2. 원격 저장소 생성하기\"></a>2. 원격 저장소 생성하기</h3><p>github에 새 프로젝트를 생성하면 원격 저장소가 만들어진다. 아래 예제에서는 test라는 이름의 원격 저장소를 생성하였다.</p><p><img src=\"/images/8.png\" alt=\"github에 저장소 만들기\"></p><p>readme.md는 저장소의 프로젝트에 대한 설명을 작성하는 용도로 흔히 사용된다. 지금은 있어도 되고, 없어도 크게 상관 없다.</p><h3 id=\"3-로컬-저장소와-원격-저장소-연결하기\"><a href=\"#3-로컬-저장소와-원격-저장소-연결하기\" class=\"headerlink\" title=\"3. 로컬 저장소와 원격 저장소 연결하기\"></a>3. 로컬 저장소와 원격 저장소 연결하기</h3><p>지금까지는 로컬 저장소와 원격 저장소 별개로 존재할 뿐 아직 연결되지 않은 상태이다.</p><h3 id=\"git-remote\"><a href=\"#git-remote\" class=\"headerlink\" title=\"git remote\"></a>git remote</h3><p>git remote는 리모트 저장소를 생성한다. 리모트 저장소란 인터넷이나 네트워크 어딘가에 있는 저장소를 말한다. remote 명령어를 통해 저장소를 추가하는 것은 <strong>네트워크 어딘가에 있는 원격 저장소를 관리할 저장소로 등록하는 행위</strong>이다. remote 명령은 아래와 같이 실행할 수 있다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git remote add 단축이름 원격저장소url</div><div class=\"line\"></div><div class=\"line\">$ git remote</div><div class=\"line\"></div><div class=\"line\">$ git remote -v</div></pre></td></tr></table></figure><p>첫번째 명령은 원격저장소를 내 리모트 저장소로 등록(추가)한다. 이때 저장소의 단축 이름을 직접 지정할 수 있다. 저장소명은 특별하지 않다면 origin을 사용하는 것이 일반적이다.</p><p><code>git remote</code> 명령은 내가 등록한 모든 리모트 저장소 목록을 설정한 단축 이름으로 보여준다.</p><p><code>git remote -v</code>는 단축 이름과 url을 함께 보여준다.</p><p><img src=\"/images/git-remote.png\" alt=\"git remote\"></p><hr><p><code>git clone</code></p><p>사실 remote 명령을 생략하고 바로 clone 명령을 사용할 수도 있다. clone은 대상이 되는 원격 저장소를 통째로 나의 로컬 저장소(PC)에 복제해온다. 저장소를 clone하면 origin이라는 이름의 리모트 저장소가 자동으로 등록된다. 따라서 remote하는 과정을 생략하고 바로 <code>git clone 저장소url</code> 명령을 수행하여도 무방하다.</p><hr><h3 id=\"4-로컬-저장소와-원격-저장소-동기화하기\"><a href=\"#4-로컬-저장소와-원격-저장소-동기화하기\" class=\"headerlink\" title=\"4. 로컬 저장소와 원격 저장소 동기화하기\"></a>4. 로컬 저장소와 원격 저장소 동기화하기</h3><p>로컬 저장소와 원격 저장소를 동기화 즉, 같은 상태로 만들어주는 방법에는 두 가지가 있다. (사실 더 많지만 일단은 크게 두 가지만 다룬다.)</p><h3 id=\"git-push\"><a href=\"#git-push\" class=\"headerlink\" title=\"git push\"></a>git push</h3><p>push 명령은 내 로컬 저장소의 확정 변경 사항(commit)을 원격 저장소에도 반영하는 것이다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git push --<span class=\"built_in\">set</span>-upstream origin master</div></pre></td></tr></table></figure><p><code>--set-upstream</code>은 push할 리모트 저장소를 지정해준다. 위에서는 origin이라는 리모트 저장소의 master 브랜치에 push 명령을 내리겠다는 의미이다. <code>--set-upstream</code>은 한번만 지정해두면 새로운 저장소 브랜치를 set하기 전까지는 <code>git push</code> 입력만으로 간편하게 push 할 수 있다.</p><hr><p><remote +=\"\" push=\"\" 오류=\"\"><br>remote 후 바로 push하는 중 발생할 수 있는 오류 몇 가지를 소개한다! 아래와 같은 에러메시지를 만날 수 있다.</remote></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"> ! [rejected]        master -&gt; master (non-fast-forward)</div><div class=\"line\">error: failed to push some refs to &apos;https://github.com/huusz/test.git&apos;</div></pre></td></tr></table></figure><p><img src=\"/images/remote-and-push.png\" alt=\"remote and push\"></p><p><strong>rejected</strong>: push가 거부되었다.<br><strong>master -&gt; master</strong>: 로컬 저장소의 master 브랜치의 변경 사항을 원격 저장소의 master 브랜치에 반영하려 하였는데,<br><strong>non-fast-forward</strong>: 원격 저장소의 master 브랜치가 로컬 저장소의 버전보다 이전 버전이 아니다!</p><p>라는 의미이다.</p><p>즉, 오류가 발생하게 된 원인은 github에서 새로운 프로젝트를 생성하면서 만들어진 원격 저장소에 함께 만들어진 readme.md 파일 때문이다. 더 정확히 말하면 readme.md 파일의 존재가 문제가 되는 것이 아니고, 원격 저장소에서 이루어진 readme.md를 추가하는 커밋이 로컬 저장소의 커밋 로그에 없기 때문이다.</p><p>push 명령은 로컬 저장소의 commit 목록과 원격 저장소의 commit 목록을 비교한다. 그런 다음 원격 저장소의 마지막 commit id와 동일한 commit id를 가진 로컬 저장소의 commit 시점을 찾아낸 뒤, 원격 저장소의 마지막 커밋과 연결한다. 이제 무엇이 이해가 될 것이다. 원격 저장소의 첫번째이자 마지막 commit인 readme를 추가하는 commit이 원격 저장소에는 존재하지 않고, 따라서 현 상태에서는 둘을 연결할 수 없다.</p><p>이 상황을 해결하는 방법은,</p><ol><li><p>원격 저장소를 삭제하고 다시 만들거나, (물론 readme 파일 없이 만들어야 합니다. readme 파일을 함께 생성하면 자동으로 커밋이 생성되기 때문이다.)</p></li><li><p>fetch나 pull 명령으로 원격 저장소의 마지막 커밋을 로컬 저장소 커밋 로그의 맨 앞으로 받아와야 한다.</p></li></ol><p>두 번째 방법으로 해결해본다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git pull origin master</div></pre></td></tr></table></figure><p>한번에 해결되면 좋겠지만, 안타깝게도 또다른 오류가 발생한다.</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">fetal: refusing to merge unrelated histories</div></pre></td></tr></table></figure><p><img src=\"/images/pull-error.png\" alt=\"pull error\"></p><p>에러 내용은 원격 저장소의 master 브랜치에서 로컬 저장소의 FETCH_HEAD를 merge하는 것이 거부되었다. 커밋 히스토리가 서로 관련이 없다. 즉 서로 관련성이 없기 때문에 merge할 수 없다는 것이다. 뒤에서도 설명하겠지만, pull 명령은 fetch + merge 작업을 한번에 처리한다. 현 상황은 fetch는 되었지만, merge가 되지 않은 상태이다.</p><p>기본적으로 merge는 원격 저장소와 로컬 저장소가 공통으로 가지고 있는 commit 지점이 존재해야 한다. 그 지점부터 병합을 시도하기 때문이다. 애초에 공통되는 commit 지점이 존재하지 않아 pull 명령도 사용할 수 없는 것이다.</p><p>해결하기 앞서 상황을 이해하기 위해 간단하게 짚고 넘어갈 개념이 있다. pull과 fetch이다.</p><ul><li>fetch는 리모트 저장소에 있는 내용을 가져오지만 자동으로 내 로컬 저장소에 merge하지 않는다. 원격 저장소의 내용을 확인만 하고 로컬에 병합(merge)하고 싶지는 않을 때 fetch를 사용한다.</li></ul><p>HEAD에는 가장 마지막에 행해진 commit 정보가 담긴다. 마찬가지로 <code>FETCH_HEAD</code>는 리모트 저장소의 가장 최신 commit 이력이 담기게 된다.</p><p><code>FETCH_HEAD</code>는 이름 없는 브랜치로 로컬에 가져오게 된다. 이 브랜치는 <code>FETCH_HEAD</code>로 checkout도 가능하다.</p><ul><li>pull 명령은 리모트 저장소에 있는 내용을 가져올 뿐 아니라 자동으로 로컬 저장소에 merge한다. 즉, git pull은 git fetch + merge FETCH_HEAD인 셈이다.</li></ul><p>복잡하고 긴 설명 끝에 결론은 어쨌든 연결되는 <strong>공통된 커밋 포인트가 없다</strong>는 것이다.</p><p>결국은 clone으로 원격 저장소를 복제해오는 것이 가장 간단하다.</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git clone 저장소url</div></pre></td></tr></table></figure><p>이렇게 하면 원격 저장소의 커밋이 내 로컬 저장소에 복사된다. 이후 add -&gt; commit -&gt; push를 통해 내 로컬 저장소에 있던 커밋 로그를 clone으로 불러온 커밋 로그 뒤에 merge할 수 있으며 이를 원격 저장소에도 반영할 수 있게 된다.</p><blockquote><p>clone은 자동으로 로컬의 master 브랜치가 리모트 저장소의 master 브랜치를 추적하도록 한다. git pull 명령은 clone한 저장소에서 데이터를 가져오고 그 데이터를 자동으로 현재 작업하는 코드와 merge시킨다.</p></blockquote><hr><p>Reference</p><ul><li><a href=\"https://git-scm.com/book/ko/v1/Git-%EB%B8%8C%EB%9E%9C%EC%B9%98-%EB%A6%AC%EB%AA%A8%ED%8A%B8-%EB%B8%8C%EB%9E%9C%EC%B9%98\" target=\"_blank\" rel=\"external\">git-scm.com</a></li><li><a href=\"https://stackoverflow.com/questions/9237348/what-does-fetch-head-in-git-mean\" target=\"_blank\" rel=\"external\">stack overflow</a></li><li><a href=\"https://backlogtool.com/git-tutorial/kr/stepup/stepup3_2.html\" target=\"_blank\" rel=\"external\">git tutorial - fetch</a></li></ul>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"로컬-저장소를-github-저장소와-연결하기\"><a href=\"#로컬-저장소를-github-저장소와-연결하기\" class=\"headerlink\" title=\"로컬 저장소를 github 저장소와 연결하기\"></a>로컬 저장소를 github 저장소와 연결하기</h1><h2 id=\"로컬-저장소-만들기\"><a href=\"#로컬-저장소-만들기\" class=\"headerlink\" title=\"로컬 저장소 만들기\"></a>로컬 저장소 만들기</h2><h3 id=\"1-프로젝트-폴더-만들기\"><a href=\"#1-프로젝트-폴더-만들기\" class=\"headerlink\" title=\"1. 프로젝트 폴더 만들기\"></a>1. 프로젝트 폴더 만들기</h3><p>우선 git 관리를 할 프로젝트 폴더를 적당한 디렉터리에 생성한다.</p><p>터미널에서 <code>cd 디렉터리</code> 명령어를 통해 원하는 디렉터리로 이동한다. <code>mkdir 폴더명</code>을 입력하면 현 위치에 새로운 폴더(디렉터리)를 만들어준다. (mkdir은 ‘make directory’이다.) <code>cd</code> 명령어를 이용해 새로 만들어진 폴더로 이동한다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ <span class=\"built_in\">cd</span> 이동할 디렉터리</div><div class=\"line\">$ mkdir 생성할 폴더명</div><div class=\"line\">$ <span class=\"built_in\">cd</span> 생성한 폴더명</div></pre></td></tr></table></figure><p>아래 예제는 desktop 디렉터리로 이동한 후, gitTest라는 폴더를 생성하였다. 그리고나서 생성한 gitTest 폴더로 이동하였다. 터미널의 오른쪽에서 디렉터리가 이동되는 것을 확인할 수 있다.</p><p><img src=\"/images/1.png\" alt=\"PC에 git 로컬 저장소 만들기\"></p><p><br></p><h3 id=\"2-git-init\"><a href=\"#2-git-init\" class=\"headerlink\" title=\"2. git init\"></a>2. git init</h3><p>앞에서처럼 새로운 폴더를 만들고 git 저장소로 만든 후 프로젝트를 진행할수도 있지만, 기존에 진행하던 (git 저장소가 아니던) 프로젝트 폴더를 git 저장소로 만들 수도 있다.</p><p><code>git init</code> 명령어는 ‘git 관리를 하겠다’는 일종의 선언 같은 것이다. 이 명령어를 터미널에 입력하면 현 위치(디렉터리)에 <code>.git</code>이라는 폴더(하위 디렉터리)를 만든다.<br><img src=\"/images/2.png\" alt=\".git\"></p><p>.git 디렉터리에는 저장소에 필요한 뼈대 파일(Skeleton)이 들어 있다. 구조는 아래와 같다.</p><p><img src=\"/images/3.png\" alt=\".git의 구조\"></p><p><code>git init</code> 명령어를 적용하면 이제 이 디렉터리는 git에 의해 관리되는 워킹 디렉터리가 된다. 하지만 이 명령은 앞에서도 말했듯, 관리를 하겠다는 선언한 것일 뿐 이것 만으로는 어떠한 버전 관리도 이루어지지 않는다.</p><p>현재 gitTest폴더에 아무것도 없는 상태이므로 변경 사항을 만들기 위해 파일 하나를 생성한다. 예시로 new.txt 파일을 생성하였다. 만약 기존에 진행하던 프로젝트 폴더를 git 저장소로 추가하고 있다면 새 파일을 만드는 이 과정은 생략해도 무방하다.</p><p><img src=\"/images/4.png\" alt=\"프로젝트 파일 추가\"></p><h3 id=\"3-git-status\"><a href=\"#3-git-status\" class=\"headerlink\" title=\"3. git status\"></a>3. git status</h3><p>git은 워킹 디렉터리의 변경 사항(파일 또는 폴더의 수정/삭제/생성 등)을 감지할 수 있다. <code>git status</code> 명령어는 현재 git 관리 상태가 어떠한지를 보여준다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git status</div></pre></td></tr></table></figure><p><img src=\"/images/5.png\" alt=\"git status\"></p><p>위 상황은 현재 new.txt라는 관리대상이 아닌 (untracked) 파일이 감지되었으며 커밋되지 않았고, stage에 올라가지 않은 상태임을 의미한다. 즉 기존에 git이 관리하던 대상(파일이나 폴더)이 아닌 것이 발견되었다는 것이다. 이는 앞에서 new.txt 파일을 새롭게 생성했던 것이 git에 의해 감지된 것이다.</p><blockquote><p>워킹 디렉토리의 모든 파일은 크게 Tracked(관리대상임)와 Untracked(관리대상이 아님)로 나눈다. Tracked 파일은 이미 스냅샷에 포함돼 있던 파일이다. Tracked 파일은 또 Unmodified(수정하지 않음)와 Modified(수정함) 그리고 Staged(커밋하면 저장소에 기록되는) 상태 중 하나이다. 그리고 나머지 파일은 모두 Untracked 파일이다. Untracked 파일은 워킹 디렉토리에 있는 모든 파일이 스냅샷에 포함돼 있는 것은 아니고 Staging Area에 있는 것도 아니다. 처음 저장소를 Clone하면 모든 파일은 Tracked이면서 Unmodified 상태가 된다. 파일을 Checkout하고 나서 아무것도 수정하지 않았기 때문에 그렇다.</p></blockquote><p>마지막 커밋 이후 아직 아무것도 수정하지 않은 상태에서 어떤 파일이 수정되면 Git은 그 즉시 파일을 Modified 상태로 인식한다. 그리고 이 수정한 파일을 Stage하고 Staged 상태인 파일을 커밋한다. 이 라이프사이클을 그림처럼 계속 반복한다.</p><p><img src=\"https://git-scm.com/figures/18333fig0201-tn.png\" alt=\"파일의 라이프 사이클\"></p><p>status에 대한 더 자세한 내용은 <a href=\"https://git-scm.com/book/ko/v1/Git%EC%9D%98-%EA%B8%B0%EC%B4%88-%EC%88%98%EC%A0%95%ED%95%98%EA%B3%A0-%EC%A0%80%EC%9E%A5%EC%86%8C%EC%97%90-%EC%A0%80%EC%9E%A5%ED%95%98%EA%B8%B0\" target=\"_blank\" rel=\"external\">링크</a>를 참고한다.</p><h2 id=\"4-git-add\"><a href=\"#4-git-add\" class=\"headerlink\" title=\"4. git add\"></a>4. git add</h2><p>commit은 내 로컬 디렉터리에서 감지된 변경 사항을 확정하는 것이다. (HEAD에 반영한다고 말한다.) add는 변화가 감지된 파일들 중에서 git에 반영할(commit할) 후보를 선정하여 목록에 올리는 것이다. 메뉴얼에서는 ‘stage에 올린다’라고 표현한다.</p><p><img src=\"/images/git-tree.png\" alt=\"출처: https://rogerdudler.github.io/git-guide/index.ko.html\"></p><p>add는 특정 변화만 선택적으로 stage에 올릴 수도 있고, 변화 전체를 한꺼번에 올릴 수도 있다. 아래 예제는 변화된 파일 전체를 스테이지에 올리는 명령이다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git add .</div></pre></td></tr></table></figure><p>만약 여러 파일 중 하나의 파일만 선택적으로 stage에 올리고 싶다면 <code>.</code>대신 <code>파일명</code>을 입력하면 된다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git add new.txt</div></pre></td></tr></table></figure><p><img src=\"/images/6.png\" alt=\"git add.\"></p><p><br></p><h3 id=\"5-git-commit\"><a href=\"#5-git-commit\" class=\"headerlink\" title=\"5. git commit\"></a>5. git commit</h3><p>이제 스테이지에 올린 변경 사항들을 commit 명령을 통해 저장한다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git commit -m <span class=\"string\">\"첫번째 버전\"</span></div></pre></td></tr></table></figure><p><code>-m</code>과 <code>&quot;&quot;</code>는 커밋 메시지를 추가하는 명령이다. <code>&quot;&quot;</code>안에 메시지를 입력하면 된다.</p><p><img src=\"/images/7.png\" alt=\"git commit\"></p><p>해석해보면 <strong>master 브랜치에 2fb5223이라는 ID를 갖는 커밋 로그가 추가되었으며, 커밋 메시지는 ‘첫번째 버전’이다. 이 커밋으로 1개의 파일이 변화하였으며, 1줄의 삽입(+)이 있었다</strong>라는 의미이다.</p><p><br></p><h2 id=\"로컬-저장소를-github-저장소에-연결하기\"><a href=\"#로컬-저장소를-github-저장소에-연결하기\" class=\"headerlink\" title=\"로컬 저장소를 github 저장소에 연결하기\"></a>로컬 저장소를 github 저장소에 연결하기</h2><p>지금까지는 내 PC에서만 관리 가능한 로컬 저장소를 만들었다. 로컬 저장소만으로는 다른 이들과 프로젝트를 공유할 수 없기 때문에 공동 작업(협업)이 불가하다.</p><p>따라서 협업이나 프로젝트의 공유를 위해서는 특정 서버에 git 저장소를 만들고, 서버를 통해 관리할 필요가 있다. 가장 많이 사용되는 github 홈페이지를 통해 git 원격 저장소를 생성할 수 있다.</p><h3 id=\"1-계정-만들기\"><a href=\"#1-계정-만들기\" class=\"headerlink\" title=\"1. 계정 만들기\"></a>1. 계정 만들기</h3><p><a href=\"github.com\">github.com</a>에 접속하여 계정을 생성하고 로그인한다.</p><h3 id=\"2-원격-저장소-생성하기\"><a href=\"#2-원격-저장소-생성하기\" class=\"headerlink\" title=\"2. 원격 저장소 생성하기\"></a>2. 원격 저장소 생성하기</h3><p>github에 새 프로젝트를 생성하면 원격 저장소가 만들어진다. 아래 예제에서는 test라는 이름의 원격 저장소를 생성하였다.</p><p><img src=\"/images/8.png\" alt=\"github에 저장소 만들기\"></p><p>readme.md는 저장소의 프로젝트에 대한 설명을 작성하는 용도로 흔히 사용된다. 지금은 있어도 되고, 없어도 크게 상관 없다.</p><h3 id=\"3-로컬-저장소와-원격-저장소-연결하기\"><a href=\"#3-로컬-저장소와-원격-저장소-연결하기\" class=\"headerlink\" title=\"3. 로컬 저장소와 원격 저장소 연결하기\"></a>3. 로컬 저장소와 원격 저장소 연결하기</h3><p>지금까지는 로컬 저장소와 원격 저장소 별개로 존재할 뿐 아직 연결되지 않은 상태이다.</p><h3 id=\"git-remote\"><a href=\"#git-remote\" class=\"headerlink\" title=\"git remote\"></a>git remote</h3><p>git remote는 리모트 저장소를 생성한다. 리모트 저장소란 인터넷이나 네트워크 어딘가에 있는 저장소를 말한다. remote 명령어를 통해 저장소를 추가하는 것은 <strong>네트워크 어딘가에 있는 원격 저장소를 관리할 저장소로 등록하는 행위</strong>이다. remote 명령은 아래와 같이 실행할 수 있다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git remote add 단축이름 원격저장소url</div><div class=\"line\"></div><div class=\"line\">$ git remote</div><div class=\"line\"></div><div class=\"line\">$ git remote -v</div></pre></td></tr></table></figure><p>첫번째 명령은 원격저장소를 내 리모트 저장소로 등록(추가)한다. 이때 저장소의 단축 이름을 직접 지정할 수 있다. 저장소명은 특별하지 않다면 origin을 사용하는 것이 일반적이다.</p><p><code>git remote</code> 명령은 내가 등록한 모든 리모트 저장소 목록을 설정한 단축 이름으로 보여준다.</p><p><code>git remote -v</code>는 단축 이름과 url을 함께 보여준다.</p><p><img src=\"/images/git-remote.png\" alt=\"git remote\"></p><hr><p><code>git clone</code></p><p>사실 remote 명령을 생략하고 바로 clone 명령을 사용할 수도 있다. clone은 대상이 되는 원격 저장소를 통째로 나의 로컬 저장소(PC)에 복제해온다. 저장소를 clone하면 origin이라는 이름의 리모트 저장소가 자동으로 등록된다. 따라서 remote하는 과정을 생략하고 바로 <code>git clone 저장소url</code> 명령을 수행하여도 무방하다.</p><hr><h3 id=\"4-로컬-저장소와-원격-저장소-동기화하기\"><a href=\"#4-로컬-저장소와-원격-저장소-동기화하기\" class=\"headerlink\" title=\"4. 로컬 저장소와 원격 저장소 동기화하기\"></a>4. 로컬 저장소와 원격 저장소 동기화하기</h3><p>로컬 저장소와 원격 저장소를 동기화 즉, 같은 상태로 만들어주는 방법에는 두 가지가 있다. (사실 더 많지만 일단은 크게 두 가지만 다룬다.)</p><h3 id=\"git-push\"><a href=\"#git-push\" class=\"headerlink\" title=\"git push\"></a>git push</h3><p>push 명령은 내 로컬 저장소의 확정 변경 사항(commit)을 원격 저장소에도 반영하는 것이다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git push --<span class=\"built_in\">set</span>-upstream origin master</div></pre></td></tr></table></figure><p><code>--set-upstream</code>은 push할 리모트 저장소를 지정해준다. 위에서는 origin이라는 리모트 저장소의 master 브랜치에 push 명령을 내리겠다는 의미이다. <code>--set-upstream</code>은 한번만 지정해두면 새로운 저장소 브랜치를 set하기 전까지는 <code>git push</code> 입력만으로 간편하게 push 할 수 있다.</p><hr><p><remote +=\"\" push=\"\" 오류=\"\"><br>remote 후 바로 push하는 중 발생할 수 있는 오류 몇 가지를 소개한다! 아래와 같은 에러메시지를 만날 수 있다.</remote></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"> ! [rejected]        master -&gt; master (non-fast-forward)</div><div class=\"line\">error: failed to push some refs to &apos;https://github.com/huusz/test.git&apos;</div></pre></td></tr></table></figure><p><img src=\"/images/remote-and-push.png\" alt=\"remote and push\"></p><p><strong>rejected</strong>: push가 거부되었다.<br><strong>master -&gt; master</strong>: 로컬 저장소의 master 브랜치의 변경 사항을 원격 저장소의 master 브랜치에 반영하려 하였는데,<br><strong>non-fast-forward</strong>: 원격 저장소의 master 브랜치가 로컬 저장소의 버전보다 이전 버전이 아니다!</p><p>라는 의미이다.</p><p>즉, 오류가 발생하게 된 원인은 github에서 새로운 프로젝트를 생성하면서 만들어진 원격 저장소에 함께 만들어진 readme.md 파일 때문이다. 더 정확히 말하면 readme.md 파일의 존재가 문제가 되는 것이 아니고, 원격 저장소에서 이루어진 readme.md를 추가하는 커밋이 로컬 저장소의 커밋 로그에 없기 때문이다.</p><p>push 명령은 로컬 저장소의 commit 목록과 원격 저장소의 commit 목록을 비교한다. 그런 다음 원격 저장소의 마지막 commit id와 동일한 commit id를 가진 로컬 저장소의 commit 시점을 찾아낸 뒤, 원격 저장소의 마지막 커밋과 연결한다. 이제 무엇이 이해가 될 것이다. 원격 저장소의 첫번째이자 마지막 commit인 readme를 추가하는 commit이 원격 저장소에는 존재하지 않고, 따라서 현 상태에서는 둘을 연결할 수 없다.</p><p>이 상황을 해결하는 방법은,</p><ol><li><p>원격 저장소를 삭제하고 다시 만들거나, (물론 readme 파일 없이 만들어야 합니다. readme 파일을 함께 생성하면 자동으로 커밋이 생성되기 때문이다.)</p></li><li><p>fetch나 pull 명령으로 원격 저장소의 마지막 커밋을 로컬 저장소 커밋 로그의 맨 앞으로 받아와야 한다.</p></li></ol><p>두 번째 방법으로 해결해본다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git pull origin master</div></pre></td></tr></table></figure><p>한번에 해결되면 좋겠지만, 안타깝게도 또다른 오류가 발생한다.</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">fetal: refusing to merge unrelated histories</div></pre></td></tr></table></figure><p><img src=\"/images/pull-error.png\" alt=\"pull error\"></p><p>에러 내용은 원격 저장소의 master 브랜치에서 로컬 저장소의 FETCH_HEAD를 merge하는 것이 거부되었다. 커밋 히스토리가 서로 관련이 없다. 즉 서로 관련성이 없기 때문에 merge할 수 없다는 것이다. 뒤에서도 설명하겠지만, pull 명령은 fetch + merge 작업을 한번에 처리한다. 현 상황은 fetch는 되었지만, merge가 되지 않은 상태이다.</p><p>기본적으로 merge는 원격 저장소와 로컬 저장소가 공통으로 가지고 있는 commit 지점이 존재해야 한다. 그 지점부터 병합을 시도하기 때문이다. 애초에 공통되는 commit 지점이 존재하지 않아 pull 명령도 사용할 수 없는 것이다.</p><p>해결하기 앞서 상황을 이해하기 위해 간단하게 짚고 넘어갈 개념이 있다. pull과 fetch이다.</p><ul><li>fetch는 리모트 저장소에 있는 내용을 가져오지만 자동으로 내 로컬 저장소에 merge하지 않는다. 원격 저장소의 내용을 확인만 하고 로컬에 병합(merge)하고 싶지는 않을 때 fetch를 사용한다.</li></ul><p>HEAD에는 가장 마지막에 행해진 commit 정보가 담긴다. 마찬가지로 <code>FETCH_HEAD</code>는 리모트 저장소의 가장 최신 commit 이력이 담기게 된다.</p><p><code>FETCH_HEAD</code>는 이름 없는 브랜치로 로컬에 가져오게 된다. 이 브랜치는 <code>FETCH_HEAD</code>로 checkout도 가능하다.</p><ul><li>pull 명령은 리모트 저장소에 있는 내용을 가져올 뿐 아니라 자동으로 로컬 저장소에 merge한다. 즉, git pull은 git fetch + merge FETCH_HEAD인 셈이다.</li></ul><p>복잡하고 긴 설명 끝에 결론은 어쨌든 연결되는 <strong>공통된 커밋 포인트가 없다</strong>는 것이다.</p><p>결국은 clone으로 원격 저장소를 복제해오는 것이 가장 간단하다.</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git clone 저장소url</div></pre></td></tr></table></figure><p>이렇게 하면 원격 저장소의 커밋이 내 로컬 저장소에 복사된다. 이후 add -&gt; commit -&gt; push를 통해 내 로컬 저장소에 있던 커밋 로그를 clone으로 불러온 커밋 로그 뒤에 merge할 수 있으며 이를 원격 저장소에도 반영할 수 있게 된다.</p><blockquote><p>clone은 자동으로 로컬의 master 브랜치가 리모트 저장소의 master 브랜치를 추적하도록 한다. git pull 명령은 clone한 저장소에서 데이터를 가져오고 그 데이터를 자동으로 현재 작업하는 코드와 merge시킨다.</p></blockquote><hr><p>Reference</p><ul><li><a href=\"https://git-scm.com/book/ko/v1/Git-%EB%B8%8C%EB%9E%9C%EC%B9%98-%EB%A6%AC%EB%AA%A8%ED%8A%B8-%EB%B8%8C%EB%9E%9C%EC%B9%98\" target=\"_blank\" rel=\"external\">git-scm.com</a></li><li><a href=\"https://stackoverflow.com/questions/9237348/what-does-fetch-head-in-git-mean\" target=\"_blank\" rel=\"external\">stack overflow</a></li><li><a href=\"https://backlogtool.com/git-tutorial/kr/stepup/stepup3_2.html\" target=\"_blank\" rel=\"external\">git tutorial - fetch</a></li></ul>"},{"title":".git: git의 내부","date":"2017-10-21T19:21:58.000Z","_content":"\ngit 은 Content-addressable 파일 시스템이고 그 위에 VCS 사용자 인터페이스가 있는\n구조입니다 .\n\n1. Content-addressable 파일 시스템\n2. 데이터 전송 원리\n3. 저장소 관리법\n\n<br>\n\n---\n\n# Git 의 내부\n\n## 1. Plumbing 명령과 Porcelain 명령\n\ngit 은 본래 VCS 라기보다 , **VCS 를 위한 툴킷 (tool kit)**입니다 . 기본적으로 매\n우 많은 저수준명령어로 구성되어 있습니다 . ( 저수준이란 사용자보다컴퓨터에게 더\n친숙함을 의미합니다 .) 저수준 명령어들을 UNIX 스타일로 엮어 실행하거나 스크립트\n로만들어 사용하도록 설계되어 있습니다 . Plumbing 명령어는 이러한 저수준 명령어를\n일컫는 말이며 , Porcelain 명령은사용자에게 친숙한 명령어를 의미합니다 . 흔히 사\n용하는 `git add`, `git commit`, `git push`, `git checkout` 등의 명령어들은 사용\n자에게더친숙한 Porcelain 명령어 입니다 .\n\n* **Plumbing** : 저수준의 명령어 .\n\n* **Porcelain** : 사용자에게 친숙한 사용자용 명령어 . 일반적으로 사용하는 git 명\n  령어들 (`add`, `commit`, `push`, `checkout` 등 ) 이 이에 해당합니다 .\n\n### Git 의 내부 구조\n\nPlumbing 명령을 사용하면 git 의 내부 구조에 접근할수 있습니다 . 그리고 git 이 왜\n, 그렇게 작동하는지도확인할 수 있습니다 . Plumbing 명령어는 직접 커맨드라인에서\n실행하기보다 새로운 도구를 만들거나 각자필요한 스크립트를 작성할 때 사용합니다 .\n\n새로 만든 디렉토리나 이미 파일이 있는 디렉토리에서 `git init` 명령을 실행하면\ngit 은 데이터를 저장하고관리하는 `.git` 디렉토리가 생성됩니다 .\n\n```\n.git/\n HEAD\n config*\n description\n hooks/\n info/\n objects/\n refs/\n```\n\n위 파일 구조는 `git init` 명령 실행 직후 보이는 새저장소의 모습입니다 .\n\n* `config` : 해당 프로젝트에만 적용되는 설정 옵션이 들어 있습니다 .\n\n* `info/` : `.gitignore`처럼 무시할 파일의 패턴을적어 두는 곳 입니다 . 하지만\n  `.gitignore`와 달리 git 으로 관리되지 않습니다 .\n\n* `hooks/` : 클라이언트 훅이나 서버 훅이 위치합니다 .\n\n<br>\n\n이제 아래 4 가지 항목이 git 의 핵심입니다 .\n\n<br>\n\n* `objects/` : 모든 컨텐츠를 저장하는 데이터베이스입니다 .\n\n* `refs/` : 커밋 개체의 포인터 (pointer) 를 저장합니다 .\n\n* `HEAD` : 현재 checkout 한 브랜치를 가리킵니다 .\n\n* `index` : Staging Area 의 정보를 저장합니다 .\n\n<br>\n\n## 2. Git 개체\n\nGit 은 Content-addressable 파일시스템 입니다 . 즉 , 단순한 key-value 데이터 저장\n소입니다 . 데이터가어떤 형식인가와 무관하게 key 를 통해 언제든 데이터를다시 가져\n올 수 있습니다 . Plumbing 명령어 `hash-object`에 데이터를 주면 `.git`디렉토리에\n저장하고 그 key 를 알려줍니다 .\n\n테스트용 폴더를 만들어 내부를 실제로 확인해볼 수있습니다 .\n\n```zsh\n$ mkdir test\n$ cd test\n$ git init # 폴더 내부에 .git 디렉터리가 생성됨\n$ find .git/objects\n.git/objects\n.git/objects/pack\n.git/objects/info\n$ find .git/objects -type f\n$\n```\n\n위에서 `.git`의 하위 디렉터리로 `objects/` 디렉터리가 있습니다 . Git 은\n`objects` 디렉터리 밑에 `pack`과 `info` 디렉터리를 만듭니다 . init 명령으로 초기\n화된 지금 상태에서는 파일이 없는 빈 디렉터리로 존재합니다 . 이제 Git 데이터베이\n스에 텍스트파일을 저장합니다 .\n\n```zsh\n# -w 옵션을 주어야 실제로 저장합니다.\n# -w가 없으면 저장하지 않고 key만 보여줍니다.\n# --stdin 옵션은 표준 입력으로 입력되는 데이터를 읽습니다. 이 옵션이 없으면 파일 경로를 알려주어야 합니다.\n$ echo 'test' | git hash-object -w --stdin\n9daeafb9864cf43055ae93beb0afd6c7d144bfa4\n# 40자 길이의 체크섬 해시\n```\n\n이 명령은 표준 입력으로 들어오는 데이터를 저장합니다 . `hash-object` 명령이 출력\n하는 것은 40 자 길이의 체크섬 해시입니다 . 이 해시는 헤더 정보와 데이터모두에 대\n한 SHA-1 해시입니다 .\n\n<br>\n\n### 2.1) blob 개체\n\n이제 Git 이 저장한 데이터를 알아봅니다 .\n\n```zsh\n$ find .git/objects -type f\n.git/objects/9d/aeafb9864cf43055ae93beb0afd6c7d144bfa4\n# 디렉터리 9d는 위 체크섬 해시의 앞 2글자 입니다.\n# 디렉터리 아래 파일명은 해시의 나머지 38글자입니다.\n# 이 파일에 데이터가 저장됩니다.\n```\n\n아까와 달리 obejct 디렉토리에 파일이 하나 생성되었습니다 . Git 은 데이터를 저장\n할 때 해시의 처음 두글자를 디렉토리 이름으로 사용하고 나머지 38 글자를그아래 파\n일 이름으로 사용합니다 . 데이터는 새로만든파일에 저장합니다 .\n\n이제 `cat-file` 명령으로 저장한 데이터를 불러올 수있습니다 . 여기에 `-p` 옵션을\n주면 파일 내용이 출력됩니다 . 이 명령은 Git 개체를 살펴보고 싶을 때언제든 사용할\n수 있습니다 .\n\n```zsh\n$ git cat-file -p 9daeafb9864cf43055ae93beb0afd6c7d144bfa4\ntest\n```\n\n다시 한 번 데이터를 Git 저장소에 추가하고 불러와봅니다 . Git 이 파일 버전을 관리\n하는 방식을 이해할수있도록 가상의 상황을 만들어보겠습니다 . 우선 새파일을 하나만\n들고 Git 저장소에 저장합니다 .\n\n```zsh\n$ echo 'version1' > test.txt\n$ git hash-object -w test.txt\n83baae61804e65cc73a7201a7252750c76066a30\n```\n\n그리고 그 파일을 수정한 뒤 다시 저장합니다 .\n\n```zsh\n$ echo 'version2' > test.txt\n$ git hash-object -w test.txt\n1f7a7a472abf3dd9643fd615f6da379c4acb3e3a\n```\n\n이제 데이터베이스에는 데이터가 두 가지 버전으로 저장되어 있습니다 .\n\n```zsh\n$ find .git/objects -type f\n.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a\n.git/objects/83/baae61804e65cc73a7201a7252750c76066a30\n.git/objects/9d/aeafb9864cf43055ae93beb0afd6c7d144bfa4\n```\n\n파일의 내용을 첫 번째 버전으로 되돌려봅니다 .\n\n```zsh\n$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 > test.txt\n$ cat test.txt\nversion 1\n```\n\n```zsh\n$ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a > test.txt\n$ cat test.txt\nversion 2\n```\n\n그런데 파일의 SHA-1 키를 외워서 사용하는 것은 너무어렵습니다 . 게다가 파일의 내\n용만 저장했을 뿐 파일의 본래 이름은 저장하지도 않았습니다 . 이런 종류의개체를\nBlob 개체라고 부릅니다 . `cat-file -t` 명령으로 해당 개체가 무슨 개체인지 확인할\n수 있습니다 .\n\n```zsh\n$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a\nblob\n```\n\n### 2.2) tree 개체\n\n그렇다면 파일 이름은 어디에 저장되는 것일까요 ? 바로 Tree 개체에 파일 이름을 저\n장합니다 . ( 트리 개체에는 파일 여러 개를 한꺼번에 저장할 수도 있습니다 .) Git\n은 모든 것을 Tree 와 Blob 개체로 저장합니다 . Tree 를 디렉토리 , Blob 은 일반 파\n일에 대응하면쉽습니다 . Tree 개체 하나는 항목을 여러 개 가질 수있고 그 항목에는\nBlob 개체나 하위 Tree 개체를가리키는 SHA-1 포인터 , 파일 모드 , 개체 타입 , 파일\n이름이 들어있습니다 . 아래와 같은 Tree 개체가 있다고할 때 ,\n\n```zsh\n# master^{tree} 구문은 master 브랜치가 가리키는 tree개체를 말합니다.\n$ git cat-file -p master^{tree}\n100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README\n100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile\n040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib\n# 디렉터리로, 또 다른 tree개체입니다.\n```\n\nGit 이 저장하는 데이터는 대략 아래와 같습니다 .\n\n![단순화한 Git 데이터 모델](https://git-scm.com/figures/18333fig0901-tn.png)\n\n<!-- \n직접 tree 개체를 만들어보겠습니다 . Git 은 일반적으로 Staging Area(Index) 의 상\n태대로 Tree 개체를만들고 기록합니다 . 그래서 Tree 개체를 만들려면 일단 Staging\nArea 에 파일을 추가해서 Index 를 만들어야합니다 . 우선 Plumbing 명령어\n`update-index`로 test.txt 파일만 들어있는 Index 를 만듭니다 . 이 명령어는 파일을\n인위적으로 Staging Area 에 추가하는명령입니다 . 아직 Staging Area 에 없는 파일이\n므로 --add 옵션을 꼭 주어야 합니다 . 그리고 디렉토리에있는 파일이 아니라 데이터\n베이스에 있는 파일을 추가하는 것이기 때문에 --casheinfo 옵션이 필요합니다 . 파일\n모드 SHA-1 해시 , 파일 이름 정보도 입력합니다 .\n\n```zsh\n$ git update-index --add --cashinfo 100644 \\\n``` -->\n\n---\n","source":"_posts/GIT/03.inner.md","raw":"---\ntitle: '.git: git의 내부'\ndate: 2017-10-22 04:21:58\ncategory: Git\ntags: git\n---\n\ngit 은 Content-addressable 파일 시스템이고 그 위에 VCS 사용자 인터페이스가 있는\n구조입니다 .\n\n1. Content-addressable 파일 시스템\n2. 데이터 전송 원리\n3. 저장소 관리법\n\n<br>\n\n---\n\n# Git 의 내부\n\n## 1. Plumbing 명령과 Porcelain 명령\n\ngit 은 본래 VCS 라기보다 , **VCS 를 위한 툴킷 (tool kit)**입니다 . 기본적으로 매\n우 많은 저수준명령어로 구성되어 있습니다 . ( 저수준이란 사용자보다컴퓨터에게 더\n친숙함을 의미합니다 .) 저수준 명령어들을 UNIX 스타일로 엮어 실행하거나 스크립트\n로만들어 사용하도록 설계되어 있습니다 . Plumbing 명령어는 이러한 저수준 명령어를\n일컫는 말이며 , Porcelain 명령은사용자에게 친숙한 명령어를 의미합니다 . 흔히 사\n용하는 `git add`, `git commit`, `git push`, `git checkout` 등의 명령어들은 사용\n자에게더친숙한 Porcelain 명령어 입니다 .\n\n* **Plumbing** : 저수준의 명령어 .\n\n* **Porcelain** : 사용자에게 친숙한 사용자용 명령어 . 일반적으로 사용하는 git 명\n  령어들 (`add`, `commit`, `push`, `checkout` 등 ) 이 이에 해당합니다 .\n\n### Git 의 내부 구조\n\nPlumbing 명령을 사용하면 git 의 내부 구조에 접근할수 있습니다 . 그리고 git 이 왜\n, 그렇게 작동하는지도확인할 수 있습니다 . Plumbing 명령어는 직접 커맨드라인에서\n실행하기보다 새로운 도구를 만들거나 각자필요한 스크립트를 작성할 때 사용합니다 .\n\n새로 만든 디렉토리나 이미 파일이 있는 디렉토리에서 `git init` 명령을 실행하면\ngit 은 데이터를 저장하고관리하는 `.git` 디렉토리가 생성됩니다 .\n\n```\n.git/\n HEAD\n config*\n description\n hooks/\n info/\n objects/\n refs/\n```\n\n위 파일 구조는 `git init` 명령 실행 직후 보이는 새저장소의 모습입니다 .\n\n* `config` : 해당 프로젝트에만 적용되는 설정 옵션이 들어 있습니다 .\n\n* `info/` : `.gitignore`처럼 무시할 파일의 패턴을적어 두는 곳 입니다 . 하지만\n  `.gitignore`와 달리 git 으로 관리되지 않습니다 .\n\n* `hooks/` : 클라이언트 훅이나 서버 훅이 위치합니다 .\n\n<br>\n\n이제 아래 4 가지 항목이 git 의 핵심입니다 .\n\n<br>\n\n* `objects/` : 모든 컨텐츠를 저장하는 데이터베이스입니다 .\n\n* `refs/` : 커밋 개체의 포인터 (pointer) 를 저장합니다 .\n\n* `HEAD` : 현재 checkout 한 브랜치를 가리킵니다 .\n\n* `index` : Staging Area 의 정보를 저장합니다 .\n\n<br>\n\n## 2. Git 개체\n\nGit 은 Content-addressable 파일시스템 입니다 . 즉 , 단순한 key-value 데이터 저장\n소입니다 . 데이터가어떤 형식인가와 무관하게 key 를 통해 언제든 데이터를다시 가져\n올 수 있습니다 . Plumbing 명령어 `hash-object`에 데이터를 주면 `.git`디렉토리에\n저장하고 그 key 를 알려줍니다 .\n\n테스트용 폴더를 만들어 내부를 실제로 확인해볼 수있습니다 .\n\n```zsh\n$ mkdir test\n$ cd test\n$ git init # 폴더 내부에 .git 디렉터리가 생성됨\n$ find .git/objects\n.git/objects\n.git/objects/pack\n.git/objects/info\n$ find .git/objects -type f\n$\n```\n\n위에서 `.git`의 하위 디렉터리로 `objects/` 디렉터리가 있습니다 . Git 은\n`objects` 디렉터리 밑에 `pack`과 `info` 디렉터리를 만듭니다 . init 명령으로 초기\n화된 지금 상태에서는 파일이 없는 빈 디렉터리로 존재합니다 . 이제 Git 데이터베이\n스에 텍스트파일을 저장합니다 .\n\n```zsh\n# -w 옵션을 주어야 실제로 저장합니다.\n# -w가 없으면 저장하지 않고 key만 보여줍니다.\n# --stdin 옵션은 표준 입력으로 입력되는 데이터를 읽습니다. 이 옵션이 없으면 파일 경로를 알려주어야 합니다.\n$ echo 'test' | git hash-object -w --stdin\n9daeafb9864cf43055ae93beb0afd6c7d144bfa4\n# 40자 길이의 체크섬 해시\n```\n\n이 명령은 표준 입력으로 들어오는 데이터를 저장합니다 . `hash-object` 명령이 출력\n하는 것은 40 자 길이의 체크섬 해시입니다 . 이 해시는 헤더 정보와 데이터모두에 대\n한 SHA-1 해시입니다 .\n\n<br>\n\n### 2.1) blob 개체\n\n이제 Git 이 저장한 데이터를 알아봅니다 .\n\n```zsh\n$ find .git/objects -type f\n.git/objects/9d/aeafb9864cf43055ae93beb0afd6c7d144bfa4\n# 디렉터리 9d는 위 체크섬 해시의 앞 2글자 입니다.\n# 디렉터리 아래 파일명은 해시의 나머지 38글자입니다.\n# 이 파일에 데이터가 저장됩니다.\n```\n\n아까와 달리 obejct 디렉토리에 파일이 하나 생성되었습니다 . Git 은 데이터를 저장\n할 때 해시의 처음 두글자를 디렉토리 이름으로 사용하고 나머지 38 글자를그아래 파\n일 이름으로 사용합니다 . 데이터는 새로만든파일에 저장합니다 .\n\n이제 `cat-file` 명령으로 저장한 데이터를 불러올 수있습니다 . 여기에 `-p` 옵션을\n주면 파일 내용이 출력됩니다 . 이 명령은 Git 개체를 살펴보고 싶을 때언제든 사용할\n수 있습니다 .\n\n```zsh\n$ git cat-file -p 9daeafb9864cf43055ae93beb0afd6c7d144bfa4\ntest\n```\n\n다시 한 번 데이터를 Git 저장소에 추가하고 불러와봅니다 . Git 이 파일 버전을 관리\n하는 방식을 이해할수있도록 가상의 상황을 만들어보겠습니다 . 우선 새파일을 하나만\n들고 Git 저장소에 저장합니다 .\n\n```zsh\n$ echo 'version1' > test.txt\n$ git hash-object -w test.txt\n83baae61804e65cc73a7201a7252750c76066a30\n```\n\n그리고 그 파일을 수정한 뒤 다시 저장합니다 .\n\n```zsh\n$ echo 'version2' > test.txt\n$ git hash-object -w test.txt\n1f7a7a472abf3dd9643fd615f6da379c4acb3e3a\n```\n\n이제 데이터베이스에는 데이터가 두 가지 버전으로 저장되어 있습니다 .\n\n```zsh\n$ find .git/objects -type f\n.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a\n.git/objects/83/baae61804e65cc73a7201a7252750c76066a30\n.git/objects/9d/aeafb9864cf43055ae93beb0afd6c7d144bfa4\n```\n\n파일의 내용을 첫 번째 버전으로 되돌려봅니다 .\n\n```zsh\n$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 > test.txt\n$ cat test.txt\nversion 1\n```\n\n```zsh\n$ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a > test.txt\n$ cat test.txt\nversion 2\n```\n\n그런데 파일의 SHA-1 키를 외워서 사용하는 것은 너무어렵습니다 . 게다가 파일의 내\n용만 저장했을 뿐 파일의 본래 이름은 저장하지도 않았습니다 . 이런 종류의개체를\nBlob 개체라고 부릅니다 . `cat-file -t` 명령으로 해당 개체가 무슨 개체인지 확인할\n수 있습니다 .\n\n```zsh\n$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a\nblob\n```\n\n### 2.2) tree 개체\n\n그렇다면 파일 이름은 어디에 저장되는 것일까요 ? 바로 Tree 개체에 파일 이름을 저\n장합니다 . ( 트리 개체에는 파일 여러 개를 한꺼번에 저장할 수도 있습니다 .) Git\n은 모든 것을 Tree 와 Blob 개체로 저장합니다 . Tree 를 디렉토리 , Blob 은 일반 파\n일에 대응하면쉽습니다 . Tree 개체 하나는 항목을 여러 개 가질 수있고 그 항목에는\nBlob 개체나 하위 Tree 개체를가리키는 SHA-1 포인터 , 파일 모드 , 개체 타입 , 파일\n이름이 들어있습니다 . 아래와 같은 Tree 개체가 있다고할 때 ,\n\n```zsh\n# master^{tree} 구문은 master 브랜치가 가리키는 tree개체를 말합니다.\n$ git cat-file -p master^{tree}\n100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README\n100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile\n040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib\n# 디렉터리로, 또 다른 tree개체입니다.\n```\n\nGit 이 저장하는 데이터는 대략 아래와 같습니다 .\n\n![단순화한 Git 데이터 모델](https://git-scm.com/figures/18333fig0901-tn.png)\n\n<!-- \n직접 tree 개체를 만들어보겠습니다 . Git 은 일반적으로 Staging Area(Index) 의 상\n태대로 Tree 개체를만들고 기록합니다 . 그래서 Tree 개체를 만들려면 일단 Staging\nArea 에 파일을 추가해서 Index 를 만들어야합니다 . 우선 Plumbing 명령어\n`update-index`로 test.txt 파일만 들어있는 Index 를 만듭니다 . 이 명령어는 파일을\n인위적으로 Staging Area 에 추가하는명령입니다 . 아직 Staging Area 에 없는 파일이\n므로 --add 옵션을 꼭 주어야 합니다 . 그리고 디렉토리에있는 파일이 아니라 데이터\n베이스에 있는 파일을 추가하는 것이기 때문에 --casheinfo 옵션이 필요합니다 . 파일\n모드 SHA-1 해시 , 파일 이름 정보도 입력합니다 .\n\n```zsh\n$ git update-index --add --cashinfo 100644 \\\n``` -->\n\n---\n","slug":"GIT/03.inner","published":1,"updated":"2017-11-27T12:21:01.237Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjai8h17m0004vb9qnz0fmvwe","content":"<p>git 은 Content-addressable 파일 시스템이고 그 위에 VCS 사용자 인터페이스가 있는<br>구조입니다 .</p><ol><li>Content-addressable 파일 시스템</li><li>데이터 전송 원리</li><li>저장소 관리법</li></ol><p><br></p><hr><h1 id=\"Git-의-내부\"><a href=\"#Git-의-내부\" class=\"headerlink\" title=\"Git 의 내부\"></a>Git 의 내부</h1><h2 id=\"1-Plumbing-명령과-Porcelain-명령\"><a href=\"#1-Plumbing-명령과-Porcelain-명령\" class=\"headerlink\" title=\"1. Plumbing 명령과 Porcelain 명령\"></a>1. Plumbing 명령과 Porcelain 명령</h2><p>git 은 본래 VCS 라기보다 , <strong>VCS 를 위한 툴킷 (tool kit)</strong>입니다 . 기본적으로 매<br>우 많은 저수준명령어로 구성되어 있습니다 . ( 저수준이란 사용자보다컴퓨터에게 더<br>친숙함을 의미합니다 .) 저수준 명령어들을 UNIX 스타일로 엮어 실행하거나 스크립트<br>로만들어 사용하도록 설계되어 있습니다 . Plumbing 명령어는 이러한 저수준 명령어를<br>일컫는 말이며 , Porcelain 명령은사용자에게 친숙한 명령어를 의미합니다 . 흔히 사<br>용하는 <code>git add</code>, <code>git commit</code>, <code>git push</code>, <code>git checkout</code> 등의 명령어들은 사용<br>자에게더친숙한 Porcelain 명령어 입니다 .</p><ul><li><p><strong>Plumbing</strong> : 저수준의 명령어 .</p></li><li><p><strong>Porcelain</strong> : 사용자에게 친숙한 사용자용 명령어 . 일반적으로 사용하는 git 명<br>령어들 (<code>add</code>, <code>commit</code>, <code>push</code>, <code>checkout</code> 등 ) 이 이에 해당합니다 .</p></li></ul><h3 id=\"Git-의-내부-구조\"><a href=\"#Git-의-내부-구조\" class=\"headerlink\" title=\"Git 의 내부 구조\"></a>Git 의 내부 구조</h3><p>Plumbing 명령을 사용하면 git 의 내부 구조에 접근할수 있습니다 . 그리고 git 이 왜<br>, 그렇게 작동하는지도확인할 수 있습니다 . Plumbing 명령어는 직접 커맨드라인에서<br>실행하기보다 새로운 도구를 만들거나 각자필요한 스크립트를 작성할 때 사용합니다 .</p><p>새로 만든 디렉토리나 이미 파일이 있는 디렉토리에서 <code>git init</code> 명령을 실행하면<br>git 은 데이터를 저장하고관리하는 <code>.git</code> 디렉토리가 생성됩니다 .</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">.git/</div><div class=\"line\"> HEAD</div><div class=\"line\"> config*</div><div class=\"line\"> description</div><div class=\"line\"> hooks/</div><div class=\"line\"> info/</div><div class=\"line\"> objects/</div><div class=\"line\"> refs/</div></pre></td></tr></table></figure><p>위 파일 구조는 <code>git init</code> 명령 실행 직후 보이는 새저장소의 모습입니다 .</p><ul><li><p><code>config</code> : 해당 프로젝트에만 적용되는 설정 옵션이 들어 있습니다 .</p></li><li><p><code>info/</code> : <code>.gitignore</code>처럼 무시할 파일의 패턴을적어 두는 곳 입니다 . 하지만<br><code>.gitignore</code>와 달리 git 으로 관리되지 않습니다 .</p></li><li><p><code>hooks/</code> : 클라이언트 훅이나 서버 훅이 위치합니다 .</p></li></ul><p><br></p><p>이제 아래 4 가지 항목이 git 의 핵심입니다 .</p><p><br></p><ul><li><p><code>objects/</code> : 모든 컨텐츠를 저장하는 데이터베이스입니다 .</p></li><li><p><code>refs/</code> : 커밋 개체의 포인터 (pointer) 를 저장합니다 .</p></li><li><p><code>HEAD</code> : 현재 checkout 한 브랜치를 가리킵니다 .</p></li><li><p><code>index</code> : Staging Area 의 정보를 저장합니다 .</p></li></ul><p><br></p><h2 id=\"2-Git-개체\"><a href=\"#2-Git-개체\" class=\"headerlink\" title=\"2. Git 개체\"></a>2. Git 개체</h2><p>Git 은 Content-addressable 파일시스템 입니다 . 즉 , 단순한 key-value 데이터 저장<br>소입니다 . 데이터가어떤 형식인가와 무관하게 key 를 통해 언제든 데이터를다시 가져<br>올 수 있습니다 . Plumbing 명령어 <code>hash-object</code>에 데이터를 주면 <code>.git</code>디렉토리에<br>저장하고 그 key 를 알려줍니다 .</p><p>테스트용 폴더를 만들어 내부를 실제로 확인해볼 수있습니다 .</p><figure class=\"highlight zsh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ mkdir <span class=\"built_in\">test</span></div><div class=\"line\">$ <span class=\"built_in\">cd</span> <span class=\"built_in\">test</span></div><div class=\"line\">$ git init <span class=\"comment\"># 폴더 내부에 .git 디렉터리가 생성됨</span></div><div class=\"line\">$ find .git/objects</div><div class=\"line\">.git/objects</div><div class=\"line\">.git/objects/pack</div><div class=\"line\">.git/objects/info</div><div class=\"line\">$ find .git/objects -<span class=\"built_in\">type</span> f</div><div class=\"line\">$</div></pre></td></tr></table></figure><p>위에서 <code>.git</code>의 하위 디렉터리로 <code>objects/</code> 디렉터리가 있습니다 . Git 은<br><code>objects</code> 디렉터리 밑에 <code>pack</code>과 <code>info</code> 디렉터리를 만듭니다 . init 명령으로 초기<br>화된 지금 상태에서는 파일이 없는 빈 디렉터리로 존재합니다 . 이제 Git 데이터베이<br>스에 텍스트파일을 저장합니다 .</p><figure class=\"highlight zsh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># -w 옵션을 주어야 실제로 저장합니다.</span></div><div class=\"line\"><span class=\"comment\"># -w가 없으면 저장하지 않고 key만 보여줍니다.</span></div><div class=\"line\"><span class=\"comment\"># --stdin 옵션은 표준 입력으로 입력되는 데이터를 읽습니다. 이 옵션이 없으면 파일 경로를 알려주어야 합니다.</span></div><div class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">'test'</span> | git <span class=\"built_in\">hash</span>-object -w --stdin</div><div class=\"line\">9daeafb9864cf43055ae93beb0afd6c7d144bfa4</div><div class=\"line\"><span class=\"comment\"># 40자 길이의 체크섬 해시</span></div></pre></td></tr></table></figure><p>이 명령은 표준 입력으로 들어오는 데이터를 저장합니다 . <code>hash-object</code> 명령이 출력<br>하는 것은 40 자 길이의 체크섬 해시입니다 . 이 해시는 헤더 정보와 데이터모두에 대<br>한 SHA-1 해시입니다 .</p><p><br></p><h3 id=\"2-1-blob-개체\"><a href=\"#2-1-blob-개체\" class=\"headerlink\" title=\"2.1) blob 개체\"></a>2.1) blob 개체</h3><p>이제 Git 이 저장한 데이터를 알아봅니다 .</p><figure class=\"highlight zsh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ find .git/objects -<span class=\"built_in\">type</span> f</div><div class=\"line\">.git/objects/9d/aeafb9864cf43055ae93beb0afd6c7d144bfa4</div><div class=\"line\"><span class=\"comment\"># 디렉터리 9d는 위 체크섬 해시의 앞 2글자 입니다.</span></div><div class=\"line\"><span class=\"comment\"># 디렉터리 아래 파일명은 해시의 나머지 38글자입니다.</span></div><div class=\"line\"><span class=\"comment\"># 이 파일에 데이터가 저장됩니다.</span></div></pre></td></tr></table></figure><p>아까와 달리 obejct 디렉토리에 파일이 하나 생성되었습니다 . Git 은 데이터를 저장<br>할 때 해시의 처음 두글자를 디렉토리 이름으로 사용하고 나머지 38 글자를그아래 파<br>일 이름으로 사용합니다 . 데이터는 새로만든파일에 저장합니다 .</p><p>이제 <code>cat-file</code> 명령으로 저장한 데이터를 불러올 수있습니다 . 여기에 <code>-p</code> 옵션을<br>주면 파일 내용이 출력됩니다 . 이 명령은 Git 개체를 살펴보고 싶을 때언제든 사용할<br>수 있습니다 .</p><figure class=\"highlight zsh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git cat-file -p 9daeafb9864cf43055ae93beb0afd6c7d144bfa4</div><div class=\"line\"><span class=\"built_in\">test</span></div></pre></td></tr></table></figure><p>다시 한 번 데이터를 Git 저장소에 추가하고 불러와봅니다 . Git 이 파일 버전을 관리<br>하는 방식을 이해할수있도록 가상의 상황을 만들어보겠습니다 . 우선 새파일을 하나만<br>들고 Git 저장소에 저장합니다 .</p><figure class=\"highlight zsh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">'version1'</span> &gt; test.txt</div><div class=\"line\">$ git <span class=\"built_in\">hash</span>-object -w test.txt</div><div class=\"line\">83baae61804e65cc73a7201a7252750c76066a30</div></pre></td></tr></table></figure><p>그리고 그 파일을 수정한 뒤 다시 저장합니다 .</p><figure class=\"highlight zsh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">'version2'</span> &gt; test.txt</div><div class=\"line\">$ git <span class=\"built_in\">hash</span>-object -w test.txt</div><div class=\"line\">1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</div></pre></td></tr></table></figure><p>이제 데이터베이스에는 데이터가 두 가지 버전으로 저장되어 있습니다 .</p><figure class=\"highlight zsh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ find .git/objects -<span class=\"built_in\">type</span> f</div><div class=\"line\">.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a</div><div class=\"line\">.git/objects/83/baae61804e65cc73a7201a7252750c76066a30</div><div class=\"line\">.git/objects/9d/aeafb9864cf43055ae93beb0afd6c7d144bfa4</div></pre></td></tr></table></figure><p>파일의 내용을 첫 번째 버전으로 되돌려봅니다 .</p><figure class=\"highlight zsh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 &gt; test.txt</div><div class=\"line\">$ cat test.txt</div><div class=\"line\">version 1</div></pre></td></tr></table></figure><figure class=\"highlight zsh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a &gt; test.txt</div><div class=\"line\">$ cat test.txt</div><div class=\"line\">version 2</div></pre></td></tr></table></figure><p>그런데 파일의 SHA-1 키를 외워서 사용하는 것은 너무어렵습니다 . 게다가 파일의 내<br>용만 저장했을 뿐 파일의 본래 이름은 저장하지도 않았습니다 . 이런 종류의개체를<br>Blob 개체라고 부릅니다 . <code>cat-file -t</code> 명령으로 해당 개체가 무슨 개체인지 확인할<br>수 있습니다 .</p><figure class=\"highlight zsh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</div><div class=\"line\">blob</div></pre></td></tr></table></figure><h3 id=\"2-2-tree-개체\"><a href=\"#2-2-tree-개체\" class=\"headerlink\" title=\"2.2) tree 개체\"></a>2.2) tree 개체</h3><p>그렇다면 파일 이름은 어디에 저장되는 것일까요 ? 바로 Tree 개체에 파일 이름을 저<br>장합니다 . ( 트리 개체에는 파일 여러 개를 한꺼번에 저장할 수도 있습니다 .) Git<br>은 모든 것을 Tree 와 Blob 개체로 저장합니다 . Tree 를 디렉토리 , Blob 은 일반 파<br>일에 대응하면쉽습니다 . Tree 개체 하나는 항목을 여러 개 가질 수있고 그 항목에는<br>Blob 개체나 하위 Tree 개체를가리키는 SHA-1 포인터 , 파일 모드 , 개체 타입 , 파일<br>이름이 들어있습니다 . 아래와 같은 Tree 개체가 있다고할 때 ,</p><figure class=\"highlight zsh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># master^&#123;tree&#125; 구문은 master 브랜치가 가리키는 tree개체를 말합니다.</span></div><div class=\"line\">$ git cat-file -p master^&#123;tree&#125;</div><div class=\"line\">100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README</div><div class=\"line\">100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile</div><div class=\"line\">040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib</div><div class=\"line\"><span class=\"comment\"># 디렉터리로, 또 다른 tree개체입니다.</span></div></pre></td></tr></table></figure><p>Git 이 저장하는 데이터는 대략 아래와 같습니다 .</p><p><img src=\"https://git-scm.com/figures/18333fig0901-tn.png\" alt=\"단순화한 Git 데이터 모델\"></p><hr>","site":{"data":{}},"excerpt":"","more":"<p>git 은 Content-addressable 파일 시스템이고 그 위에 VCS 사용자 인터페이스가 있는<br>구조입니다 .</p><ol><li>Content-addressable 파일 시스템</li><li>데이터 전송 원리</li><li>저장소 관리법</li></ol><p><br></p><hr><h1 id=\"Git-의-내부\"><a href=\"#Git-의-내부\" class=\"headerlink\" title=\"Git 의 내부\"></a>Git 의 내부</h1><h2 id=\"1-Plumbing-명령과-Porcelain-명령\"><a href=\"#1-Plumbing-명령과-Porcelain-명령\" class=\"headerlink\" title=\"1. Plumbing 명령과 Porcelain 명령\"></a>1. Plumbing 명령과 Porcelain 명령</h2><p>git 은 본래 VCS 라기보다 , <strong>VCS 를 위한 툴킷 (tool kit)</strong>입니다 . 기본적으로 매<br>우 많은 저수준명령어로 구성되어 있습니다 . ( 저수준이란 사용자보다컴퓨터에게 더<br>친숙함을 의미합니다 .) 저수준 명령어들을 UNIX 스타일로 엮어 실행하거나 스크립트<br>로만들어 사용하도록 설계되어 있습니다 . Plumbing 명령어는 이러한 저수준 명령어를<br>일컫는 말이며 , Porcelain 명령은사용자에게 친숙한 명령어를 의미합니다 . 흔히 사<br>용하는 <code>git add</code>, <code>git commit</code>, <code>git push</code>, <code>git checkout</code> 등의 명령어들은 사용<br>자에게더친숙한 Porcelain 명령어 입니다 .</p><ul><li><p><strong>Plumbing</strong> : 저수준의 명령어 .</p></li><li><p><strong>Porcelain</strong> : 사용자에게 친숙한 사용자용 명령어 . 일반적으로 사용하는 git 명<br>령어들 (<code>add</code>, <code>commit</code>, <code>push</code>, <code>checkout</code> 등 ) 이 이에 해당합니다 .</p></li></ul><h3 id=\"Git-의-내부-구조\"><a href=\"#Git-의-내부-구조\" class=\"headerlink\" title=\"Git 의 내부 구조\"></a>Git 의 내부 구조</h3><p>Plumbing 명령을 사용하면 git 의 내부 구조에 접근할수 있습니다 . 그리고 git 이 왜<br>, 그렇게 작동하는지도확인할 수 있습니다 . Plumbing 명령어는 직접 커맨드라인에서<br>실행하기보다 새로운 도구를 만들거나 각자필요한 스크립트를 작성할 때 사용합니다 .</p><p>새로 만든 디렉토리나 이미 파일이 있는 디렉토리에서 <code>git init</code> 명령을 실행하면<br>git 은 데이터를 저장하고관리하는 <code>.git</code> 디렉토리가 생성됩니다 .</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">.git/</div><div class=\"line\"> HEAD</div><div class=\"line\"> config*</div><div class=\"line\"> description</div><div class=\"line\"> hooks/</div><div class=\"line\"> info/</div><div class=\"line\"> objects/</div><div class=\"line\"> refs/</div></pre></td></tr></table></figure><p>위 파일 구조는 <code>git init</code> 명령 실행 직후 보이는 새저장소의 모습입니다 .</p><ul><li><p><code>config</code> : 해당 프로젝트에만 적용되는 설정 옵션이 들어 있습니다 .</p></li><li><p><code>info/</code> : <code>.gitignore</code>처럼 무시할 파일의 패턴을적어 두는 곳 입니다 . 하지만<br><code>.gitignore</code>와 달리 git 으로 관리되지 않습니다 .</p></li><li><p><code>hooks/</code> : 클라이언트 훅이나 서버 훅이 위치합니다 .</p></li></ul><p><br></p><p>이제 아래 4 가지 항목이 git 의 핵심입니다 .</p><p><br></p><ul><li><p><code>objects/</code> : 모든 컨텐츠를 저장하는 데이터베이스입니다 .</p></li><li><p><code>refs/</code> : 커밋 개체의 포인터 (pointer) 를 저장합니다 .</p></li><li><p><code>HEAD</code> : 현재 checkout 한 브랜치를 가리킵니다 .</p></li><li><p><code>index</code> : Staging Area 의 정보를 저장합니다 .</p></li></ul><p><br></p><h2 id=\"2-Git-개체\"><a href=\"#2-Git-개체\" class=\"headerlink\" title=\"2. Git 개체\"></a>2. Git 개체</h2><p>Git 은 Content-addressable 파일시스템 입니다 . 즉 , 단순한 key-value 데이터 저장<br>소입니다 . 데이터가어떤 형식인가와 무관하게 key 를 통해 언제든 데이터를다시 가져<br>올 수 있습니다 . Plumbing 명령어 <code>hash-object</code>에 데이터를 주면 <code>.git</code>디렉토리에<br>저장하고 그 key 를 알려줍니다 .</p><p>테스트용 폴더를 만들어 내부를 실제로 확인해볼 수있습니다 .</p><figure class=\"highlight zsh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ mkdir <span class=\"built_in\">test</span></div><div class=\"line\">$ <span class=\"built_in\">cd</span> <span class=\"built_in\">test</span></div><div class=\"line\">$ git init <span class=\"comment\"># 폴더 내부에 .git 디렉터리가 생성됨</span></div><div class=\"line\">$ find .git/objects</div><div class=\"line\">.git/objects</div><div class=\"line\">.git/objects/pack</div><div class=\"line\">.git/objects/info</div><div class=\"line\">$ find .git/objects -<span class=\"built_in\">type</span> f</div><div class=\"line\">$</div></pre></td></tr></table></figure><p>위에서 <code>.git</code>의 하위 디렉터리로 <code>objects/</code> 디렉터리가 있습니다 . Git 은<br><code>objects</code> 디렉터리 밑에 <code>pack</code>과 <code>info</code> 디렉터리를 만듭니다 . init 명령으로 초기<br>화된 지금 상태에서는 파일이 없는 빈 디렉터리로 존재합니다 . 이제 Git 데이터베이<br>스에 텍스트파일을 저장합니다 .</p><figure class=\"highlight zsh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># -w 옵션을 주어야 실제로 저장합니다.</span></div><div class=\"line\"><span class=\"comment\"># -w가 없으면 저장하지 않고 key만 보여줍니다.</span></div><div class=\"line\"><span class=\"comment\"># --stdin 옵션은 표준 입력으로 입력되는 데이터를 읽습니다. 이 옵션이 없으면 파일 경로를 알려주어야 합니다.</span></div><div class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">'test'</span> | git <span class=\"built_in\">hash</span>-object -w --stdin</div><div class=\"line\">9daeafb9864cf43055ae93beb0afd6c7d144bfa4</div><div class=\"line\"><span class=\"comment\"># 40자 길이의 체크섬 해시</span></div></pre></td></tr></table></figure><p>이 명령은 표준 입력으로 들어오는 데이터를 저장합니다 . <code>hash-object</code> 명령이 출력<br>하는 것은 40 자 길이의 체크섬 해시입니다 . 이 해시는 헤더 정보와 데이터모두에 대<br>한 SHA-1 해시입니다 .</p><p><br></p><h3 id=\"2-1-blob-개체\"><a href=\"#2-1-blob-개체\" class=\"headerlink\" title=\"2.1) blob 개체\"></a>2.1) blob 개체</h3><p>이제 Git 이 저장한 데이터를 알아봅니다 .</p><figure class=\"highlight zsh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ find .git/objects -<span class=\"built_in\">type</span> f</div><div class=\"line\">.git/objects/9d/aeafb9864cf43055ae93beb0afd6c7d144bfa4</div><div class=\"line\"><span class=\"comment\"># 디렉터리 9d는 위 체크섬 해시의 앞 2글자 입니다.</span></div><div class=\"line\"><span class=\"comment\"># 디렉터리 아래 파일명은 해시의 나머지 38글자입니다.</span></div><div class=\"line\"><span class=\"comment\"># 이 파일에 데이터가 저장됩니다.</span></div></pre></td></tr></table></figure><p>아까와 달리 obejct 디렉토리에 파일이 하나 생성되었습니다 . Git 은 데이터를 저장<br>할 때 해시의 처음 두글자를 디렉토리 이름으로 사용하고 나머지 38 글자를그아래 파<br>일 이름으로 사용합니다 . 데이터는 새로만든파일에 저장합니다 .</p><p>이제 <code>cat-file</code> 명령으로 저장한 데이터를 불러올 수있습니다 . 여기에 <code>-p</code> 옵션을<br>주면 파일 내용이 출력됩니다 . 이 명령은 Git 개체를 살펴보고 싶을 때언제든 사용할<br>수 있습니다 .</p><figure class=\"highlight zsh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git cat-file -p 9daeafb9864cf43055ae93beb0afd6c7d144bfa4</div><div class=\"line\"><span class=\"built_in\">test</span></div></pre></td></tr></table></figure><p>다시 한 번 데이터를 Git 저장소에 추가하고 불러와봅니다 . Git 이 파일 버전을 관리<br>하는 방식을 이해할수있도록 가상의 상황을 만들어보겠습니다 . 우선 새파일을 하나만<br>들고 Git 저장소에 저장합니다 .</p><figure class=\"highlight zsh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">'version1'</span> &gt; test.txt</div><div class=\"line\">$ git <span class=\"built_in\">hash</span>-object -w test.txt</div><div class=\"line\">83baae61804e65cc73a7201a7252750c76066a30</div></pre></td></tr></table></figure><p>그리고 그 파일을 수정한 뒤 다시 저장합니다 .</p><figure class=\"highlight zsh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">'version2'</span> &gt; test.txt</div><div class=\"line\">$ git <span class=\"built_in\">hash</span>-object -w test.txt</div><div class=\"line\">1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</div></pre></td></tr></table></figure><p>이제 데이터베이스에는 데이터가 두 가지 버전으로 저장되어 있습니다 .</p><figure class=\"highlight zsh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ find .git/objects -<span class=\"built_in\">type</span> f</div><div class=\"line\">.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a</div><div class=\"line\">.git/objects/83/baae61804e65cc73a7201a7252750c76066a30</div><div class=\"line\">.git/objects/9d/aeafb9864cf43055ae93beb0afd6c7d144bfa4</div></pre></td></tr></table></figure><p>파일의 내용을 첫 번째 버전으로 되돌려봅니다 .</p><figure class=\"highlight zsh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 &gt; test.txt</div><div class=\"line\">$ cat test.txt</div><div class=\"line\">version 1</div></pre></td></tr></table></figure><figure class=\"highlight zsh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a &gt; test.txt</div><div class=\"line\">$ cat test.txt</div><div class=\"line\">version 2</div></pre></td></tr></table></figure><p>그런데 파일의 SHA-1 키를 외워서 사용하는 것은 너무어렵습니다 . 게다가 파일의 내<br>용만 저장했을 뿐 파일의 본래 이름은 저장하지도 않았습니다 . 이런 종류의개체를<br>Blob 개체라고 부릅니다 . <code>cat-file -t</code> 명령으로 해당 개체가 무슨 개체인지 확인할<br>수 있습니다 .</p><figure class=\"highlight zsh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</div><div class=\"line\">blob</div></pre></td></tr></table></figure><h3 id=\"2-2-tree-개체\"><a href=\"#2-2-tree-개체\" class=\"headerlink\" title=\"2.2) tree 개체\"></a>2.2) tree 개체</h3><p>그렇다면 파일 이름은 어디에 저장되는 것일까요 ? 바로 Tree 개체에 파일 이름을 저<br>장합니다 . ( 트리 개체에는 파일 여러 개를 한꺼번에 저장할 수도 있습니다 .) Git<br>은 모든 것을 Tree 와 Blob 개체로 저장합니다 . Tree 를 디렉토리 , Blob 은 일반 파<br>일에 대응하면쉽습니다 . Tree 개체 하나는 항목을 여러 개 가질 수있고 그 항목에는<br>Blob 개체나 하위 Tree 개체를가리키는 SHA-1 포인터 , 파일 모드 , 개체 타입 , 파일<br>이름이 들어있습니다 . 아래와 같은 Tree 개체가 있다고할 때 ,</p><figure class=\"highlight zsh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># master^&#123;tree&#125; 구문은 master 브랜치가 가리키는 tree개체를 말합니다.</span></div><div class=\"line\">$ git cat-file -p master^&#123;tree&#125;</div><div class=\"line\">100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README</div><div class=\"line\">100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile</div><div class=\"line\">040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib</div><div class=\"line\"><span class=\"comment\"># 디렉터리로, 또 다른 tree개체입니다.</span></div></pre></td></tr></table></figure><p>Git 이 저장하는 데이터는 대략 아래와 같습니다 .</p><p><img src=\"https://git-scm.com/figures/18333fig0901-tn.png\" alt=\"단순화한 Git 데이터 모델\"></p><hr>"},{"title":"git remote prune, git prune, git fetch --prune 명령들 간 무슨 차이가 있나요?","date":"2017-10-19T17:10:46.000Z","_content":"> 본 내용은 [StackOverflow](https://stackoverflow.com/questions/20106712/what-are-the-differences-between-git-remote-prune-git-prune-git-fetch-prune)에 올라온 답글에 대한 번역글 입니다.\n\n---\n\n모든 리모트 브랜치는 잠재적으로 아래 세가지 버전으로 존재합니다.\n\n1. remote branch\n2. ref branch\n3. local branch\n\n1번 브랜치는 리모트 저장소에 실제로 존재하는 브랜치 입니다. 2번은 리모트 브랜치에 대한 사용자의 스냅샷(snapshot)으로, 로컬에 존재하며 `refs/remotes/..` 로 보관됩니다. 3번은 로컬 저장소에 존재하는 브랜치로, 리모트 브랜치를 추적(tracking)하는 브랜치입니다.\n\n<br>\n\n## `git prune`\n\n`git prune`은 더 이상 참조 되지 않는 ***객체(Object)***를 제거합니다. reference들을 제거하는 것이 아닙니다. 질문자의 경우, 질문자는 로컬 브랜치(3)를 보유하고 있습니다. 그말은 즉, `random_branch_I_want_deleted` 라는 이름의 ref 브랜치(2)가 존재하고, 이 ref 브랜치는 해당 브랜치의 히스토리를 표현하는 몇 가지 객체를 가지고 있음을 의미합니다.\n\n정의에 따르면, `git prune`은 `random_branch_I_want_deleted` 브랜치를 지우지 않을 것입니다. `git prune`은 실제로 git에 쌓이긴 했지만 유용하게 참조 되는 경우가 없는 데이터를 삭제하는 방법입니다.\n\n일반적으로, 당신에게 실제로 보이는 브랜치(1,3) view에는 어떠한 영향도 미치지 않습니다. (명령어를 적용한 전 후 외견상 차이를 감지하지 못할 수 있습니다.)\n\n`git remote prune origin` 와 `git fetch --prune` 는 둘 다 `refs/remotes/...` 아래에 있는 reference들에 대해 동일한 작업을 수행합니다. (이제 `refs/remotes/...` 아래에 있는 reference들을 **remote reference**라 부르겠습니다.) 이 remote reference들은 로컬 브랜치들에는 아무런 영향도 주지 않습니다. `git remote prune origin`은 당신이 특정 리모트 아래 있는 remote reference를 지우길 원할 때에만 유용합니다. 그렇지 않고서야, `git remote prune origin`과 `git fetch --prune`은 완벽하게 같은 작업을 수행합니다. \n\n요약하면, `git remote prune`과 `git fetch --prune`은 위의 3가지 분류 중 2번인, `ref 브랜치`에 대한 작업만 합니다.\n\n로컬 브랜치(3)를 지우고자 한다면, `git branch -d`(만약 지우려는 대상이 어디에도 merge 된 적 없는 브랜치라면 `git branch -D` 명령으로 강제로 삭제할 수 있습니다.)\n\n어쨌든, 리모트 브랜치(1)가 사라진(지워진) 경우, 해당 리모트 브랜치(1)를 추적(tracking)하는 로컬 브랜치(3)를 자동으로 지워 주는 git 명령어는 존재하지 않습니다.\n\n*answered Nov 20 '13 at 21:14 jszakmeister*\n\n---\n\n<br>\n\n`git remote prune`과 `git fetch --prune`은 같은 일을 합니다. 리모트 저장소에 더 이상 존재하지 않는 브랜치들에 해당하는 ref들을 지웁니다. 다만, `git fetch --prune` 명령은 리모트 저장소에 연결합니다. 그리고 pruning하기 전에 저장소의 현재(존재하는) 브랜치들을 fetch합니다. 하지만 이 명령들은 로컬 브랜치는 터치하지 않습니다. (리모트 저장소에 삭제된 브랜치에 대한 ref가 로컬에 남아 있으면 그걸 삭제해줄 뿐, 로컬에 남아 있는 브랜치는 삭제해주지 않는다는 말.) 남은 로컬 브랜치가 존재하는지는 본인이 직접 확인해서, `git branch -d` 명령을 통해서 간단하게 삭제해야 합니다. `git prune`은 조금 다르게 동작합니다. 이 명령은 변경할 수 없는 객체나 어떤 브랜치나 태그에서도 도달할 수 없는, 따라서 더이상 필요하지 않은 커밋들을 깨끗하게 제거합니다.\n\n*answered Nov 20 '13 at 21:04 CharlesB*\n","source":"_posts/GIT/02.diffrence-branch-command.md","raw":"---\ntitle: 'git remote prune, git prune, git fetch --prune 명령들 간 무슨 차이가 있나요?'\ndate: 2017-10-20 02:10:46\ncategory: Git\ntags: \n  - git\n  - prune\n---\n> 본 내용은 [StackOverflow](https://stackoverflow.com/questions/20106712/what-are-the-differences-between-git-remote-prune-git-prune-git-fetch-prune)에 올라온 답글에 대한 번역글 입니다.\n\n---\n\n모든 리모트 브랜치는 잠재적으로 아래 세가지 버전으로 존재합니다.\n\n1. remote branch\n2. ref branch\n3. local branch\n\n1번 브랜치는 리모트 저장소에 실제로 존재하는 브랜치 입니다. 2번은 리모트 브랜치에 대한 사용자의 스냅샷(snapshot)으로, 로컬에 존재하며 `refs/remotes/..` 로 보관됩니다. 3번은 로컬 저장소에 존재하는 브랜치로, 리모트 브랜치를 추적(tracking)하는 브랜치입니다.\n\n<br>\n\n## `git prune`\n\n`git prune`은 더 이상 참조 되지 않는 ***객체(Object)***를 제거합니다. reference들을 제거하는 것이 아닙니다. 질문자의 경우, 질문자는 로컬 브랜치(3)를 보유하고 있습니다. 그말은 즉, `random_branch_I_want_deleted` 라는 이름의 ref 브랜치(2)가 존재하고, 이 ref 브랜치는 해당 브랜치의 히스토리를 표현하는 몇 가지 객체를 가지고 있음을 의미합니다.\n\n정의에 따르면, `git prune`은 `random_branch_I_want_deleted` 브랜치를 지우지 않을 것입니다. `git prune`은 실제로 git에 쌓이긴 했지만 유용하게 참조 되는 경우가 없는 데이터를 삭제하는 방법입니다.\n\n일반적으로, 당신에게 실제로 보이는 브랜치(1,3) view에는 어떠한 영향도 미치지 않습니다. (명령어를 적용한 전 후 외견상 차이를 감지하지 못할 수 있습니다.)\n\n`git remote prune origin` 와 `git fetch --prune` 는 둘 다 `refs/remotes/...` 아래에 있는 reference들에 대해 동일한 작업을 수행합니다. (이제 `refs/remotes/...` 아래에 있는 reference들을 **remote reference**라 부르겠습니다.) 이 remote reference들은 로컬 브랜치들에는 아무런 영향도 주지 않습니다. `git remote prune origin`은 당신이 특정 리모트 아래 있는 remote reference를 지우길 원할 때에만 유용합니다. 그렇지 않고서야, `git remote prune origin`과 `git fetch --prune`은 완벽하게 같은 작업을 수행합니다. \n\n요약하면, `git remote prune`과 `git fetch --prune`은 위의 3가지 분류 중 2번인, `ref 브랜치`에 대한 작업만 합니다.\n\n로컬 브랜치(3)를 지우고자 한다면, `git branch -d`(만약 지우려는 대상이 어디에도 merge 된 적 없는 브랜치라면 `git branch -D` 명령으로 강제로 삭제할 수 있습니다.)\n\n어쨌든, 리모트 브랜치(1)가 사라진(지워진) 경우, 해당 리모트 브랜치(1)를 추적(tracking)하는 로컬 브랜치(3)를 자동으로 지워 주는 git 명령어는 존재하지 않습니다.\n\n*answered Nov 20 '13 at 21:14 jszakmeister*\n\n---\n\n<br>\n\n`git remote prune`과 `git fetch --prune`은 같은 일을 합니다. 리모트 저장소에 더 이상 존재하지 않는 브랜치들에 해당하는 ref들을 지웁니다. 다만, `git fetch --prune` 명령은 리모트 저장소에 연결합니다. 그리고 pruning하기 전에 저장소의 현재(존재하는) 브랜치들을 fetch합니다. 하지만 이 명령들은 로컬 브랜치는 터치하지 않습니다. (리모트 저장소에 삭제된 브랜치에 대한 ref가 로컬에 남아 있으면 그걸 삭제해줄 뿐, 로컬에 남아 있는 브랜치는 삭제해주지 않는다는 말.) 남은 로컬 브랜치가 존재하는지는 본인이 직접 확인해서, `git branch -d` 명령을 통해서 간단하게 삭제해야 합니다. `git prune`은 조금 다르게 동작합니다. 이 명령은 변경할 수 없는 객체나 어떤 브랜치나 태그에서도 도달할 수 없는, 따라서 더이상 필요하지 않은 커밋들을 깨끗하게 제거합니다.\n\n*answered Nov 20 '13 at 21:04 CharlesB*\n","slug":"GIT/02.diffrence-branch-command","published":1,"updated":"2017-11-17T09:24:21.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjai8h17r0007vb9q8f41c8kb","content":"<blockquote><p>본 내용은 <a href=\"https://stackoverflow.com/questions/20106712/what-are-the-differences-between-git-remote-prune-git-prune-git-fetch-prune\" target=\"_blank\" rel=\"external\">StackOverflow</a>에 올라온 답글에 대한 번역글 입니다.</p></blockquote><hr><p>모든 리모트 브랜치는 잠재적으로 아래 세가지 버전으로 존재합니다.</p><ol><li>remote branch</li><li>ref branch</li><li>local branch</li></ol><p>1번 브랜치는 리모트 저장소에 실제로 존재하는 브랜치 입니다. 2번은 리모트 브랜치에 대한 사용자의 스냅샷(snapshot)으로, 로컬에 존재하며 <code>refs/remotes/..</code> 로 보관됩니다. 3번은 로컬 저장소에 존재하는 브랜치로, 리모트 브랜치를 추적(tracking)하는 브랜치입니다.</p><p><br></p><h2 id=\"git-prune\"><a href=\"#git-prune\" class=\"headerlink\" title=\"git prune\"></a><code>git prune</code></h2><p><code>git prune</code>은 더 이상 참조 되지 않는 <strong><em>객체(Object)</em></strong>를 제거합니다. reference들을 제거하는 것이 아닙니다. 질문자의 경우, 질문자는 로컬 브랜치(3)를 보유하고 있습니다. 그말은 즉, <code>random_branch_I_want_deleted</code> 라는 이름의 ref 브랜치(2)가 존재하고, 이 ref 브랜치는 해당 브랜치의 히스토리를 표현하는 몇 가지 객체를 가지고 있음을 의미합니다.</p><p>정의에 따르면, <code>git prune</code>은 <code>random_branch_I_want_deleted</code> 브랜치를 지우지 않을 것입니다. <code>git prune</code>은 실제로 git에 쌓이긴 했지만 유용하게 참조 되는 경우가 없는 데이터를 삭제하는 방법입니다.</p><p>일반적으로, 당신에게 실제로 보이는 브랜치(1,3) view에는 어떠한 영향도 미치지 않습니다. (명령어를 적용한 전 후 외견상 차이를 감지하지 못할 수 있습니다.)</p><p><code>git remote prune origin</code> 와 <code>git fetch --prune</code> 는 둘 다 <code>refs/remotes/...</code> 아래에 있는 reference들에 대해 동일한 작업을 수행합니다. (이제 <code>refs/remotes/...</code> 아래에 있는 reference들을 <strong>remote reference</strong>라 부르겠습니다.) 이 remote reference들은 로컬 브랜치들에는 아무런 영향도 주지 않습니다. <code>git remote prune origin</code>은 당신이 특정 리모트 아래 있는 remote reference를 지우길 원할 때에만 유용합니다. 그렇지 않고서야, <code>git remote prune origin</code>과 <code>git fetch --prune</code>은 완벽하게 같은 작업을 수행합니다.</p><p>요약하면, <code>git remote prune</code>과 <code>git fetch --prune</code>은 위의 3가지 분류 중 2번인, <code>ref 브랜치</code>에 대한 작업만 합니다.</p><p>로컬 브랜치(3)를 지우고자 한다면, <code>git branch -d</code>(만약 지우려는 대상이 어디에도 merge 된 적 없는 브랜치라면 <code>git branch -D</code> 명령으로 강제로 삭제할 수 있습니다.)</p><p>어쨌든, 리모트 브랜치(1)가 사라진(지워진) 경우, 해당 리모트 브랜치(1)를 추적(tracking)하는 로컬 브랜치(3)를 자동으로 지워 주는 git 명령어는 존재하지 않습니다.</p><p><em>answered Nov 20 ‘13 at 21:14 jszakmeister</em></p><hr><p><br></p><p><code>git remote prune</code>과 <code>git fetch --prune</code>은 같은 일을 합니다. 리모트 저장소에 더 이상 존재하지 않는 브랜치들에 해당하는 ref들을 지웁니다. 다만, <code>git fetch --prune</code> 명령은 리모트 저장소에 연결합니다. 그리고 pruning하기 전에 저장소의 현재(존재하는) 브랜치들을 fetch합니다. 하지만 이 명령들은 로컬 브랜치는 터치하지 않습니다. (리모트 저장소에 삭제된 브랜치에 대한 ref가 로컬에 남아 있으면 그걸 삭제해줄 뿐, 로컬에 남아 있는 브랜치는 삭제해주지 않는다는 말.) 남은 로컬 브랜치가 존재하는지는 본인이 직접 확인해서, <code>git branch -d</code> 명령을 통해서 간단하게 삭제해야 합니다. <code>git prune</code>은 조금 다르게 동작합니다. 이 명령은 변경할 수 없는 객체나 어떤 브랜치나 태그에서도 도달할 수 없는, 따라서 더이상 필요하지 않은 커밋들을 깨끗하게 제거합니다.</p><p><em>answered Nov 20 ‘13 at 21:04 CharlesB</em></p>","site":{"data":{}},"excerpt":"","more":"<blockquote><p>본 내용은 <a href=\"https://stackoverflow.com/questions/20106712/what-are-the-differences-between-git-remote-prune-git-prune-git-fetch-prune\" target=\"_blank\" rel=\"external\">StackOverflow</a>에 올라온 답글에 대한 번역글 입니다.</p></blockquote><hr><p>모든 리모트 브랜치는 잠재적으로 아래 세가지 버전으로 존재합니다.</p><ol><li>remote branch</li><li>ref branch</li><li>local branch</li></ol><p>1번 브랜치는 리모트 저장소에 실제로 존재하는 브랜치 입니다. 2번은 리모트 브랜치에 대한 사용자의 스냅샷(snapshot)으로, 로컬에 존재하며 <code>refs/remotes/..</code> 로 보관됩니다. 3번은 로컬 저장소에 존재하는 브랜치로, 리모트 브랜치를 추적(tracking)하는 브랜치입니다.</p><p><br></p><h2 id=\"git-prune\"><a href=\"#git-prune\" class=\"headerlink\" title=\"git prune\"></a><code>git prune</code></h2><p><code>git prune</code>은 더 이상 참조 되지 않는 <strong><em>객체(Object)</em></strong>를 제거합니다. reference들을 제거하는 것이 아닙니다. 질문자의 경우, 질문자는 로컬 브랜치(3)를 보유하고 있습니다. 그말은 즉, <code>random_branch_I_want_deleted</code> 라는 이름의 ref 브랜치(2)가 존재하고, 이 ref 브랜치는 해당 브랜치의 히스토리를 표현하는 몇 가지 객체를 가지고 있음을 의미합니다.</p><p>정의에 따르면, <code>git prune</code>은 <code>random_branch_I_want_deleted</code> 브랜치를 지우지 않을 것입니다. <code>git prune</code>은 실제로 git에 쌓이긴 했지만 유용하게 참조 되는 경우가 없는 데이터를 삭제하는 방법입니다.</p><p>일반적으로, 당신에게 실제로 보이는 브랜치(1,3) view에는 어떠한 영향도 미치지 않습니다. (명령어를 적용한 전 후 외견상 차이를 감지하지 못할 수 있습니다.)</p><p><code>git remote prune origin</code> 와 <code>git fetch --prune</code> 는 둘 다 <code>refs/remotes/...</code> 아래에 있는 reference들에 대해 동일한 작업을 수행합니다. (이제 <code>refs/remotes/...</code> 아래에 있는 reference들을 <strong>remote reference</strong>라 부르겠습니다.) 이 remote reference들은 로컬 브랜치들에는 아무런 영향도 주지 않습니다. <code>git remote prune origin</code>은 당신이 특정 리모트 아래 있는 remote reference를 지우길 원할 때에만 유용합니다. 그렇지 않고서야, <code>git remote prune origin</code>과 <code>git fetch --prune</code>은 완벽하게 같은 작업을 수행합니다.</p><p>요약하면, <code>git remote prune</code>과 <code>git fetch --prune</code>은 위의 3가지 분류 중 2번인, <code>ref 브랜치</code>에 대한 작업만 합니다.</p><p>로컬 브랜치(3)를 지우고자 한다면, <code>git branch -d</code>(만약 지우려는 대상이 어디에도 merge 된 적 없는 브랜치라면 <code>git branch -D</code> 명령으로 강제로 삭제할 수 있습니다.)</p><p>어쨌든, 리모트 브랜치(1)가 사라진(지워진) 경우, 해당 리모트 브랜치(1)를 추적(tracking)하는 로컬 브랜치(3)를 자동으로 지워 주는 git 명령어는 존재하지 않습니다.</p><p><em>answered Nov 20 ‘13 at 21:14 jszakmeister</em></p><hr><p><br></p><p><code>git remote prune</code>과 <code>git fetch --prune</code>은 같은 일을 합니다. 리모트 저장소에 더 이상 존재하지 않는 브랜치들에 해당하는 ref들을 지웁니다. 다만, <code>git fetch --prune</code> 명령은 리모트 저장소에 연결합니다. 그리고 pruning하기 전에 저장소의 현재(존재하는) 브랜치들을 fetch합니다. 하지만 이 명령들은 로컬 브랜치는 터치하지 않습니다. (리모트 저장소에 삭제된 브랜치에 대한 ref가 로컬에 남아 있으면 그걸 삭제해줄 뿐, 로컬에 남아 있는 브랜치는 삭제해주지 않는다는 말.) 남은 로컬 브랜치가 존재하는지는 본인이 직접 확인해서, <code>git branch -d</code> 명령을 통해서 간단하게 삭제해야 합니다. <code>git prune</code>은 조금 다르게 동작합니다. 이 명령은 변경할 수 없는 객체나 어떤 브랜치나 태그에서도 도달할 수 없는, 따라서 더이상 필요하지 않은 커밋들을 깨끗하게 제거합니다.</p><p><em>answered Nov 20 ‘13 at 21:04 CharlesB</em></p>"},{"title":"[React] 리액트 입문하기","date":"2017-09-20T11:32:01.000Z","_content":"\n![](https://cdn-images-1.medium.com/max/2000/1*HSisLuifMO6KbLfPOKtLow.jpeg)\n\n\n## 1. What is React?\n\nReact는 페이스북에서 개발한 자바스크립트 라이브러리이다. 공식 문서에서는 **사용자 인터페이스(User Interface)를 구축하기위한 선언적(declarative)이고 효율적(efficient)이며 유연한(flexible) JavaScript 라이브러리**라고 설명하고있다. React는 '컴포넌트'단위로 재사용 가능한 UI 템플릿을 만든다. 현재 페이스북, 인스타그램, MS 등 대형 서비스에서도 사용되고있는 견고한 라이브러리이다.  \n\nReact는 Virtual DOM이라는 개념을 사용하여 상태(state)의 변함(diff)에 따라 선택적으로 UI를 렌더링한다. 따라서 최소한의 DOM 처리로 컴포넌트 업데이트가 가능하다.  \n\n<br>\n\n## 2. Virtual DOM\n\n### 1) DOM\n\nDOM(Document Object Model)이란 객체를 통해 구조화된 문서를 표현하는 방법을 말한다. XML또는 HTML로 작성된다. 웹 브라우저는 DOM을 이용해 객체에 자바스크립트와 CSS를 적용한다. DOM은 트리 형태로 되어있으며 특정 노드(node)의 서치(search)와 수정, 제거, 삽입이 가능하다.\n\nDOM의 문제점은 동적 UI에 최적화되어 있지 않다는 것이다. HTML은 그 자체로 정적인 문서(document)이기 때문이다. 큰 규모의 웹 어플리케이션은 하나의 페이지에도 수 많은 요소들이 생기는데, 이 모든 요소들을 DOM에 직접 접근하여 조작하면서 변화룰 주다보면 속도 저하를 피할 수 없게 된다.  \n\n브라우저 단에서 DOM의 변화가 일어나면 브라우저는 CSS를 다시 연산하고 레이아웃을 새로 구성(=리플로우, reflow )하며 웹 페이지에서 레이아웃에 관계 없는 나머지(색상 변경 등)를 처리(=리페인트, repaint) 하는 데, 이 과정이 DOM에 접근하는 만큼 반복된다. 속도 저하는 바로 이 부분에서 발생한다.  \n\n```js\nvar style = document.body.style; // 캐싱\nstyle.padding = \"20px\"; // reflow, repaint\nstyle.border = \"10px solid red\"; // reflow, repaint\n\nstyle.color = \"blue\"; // repaint\nstyle.backgroundColor = \"#ffa\"; // repaint\n\nstyle.fontSize = \"1em\"; // reflow, repaint\n\n// reflow, repaint\ndocument.body.appendChild(document.createTextNode('hello World'));\n```\n\n이렇게 코드가 실행될 때마다 reflow하는 것은 매우 비효율적이며 이에 따른 성능 저하를 우려하지 않을 수 없다. 브라우저는 성능 저하를 단축시키기 위해 짧은 시간 내에 여러 reflow가 발생하려 할 시 이 작업을 미루고 한번에 처리한다. (하지만, `offsetTop`, `scrollTop`, `getComputedStyle()` 등 코드 실행 당시 값을 가져오는 것이 중요한 일부 코드들은 reflow가 여러번 발생할 수 없으므로 브라우저에서 최적화하지 못한다.) 따라서 성능 개선을 위해서는 reflow 횟수를 줄이기 위해 코드를 최적화 해야 한다.\n\n### 2) Virtual DOM\n\nHTML 마크업을 시각적 형태로 변환하는 것은 브라우저의 주 역할이다. 결국 DOM 조작을 아예 하지 않을 수는 없으니, 최소한의 조작만 하여 성능 저하 문제를 해결해보고자 하는 노력이 Virtual DOM을 탄생시켰다.  \n\nVirtual DOM은 언어 그대로 가상 DOM이다. DOM 작업을 가상화(추상화)하여 미리 처리한 다음, 실제 DOM에 한번에 적용하는 방식이다. \n\nReact의 실제 DOM 업데이트는 아래 3단계로 이루어진다. \n1. 데이터가 업데이트되면, 전체 UI를 virtual DOM에 리렌더링한다.\n2. 이전 Virtual DOM에 있던 내용과 현재 내용을 비교한다.\n3. 바뀐 부분만 실제 DOM에 적용한다.\n\n결국 컴포넌트가 업데이트 될 때, 레이아웃 계산(reflow)이 한번만 이루어지므로 속도 저하 문제를 개선할 수 있게 되는 것이다.\n\n하지만, Virtual DOM이 모든 경우에서 무조건 더 좋은 퍼포먼스를 내는 것은 아니다. 오히려 단순 라우팅만 있는 정적 웹페이지의 경우 React를 쓰지 않는 편이 더 낫기도 하다. (React는 지속적으로 데이터가 변화하는 대규모 애플리케이션 구축에 적절하다고 공식 매뉴얼에서 밝히고 있다.)  \n\nReact와 Virtual DOM이 주는 최고의 편의성은 **간결한 업데이트 처리**이다. UI를 업데이트 하는 과정에서 발생하는 복잡함을 해소해줄 뿐 아니라, 업데이트에 쉽게 접근할 수 있게 해준다.\n\n```js\n// index.html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n\n  <script src=\"https://unpkg.com/react@latest/dist/react.js\"></script>\n  <script src=\"https://unpkg.com/react-dom@latest/dist/react-dom.js\"></script>\n  <script src=\"https://unpkg.com/babel-standalone@6.15.0/babel.min.js\"></script>\n</head>\n<body>\n  <h1>Welcome to React</h1>\n  <div id=\"react-app\"></div>\n  <script type=\"text/babel\"></script>\n  class BlogPost extends React.Component {\n    render() {\n      return (\n        <div>\n          This is a blog post\n        </div>\n      )\n    }\n  }\n\n  reactDOM.render(\n  <BlogPost/>,\n  document.getElementById('react-app');\n  );\n</body>\n</html>\n```\n\n## 3. create-react-app\n\n[create-react-app](https://github.com/facebookincubator/create-react-app)은 간편하게 React 앱을 만들수 있도록 자동으로 빌드해주는 도구이다. 이 패키지를 이용하면 Webpack이나 Babel을 설치하고 구성하는 복잡한 빌드 과정을 생략할 수 있다.   \n\n```bash\n# npm으로 create-react-app 패키지 설치\n$ npm install -g create-react-app\n\n# 패키지를 통해 react 프로젝트를 생성\n$ create-react-app my-app(프로젝트이름)\n```\n\n명령을 통해 my-app 프로젝트 폴더가 생성된다. 폴더 구조는 아래와 같다.\n\n```bash\nmy-app\n├── README.md\n├── node_modules\n├── package.json\n├── .gitignore\n├── public # 서버 public path\n│   └── favicon.ico\n│   └── index.html # 메인 페이지\n│   └── manifest.json\n└── src # React.js 프로젝트 루트\n    └── App.css \n    └── App.js # App 컴포넌트\n    └── App.test.js # test file\n    └── index.css\n    └── index.js # Webpack Entry point\n    └── logo.svg\n    └── registerServiceWorker.js\n```\n\n\n```bash\n# 프로젝트 폴더로 이동\n$ cd my-app\n\n# 이후에는 아래 두 가지 방법 중 택1\n# 1. yarn을 이용하는 방법\n\n$ npm install -g yarn # yarn이 설치되어 있다면 생략 가능\n\n$ yarn start\n\n# 2. npm을 이용하는 방법\n\n$ npm start\n\n# 위 작업을 마치면 http://localhost:3000 서버로 React 앱을 열 수 있다.\n```\n코드가 수정되면 자동으로 페이지가 로드되며 콘솔창을 통해 빌드 오류 및 lint 경고가 출력된다.\n\n```bash\n# 아래 두 명령어 중 택 1로 앱을 번들링하여 배포할 수 있다.\n# 프로덕션용 앱을 build 폴더에 빌드하며 최적의 성능을 위한 최적화(minify)를 진행한다. 빌드가 축소되며 파일이름에 해시가 포함된다. \n\n$ yarn build\n\n$ npm run build\n```\n\n아래는 자동 생성된 app.js 파일이다.\n\n```js\n// app.js\nimport React, { Component } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\n\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <div className=\"App-header\">\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <h2>Welcome to React</h2>\n        </div>\n        <p className=\"App-intro\">\n          To get started, edit <code>src/App.js</code> and save to reload.\n        </p>\n      </div>\n    );\n  }\n}\n\nexport default App;\n```\n\n<br>\n\n## 4. import, export\n\nimport는 ES6(ECMA Script 2016)의 문법이다. node의 require()와 동일한 의미이다. 이렇게 모듈을 require하는 방식은 서버단인 node의 방식이다. 클라이언트단에서는 `<script>`태그를 이용하여 파일을 로드해오는 것이 일반적이다. (require를 지원하지도 않는다.) 하지만 webpack으로 클라이언트에서도 node에서처럼 모듈을 불러올 수 있다. webpack은 import한 모듈을 한 파일로 합치는 번들링(bundling) 작업을 수행하는 모듈 번들러이다. `create-react-app`의 기본 구성도 webpack이다.\n\n아래는 `create-react-app` 패키지의 구성 요소이다.\n\n* webpack with webpack-dev-server, html-webpack-plugin and style-loader\n* Babel with ES6 and extensions used by Facebook (JSX, object spread, class properties)\n* Autoprefixer\n* ESLint\n* Jest\n* and others.\n\n기본 문법(syntax)은 `import 변수명 from 가져올 모듈의 경로`이다. 리액트의 모든 컴포넌트는 필수적으로 react모듈을 import해야 한다.  \n\n```js\n// es6\nimport React from 'react' // (필수)\nimport './App'\n// require와 같은 의미이다.\n // node\nvar React = require('react');\nvar App = require('./App');\n```\n\n경로 작성시 주의할 것이 있다면, React는 경로 맨 앞에 `./`를 붙이지 않으면 `node_modules`에서 해당 파일을 찾는다는 점이다. 코드에서 `'react'`는 `node_modules`에 있는 리액트 모듈을 가리키며, `./App.css`는 개발자가 직접 정의한 컴포넌트인 App.js를 가리킨다.\n\n위와 같이 import하기 위해서는 해당 컴포넌트에 export가 필수적으로 정의되어 있어야 한다. export 선언되지 않은 컴포넌트는 import도 할 수 없다.\n\n```js\nimport React from 'react'\nimport './App.css'\n\nclass App extends React.Component {\n  render(){\n    return (\n      <h1>Hello React</h1>\n    );\n  }\n}\n\nexport default App;\n```\n\ndefault로 export되는 컴포넌트에 한해서 아래와 같이 표현할 수도 있다.\n\n```js\nimport React from 'react'\nimport './App.css'\n\nexport default class App extends React.Component {\n  ...\n}\n```\n\n<br>\n\n## 5. JSX\n\n[webpackbin.com](https://www.webpackbin.com/bins/-KeVMcQWGocAn5VJL6XL)을 통해 간단한 react project를 확인해 볼 수 있다.\n\n```js\n// HelloWorld.js\nimport React from 'react';\n\n// stateless Function\nfunction HelloWorld() {\n  return (\n    <h1>Hello from React!</h1> // JSX 문법\n  );\n}\n\nexport default HelloWorld;\n```\n\nReact는 일반 js문법과는 다른 xml형태의 JSX 문법을 사용한다. JSX는 자바스크립트로 만든 xml로, HTML과 매우 유사한 모양을 하고 있다. 위 예제에서 자바스크립트 코드 내부에  `\"`나 `'`없이 HTML 코드가 섞여있는 것을 볼 수 있다. 이와 같은 모양을 JSX라고 하며, React는 JSX문법을 사용하여 UI를 템플릿화한다. 이 코드는 webpack의 babel-loader를 통해 자바스크립트 코드로 번들링된다. 위 코드는 아래와 같이 변환된다.\n\n```\nreturn React.createElement(\n  \"h1\",\n  null,\n  \"Hello from React!\"\n);\n```\n\n<br>\n\n## 6. 컴포넌트 로드하기  \n\n```js\n// main.js\nimport React from 'react';\nimport {render} from 'react-dom';\nimport Hello from './HelloWorld.js';\n\nrender(<HelloWorld/>, document.querySelector('#app'));\n```\n\nmain.js파일은 webpack의 entry 파일(진입점)으로 번들링 작업이 이루어지는 중심 지점이다. HelloWorld.js에서 만든 컴포넌트를 import하고, 기타 import한 파일들을 재귀적으로 불러와 하나의 파일로 합치는 작업을 수행한 후 페이지에 렌더링한다.\n\nReact 컴포넌트를 페이지에 렌더링할 때는 react-dom 모듈을 불러와 render 함수를 통해 처리한다. render 함수의 첫번째 파라미터는 렌더링할 JSX 형태의 코드로, 여기서는 HelloWorld 컴포넌트를 렌더링한다. 컴포넌트를 만들면 `<컴포넌트이름 />`의 형태(HTML의 태그처럼)로 작성할 수 있다. 두번째 파라미터는 렌더링할 HTML 요소이다. 위에서는 `index.html`의 id값이 app인 요소에 렌더링하도록 설정되었다.\n\n```html\n<!-- index.html -->\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\"/>\n  </head>\n  <body>\n    <div id=\"app\">\n    <!-- 여기에 렌더링한다. -->\n    </div>\n    <script src=\"main.js\"></script>\n  </body>\n</html>\n```\n\n<br>\n\n## 7. 컴포넌트에 속성 부여하기\n\n```js\n// HelloWorld.js\nimport React from 'react';\n\nfunction HelloWorld (props) {\n  return (\n    <h1>Hello {props.name}!</h1>\n  );\n}\n\nexport default HelloWorld;\n```\n위 코드는 함수 HelloWorld에 props 파라미터를 부여하고 props.name(props의 name 속성) 값을 JSX 안에서 렌더링하게 하였다.\n\n```js\n// main.js\nimport React from 'react';\nimport {render} from 'react-dom';\nimport HelloWorld from './HelloWorld.js';\n\nrender(<HelloWorld name=\"World\"/>, document.querySelector('#app'));\n```\n\nmain.js에서 렌더링할 때 HelloWorld 컴포넌트에 name 값을 \"World\"로 설정해주었다. 출력은 아래와 같을 것이다.\n\n```\nHello World!\n```\n\n<br>\n\n## 8. prop, state\n\n### 1) Components and Props\n\n컴포넌트를 이용해 UI를 독립적이고 재사용 가능한 부분으로 분리할 수 있으며 분리된 각 부분들을 개별적인 것(isolation)으로 생각할 수 있다. component는 view를 생성하는 자바스크립트 함수이다. 컴포넌트는 props라 불리는 임의의 입력을 받고, (prop는 사전적 의미로 '소품'이다.) React 요소를 반환한다. 이 요소는 화면에 무엇이 나타나야 하는지(render)를 설명한다.\n\n### 2) Props are Read-Only\n\nProp 값은 읽기만 가능한 값이다. 컴포넌트의 선언 방식(함수 또는 클래스로 선언될 수 있다.)과 관계 없이 컴포넌트의 prop는 직접적인 값의 수정이 절대 불가하다.\n\n```js\nfunction sum(a, b) {\n  return a + b ;\n}\n```\n\n위와 같은 함수들은 \"pure\"하다고 말한다. 입력값을 변경하지 않으며, 동일한 입력에 대해 항상 동일한 결과를 반환하기 때문이다. 위 예제는 a=2, b=3 일 때, 항상 5라는 값을 반환한다. 결과로서 a나 b를 변환하지 않는다. a는 항상 2이며 b도 항상 3이다.\n\n반면, 아래와 같은 함수는 \"impure\"하다. 결과값을 반환하면서 input을 스스로 바꿔버리기 때문이다. 이러한 함수는 입력값이 계속 변화함에 따라 결과값도 변화하기 때문에 항상 동일한 결과가 보장되지 않는다.\n\n```js\nfunction withdraw(accout, amount) {\n  accout.total -= amount;\n}\n```\n\n리액트는 상당히 유연하지만 엄격한 규칙이 하나 있다.\n**모든 React 컴포넌트는 props에 관해서는 반드시 pure함수처럼 동작해야 한다.**\n\n물론 어플리케이션 UI는 동적이며 시점(시간의 흐름)에 따라 변화한다. state는 React 컴포넌트가 이 규칙을 위반하지 않으면서 (유저의 행동, 네트워크 응답, 그리고 그 외 여러가지 요인들에 대한 응답으로) 변화된 시점에 따라 결과값을 변경할 수 있게 한다.\n\n> this.prop는 변경할 수 없고 this.state는 변경이 가능하다. 단 setState로만 바꿀 수 있다. state를 변경하는 방식은 담고 있는 값을 변경하는 것이 아니라, 새로운 값을 담은 새로운 state를 만들어주는 방식이다. 즉, 이전 state와 새로운 state는 완전히 다른 객체이다.\n\n> state의 immutable은 강제되는 부분은 아니지만 (오류가 발생하지 않는다.) 의도한 대로 동작하게 하기 위해서는 immutable을 지켜주어야 한다.\n\n### 3) State and Life-Cycle\n\n지금까지 배운 바에 의하면, 렌더된 출력을 변경하기 위해 `ReactDOM.render()`를 호출할 수 있다. 아래는 Live 시계를 만드는 컴포넌트이다.\n\n```js\nfunction tick() {\n  const element = (\n    <div>\n      <h1>Hello, World!</h1>\n      <h2>It is {new Date().toLocaleTimeString()}.</h2>\n    </div>\n  );\n  ReactDOM.render(\n    element,\n    document.getElementById('root')\n  );\n}\n\nsetInterval(tick, 1000);\n```\n\n위 `clock` 코드를 캡슐화하고 재사용하기 위해 컴포넌트화 할 수 있다. 먼저 위 함수는 크게 시계가 화면에 보이게 하는 것과 1초마다 시간이 갱신되게 하는 것으로 두 가지 일을 한다. 다음과 같이 분리할 수 있을 것이다.\n\n```js\nfunction Clock(props) {\n  return (\n    <div>\n      <h1>Hello, World!</h1>\n      <h2>It is {props.date.toLocaleTimeString()}.</h2>\n    </div>\n  )\n}\n\nfunction tick() {\n  ReactDOM.render(\n    <Clock data={new Date()} />,\n    document.getElementById('root')\n  );\n}\n\nsetInterval(tick, 1000);\n```\n\n사실 이렇게 분리하는 것은 별로 좋은 방법이 아니다. 위 코드에서는 Clock 함수를 매 초마다 불러내 매번 새로 UI를 업데이트한다. 이상적인 것은 Clock을 한번만 작성하는 것이다. 한번만 작성하면 Clock 함수가 스스로 업데이트 하도록 하는 것이 좋다.\n\n```js\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root')\n);\n```\n\n이를 구현하려면 clock 구성 요소에 `state`를 추가해야 한다. State는 props와 유사하지만 private하며 제어권이 완전히 컴포넌트에 있다. 클래스로 정의된 컴포넌트는 몇 가지 추가 기능을 가지고 있다고 하였다. **로컬(Local) state는 클래스 안에서만 사용할 수 있는 기능이다.**\n\n### 4) Converting a Function to a Class\n\n앞에서 정의한 `Clock`과 같은 함수형 컴포넌트를 클래스 컴포넌트로 변환할 수 있다. 다음 5단계를 거친다.   \n\n1. React.Component로부터 extends한 동일한 이름의 ES6 클래스를 만든다.\n2. `render()` 메서드를 추가한다.\n3. 함수 바디를 `render()` 메서드 내부로 옮긴다.\n4. `render()` 내부에 정의된 `props`를 `this.props`로 바꾼다.\n5. 나머지 빈 함수 선언문을 지운다.\n\n```js\nclass Clock extends React.Component {\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.props.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n```\n\n`Clock`함수가 class로 정의되었다. 이제 local state와 lifecycle hooks과 같은 추가 기능을 사용할 수 있다.\n\n### 5) Adding Local State to a Class\n\n이제 `date`를 props에서 state로 변환할 차례이다. 아래 3단계를 거친다.  \n\n**1.** `render()`메서드 내부의 `this.props.date`를 `this.state.date`로 바꾼다.  \n\n```js\nclass Clock extends React.Component {\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n```\n\n**2.** `this.state`의 초기값을 할당하는 class constructor(생성자)를 추가한다.\n\n```js\nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n```\n\n기본 생성자에 `props` 값을 전달하는 방법은 아래와 같음을 기억해두자.\n\n```js\nconstructor(props) {\n  super(props);\n  this.state = {date: new Date()};\n}\n```\n\n클래스 컴포넌트는 항상 `props`와 함께 기본 생성자(base constructor)를 호출해야 한다.\n\n**3.** `<Clock />`요소에서 `date` prop를 제거한다.\n\n```js\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root')\n);\n```\n\n타이머 코드는 나중에 컴포넌트에 다시 추가할 것이다.\n지금까지의 결과는 아래와 같다.\n\n```js\nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root')\n);\n```\n\n<br>\n\n### 6) Adding Lifecycle Methods to a Class\n\n위에서는 `Clock`이 DOM 위에 그려졌다가 사라지는 것을 1초마다 반복한다. `Clock`이 렌더될 때마다 DOM 위에 타이머를 셋업(set up)하는 것을 리액트에서는 마운팅(Mounting)이라고 한다. 또 DOM 위에서 타이머가 `clear`될 때마다 `Clock`을 DOM에서 지우는데, 이를 리액트에서는 unmounting이라고 한다.\n\nclass 컴포넌트에는 마운트 또는 언마운트될 때 특정 코드를 실행하는 메서드가 있다.\n\n```js\nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {data: new Date()};\n  }\n  componentDidMount() {\n    // 컴포넌트가 마운트 되었다는 의미의 메서드\n    // 컴포넌트가 마운트된 후에 실행된다.\n\n  }\n  componentWillMount() {\n    // 컴포넌트가 마운트 될 것이라는 의미의 메서드\n    // 컴포넌트가 마운트되기 전에 실행된다.\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Hello world!</h1>\n        <h2>It is {this.state.data.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n```\n\n위와 같은 방법을 'lifecycle hooks'라고 한다. \n\n![React Lifecycle in ES6. Inspired by Simon Sturmer](https://cdn-images-1.medium.com/max/800/1*YD6sBv5Ly548pGl042z3DA.jpeg)\n\n위 그림은 Lifecycle API를 표현한 것이다. 컴포넌트 생성은 `constructor` -> `componentWillMount` -> `render` 순으로 실행되며, `componentDidMount`가 가장 마지막에 위치하는 것을 확인할 수 있다.\n\n다시 타이머로 돌아와서, `componentDidMount()` hook은 컴포넌트 출력이 DOM에 렌더된 이후에 실행된다. 따라서 이 메서드에 타이머를 넣는 것이 좋은 방법일 것 같다.  \n\n```js\ncomponentDidMount() {\n  this.timerID = setInterval(\n    () => this.tick(),\n    1000\n  );\n}\n```\n\ntimerID를 어떤 식으로 저장하는지 눈여겨 보자. `this.props`는 리액트가 자체적으로 설정하지만, `this.state`는 특별한 의미를 갖기 때문에, 자유롭게 부가적인 필드를 추가할 수 있다. 만약 state를 보이지 않게 하려는 경우라면, 클래스에 수동으로 아래와 같은 필드를 추가할 수 있다.\n\n```js\ncomponentWillUnmount() {\n  clearInterval(this.timerID);\n}\n```\n\n마지막으로, 1초마다 실행되는 tick() 메서드를 구현해본다.\n`this.setState()`를 사용하여 컴포넌트의 local state 값을 업데이트할 수 있다.\n\n```js\nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {data: new Date()};\n  }\n  \n  componentDidMount() {\n    this.timerID = setInterval(\n      () => this. tick(), 1000\n    );\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.timerID);\n  }\n\n  tick() {\n    this.setState({\n      date: new Date()\n    });\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root');\n);\n```\n\n타이머가 완성되었다.\n\n이제 진행중인 작업과 메서드가 호출되는 순서를 간단히 요약해보자.\n\n**1)** `<Clock />`이 `ReactDOM.render()`에 전달되면 React가 `Clock` 구성 요소의 생성자를 호출한다. `Clock`은 현재 시간을 표시해야하므로 `this.state`를 현재 시간을 포함하는 객체로 초기화한다. 나중에 이 상태를 업데이트 할 것이다.  \n\n**2)** 그런 다음 React는 Clock 구성 요소의 `render()` 메서드를 호출한다. 이 메서드를 통해 React는 화면에 무엇을 표시해야 하는지 알아낸다. 그런 다음 React가 `Clock`의 렌더링 결과와 일치하도록 DOM을 업데이트한다.  \n\n**3)** `Clock` 출력이 DOM에 삽입되면 React는 `componentDidMount()` 라이프 사이클 후크를 호출한다. 내부에있는 Clock 컴포넌트는 브라우저에 `tick()`을 한 번씩 호출하는 타이머를 설정하도록 요청한다.  \n \n**4)** 초마다 브라우저에서 `tick()` 메소드를 호출한다. 그 내부에서 Clock 구성 요소는 현재 시간을 포함하는 객체로 `setState()`를 호출하여 UI 업데이트를 예약한다. `setState()` 호출 덕분에 React는 상태가 변경된 것을 알아채고 `render()` 메서드를 다시 호출하여 화면에 무엇이 있어야 하는지를 파악한다. 이번에는 `render()` 메서드의 `this.state.date`가 달라 지므로 렌더 결과에 업데이트 된 시간이 포함된다. React는 그에 따라 DOM을 업데이트한다.  \n\n**5)** `Clock` 컴포넌트가 DOM에서 제거되면 React가 `componentWillUnmount()` 라이프 사이클 후크를 호출하여 타이머가 중지된다. \n\n<br>\n\n---\n\n### What is “Mounting” in React js?\n\nReact에서 작업하는 컴포넌트는 모두 React 노드와 DOM 노드로 나타낼 수 있다. React노드를 DOM노드로 표시하는 방식, 위치, 시기는 최상위 API에서 관리한다. 아래 예제를 통해 좀 더 쉽게 이해해보자.\n\n```js\nlet foo = React.createElement(FooComponent);\n```\n\nfoo는 무엇이고 저 객체로 무엇을 할 수 있는가? 지금 이 시점의 foo는 React 타입인 FooComponent의 인스턴스이다. 즉, 현 시점에서는 페이지 그 어디에도 존재하지 않는다. DOM 요소가 아니므로 DOM 트리 어디에도 존재하지 않는 (React 요소 노드를 제외하고) document 상에서 아무런 의미도 없는 객체이다.\n\n이 상태에서 `React.findDOMNode(foo)`를 호출하면, falsy object를 반환할 것이다. 이유가 무엇일까? foo는 DOM 트리에 있을 필요가 없다. 따라서 DOM 표현(representation)을 가지고 있지 않다.\n\n그러나 React 요소 노드를 document에 마운트(mount)하려고하면 DOM 노드를 만드는 컴포넌트 생명주기가 시작된다.\n\n```js\nReact.render(foo, container);\n```\n\n이제 foo는 더이상 React 노드가 아니다. 연관되는 DOM 노드가 있으며 현재 document에 속하게 된다. 이제 실제 DOM 노드에서 어디서든지 foo를 찾을 수 있고 다른 DOM 요소들과 상호작용할 수 있으며, 높이나 너비를 계산하거나 스타일을 적용하거나, jQuery로 전달하는 등 일반적인 DOM 요소처럼 취급할 수 있게 된다.\n\n\n<br>\n\n---\n\n**Reference**\n\n[React Document](https://facebook.github.io/react/tutorial/tutorial.html#what-is-react)\n\n[React Lecture Blog - Korean](https://velopert.com/867)\n\n[create-react-app github](https://github.com/facebookincubator/create-react-app)\n\n[stack overflow - What is “Mounting” in React js?](https://stackoverflow.com/questions/31556450/what-is-mounting-in-react-js)\n","source":"_posts/React/01.basic.md","raw":"---\ntitle: '[React] 리액트 입문하기'\ndate: 2017-09-20 20:32:01\ncategory: React\ntags: react\n---\n\n![](https://cdn-images-1.medium.com/max/2000/1*HSisLuifMO6KbLfPOKtLow.jpeg)\n\n\n## 1. What is React?\n\nReact는 페이스북에서 개발한 자바스크립트 라이브러리이다. 공식 문서에서는 **사용자 인터페이스(User Interface)를 구축하기위한 선언적(declarative)이고 효율적(efficient)이며 유연한(flexible) JavaScript 라이브러리**라고 설명하고있다. React는 '컴포넌트'단위로 재사용 가능한 UI 템플릿을 만든다. 현재 페이스북, 인스타그램, MS 등 대형 서비스에서도 사용되고있는 견고한 라이브러리이다.  \n\nReact는 Virtual DOM이라는 개념을 사용하여 상태(state)의 변함(diff)에 따라 선택적으로 UI를 렌더링한다. 따라서 최소한의 DOM 처리로 컴포넌트 업데이트가 가능하다.  \n\n<br>\n\n## 2. Virtual DOM\n\n### 1) DOM\n\nDOM(Document Object Model)이란 객체를 통해 구조화된 문서를 표현하는 방법을 말한다. XML또는 HTML로 작성된다. 웹 브라우저는 DOM을 이용해 객체에 자바스크립트와 CSS를 적용한다. DOM은 트리 형태로 되어있으며 특정 노드(node)의 서치(search)와 수정, 제거, 삽입이 가능하다.\n\nDOM의 문제점은 동적 UI에 최적화되어 있지 않다는 것이다. HTML은 그 자체로 정적인 문서(document)이기 때문이다. 큰 규모의 웹 어플리케이션은 하나의 페이지에도 수 많은 요소들이 생기는데, 이 모든 요소들을 DOM에 직접 접근하여 조작하면서 변화룰 주다보면 속도 저하를 피할 수 없게 된다.  \n\n브라우저 단에서 DOM의 변화가 일어나면 브라우저는 CSS를 다시 연산하고 레이아웃을 새로 구성(=리플로우, reflow )하며 웹 페이지에서 레이아웃에 관계 없는 나머지(색상 변경 등)를 처리(=리페인트, repaint) 하는 데, 이 과정이 DOM에 접근하는 만큼 반복된다. 속도 저하는 바로 이 부분에서 발생한다.  \n\n```js\nvar style = document.body.style; // 캐싱\nstyle.padding = \"20px\"; // reflow, repaint\nstyle.border = \"10px solid red\"; // reflow, repaint\n\nstyle.color = \"blue\"; // repaint\nstyle.backgroundColor = \"#ffa\"; // repaint\n\nstyle.fontSize = \"1em\"; // reflow, repaint\n\n// reflow, repaint\ndocument.body.appendChild(document.createTextNode('hello World'));\n```\n\n이렇게 코드가 실행될 때마다 reflow하는 것은 매우 비효율적이며 이에 따른 성능 저하를 우려하지 않을 수 없다. 브라우저는 성능 저하를 단축시키기 위해 짧은 시간 내에 여러 reflow가 발생하려 할 시 이 작업을 미루고 한번에 처리한다. (하지만, `offsetTop`, `scrollTop`, `getComputedStyle()` 등 코드 실행 당시 값을 가져오는 것이 중요한 일부 코드들은 reflow가 여러번 발생할 수 없으므로 브라우저에서 최적화하지 못한다.) 따라서 성능 개선을 위해서는 reflow 횟수를 줄이기 위해 코드를 최적화 해야 한다.\n\n### 2) Virtual DOM\n\nHTML 마크업을 시각적 형태로 변환하는 것은 브라우저의 주 역할이다. 결국 DOM 조작을 아예 하지 않을 수는 없으니, 최소한의 조작만 하여 성능 저하 문제를 해결해보고자 하는 노력이 Virtual DOM을 탄생시켰다.  \n\nVirtual DOM은 언어 그대로 가상 DOM이다. DOM 작업을 가상화(추상화)하여 미리 처리한 다음, 실제 DOM에 한번에 적용하는 방식이다. \n\nReact의 실제 DOM 업데이트는 아래 3단계로 이루어진다. \n1. 데이터가 업데이트되면, 전체 UI를 virtual DOM에 리렌더링한다.\n2. 이전 Virtual DOM에 있던 내용과 현재 내용을 비교한다.\n3. 바뀐 부분만 실제 DOM에 적용한다.\n\n결국 컴포넌트가 업데이트 될 때, 레이아웃 계산(reflow)이 한번만 이루어지므로 속도 저하 문제를 개선할 수 있게 되는 것이다.\n\n하지만, Virtual DOM이 모든 경우에서 무조건 더 좋은 퍼포먼스를 내는 것은 아니다. 오히려 단순 라우팅만 있는 정적 웹페이지의 경우 React를 쓰지 않는 편이 더 낫기도 하다. (React는 지속적으로 데이터가 변화하는 대규모 애플리케이션 구축에 적절하다고 공식 매뉴얼에서 밝히고 있다.)  \n\nReact와 Virtual DOM이 주는 최고의 편의성은 **간결한 업데이트 처리**이다. UI를 업데이트 하는 과정에서 발생하는 복잡함을 해소해줄 뿐 아니라, 업데이트에 쉽게 접근할 수 있게 해준다.\n\n```js\n// index.html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n\n  <script src=\"https://unpkg.com/react@latest/dist/react.js\"></script>\n  <script src=\"https://unpkg.com/react-dom@latest/dist/react-dom.js\"></script>\n  <script src=\"https://unpkg.com/babel-standalone@6.15.0/babel.min.js\"></script>\n</head>\n<body>\n  <h1>Welcome to React</h1>\n  <div id=\"react-app\"></div>\n  <script type=\"text/babel\"></script>\n  class BlogPost extends React.Component {\n    render() {\n      return (\n        <div>\n          This is a blog post\n        </div>\n      )\n    }\n  }\n\n  reactDOM.render(\n  <BlogPost/>,\n  document.getElementById('react-app');\n  );\n</body>\n</html>\n```\n\n## 3. create-react-app\n\n[create-react-app](https://github.com/facebookincubator/create-react-app)은 간편하게 React 앱을 만들수 있도록 자동으로 빌드해주는 도구이다. 이 패키지를 이용하면 Webpack이나 Babel을 설치하고 구성하는 복잡한 빌드 과정을 생략할 수 있다.   \n\n```bash\n# npm으로 create-react-app 패키지 설치\n$ npm install -g create-react-app\n\n# 패키지를 통해 react 프로젝트를 생성\n$ create-react-app my-app(프로젝트이름)\n```\n\n명령을 통해 my-app 프로젝트 폴더가 생성된다. 폴더 구조는 아래와 같다.\n\n```bash\nmy-app\n├── README.md\n├── node_modules\n├── package.json\n├── .gitignore\n├── public # 서버 public path\n│   └── favicon.ico\n│   └── index.html # 메인 페이지\n│   └── manifest.json\n└── src # React.js 프로젝트 루트\n    └── App.css \n    └── App.js # App 컴포넌트\n    └── App.test.js # test file\n    └── index.css\n    └── index.js # Webpack Entry point\n    └── logo.svg\n    └── registerServiceWorker.js\n```\n\n\n```bash\n# 프로젝트 폴더로 이동\n$ cd my-app\n\n# 이후에는 아래 두 가지 방법 중 택1\n# 1. yarn을 이용하는 방법\n\n$ npm install -g yarn # yarn이 설치되어 있다면 생략 가능\n\n$ yarn start\n\n# 2. npm을 이용하는 방법\n\n$ npm start\n\n# 위 작업을 마치면 http://localhost:3000 서버로 React 앱을 열 수 있다.\n```\n코드가 수정되면 자동으로 페이지가 로드되며 콘솔창을 통해 빌드 오류 및 lint 경고가 출력된다.\n\n```bash\n# 아래 두 명령어 중 택 1로 앱을 번들링하여 배포할 수 있다.\n# 프로덕션용 앱을 build 폴더에 빌드하며 최적의 성능을 위한 최적화(minify)를 진행한다. 빌드가 축소되며 파일이름에 해시가 포함된다. \n\n$ yarn build\n\n$ npm run build\n```\n\n아래는 자동 생성된 app.js 파일이다.\n\n```js\n// app.js\nimport React, { Component } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\n\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <div className=\"App-header\">\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <h2>Welcome to React</h2>\n        </div>\n        <p className=\"App-intro\">\n          To get started, edit <code>src/App.js</code> and save to reload.\n        </p>\n      </div>\n    );\n  }\n}\n\nexport default App;\n```\n\n<br>\n\n## 4. import, export\n\nimport는 ES6(ECMA Script 2016)의 문법이다. node의 require()와 동일한 의미이다. 이렇게 모듈을 require하는 방식은 서버단인 node의 방식이다. 클라이언트단에서는 `<script>`태그를 이용하여 파일을 로드해오는 것이 일반적이다. (require를 지원하지도 않는다.) 하지만 webpack으로 클라이언트에서도 node에서처럼 모듈을 불러올 수 있다. webpack은 import한 모듈을 한 파일로 합치는 번들링(bundling) 작업을 수행하는 모듈 번들러이다. `create-react-app`의 기본 구성도 webpack이다.\n\n아래는 `create-react-app` 패키지의 구성 요소이다.\n\n* webpack with webpack-dev-server, html-webpack-plugin and style-loader\n* Babel with ES6 and extensions used by Facebook (JSX, object spread, class properties)\n* Autoprefixer\n* ESLint\n* Jest\n* and others.\n\n기본 문법(syntax)은 `import 변수명 from 가져올 모듈의 경로`이다. 리액트의 모든 컴포넌트는 필수적으로 react모듈을 import해야 한다.  \n\n```js\n// es6\nimport React from 'react' // (필수)\nimport './App'\n// require와 같은 의미이다.\n // node\nvar React = require('react');\nvar App = require('./App');\n```\n\n경로 작성시 주의할 것이 있다면, React는 경로 맨 앞에 `./`를 붙이지 않으면 `node_modules`에서 해당 파일을 찾는다는 점이다. 코드에서 `'react'`는 `node_modules`에 있는 리액트 모듈을 가리키며, `./App.css`는 개발자가 직접 정의한 컴포넌트인 App.js를 가리킨다.\n\n위와 같이 import하기 위해서는 해당 컴포넌트에 export가 필수적으로 정의되어 있어야 한다. export 선언되지 않은 컴포넌트는 import도 할 수 없다.\n\n```js\nimport React from 'react'\nimport './App.css'\n\nclass App extends React.Component {\n  render(){\n    return (\n      <h1>Hello React</h1>\n    );\n  }\n}\n\nexport default App;\n```\n\ndefault로 export되는 컴포넌트에 한해서 아래와 같이 표현할 수도 있다.\n\n```js\nimport React from 'react'\nimport './App.css'\n\nexport default class App extends React.Component {\n  ...\n}\n```\n\n<br>\n\n## 5. JSX\n\n[webpackbin.com](https://www.webpackbin.com/bins/-KeVMcQWGocAn5VJL6XL)을 통해 간단한 react project를 확인해 볼 수 있다.\n\n```js\n// HelloWorld.js\nimport React from 'react';\n\n// stateless Function\nfunction HelloWorld() {\n  return (\n    <h1>Hello from React!</h1> // JSX 문법\n  );\n}\n\nexport default HelloWorld;\n```\n\nReact는 일반 js문법과는 다른 xml형태의 JSX 문법을 사용한다. JSX는 자바스크립트로 만든 xml로, HTML과 매우 유사한 모양을 하고 있다. 위 예제에서 자바스크립트 코드 내부에  `\"`나 `'`없이 HTML 코드가 섞여있는 것을 볼 수 있다. 이와 같은 모양을 JSX라고 하며, React는 JSX문법을 사용하여 UI를 템플릿화한다. 이 코드는 webpack의 babel-loader를 통해 자바스크립트 코드로 번들링된다. 위 코드는 아래와 같이 변환된다.\n\n```\nreturn React.createElement(\n  \"h1\",\n  null,\n  \"Hello from React!\"\n);\n```\n\n<br>\n\n## 6. 컴포넌트 로드하기  \n\n```js\n// main.js\nimport React from 'react';\nimport {render} from 'react-dom';\nimport Hello from './HelloWorld.js';\n\nrender(<HelloWorld/>, document.querySelector('#app'));\n```\n\nmain.js파일은 webpack의 entry 파일(진입점)으로 번들링 작업이 이루어지는 중심 지점이다. HelloWorld.js에서 만든 컴포넌트를 import하고, 기타 import한 파일들을 재귀적으로 불러와 하나의 파일로 합치는 작업을 수행한 후 페이지에 렌더링한다.\n\nReact 컴포넌트를 페이지에 렌더링할 때는 react-dom 모듈을 불러와 render 함수를 통해 처리한다. render 함수의 첫번째 파라미터는 렌더링할 JSX 형태의 코드로, 여기서는 HelloWorld 컴포넌트를 렌더링한다. 컴포넌트를 만들면 `<컴포넌트이름 />`의 형태(HTML의 태그처럼)로 작성할 수 있다. 두번째 파라미터는 렌더링할 HTML 요소이다. 위에서는 `index.html`의 id값이 app인 요소에 렌더링하도록 설정되었다.\n\n```html\n<!-- index.html -->\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\"/>\n  </head>\n  <body>\n    <div id=\"app\">\n    <!-- 여기에 렌더링한다. -->\n    </div>\n    <script src=\"main.js\"></script>\n  </body>\n</html>\n```\n\n<br>\n\n## 7. 컴포넌트에 속성 부여하기\n\n```js\n// HelloWorld.js\nimport React from 'react';\n\nfunction HelloWorld (props) {\n  return (\n    <h1>Hello {props.name}!</h1>\n  );\n}\n\nexport default HelloWorld;\n```\n위 코드는 함수 HelloWorld에 props 파라미터를 부여하고 props.name(props의 name 속성) 값을 JSX 안에서 렌더링하게 하였다.\n\n```js\n// main.js\nimport React from 'react';\nimport {render} from 'react-dom';\nimport HelloWorld from './HelloWorld.js';\n\nrender(<HelloWorld name=\"World\"/>, document.querySelector('#app'));\n```\n\nmain.js에서 렌더링할 때 HelloWorld 컴포넌트에 name 값을 \"World\"로 설정해주었다. 출력은 아래와 같을 것이다.\n\n```\nHello World!\n```\n\n<br>\n\n## 8. prop, state\n\n### 1) Components and Props\n\n컴포넌트를 이용해 UI를 독립적이고 재사용 가능한 부분으로 분리할 수 있으며 분리된 각 부분들을 개별적인 것(isolation)으로 생각할 수 있다. component는 view를 생성하는 자바스크립트 함수이다. 컴포넌트는 props라 불리는 임의의 입력을 받고, (prop는 사전적 의미로 '소품'이다.) React 요소를 반환한다. 이 요소는 화면에 무엇이 나타나야 하는지(render)를 설명한다.\n\n### 2) Props are Read-Only\n\nProp 값은 읽기만 가능한 값이다. 컴포넌트의 선언 방식(함수 또는 클래스로 선언될 수 있다.)과 관계 없이 컴포넌트의 prop는 직접적인 값의 수정이 절대 불가하다.\n\n```js\nfunction sum(a, b) {\n  return a + b ;\n}\n```\n\n위와 같은 함수들은 \"pure\"하다고 말한다. 입력값을 변경하지 않으며, 동일한 입력에 대해 항상 동일한 결과를 반환하기 때문이다. 위 예제는 a=2, b=3 일 때, 항상 5라는 값을 반환한다. 결과로서 a나 b를 변환하지 않는다. a는 항상 2이며 b도 항상 3이다.\n\n반면, 아래와 같은 함수는 \"impure\"하다. 결과값을 반환하면서 input을 스스로 바꿔버리기 때문이다. 이러한 함수는 입력값이 계속 변화함에 따라 결과값도 변화하기 때문에 항상 동일한 결과가 보장되지 않는다.\n\n```js\nfunction withdraw(accout, amount) {\n  accout.total -= amount;\n}\n```\n\n리액트는 상당히 유연하지만 엄격한 규칙이 하나 있다.\n**모든 React 컴포넌트는 props에 관해서는 반드시 pure함수처럼 동작해야 한다.**\n\n물론 어플리케이션 UI는 동적이며 시점(시간의 흐름)에 따라 변화한다. state는 React 컴포넌트가 이 규칙을 위반하지 않으면서 (유저의 행동, 네트워크 응답, 그리고 그 외 여러가지 요인들에 대한 응답으로) 변화된 시점에 따라 결과값을 변경할 수 있게 한다.\n\n> this.prop는 변경할 수 없고 this.state는 변경이 가능하다. 단 setState로만 바꿀 수 있다. state를 변경하는 방식은 담고 있는 값을 변경하는 것이 아니라, 새로운 값을 담은 새로운 state를 만들어주는 방식이다. 즉, 이전 state와 새로운 state는 완전히 다른 객체이다.\n\n> state의 immutable은 강제되는 부분은 아니지만 (오류가 발생하지 않는다.) 의도한 대로 동작하게 하기 위해서는 immutable을 지켜주어야 한다.\n\n### 3) State and Life-Cycle\n\n지금까지 배운 바에 의하면, 렌더된 출력을 변경하기 위해 `ReactDOM.render()`를 호출할 수 있다. 아래는 Live 시계를 만드는 컴포넌트이다.\n\n```js\nfunction tick() {\n  const element = (\n    <div>\n      <h1>Hello, World!</h1>\n      <h2>It is {new Date().toLocaleTimeString()}.</h2>\n    </div>\n  );\n  ReactDOM.render(\n    element,\n    document.getElementById('root')\n  );\n}\n\nsetInterval(tick, 1000);\n```\n\n위 `clock` 코드를 캡슐화하고 재사용하기 위해 컴포넌트화 할 수 있다. 먼저 위 함수는 크게 시계가 화면에 보이게 하는 것과 1초마다 시간이 갱신되게 하는 것으로 두 가지 일을 한다. 다음과 같이 분리할 수 있을 것이다.\n\n```js\nfunction Clock(props) {\n  return (\n    <div>\n      <h1>Hello, World!</h1>\n      <h2>It is {props.date.toLocaleTimeString()}.</h2>\n    </div>\n  )\n}\n\nfunction tick() {\n  ReactDOM.render(\n    <Clock data={new Date()} />,\n    document.getElementById('root')\n  );\n}\n\nsetInterval(tick, 1000);\n```\n\n사실 이렇게 분리하는 것은 별로 좋은 방법이 아니다. 위 코드에서는 Clock 함수를 매 초마다 불러내 매번 새로 UI를 업데이트한다. 이상적인 것은 Clock을 한번만 작성하는 것이다. 한번만 작성하면 Clock 함수가 스스로 업데이트 하도록 하는 것이 좋다.\n\n```js\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root')\n);\n```\n\n이를 구현하려면 clock 구성 요소에 `state`를 추가해야 한다. State는 props와 유사하지만 private하며 제어권이 완전히 컴포넌트에 있다. 클래스로 정의된 컴포넌트는 몇 가지 추가 기능을 가지고 있다고 하였다. **로컬(Local) state는 클래스 안에서만 사용할 수 있는 기능이다.**\n\n### 4) Converting a Function to a Class\n\n앞에서 정의한 `Clock`과 같은 함수형 컴포넌트를 클래스 컴포넌트로 변환할 수 있다. 다음 5단계를 거친다.   \n\n1. React.Component로부터 extends한 동일한 이름의 ES6 클래스를 만든다.\n2. `render()` 메서드를 추가한다.\n3. 함수 바디를 `render()` 메서드 내부로 옮긴다.\n4. `render()` 내부에 정의된 `props`를 `this.props`로 바꾼다.\n5. 나머지 빈 함수 선언문을 지운다.\n\n```js\nclass Clock extends React.Component {\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.props.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n```\n\n`Clock`함수가 class로 정의되었다. 이제 local state와 lifecycle hooks과 같은 추가 기능을 사용할 수 있다.\n\n### 5) Adding Local State to a Class\n\n이제 `date`를 props에서 state로 변환할 차례이다. 아래 3단계를 거친다.  \n\n**1.** `render()`메서드 내부의 `this.props.date`를 `this.state.date`로 바꾼다.  \n\n```js\nclass Clock extends React.Component {\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n```\n\n**2.** `this.state`의 초기값을 할당하는 class constructor(생성자)를 추가한다.\n\n```js\nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n```\n\n기본 생성자에 `props` 값을 전달하는 방법은 아래와 같음을 기억해두자.\n\n```js\nconstructor(props) {\n  super(props);\n  this.state = {date: new Date()};\n}\n```\n\n클래스 컴포넌트는 항상 `props`와 함께 기본 생성자(base constructor)를 호출해야 한다.\n\n**3.** `<Clock />`요소에서 `date` prop를 제거한다.\n\n```js\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root')\n);\n```\n\n타이머 코드는 나중에 컴포넌트에 다시 추가할 것이다.\n지금까지의 결과는 아래와 같다.\n\n```js\nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root')\n);\n```\n\n<br>\n\n### 6) Adding Lifecycle Methods to a Class\n\n위에서는 `Clock`이 DOM 위에 그려졌다가 사라지는 것을 1초마다 반복한다. `Clock`이 렌더될 때마다 DOM 위에 타이머를 셋업(set up)하는 것을 리액트에서는 마운팅(Mounting)이라고 한다. 또 DOM 위에서 타이머가 `clear`될 때마다 `Clock`을 DOM에서 지우는데, 이를 리액트에서는 unmounting이라고 한다.\n\nclass 컴포넌트에는 마운트 또는 언마운트될 때 특정 코드를 실행하는 메서드가 있다.\n\n```js\nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {data: new Date()};\n  }\n  componentDidMount() {\n    // 컴포넌트가 마운트 되었다는 의미의 메서드\n    // 컴포넌트가 마운트된 후에 실행된다.\n\n  }\n  componentWillMount() {\n    // 컴포넌트가 마운트 될 것이라는 의미의 메서드\n    // 컴포넌트가 마운트되기 전에 실행된다.\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Hello world!</h1>\n        <h2>It is {this.state.data.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n```\n\n위와 같은 방법을 'lifecycle hooks'라고 한다. \n\n![React Lifecycle in ES6. Inspired by Simon Sturmer](https://cdn-images-1.medium.com/max/800/1*YD6sBv5Ly548pGl042z3DA.jpeg)\n\n위 그림은 Lifecycle API를 표현한 것이다. 컴포넌트 생성은 `constructor` -> `componentWillMount` -> `render` 순으로 실행되며, `componentDidMount`가 가장 마지막에 위치하는 것을 확인할 수 있다.\n\n다시 타이머로 돌아와서, `componentDidMount()` hook은 컴포넌트 출력이 DOM에 렌더된 이후에 실행된다. 따라서 이 메서드에 타이머를 넣는 것이 좋은 방법일 것 같다.  \n\n```js\ncomponentDidMount() {\n  this.timerID = setInterval(\n    () => this.tick(),\n    1000\n  );\n}\n```\n\ntimerID를 어떤 식으로 저장하는지 눈여겨 보자. `this.props`는 리액트가 자체적으로 설정하지만, `this.state`는 특별한 의미를 갖기 때문에, 자유롭게 부가적인 필드를 추가할 수 있다. 만약 state를 보이지 않게 하려는 경우라면, 클래스에 수동으로 아래와 같은 필드를 추가할 수 있다.\n\n```js\ncomponentWillUnmount() {\n  clearInterval(this.timerID);\n}\n```\n\n마지막으로, 1초마다 실행되는 tick() 메서드를 구현해본다.\n`this.setState()`를 사용하여 컴포넌트의 local state 값을 업데이트할 수 있다.\n\n```js\nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {data: new Date()};\n  }\n  \n  componentDidMount() {\n    this.timerID = setInterval(\n      () => this. tick(), 1000\n    );\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.timerID);\n  }\n\n  tick() {\n    this.setState({\n      date: new Date()\n    });\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root');\n);\n```\n\n타이머가 완성되었다.\n\n이제 진행중인 작업과 메서드가 호출되는 순서를 간단히 요약해보자.\n\n**1)** `<Clock />`이 `ReactDOM.render()`에 전달되면 React가 `Clock` 구성 요소의 생성자를 호출한다. `Clock`은 현재 시간을 표시해야하므로 `this.state`를 현재 시간을 포함하는 객체로 초기화한다. 나중에 이 상태를 업데이트 할 것이다.  \n\n**2)** 그런 다음 React는 Clock 구성 요소의 `render()` 메서드를 호출한다. 이 메서드를 통해 React는 화면에 무엇을 표시해야 하는지 알아낸다. 그런 다음 React가 `Clock`의 렌더링 결과와 일치하도록 DOM을 업데이트한다.  \n\n**3)** `Clock` 출력이 DOM에 삽입되면 React는 `componentDidMount()` 라이프 사이클 후크를 호출한다. 내부에있는 Clock 컴포넌트는 브라우저에 `tick()`을 한 번씩 호출하는 타이머를 설정하도록 요청한다.  \n \n**4)** 초마다 브라우저에서 `tick()` 메소드를 호출한다. 그 내부에서 Clock 구성 요소는 현재 시간을 포함하는 객체로 `setState()`를 호출하여 UI 업데이트를 예약한다. `setState()` 호출 덕분에 React는 상태가 변경된 것을 알아채고 `render()` 메서드를 다시 호출하여 화면에 무엇이 있어야 하는지를 파악한다. 이번에는 `render()` 메서드의 `this.state.date`가 달라 지므로 렌더 결과에 업데이트 된 시간이 포함된다. React는 그에 따라 DOM을 업데이트한다.  \n\n**5)** `Clock` 컴포넌트가 DOM에서 제거되면 React가 `componentWillUnmount()` 라이프 사이클 후크를 호출하여 타이머가 중지된다. \n\n<br>\n\n---\n\n### What is “Mounting” in React js?\n\nReact에서 작업하는 컴포넌트는 모두 React 노드와 DOM 노드로 나타낼 수 있다. React노드를 DOM노드로 표시하는 방식, 위치, 시기는 최상위 API에서 관리한다. 아래 예제를 통해 좀 더 쉽게 이해해보자.\n\n```js\nlet foo = React.createElement(FooComponent);\n```\n\nfoo는 무엇이고 저 객체로 무엇을 할 수 있는가? 지금 이 시점의 foo는 React 타입인 FooComponent의 인스턴스이다. 즉, 현 시점에서는 페이지 그 어디에도 존재하지 않는다. DOM 요소가 아니므로 DOM 트리 어디에도 존재하지 않는 (React 요소 노드를 제외하고) document 상에서 아무런 의미도 없는 객체이다.\n\n이 상태에서 `React.findDOMNode(foo)`를 호출하면, falsy object를 반환할 것이다. 이유가 무엇일까? foo는 DOM 트리에 있을 필요가 없다. 따라서 DOM 표현(representation)을 가지고 있지 않다.\n\n그러나 React 요소 노드를 document에 마운트(mount)하려고하면 DOM 노드를 만드는 컴포넌트 생명주기가 시작된다.\n\n```js\nReact.render(foo, container);\n```\n\n이제 foo는 더이상 React 노드가 아니다. 연관되는 DOM 노드가 있으며 현재 document에 속하게 된다. 이제 실제 DOM 노드에서 어디서든지 foo를 찾을 수 있고 다른 DOM 요소들과 상호작용할 수 있으며, 높이나 너비를 계산하거나 스타일을 적용하거나, jQuery로 전달하는 등 일반적인 DOM 요소처럼 취급할 수 있게 된다.\n\n\n<br>\n\n---\n\n**Reference**\n\n[React Document](https://facebook.github.io/react/tutorial/tutorial.html#what-is-react)\n\n[React Lecture Blog - Korean](https://velopert.com/867)\n\n[create-react-app github](https://github.com/facebookincubator/create-react-app)\n\n[stack overflow - What is “Mounting” in React js?](https://stackoverflow.com/questions/31556450/what-is-mounting-in-react-js)\n","slug":"React/01.basic","published":1,"updated":"2017-11-21T10:10:40.591Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjai8h17s0008vb9qm7mn7rs6","content":"<p><img src=\"https://cdn-images-1.medium.com/max/2000/1*HSisLuifMO6KbLfPOKtLow.jpeg\" alt=\"\"></p><h2 id=\"1-What-is-React\"><a href=\"#1-What-is-React\" class=\"headerlink\" title=\"1. What is React?\"></a>1. What is React?</h2><p>React는 페이스북에서 개발한 자바스크립트 라이브러리이다. 공식 문서에서는 <strong>사용자 인터페이스(User Interface)를 구축하기위한 선언적(declarative)이고 효율적(efficient)이며 유연한(flexible) JavaScript 라이브러리</strong>라고 설명하고있다. React는 ‘컴포넌트’단위로 재사용 가능한 UI 템플릿을 만든다. 현재 페이스북, 인스타그램, MS 등 대형 서비스에서도 사용되고있는 견고한 라이브러리이다.</p><p>React는 Virtual DOM이라는 개념을 사용하여 상태(state)의 변함(diff)에 따라 선택적으로 UI를 렌더링한다. 따라서 최소한의 DOM 처리로 컴포넌트 업데이트가 가능하다.</p><p><br></p><h2 id=\"2-Virtual-DOM\"><a href=\"#2-Virtual-DOM\" class=\"headerlink\" title=\"2. Virtual DOM\"></a>2. Virtual DOM</h2><h3 id=\"1-DOM\"><a href=\"#1-DOM\" class=\"headerlink\" title=\"1) DOM\"></a>1) DOM</h3><p>DOM(Document Object Model)이란 객체를 통해 구조화된 문서를 표현하는 방법을 말한다. XML또는 HTML로 작성된다. 웹 브라우저는 DOM을 이용해 객체에 자바스크립트와 CSS를 적용한다. DOM은 트리 형태로 되어있으며 특정 노드(node)의 서치(search)와 수정, 제거, 삽입이 가능하다.</p><p>DOM의 문제점은 동적 UI에 최적화되어 있지 않다는 것이다. HTML은 그 자체로 정적인 문서(document)이기 때문이다. 큰 규모의 웹 어플리케이션은 하나의 페이지에도 수 많은 요소들이 생기는데, 이 모든 요소들을 DOM에 직접 접근하여 조작하면서 변화룰 주다보면 속도 저하를 피할 수 없게 된다.</p><p>브라우저 단에서 DOM의 변화가 일어나면 브라우저는 CSS를 다시 연산하고 레이아웃을 새로 구성(=리플로우, reflow )하며 웹 페이지에서 레이아웃에 관계 없는 나머지(색상 변경 등)를 처리(=리페인트, repaint) 하는 데, 이 과정이 DOM에 접근하는 만큼 반복된다. 속도 저하는 바로 이 부분에서 발생한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> style = <span class=\"built_in\">document</span>.body.style; <span class=\"comment\">// 캐싱</span></div><div class=\"line\">style.padding = <span class=\"string\">\"20px\"</span>; <span class=\"comment\">// reflow, repaint</span></div><div class=\"line\">style.border = <span class=\"string\">\"10px solid red\"</span>; <span class=\"comment\">// reflow, repaint</span></div><div class=\"line\"></div><div class=\"line\">style.color = <span class=\"string\">\"blue\"</span>; <span class=\"comment\">// repaint</span></div><div class=\"line\">style.backgroundColor = <span class=\"string\">\"#ffa\"</span>; <span class=\"comment\">// repaint</span></div><div class=\"line\"></div><div class=\"line\">style.fontSize = <span class=\"string\">\"1em\"</span>; <span class=\"comment\">// reflow, repaint</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// reflow, repaint</span></div><div class=\"line\"><span class=\"built_in\">document</span>.body.appendChild(<span class=\"built_in\">document</span>.createTextNode(<span class=\"string\">'hello World'</span>));</div></pre></td></tr></table></figure><p>이렇게 코드가 실행될 때마다 reflow하는 것은 매우 비효율적이며 이에 따른 성능 저하를 우려하지 않을 수 없다. 브라우저는 성능 저하를 단축시키기 위해 짧은 시간 내에 여러 reflow가 발생하려 할 시 이 작업을 미루고 한번에 처리한다. (하지만, <code>offsetTop</code>, <code>scrollTop</code>, <code>getComputedStyle()</code> 등 코드 실행 당시 값을 가져오는 것이 중요한 일부 코드들은 reflow가 여러번 발생할 수 없으므로 브라우저에서 최적화하지 못한다.) 따라서 성능 개선을 위해서는 reflow 횟수를 줄이기 위해 코드를 최적화 해야 한다.</p><h3 id=\"2-Virtual-DOM-1\"><a href=\"#2-Virtual-DOM-1\" class=\"headerlink\" title=\"2) Virtual DOM\"></a>2) Virtual DOM</h3><p>HTML 마크업을 시각적 형태로 변환하는 것은 브라우저의 주 역할이다. 결국 DOM 조작을 아예 하지 않을 수는 없으니, 최소한의 조작만 하여 성능 저하 문제를 해결해보고자 하는 노력이 Virtual DOM을 탄생시켰다.</p><p>Virtual DOM은 언어 그대로 가상 DOM이다. DOM 작업을 가상화(추상화)하여 미리 처리한 다음, 실제 DOM에 한번에 적용하는 방식이다.</p><p>React의 실제 DOM 업데이트는 아래 3단계로 이루어진다.</p><ol><li>데이터가 업데이트되면, 전체 UI를 virtual DOM에 리렌더링한다.</li><li>이전 Virtual DOM에 있던 내용과 현재 내용을 비교한다.</li><li>바뀐 부분만 실제 DOM에 적용한다.</li></ol><p>결국 컴포넌트가 업데이트 될 때, 레이아웃 계산(reflow)이 한번만 이루어지므로 속도 저하 문제를 개선할 수 있게 되는 것이다.</p><p>하지만, Virtual DOM이 모든 경우에서 무조건 더 좋은 퍼포먼스를 내는 것은 아니다. 오히려 단순 라우팅만 있는 정적 웹페이지의 경우 React를 쓰지 않는 편이 더 낫기도 하다. (React는 지속적으로 데이터가 변화하는 대규모 애플리케이션 구축에 적절하다고 공식 매뉴얼에서 밝히고 있다.)</p><p>React와 Virtual DOM이 주는 최고의 편의성은 <strong>간결한 업데이트 처리</strong>이다. UI를 업데이트 하는 과정에서 발생하는 복잡함을 해소해줄 뿐 아니라, 업데이트에 쉽게 접근할 수 있게 해준다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// index.html</span></div><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html lang=<span class=\"string\">\"en\"</span>&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">  &lt;meta charset=<span class=\"string\">\"UTF-8\"</span>&gt;</div><div class=\"line\">  &lt;meta name=<span class=\"string\">\"viewport\"</span> content=<span class=\"string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</div><div class=\"line\">  &lt;meta http-equiv=<span class=\"string\">\"X-UA-Compatible\"</span> content=<span class=\"string\">\"ie=edge\"</span>&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;script src=<span class=\"string\">\"https://unpkg.com/react@latest/dist/react.js\"</span>&gt;&lt;/script&gt;</div><div class=\"line\">  &lt;script src=<span class=\"string\">\"https://unpkg.com/react-dom@latest/dist/react-dom.js\"</span>&gt;&lt;/script&gt;</div><div class=\"line\">  &lt;script src=<span class=\"string\">\"https://unpkg.com/babel-standalone@6.15.0/babel.min.js\"</span>&gt;&lt;/script&gt;</div><div class=\"line\">&lt;<span class=\"regexp\">/head&gt;</span></div><div class=\"line\"><span class=\"regexp\">&lt;body&gt;</span></div><div class=\"line\"><span class=\"regexp\">  &lt;h1&gt;Welcome to React&lt;/</span>h1&gt;</div><div class=\"line\">  &lt;div id=<span class=\"string\">\"react-app\"</span>&gt;&lt;/div&gt;</div><div class=\"line\">  &lt;script type=<span class=\"string\">\"text/babel\"</span>&gt;&lt;/script&gt;</div><div class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BlogPost</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">    render() &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> (</div><div class=\"line\">        &lt;div&gt;</div><div class=\"line\">          This is a blog post</div><div class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></div><div class=\"line\"><span class=\"regexp\">      )</span></div><div class=\"line\"><span class=\"regexp\">    &#125;</span></div><div class=\"line\"><span class=\"regexp\">  &#125;</span></div><div class=\"line\"><span class=\"regexp\"></span></div><div class=\"line\"><span class=\"regexp\">  reactDOM.render(</span></div><div class=\"line\"><span class=\"regexp\">  &lt;BlogPost/</span>&gt;,</div><div class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'react-app'</span>);</div><div class=\"line\">  );</div><div class=\"line\">&lt;<span class=\"regexp\">/body&gt;</span></div><div class=\"line\"><span class=\"regexp\">&lt;/</span>html&gt;</div></pre></td></tr></table></figure><h2 id=\"3-create-react-app\"><a href=\"#3-create-react-app\" class=\"headerlink\" title=\"3. create-react-app\"></a>3. create-react-app</h2><p><a href=\"https://github.com/facebookincubator/create-react-app\" target=\"_blank\" rel=\"external\">create-react-app</a>은 간편하게 React 앱을 만들수 있도록 자동으로 빌드해주는 도구이다. 이 패키지를 이용하면 Webpack이나 Babel을 설치하고 구성하는 복잡한 빌드 과정을 생략할 수 있다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># npm으로 create-react-app 패키지 설치</span></div><div class=\"line\">$ npm install -g create-react-app</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 패키지를 통해 react 프로젝트를 생성</span></div><div class=\"line\">$ create-react-app my-app(프로젝트이름)</div></pre></td></tr></table></figure><p>명령을 통해 my-app 프로젝트 폴더가 생성된다. 폴더 구조는 아래와 같다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">my-app</div><div class=\"line\">├── README.md</div><div class=\"line\">├── node_modules</div><div class=\"line\">├── package.json</div><div class=\"line\">├── .gitignore</div><div class=\"line\">├── public <span class=\"comment\"># 서버 public path</span></div><div class=\"line\">│   └── favicon.ico</div><div class=\"line\">│   └── index.html <span class=\"comment\"># 메인 페이지</span></div><div class=\"line\">│   └── manifest.json</div><div class=\"line\">└── src <span class=\"comment\"># React.js 프로젝트 루트</span></div><div class=\"line\">    └── App.css </div><div class=\"line\">    └── App.js <span class=\"comment\"># App 컴포넌트</span></div><div class=\"line\">    └── App.test.js <span class=\"comment\"># test file</span></div><div class=\"line\">    └── index.css</div><div class=\"line\">    └── index.js <span class=\"comment\"># Webpack Entry point</span></div><div class=\"line\">    └── logo.svg</div><div class=\"line\">    └── registerServiceWorker.js</div></pre></td></tr></table></figure><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 프로젝트 폴더로 이동</span></div><div class=\"line\">$ <span class=\"built_in\">cd</span> my-app</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 이후에는 아래 두 가지 방법 중 택1</span></div><div class=\"line\"><span class=\"comment\"># 1. yarn을 이용하는 방법</span></div><div class=\"line\"></div><div class=\"line\">$ npm install -g yarn <span class=\"comment\"># yarn이 설치되어 있다면 생략 가능</span></div><div class=\"line\"></div><div class=\"line\">$ yarn start</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 2. npm을 이용하는 방법</span></div><div class=\"line\"></div><div class=\"line\">$ npm start</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 위 작업을 마치면 http://localhost:3000 서버로 React 앱을 열 수 있다.</span></div></pre></td></tr></table></figure><p>코드가 수정되면 자동으로 페이지가 로드되며 콘솔창을 통해 빌드 오류 및 lint 경고가 출력된다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 아래 두 명령어 중 택 1로 앱을 번들링하여 배포할 수 있다.</span></div><div class=\"line\"><span class=\"comment\"># 프로덕션용 앱을 build 폴더에 빌드하며 최적의 성능을 위한 최적화(minify)를 진행한다. 빌드가 축소되며 파일이름에 해시가 포함된다. </span></div><div class=\"line\"></div><div class=\"line\">$ yarn build</div><div class=\"line\"></div><div class=\"line\">$ npm run build</div></pre></td></tr></table></figure><p>아래는 자동 생성된 app.js 파일이다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// app.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> logo <span class=\"keyword\">from</span> <span class=\"string\">'./logo.svg'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App.css'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</div><div class=\"line\">        &lt;div className=<span class=\"string\">\"App-header\"</span>&gt;</div><div class=\"line\">          &lt;img src=&#123;logo&#125; className=<span class=\"string\">\"App-logo\"</span> alt=<span class=\"string\">\"logo\"</span> /&gt;</div><div class=\"line\">          &lt;h2&gt;Welcome to React&lt;<span class=\"regexp\">/h2&gt;</span></div><div class=\"line\"><span class=\"regexp\">        &lt;/</span>div&gt;</div><div class=\"line\">        &lt;p className=<span class=\"string\">\"App-intro\"</span>&gt;</div><div class=\"line\">          To get started, edit &lt;code&gt;src/App.js&lt;<span class=\"regexp\">/code&gt; and save to reload.</span></div><div class=\"line\"><span class=\"regexp\">        &lt;/</span>p&gt;</div><div class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></div><div class=\"line\"><span class=\"regexp\">    );</span></div><div class=\"line\"><span class=\"regexp\">  &#125;</span></div><div class=\"line\"><span class=\"regexp\">&#125;</span></div><div class=\"line\"><span class=\"regexp\"></span></div><div class=\"line\"><span class=\"regexp\">export default App;</span></div></pre></td></tr></table></figure><p><br></p><h2 id=\"4-import-export\"><a href=\"#4-import-export\" class=\"headerlink\" title=\"4. import, export\"></a>4. import, export</h2><p>import는 ES6(ECMA Script 2016)의 문법이다. node의 require()와 동일한 의미이다. 이렇게 모듈을 require하는 방식은 서버단인 node의 방식이다. 클라이언트단에서는 <code>&lt;script&gt;</code>태그를 이용하여 파일을 로드해오는 것이 일반적이다. (require를 지원하지도 않는다.) 하지만 webpack으로 클라이언트에서도 node에서처럼 모듈을 불러올 수 있다. webpack은 import한 모듈을 한 파일로 합치는 번들링(bundling) 작업을 수행하는 모듈 번들러이다. <code>create-react-app</code>의 기본 구성도 webpack이다.</p><p>아래는 <code>create-react-app</code> 패키지의 구성 요소이다.</p><ul><li>webpack with webpack-dev-server, html-webpack-plugin and style-loader</li><li>Babel with ES6 and extensions used by Facebook (JSX, object spread, class properties)</li><li>Autoprefixer</li><li>ESLint</li><li>Jest</li><li>and others.</li></ul><p>기본 문법(syntax)은 <code>import 변수명 from 가져올 모듈의 경로</code>이다. 리액트의 모든 컴포넌트는 필수적으로 react모듈을 import해야 한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// es6</span></div><div class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span> <span class=\"comment\">// (필수)</span></div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App'</span></div><div class=\"line\"><span class=\"comment\">// require와 같은 의미이다.</span></div><div class=\"line\"> <span class=\"comment\">// node</span></div><div class=\"line\"><span class=\"keyword\">var</span> React = <span class=\"built_in\">require</span>(<span class=\"string\">'react'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> App = <span class=\"built_in\">require</span>(<span class=\"string\">'./App'</span>);</div></pre></td></tr></table></figure><p>경로 작성시 주의할 것이 있다면, React는 경로 맨 앞에 <code>./</code>를 붙이지 않으면 <code>node_modules</code>에서 해당 파일을 찾는다는 점이다. 코드에서 <code>&#39;react&#39;</code>는 <code>node_modules</code>에 있는 리액트 모듈을 가리키며, <code>./App.css</code>는 개발자가 직접 정의한 컴포넌트인 App.js를 가리킨다.</p><p>위와 같이 import하기 위해서는 해당 컴포넌트에 export가 필수적으로 정의되어 있어야 한다. export 선언되지 않은 컴포넌트는 import도 할 수 없다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App.css'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render()&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;h1&gt;Hello React&lt;<span class=\"regexp\">/h1&gt;</span></div><div class=\"line\"><span class=\"regexp\">    );</span></div><div class=\"line\"><span class=\"regexp\">  &#125;</span></div><div class=\"line\"><span class=\"regexp\">&#125;</span></div><div class=\"line\"><span class=\"regexp\"></span></div><div class=\"line\"><span class=\"regexp\">export default App;</span></div></pre></td></tr></table></figure><p>default로 export되는 컴포넌트에 한해서 아래와 같이 표현할 수도 있다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App.css'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p><br></p><h2 id=\"5-JSX\"><a href=\"#5-JSX\" class=\"headerlink\" title=\"5. JSX\"></a>5. JSX</h2><p><a href=\"https://www.webpackbin.com/bins/-KeVMcQWGocAn5VJL6XL\" target=\"_blank\" rel=\"external\">webpackbin.com</a>을 통해 간단한 react project를 확인해 볼 수 있다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// HelloWorld.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// stateless Function</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HelloWorld</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    &lt;h1&gt;Hello <span class=\"keyword\">from</span> React!&lt;/h1&gt; <span class=\"comment\">// JSX 문법</span></div><div class=\"line\">  );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> HelloWorld;</div></pre></td></tr></table></figure><p>React는 일반 js문법과는 다른 xml형태의 JSX 문법을 사용한다. JSX는 자바스크립트로 만든 xml로, HTML과 매우 유사한 모양을 하고 있다. 위 예제에서 자바스크립트 코드 내부에 <code>&quot;</code>나 <code>&#39;</code>없이 HTML 코드가 섞여있는 것을 볼 수 있다. 이와 같은 모양을 JSX라고 하며, React는 JSX문법을 사용하여 UI를 템플릿화한다. 이 코드는 webpack의 babel-loader를 통해 자바스크립트 코드로 번들링된다. 위 코드는 아래와 같이 변환된다.</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">return React.createElement(</div><div class=\"line\">  &quot;h1&quot;,</div><div class=\"line\">  null,</div><div class=\"line\">  &quot;Hello from React!&quot;</div><div class=\"line\">);</div></pre></td></tr></table></figure><p><br></p><h2 id=\"6-컴포넌트-로드하기\"><a href=\"#6-컴포넌트-로드하기\" class=\"headerlink\" title=\"6. 컴포넌트 로드하기\"></a>6. 컴포넌트 로드하기</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// main.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123;render&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> Hello <span class=\"keyword\">from</span> <span class=\"string\">'./HelloWorld.js'</span>;</div><div class=\"line\"></div><div class=\"line\">render(&lt;HelloWorld/&gt;, <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#app'</span>));</div></pre></td></tr></table></figure><p>main.js파일은 webpack의 entry 파일(진입점)으로 번들링 작업이 이루어지는 중심 지점이다. HelloWorld.js에서 만든 컴포넌트를 import하고, 기타 import한 파일들을 재귀적으로 불러와 하나의 파일로 합치는 작업을 수행한 후 페이지에 렌더링한다.</p><p>React 컴포넌트를 페이지에 렌더링할 때는 react-dom 모듈을 불러와 render 함수를 통해 처리한다. render 함수의 첫번째 파라미터는 렌더링할 JSX 형태의 코드로, 여기서는 HelloWorld 컴포넌트를 렌더링한다. 컴포넌트를 만들면 <code>&lt;컴포넌트이름 /&gt;</code>의 형태(HTML의 태그처럼)로 작성할 수 있다. 두번째 파라미터는 렌더링할 HTML 요소이다. 위에서는 <code>index.html</code>의 id값이 app인 요소에 렌더링하도록 설정되었다.</p><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- index.html --&gt;</span></div><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>/&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 여기에 렌더링한다. --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"main.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure><p><br></p><h2 id=\"7-컴포넌트에-속성-부여하기\"><a href=\"#7-컴포넌트에-속성-부여하기\" class=\"headerlink\" title=\"7. 컴포넌트에 속성 부여하기\"></a>7. 컴포넌트에 속성 부여하기</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// HelloWorld.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HelloWorld</span> (<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    &lt;h1&gt;Hello &#123;props.name&#125;!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">  );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> HelloWorld;</div></pre></td></tr></table></figure><p>위 코드는 함수 HelloWorld에 props 파라미터를 부여하고 props.name(props의 name 속성) 값을 JSX 안에서 렌더링하게 하였다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// main.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123;render&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> HelloWorld <span class=\"keyword\">from</span> <span class=\"string\">'./HelloWorld.js'</span>;</div><div class=\"line\"></div><div class=\"line\">render(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">HelloWorld</span> <span class=\"attr\">name</span>=<span class=\"string\">\"World\"</span>/&gt;</span>, document.querySelector('#app'));</span></div></pre></td></tr></table></figure><p>main.js에서 렌더링할 때 HelloWorld 컴포넌트에 name 값을 “World”로 설정해주었다. 출력은 아래와 같을 것이다.</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Hello World!</div></pre></td></tr></table></figure><p><br></p><h2 id=\"8-prop-state\"><a href=\"#8-prop-state\" class=\"headerlink\" title=\"8. prop, state\"></a>8. prop, state</h2><h3 id=\"1-Components-and-Props\"><a href=\"#1-Components-and-Props\" class=\"headerlink\" title=\"1) Components and Props\"></a>1) Components and Props</h3><p>컴포넌트를 이용해 UI를 독립적이고 재사용 가능한 부분으로 분리할 수 있으며 분리된 각 부분들을 개별적인 것(isolation)으로 생각할 수 있다. component는 view를 생성하는 자바스크립트 함수이다. 컴포넌트는 props라 불리는 임의의 입력을 받고, (prop는 사전적 의미로 ‘소품’이다.) React 요소를 반환한다. 이 요소는 화면에 무엇이 나타나야 하는지(render)를 설명한다.</p><h3 id=\"2-Props-are-Read-Only\"><a href=\"#2-Props-are-Read-Only\" class=\"headerlink\" title=\"2) Props are Read-Only\"></a>2) Props are Read-Only</h3><p>Prop 값은 읽기만 가능한 값이다. 컴포넌트의 선언 방식(함수 또는 클래스로 선언될 수 있다.)과 관계 없이 컴포넌트의 prop는 직접적인 값의 수정이 절대 불가하다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a + b ;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>위와 같은 함수들은 “pure”하다고 말한다. 입력값을 변경하지 않으며, 동일한 입력에 대해 항상 동일한 결과를 반환하기 때문이다. 위 예제는 a=2, b=3 일 때, 항상 5라는 값을 반환한다. 결과로서 a나 b를 변환하지 않는다. a는 항상 2이며 b도 항상 3이다.</p><p>반면, 아래와 같은 함수는 “impure”하다. 결과값을 반환하면서 input을 스스로 바꿔버리기 때문이다. 이러한 함수는 입력값이 계속 변화함에 따라 결과값도 변화하기 때문에 항상 동일한 결과가 보장되지 않는다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withdraw</span>(<span class=\"params\">accout, amount</span>) </span>&#123;</div><div class=\"line\">  accout.total -= amount;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>리액트는 상당히 유연하지만 엄격한 규칙이 하나 있다.<br><strong>모든 React 컴포넌트는 props에 관해서는 반드시 pure함수처럼 동작해야 한다.</strong></p><p>물론 어플리케이션 UI는 동적이며 시점(시간의 흐름)에 따라 변화한다. state는 React 컴포넌트가 이 규칙을 위반하지 않으면서 (유저의 행동, 네트워크 응답, 그리고 그 외 여러가지 요인들에 대한 응답으로) 변화된 시점에 따라 결과값을 변경할 수 있게 한다.</p><blockquote><p>this.prop는 변경할 수 없고 this.state는 변경이 가능하다. 단 setState로만 바꿀 수 있다. state를 변경하는 방식은 담고 있는 값을 변경하는 것이 아니라, 새로운 값을 담은 새로운 state를 만들어주는 방식이다. 즉, 이전 state와 새로운 state는 완전히 다른 객체이다.</p><p>state의 immutable은 강제되는 부분은 아니지만 (오류가 발생하지 않는다.) 의도한 대로 동작하게 하기 위해서는 immutable을 지켜주어야 한다.</p></blockquote><h3 id=\"3-State-and-Life-Cycle\"><a href=\"#3-State-and-Life-Cycle\" class=\"headerlink\" title=\"3) State and Life-Cycle\"></a>3) State and Life-Cycle</h3><p>지금까지 배운 바에 의하면, 렌더된 출력을 변경하기 위해 <code>ReactDOM.render()</code>를 호출할 수 있다. 아래는 Live 시계를 만드는 컴포넌트이다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tick</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> element = (</div><div class=\"line\">    &lt;div&gt;</div><div class=\"line\">      &lt;h1&gt;Hello, World!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">      &lt;h2&gt;It is &#123;<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().toLocaleTimeString()&#125;.&lt;<span class=\"regexp\">/h2&gt;</span></div><div class=\"line\"><span class=\"regexp\">    &lt;/</span>div&gt;</div><div class=\"line\">  );</div><div class=\"line\">  ReactDOM.render(</div><div class=\"line\">    element,</div><div class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</div><div class=\"line\">  );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">setInterval(tick, <span class=\"number\">1000</span>);</div></pre></td></tr></table></figure><p>위 <code>clock</code> 코드를 캡슐화하고 재사용하기 위해 컴포넌트화 할 수 있다. 먼저 위 함수는 크게 시계가 화면에 보이게 하는 것과 1초마다 시간이 갱신되게 하는 것으로 두 가지 일을 한다. 다음과 같이 분리할 수 있을 것이다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Clock</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    &lt;div&gt;</div><div class=\"line\">      &lt;h1&gt;Hello, World!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">      &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;<span class=\"regexp\">/h2&gt;</span></div><div class=\"line\"><span class=\"regexp\">    &lt;/</span>div&gt;</div><div class=\"line\">  )</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tick</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  ReactDOM.render(</div><div class=\"line\">    &lt;Clock data=&#123;<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()&#125; /&gt;,</div><div class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</div><div class=\"line\">  );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">setInterval(tick, <span class=\"number\">1000</span>);</div></pre></td></tr></table></figure><p>사실 이렇게 분리하는 것은 별로 좋은 방법이 아니다. 위 코드에서는 Clock 함수를 매 초마다 불러내 매번 새로 UI를 업데이트한다. 이상적인 것은 Clock을 한번만 작성하는 것이다. 한번만 작성하면 Clock 함수가 스스로 업데이트 하도록 하는 것이 좋다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  &lt;Clock /&gt;,</div><div class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</div><div class=\"line\">);</div></pre></td></tr></table></figure><p>이를 구현하려면 clock 구성 요소에 <code>state</code>를 추가해야 한다. State는 props와 유사하지만 private하며 제어권이 완전히 컴포넌트에 있다. 클래스로 정의된 컴포넌트는 몇 가지 추가 기능을 가지고 있다고 하였다. <strong>로컬(Local) state는 클래스 안에서만 사용할 수 있는 기능이다.</strong></p><h3 id=\"4-Converting-a-Function-to-a-Class\"><a href=\"#4-Converting-a-Function-to-a-Class\" class=\"headerlink\" title=\"4) Converting a Function to a Class\"></a>4) Converting a Function to a Class</h3><p>앞에서 정의한 <code>Clock</code>과 같은 함수형 컴포넌트를 클래스 컴포넌트로 변환할 수 있다. 다음 5단계를 거친다.</p><ol><li>React.Component로부터 extends한 동일한 이름의 ES6 클래스를 만든다.</li><li><code>render()</code> 메서드를 추가한다.</li><li>함수 바디를 <code>render()</code> 메서드 내부로 옮긴다.</li><li><code>render()</code> 내부에 정의된 <code>props</code>를 <code>this.props</code>로 바꾼다.</li><li>나머지 빈 함수 선언문을 지운다.</li></ol><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Clock</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;div&gt;</div><div class=\"line\">        &lt;h1&gt;Hello, world!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">        &lt;h2&gt;It is &#123;<span class=\"keyword\">this</span>.props.date.toLocaleTimeString()&#125;.&lt;<span class=\"regexp\">/h2&gt;</span></div><div class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p><code>Clock</code>함수가 class로 정의되었다. 이제 local state와 lifecycle hooks과 같은 추가 기능을 사용할 수 있다.</p><h3 id=\"5-Adding-Local-State-to-a-Class\"><a href=\"#5-Adding-Local-State-to-a-Class\" class=\"headerlink\" title=\"5) Adding Local State to a Class\"></a>5) Adding Local State to a Class</h3><p>이제 <code>date</code>를 props에서 state로 변환할 차례이다. 아래 3단계를 거친다.</p><p><strong>1.</strong> <code>render()</code>메서드 내부의 <code>this.props.date</code>를 <code>this.state.date</code>로 바꾼다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Clock</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;div&gt;</div><div class=\"line\">        &lt;h1&gt;Hello, world!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">        &lt;h2&gt;It is &#123;<span class=\"keyword\">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class=\"regexp\">/h2&gt;</span></div><div class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p><strong>2.</strong> <code>this.state</code>의 초기값을 할당하는 class constructor(생성자)를 추가한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Clock</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">date</span>: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;div&gt;</div><div class=\"line\">        &lt;h1&gt;Hello, world!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">        &lt;h2&gt;It is &#123;<span class=\"keyword\">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class=\"regexp\">/h2&gt;</span></div><div class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>기본 생성자에 <code>props</code> 값을 전달하는 방법은 아래와 같음을 기억해두자.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">  <span class=\"keyword\">super</span>(props);</div><div class=\"line\">  <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">date</span>: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()&#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>클래스 컴포넌트는 항상 <code>props</code>와 함께 기본 생성자(base constructor)를 호출해야 한다.</p><p><strong>3.</strong> <code>&lt;Clock /&gt;</code>요소에서 <code>date</code> prop를 제거한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  &lt;Clock /&gt;,</div><div class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</div><div class=\"line\">);</div></pre></td></tr></table></figure><p>타이머 코드는 나중에 컴포넌트에 다시 추가할 것이다.<br>지금까지의 결과는 아래와 같다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Clock</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">date</span>: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;div&gt;</div><div class=\"line\">        &lt;h1&gt;Hello, world!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">        &lt;h2&gt;It is &#123;<span class=\"keyword\">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class=\"regexp\">/h2&gt;</span></div><div class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  &lt;Clock /&gt;,</div><div class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</div><div class=\"line\">);</div></pre></td></tr></table></figure><p><br></p><h3 id=\"6-Adding-Lifecycle-Methods-to-a-Class\"><a href=\"#6-Adding-Lifecycle-Methods-to-a-Class\" class=\"headerlink\" title=\"6) Adding Lifecycle Methods to a Class\"></a>6) Adding Lifecycle Methods to a Class</h3><p>위에서는 <code>Clock</code>이 DOM 위에 그려졌다가 사라지는 것을 1초마다 반복한다. <code>Clock</code>이 렌더될 때마다 DOM 위에 타이머를 셋업(set up)하는 것을 리액트에서는 마운팅(Mounting)이라고 한다. 또 DOM 위에서 타이머가 <code>clear</code>될 때마다 <code>Clock</code>을 DOM에서 지우는데, 이를 리액트에서는 unmounting이라고 한다.</p><p>class 컴포넌트에는 마운트 또는 언마운트될 때 특정 코드를 실행하는 메서드가 있다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Clock</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">data</span>: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\">  componentDidMount() &#123;</div><div class=\"line\">    <span class=\"comment\">// 컴포넌트가 마운트 되었다는 의미의 메서드</span></div><div class=\"line\">    <span class=\"comment\">// 컴포넌트가 마운트된 후에 실행된다.</span></div><div class=\"line\"></div><div class=\"line\">  &#125;</div><div class=\"line\">  componentWillMount() &#123;</div><div class=\"line\">    <span class=\"comment\">// 컴포넌트가 마운트 될 것이라는 의미의 메서드</span></div><div class=\"line\">    <span class=\"comment\">// 컴포넌트가 마운트되기 전에 실행된다.</span></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;div&gt;</div><div class=\"line\">        &lt;h1&gt;Hello world!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">        &lt;h2&gt;It is &#123;<span class=\"keyword\">this</span>.state.data.toLocaleTimeString()&#125;.&lt;<span class=\"regexp\">/h2&gt;</span></div><div class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>위와 같은 방법을 ‘lifecycle hooks’라고 한다.</p><p><img src=\"https://cdn-images-1.medium.com/max/800/1*YD6sBv5Ly548pGl042z3DA.jpeg\" alt=\"React Lifecycle in ES6. Inspired by Simon Sturmer\"></p><p>위 그림은 Lifecycle API를 표현한 것이다. 컴포넌트 생성은 <code>constructor</code> -&gt; <code>componentWillMount</code> -&gt; <code>render</code> 순으로 실행되며, <code>componentDidMount</code>가 가장 마지막에 위치하는 것을 확인할 수 있다.</p><p>다시 타이머로 돌아와서, <code>componentDidMount()</code> hook은 컴포넌트 출력이 DOM에 렌더된 이후에 실행된다. 따라서 이 메서드에 타이머를 넣는 것이 좋은 방법일 것 같다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">componentDidMount() &#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.timerID = setInterval(</div><div class=\"line\">    () =&gt; <span class=\"keyword\">this</span>.tick(),</div><div class=\"line\">    <span class=\"number\">1000</span></div><div class=\"line\">  );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>timerID를 어떤 식으로 저장하는지 눈여겨 보자. <code>this.props</code>는 리액트가 자체적으로 설정하지만, <code>this.state</code>는 특별한 의미를 갖기 때문에, 자유롭게 부가적인 필드를 추가할 수 있다. 만약 state를 보이지 않게 하려는 경우라면, 클래스에 수동으로 아래와 같은 필드를 추가할 수 있다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">componentWillUnmount() &#123;</div><div class=\"line\">  clearInterval(<span class=\"keyword\">this</span>.timerID);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>마지막으로, 1초마다 실행되는 tick() 메서드를 구현해본다.<br><code>this.setState()</code>를 사용하여 컴포넌트의 local state 값을 업데이트할 수 있다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Clock</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">data</span>: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  componentDidMount() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.timerID = setInterval(</div><div class=\"line\">      () =&gt; <span class=\"keyword\">this</span>. tick(), <span class=\"number\">1000</span></div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  componentWillUnmount() &#123;</div><div class=\"line\">    clearInterval(<span class=\"keyword\">this</span>.timerID);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  tick() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</div><div class=\"line\">      date: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;div&gt;</div><div class=\"line\">        &lt;h1&gt;Hello, world!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">        &lt;h2&gt;It is &#123;<span class=\"keyword\">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class=\"regexp\">/h2&gt;</span></div><div class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  &lt;Clock /&gt;,</div><div class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>);</div><div class=\"line\">);</div></pre></td></tr></table></figure><p>타이머가 완성되었다.</p><p>이제 진행중인 작업과 메서드가 호출되는 순서를 간단히 요약해보자.</p><p><strong>1)</strong> <code>&lt;Clock /&gt;</code>이 <code>ReactDOM.render()</code>에 전달되면 React가 <code>Clock</code> 구성 요소의 생성자를 호출한다. <code>Clock</code>은 현재 시간을 표시해야하므로 <code>this.state</code>를 현재 시간을 포함하는 객체로 초기화한다. 나중에 이 상태를 업데이트 할 것이다.</p><p><strong>2)</strong> 그런 다음 React는 Clock 구성 요소의 <code>render()</code> 메서드를 호출한다. 이 메서드를 통해 React는 화면에 무엇을 표시해야 하는지 알아낸다. 그런 다음 React가 <code>Clock</code>의 렌더링 결과와 일치하도록 DOM을 업데이트한다.</p><p><strong>3)</strong> <code>Clock</code> 출력이 DOM에 삽입되면 React는 <code>componentDidMount()</code> 라이프 사이클 후크를 호출한다. 내부에있는 Clock 컴포넌트는 브라우저에 <code>tick()</code>을 한 번씩 호출하는 타이머를 설정하도록 요청한다.</p><p><strong>4)</strong> 초마다 브라우저에서 <code>tick()</code> 메소드를 호출한다. 그 내부에서 Clock 구성 요소는 현재 시간을 포함하는 객체로 <code>setState()</code>를 호출하여 UI 업데이트를 예약한다. <code>setState()</code> 호출 덕분에 React는 상태가 변경된 것을 알아채고 <code>render()</code> 메서드를 다시 호출하여 화면에 무엇이 있어야 하는지를 파악한다. 이번에는 <code>render()</code> 메서드의 <code>this.state.date</code>가 달라 지므로 렌더 결과에 업데이트 된 시간이 포함된다. React는 그에 따라 DOM을 업데이트한다.</p><p><strong>5)</strong> <code>Clock</code> 컴포넌트가 DOM에서 제거되면 React가 <code>componentWillUnmount()</code> 라이프 사이클 후크를 호출하여 타이머가 중지된다.</p><p><br></p><hr><h3 id=\"What-is-“Mounting”-in-React-js\"><a href=\"#What-is-“Mounting”-in-React-js\" class=\"headerlink\" title=\"What is “Mounting” in React js?\"></a>What is “Mounting” in React js?</h3><p>React에서 작업하는 컴포넌트는 모두 React 노드와 DOM 노드로 나타낼 수 있다. React노드를 DOM노드로 표시하는 방식, 위치, 시기는 최상위 API에서 관리한다. 아래 예제를 통해 좀 더 쉽게 이해해보자.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> foo = React.createElement(FooComponent);</div></pre></td></tr></table></figure><p>foo는 무엇이고 저 객체로 무엇을 할 수 있는가? 지금 이 시점의 foo는 React 타입인 FooComponent의 인스턴스이다. 즉, 현 시점에서는 페이지 그 어디에도 존재하지 않는다. DOM 요소가 아니므로 DOM 트리 어디에도 존재하지 않는 (React 요소 노드를 제외하고) document 상에서 아무런 의미도 없는 객체이다.</p><p>이 상태에서 <code>React.findDOMNode(foo)</code>를 호출하면, falsy object를 반환할 것이다. 이유가 무엇일까? foo는 DOM 트리에 있을 필요가 없다. 따라서 DOM 표현(representation)을 가지고 있지 않다.</p><p>그러나 React 요소 노드를 document에 마운트(mount)하려고하면 DOM 노드를 만드는 컴포넌트 생명주기가 시작된다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">React.render(foo, container);</div></pre></td></tr></table></figure><p>이제 foo는 더이상 React 노드가 아니다. 연관되는 DOM 노드가 있으며 현재 document에 속하게 된다. 이제 실제 DOM 노드에서 어디서든지 foo를 찾을 수 있고 다른 DOM 요소들과 상호작용할 수 있으며, 높이나 너비를 계산하거나 스타일을 적용하거나, jQuery로 전달하는 등 일반적인 DOM 요소처럼 취급할 수 있게 된다.</p><p><br></p><hr><p><strong>Reference</strong></p><p><a href=\"https://facebook.github.io/react/tutorial/tutorial.html#what-is-react\" target=\"_blank\" rel=\"external\">React Document</a></p><p><a href=\"https://velopert.com/867\" target=\"_blank\" rel=\"external\">React Lecture Blog - Korean</a></p><p><a href=\"https://github.com/facebookincubator/create-react-app\" target=\"_blank\" rel=\"external\">create-react-app github</a></p><p><a href=\"https://stackoverflow.com/questions/31556450/what-is-mounting-in-react-js\" target=\"_blank\" rel=\"external\">stack overflow - What is “Mounting” in React js?</a></p>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://cdn-images-1.medium.com/max/2000/1*HSisLuifMO6KbLfPOKtLow.jpeg\" alt=\"\"></p><h2 id=\"1-What-is-React\"><a href=\"#1-What-is-React\" class=\"headerlink\" title=\"1. What is React?\"></a>1. What is React?</h2><p>React는 페이스북에서 개발한 자바스크립트 라이브러리이다. 공식 문서에서는 <strong>사용자 인터페이스(User Interface)를 구축하기위한 선언적(declarative)이고 효율적(efficient)이며 유연한(flexible) JavaScript 라이브러리</strong>라고 설명하고있다. React는 ‘컴포넌트’단위로 재사용 가능한 UI 템플릿을 만든다. 현재 페이스북, 인스타그램, MS 등 대형 서비스에서도 사용되고있는 견고한 라이브러리이다.</p><p>React는 Virtual DOM이라는 개념을 사용하여 상태(state)의 변함(diff)에 따라 선택적으로 UI를 렌더링한다. 따라서 최소한의 DOM 처리로 컴포넌트 업데이트가 가능하다.</p><p><br></p><h2 id=\"2-Virtual-DOM\"><a href=\"#2-Virtual-DOM\" class=\"headerlink\" title=\"2. Virtual DOM\"></a>2. Virtual DOM</h2><h3 id=\"1-DOM\"><a href=\"#1-DOM\" class=\"headerlink\" title=\"1) DOM\"></a>1) DOM</h3><p>DOM(Document Object Model)이란 객체를 통해 구조화된 문서를 표현하는 방법을 말한다. XML또는 HTML로 작성된다. 웹 브라우저는 DOM을 이용해 객체에 자바스크립트와 CSS를 적용한다. DOM은 트리 형태로 되어있으며 특정 노드(node)의 서치(search)와 수정, 제거, 삽입이 가능하다.</p><p>DOM의 문제점은 동적 UI에 최적화되어 있지 않다는 것이다. HTML은 그 자체로 정적인 문서(document)이기 때문이다. 큰 규모의 웹 어플리케이션은 하나의 페이지에도 수 많은 요소들이 생기는데, 이 모든 요소들을 DOM에 직접 접근하여 조작하면서 변화룰 주다보면 속도 저하를 피할 수 없게 된다.</p><p>브라우저 단에서 DOM의 변화가 일어나면 브라우저는 CSS를 다시 연산하고 레이아웃을 새로 구성(=리플로우, reflow )하며 웹 페이지에서 레이아웃에 관계 없는 나머지(색상 변경 등)를 처리(=리페인트, repaint) 하는 데, 이 과정이 DOM에 접근하는 만큼 반복된다. 속도 저하는 바로 이 부분에서 발생한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> style = <span class=\"built_in\">document</span>.body.style; <span class=\"comment\">// 캐싱</span></div><div class=\"line\">style.padding = <span class=\"string\">\"20px\"</span>; <span class=\"comment\">// reflow, repaint</span></div><div class=\"line\">style.border = <span class=\"string\">\"10px solid red\"</span>; <span class=\"comment\">// reflow, repaint</span></div><div class=\"line\"></div><div class=\"line\">style.color = <span class=\"string\">\"blue\"</span>; <span class=\"comment\">// repaint</span></div><div class=\"line\">style.backgroundColor = <span class=\"string\">\"#ffa\"</span>; <span class=\"comment\">// repaint</span></div><div class=\"line\"></div><div class=\"line\">style.fontSize = <span class=\"string\">\"1em\"</span>; <span class=\"comment\">// reflow, repaint</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// reflow, repaint</span></div><div class=\"line\"><span class=\"built_in\">document</span>.body.appendChild(<span class=\"built_in\">document</span>.createTextNode(<span class=\"string\">'hello World'</span>));</div></pre></td></tr></table></figure><p>이렇게 코드가 실행될 때마다 reflow하는 것은 매우 비효율적이며 이에 따른 성능 저하를 우려하지 않을 수 없다. 브라우저는 성능 저하를 단축시키기 위해 짧은 시간 내에 여러 reflow가 발생하려 할 시 이 작업을 미루고 한번에 처리한다. (하지만, <code>offsetTop</code>, <code>scrollTop</code>, <code>getComputedStyle()</code> 등 코드 실행 당시 값을 가져오는 것이 중요한 일부 코드들은 reflow가 여러번 발생할 수 없으므로 브라우저에서 최적화하지 못한다.) 따라서 성능 개선을 위해서는 reflow 횟수를 줄이기 위해 코드를 최적화 해야 한다.</p><h3 id=\"2-Virtual-DOM-1\"><a href=\"#2-Virtual-DOM-1\" class=\"headerlink\" title=\"2) Virtual DOM\"></a>2) Virtual DOM</h3><p>HTML 마크업을 시각적 형태로 변환하는 것은 브라우저의 주 역할이다. 결국 DOM 조작을 아예 하지 않을 수는 없으니, 최소한의 조작만 하여 성능 저하 문제를 해결해보고자 하는 노력이 Virtual DOM을 탄생시켰다.</p><p>Virtual DOM은 언어 그대로 가상 DOM이다. DOM 작업을 가상화(추상화)하여 미리 처리한 다음, 실제 DOM에 한번에 적용하는 방식이다.</p><p>React의 실제 DOM 업데이트는 아래 3단계로 이루어진다.</p><ol><li>데이터가 업데이트되면, 전체 UI를 virtual DOM에 리렌더링한다.</li><li>이전 Virtual DOM에 있던 내용과 현재 내용을 비교한다.</li><li>바뀐 부분만 실제 DOM에 적용한다.</li></ol><p>결국 컴포넌트가 업데이트 될 때, 레이아웃 계산(reflow)이 한번만 이루어지므로 속도 저하 문제를 개선할 수 있게 되는 것이다.</p><p>하지만, Virtual DOM이 모든 경우에서 무조건 더 좋은 퍼포먼스를 내는 것은 아니다. 오히려 단순 라우팅만 있는 정적 웹페이지의 경우 React를 쓰지 않는 편이 더 낫기도 하다. (React는 지속적으로 데이터가 변화하는 대규모 애플리케이션 구축에 적절하다고 공식 매뉴얼에서 밝히고 있다.)</p><p>React와 Virtual DOM이 주는 최고의 편의성은 <strong>간결한 업데이트 처리</strong>이다. UI를 업데이트 하는 과정에서 발생하는 복잡함을 해소해줄 뿐 아니라, 업데이트에 쉽게 접근할 수 있게 해준다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// index.html</span></div><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html lang=<span class=\"string\">\"en\"</span>&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">  &lt;meta charset=<span class=\"string\">\"UTF-8\"</span>&gt;</div><div class=\"line\">  &lt;meta name=<span class=\"string\">\"viewport\"</span> content=<span class=\"string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</div><div class=\"line\">  &lt;meta http-equiv=<span class=\"string\">\"X-UA-Compatible\"</span> content=<span class=\"string\">\"ie=edge\"</span>&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;script src=<span class=\"string\">\"https://unpkg.com/react@latest/dist/react.js\"</span>&gt;&lt;/script&gt;</div><div class=\"line\">  &lt;script src=<span class=\"string\">\"https://unpkg.com/react-dom@latest/dist/react-dom.js\"</span>&gt;&lt;/script&gt;</div><div class=\"line\">  &lt;script src=<span class=\"string\">\"https://unpkg.com/babel-standalone@6.15.0/babel.min.js\"</span>&gt;&lt;/script&gt;</div><div class=\"line\">&lt;<span class=\"regexp\">/head&gt;</span></div><div class=\"line\"><span class=\"regexp\">&lt;body&gt;</span></div><div class=\"line\"><span class=\"regexp\">  &lt;h1&gt;Welcome to React&lt;/</span>h1&gt;</div><div class=\"line\">  &lt;div id=<span class=\"string\">\"react-app\"</span>&gt;&lt;/div&gt;</div><div class=\"line\">  &lt;script type=<span class=\"string\">\"text/babel\"</span>&gt;&lt;/script&gt;</div><div class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BlogPost</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">    render() &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> (</div><div class=\"line\">        &lt;div&gt;</div><div class=\"line\">          This is a blog post</div><div class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></div><div class=\"line\"><span class=\"regexp\">      )</span></div><div class=\"line\"><span class=\"regexp\">    &#125;</span></div><div class=\"line\"><span class=\"regexp\">  &#125;</span></div><div class=\"line\"><span class=\"regexp\"></span></div><div class=\"line\"><span class=\"regexp\">  reactDOM.render(</span></div><div class=\"line\"><span class=\"regexp\">  &lt;BlogPost/</span>&gt;,</div><div class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'react-app'</span>);</div><div class=\"line\">  );</div><div class=\"line\">&lt;<span class=\"regexp\">/body&gt;</span></div><div class=\"line\"><span class=\"regexp\">&lt;/</span>html&gt;</div></pre></td></tr></table></figure><h2 id=\"3-create-react-app\"><a href=\"#3-create-react-app\" class=\"headerlink\" title=\"3. create-react-app\"></a>3. create-react-app</h2><p><a href=\"https://github.com/facebookincubator/create-react-app\" target=\"_blank\" rel=\"external\">create-react-app</a>은 간편하게 React 앱을 만들수 있도록 자동으로 빌드해주는 도구이다. 이 패키지를 이용하면 Webpack이나 Babel을 설치하고 구성하는 복잡한 빌드 과정을 생략할 수 있다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># npm으로 create-react-app 패키지 설치</span></div><div class=\"line\">$ npm install -g create-react-app</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 패키지를 통해 react 프로젝트를 생성</span></div><div class=\"line\">$ create-react-app my-app(프로젝트이름)</div></pre></td></tr></table></figure><p>명령을 통해 my-app 프로젝트 폴더가 생성된다. 폴더 구조는 아래와 같다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">my-app</div><div class=\"line\">├── README.md</div><div class=\"line\">├── node_modules</div><div class=\"line\">├── package.json</div><div class=\"line\">├── .gitignore</div><div class=\"line\">├── public <span class=\"comment\"># 서버 public path</span></div><div class=\"line\">│   └── favicon.ico</div><div class=\"line\">│   └── index.html <span class=\"comment\"># 메인 페이지</span></div><div class=\"line\">│   └── manifest.json</div><div class=\"line\">└── src <span class=\"comment\"># React.js 프로젝트 루트</span></div><div class=\"line\">    └── App.css </div><div class=\"line\">    └── App.js <span class=\"comment\"># App 컴포넌트</span></div><div class=\"line\">    └── App.test.js <span class=\"comment\"># test file</span></div><div class=\"line\">    └── index.css</div><div class=\"line\">    └── index.js <span class=\"comment\"># Webpack Entry point</span></div><div class=\"line\">    └── logo.svg</div><div class=\"line\">    └── registerServiceWorker.js</div></pre></td></tr></table></figure><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 프로젝트 폴더로 이동</span></div><div class=\"line\">$ <span class=\"built_in\">cd</span> my-app</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 이후에는 아래 두 가지 방법 중 택1</span></div><div class=\"line\"><span class=\"comment\"># 1. yarn을 이용하는 방법</span></div><div class=\"line\"></div><div class=\"line\">$ npm install -g yarn <span class=\"comment\"># yarn이 설치되어 있다면 생략 가능</span></div><div class=\"line\"></div><div class=\"line\">$ yarn start</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 2. npm을 이용하는 방법</span></div><div class=\"line\"></div><div class=\"line\">$ npm start</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 위 작업을 마치면 http://localhost:3000 서버로 React 앱을 열 수 있다.</span></div></pre></td></tr></table></figure><p>코드가 수정되면 자동으로 페이지가 로드되며 콘솔창을 통해 빌드 오류 및 lint 경고가 출력된다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 아래 두 명령어 중 택 1로 앱을 번들링하여 배포할 수 있다.</span></div><div class=\"line\"><span class=\"comment\"># 프로덕션용 앱을 build 폴더에 빌드하며 최적의 성능을 위한 최적화(minify)를 진행한다. 빌드가 축소되며 파일이름에 해시가 포함된다. </span></div><div class=\"line\"></div><div class=\"line\">$ yarn build</div><div class=\"line\"></div><div class=\"line\">$ npm run build</div></pre></td></tr></table></figure><p>아래는 자동 생성된 app.js 파일이다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// app.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> logo <span class=\"keyword\">from</span> <span class=\"string\">'./logo.svg'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App.css'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;div className=<span class=\"string\">\"App\"</span>&gt;</div><div class=\"line\">        &lt;div className=<span class=\"string\">\"App-header\"</span>&gt;</div><div class=\"line\">          &lt;img src=&#123;logo&#125; className=<span class=\"string\">\"App-logo\"</span> alt=<span class=\"string\">\"logo\"</span> /&gt;</div><div class=\"line\">          &lt;h2&gt;Welcome to React&lt;<span class=\"regexp\">/h2&gt;</span></div><div class=\"line\"><span class=\"regexp\">        &lt;/</span>div&gt;</div><div class=\"line\">        &lt;p className=<span class=\"string\">\"App-intro\"</span>&gt;</div><div class=\"line\">          To get started, edit &lt;code&gt;src/App.js&lt;<span class=\"regexp\">/code&gt; and save to reload.</span></div><div class=\"line\"><span class=\"regexp\">        &lt;/</span>p&gt;</div><div class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></div><div class=\"line\"><span class=\"regexp\">    );</span></div><div class=\"line\"><span class=\"regexp\">  &#125;</span></div><div class=\"line\"><span class=\"regexp\">&#125;</span></div><div class=\"line\"><span class=\"regexp\"></span></div><div class=\"line\"><span class=\"regexp\">export default App;</span></div></pre></td></tr></table></figure><p><br></p><h2 id=\"4-import-export\"><a href=\"#4-import-export\" class=\"headerlink\" title=\"4. import, export\"></a>4. import, export</h2><p>import는 ES6(ECMA Script 2016)의 문법이다. node의 require()와 동일한 의미이다. 이렇게 모듈을 require하는 방식은 서버단인 node의 방식이다. 클라이언트단에서는 <code>&lt;script&gt;</code>태그를 이용하여 파일을 로드해오는 것이 일반적이다. (require를 지원하지도 않는다.) 하지만 webpack으로 클라이언트에서도 node에서처럼 모듈을 불러올 수 있다. webpack은 import한 모듈을 한 파일로 합치는 번들링(bundling) 작업을 수행하는 모듈 번들러이다. <code>create-react-app</code>의 기본 구성도 webpack이다.</p><p>아래는 <code>create-react-app</code> 패키지의 구성 요소이다.</p><ul><li>webpack with webpack-dev-server, html-webpack-plugin and style-loader</li><li>Babel with ES6 and extensions used by Facebook (JSX, object spread, class properties)</li><li>Autoprefixer</li><li>ESLint</li><li>Jest</li><li>and others.</li></ul><p>기본 문법(syntax)은 <code>import 변수명 from 가져올 모듈의 경로</code>이다. 리액트의 모든 컴포넌트는 필수적으로 react모듈을 import해야 한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// es6</span></div><div class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span> <span class=\"comment\">// (필수)</span></div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App'</span></div><div class=\"line\"><span class=\"comment\">// require와 같은 의미이다.</span></div><div class=\"line\"> <span class=\"comment\">// node</span></div><div class=\"line\"><span class=\"keyword\">var</span> React = <span class=\"built_in\">require</span>(<span class=\"string\">'react'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> App = <span class=\"built_in\">require</span>(<span class=\"string\">'./App'</span>);</div></pre></td></tr></table></figure><p>경로 작성시 주의할 것이 있다면, React는 경로 맨 앞에 <code>./</code>를 붙이지 않으면 <code>node_modules</code>에서 해당 파일을 찾는다는 점이다. 코드에서 <code>&#39;react&#39;</code>는 <code>node_modules</code>에 있는 리액트 모듈을 가리키며, <code>./App.css</code>는 개발자가 직접 정의한 컴포넌트인 App.js를 가리킨다.</p><p>위와 같이 import하기 위해서는 해당 컴포넌트에 export가 필수적으로 정의되어 있어야 한다. export 선언되지 않은 컴포넌트는 import도 할 수 없다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App.css'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render()&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;h1&gt;Hello React&lt;<span class=\"regexp\">/h1&gt;</span></div><div class=\"line\"><span class=\"regexp\">    );</span></div><div class=\"line\"><span class=\"regexp\">  &#125;</span></div><div class=\"line\"><span class=\"regexp\">&#125;</span></div><div class=\"line\"><span class=\"regexp\"></span></div><div class=\"line\"><span class=\"regexp\">export default App;</span></div></pre></td></tr></table></figure><p>default로 export되는 컴포넌트에 한해서 아래와 같이 표현할 수도 있다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App.css'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p><br></p><h2 id=\"5-JSX\"><a href=\"#5-JSX\" class=\"headerlink\" title=\"5. JSX\"></a>5. JSX</h2><p><a href=\"https://www.webpackbin.com/bins/-KeVMcQWGocAn5VJL6XL\" target=\"_blank\" rel=\"external\">webpackbin.com</a>을 통해 간단한 react project를 확인해 볼 수 있다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// HelloWorld.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// stateless Function</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HelloWorld</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    &lt;h1&gt;Hello <span class=\"keyword\">from</span> React!&lt;/h1&gt; <span class=\"comment\">// JSX 문법</span></div><div class=\"line\">  );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> HelloWorld;</div></pre></td></tr></table></figure><p>React는 일반 js문법과는 다른 xml형태의 JSX 문법을 사용한다. JSX는 자바스크립트로 만든 xml로, HTML과 매우 유사한 모양을 하고 있다. 위 예제에서 자바스크립트 코드 내부에 <code>&quot;</code>나 <code>&#39;</code>없이 HTML 코드가 섞여있는 것을 볼 수 있다. 이와 같은 모양을 JSX라고 하며, React는 JSX문법을 사용하여 UI를 템플릿화한다. 이 코드는 webpack의 babel-loader를 통해 자바스크립트 코드로 번들링된다. 위 코드는 아래와 같이 변환된다.</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">return React.createElement(</div><div class=\"line\">  &quot;h1&quot;,</div><div class=\"line\">  null,</div><div class=\"line\">  &quot;Hello from React!&quot;</div><div class=\"line\">);</div></pre></td></tr></table></figure><p><br></p><h2 id=\"6-컴포넌트-로드하기\"><a href=\"#6-컴포넌트-로드하기\" class=\"headerlink\" title=\"6. 컴포넌트 로드하기\"></a>6. 컴포넌트 로드하기</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// main.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123;render&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> Hello <span class=\"keyword\">from</span> <span class=\"string\">'./HelloWorld.js'</span>;</div><div class=\"line\"></div><div class=\"line\">render(&lt;HelloWorld/&gt;, <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#app'</span>));</div></pre></td></tr></table></figure><p>main.js파일은 webpack의 entry 파일(진입점)으로 번들링 작업이 이루어지는 중심 지점이다. HelloWorld.js에서 만든 컴포넌트를 import하고, 기타 import한 파일들을 재귀적으로 불러와 하나의 파일로 합치는 작업을 수행한 후 페이지에 렌더링한다.</p><p>React 컴포넌트를 페이지에 렌더링할 때는 react-dom 모듈을 불러와 render 함수를 통해 처리한다. render 함수의 첫번째 파라미터는 렌더링할 JSX 형태의 코드로, 여기서는 HelloWorld 컴포넌트를 렌더링한다. 컴포넌트를 만들면 <code>&lt;컴포넌트이름 /&gt;</code>의 형태(HTML의 태그처럼)로 작성할 수 있다. 두번째 파라미터는 렌더링할 HTML 요소이다. 위에서는 <code>index.html</code>의 id값이 app인 요소에 렌더링하도록 설정되었다.</p><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- index.html --&gt;</span></div><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>/&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 여기에 렌더링한다. --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"main.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure><p><br></p><h2 id=\"7-컴포넌트에-속성-부여하기\"><a href=\"#7-컴포넌트에-속성-부여하기\" class=\"headerlink\" title=\"7. 컴포넌트에 속성 부여하기\"></a>7. 컴포넌트에 속성 부여하기</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// HelloWorld.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HelloWorld</span> (<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    &lt;h1&gt;Hello &#123;props.name&#125;!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">  );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> HelloWorld;</div></pre></td></tr></table></figure><p>위 코드는 함수 HelloWorld에 props 파라미터를 부여하고 props.name(props의 name 속성) 값을 JSX 안에서 렌더링하게 하였다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// main.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> &#123;render&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> HelloWorld <span class=\"keyword\">from</span> <span class=\"string\">'./HelloWorld.js'</span>;</div><div class=\"line\"></div><div class=\"line\">render(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">HelloWorld</span> <span class=\"attr\">name</span>=<span class=\"string\">\"World\"</span>/&gt;</span>, document.querySelector('#app'));</span></div></pre></td></tr></table></figure><p>main.js에서 렌더링할 때 HelloWorld 컴포넌트에 name 값을 “World”로 설정해주었다. 출력은 아래와 같을 것이다.</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Hello World!</div></pre></td></tr></table></figure><p><br></p><h2 id=\"8-prop-state\"><a href=\"#8-prop-state\" class=\"headerlink\" title=\"8. prop, state\"></a>8. prop, state</h2><h3 id=\"1-Components-and-Props\"><a href=\"#1-Components-and-Props\" class=\"headerlink\" title=\"1) Components and Props\"></a>1) Components and Props</h3><p>컴포넌트를 이용해 UI를 독립적이고 재사용 가능한 부분으로 분리할 수 있으며 분리된 각 부분들을 개별적인 것(isolation)으로 생각할 수 있다. component는 view를 생성하는 자바스크립트 함수이다. 컴포넌트는 props라 불리는 임의의 입력을 받고, (prop는 사전적 의미로 ‘소품’이다.) React 요소를 반환한다. 이 요소는 화면에 무엇이 나타나야 하는지(render)를 설명한다.</p><h3 id=\"2-Props-are-Read-Only\"><a href=\"#2-Props-are-Read-Only\" class=\"headerlink\" title=\"2) Props are Read-Only\"></a>2) Props are Read-Only</h3><p>Prop 값은 읽기만 가능한 값이다. 컴포넌트의 선언 방식(함수 또는 클래스로 선언될 수 있다.)과 관계 없이 컴포넌트의 prop는 직접적인 값의 수정이 절대 불가하다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a + b ;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>위와 같은 함수들은 “pure”하다고 말한다. 입력값을 변경하지 않으며, 동일한 입력에 대해 항상 동일한 결과를 반환하기 때문이다. 위 예제는 a=2, b=3 일 때, 항상 5라는 값을 반환한다. 결과로서 a나 b를 변환하지 않는다. a는 항상 2이며 b도 항상 3이다.</p><p>반면, 아래와 같은 함수는 “impure”하다. 결과값을 반환하면서 input을 스스로 바꿔버리기 때문이다. 이러한 함수는 입력값이 계속 변화함에 따라 결과값도 변화하기 때문에 항상 동일한 결과가 보장되지 않는다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withdraw</span>(<span class=\"params\">accout, amount</span>) </span>&#123;</div><div class=\"line\">  accout.total -= amount;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>리액트는 상당히 유연하지만 엄격한 규칙이 하나 있다.<br><strong>모든 React 컴포넌트는 props에 관해서는 반드시 pure함수처럼 동작해야 한다.</strong></p><p>물론 어플리케이션 UI는 동적이며 시점(시간의 흐름)에 따라 변화한다. state는 React 컴포넌트가 이 규칙을 위반하지 않으면서 (유저의 행동, 네트워크 응답, 그리고 그 외 여러가지 요인들에 대한 응답으로) 변화된 시점에 따라 결과값을 변경할 수 있게 한다.</p><blockquote><p>this.prop는 변경할 수 없고 this.state는 변경이 가능하다. 단 setState로만 바꿀 수 있다. state를 변경하는 방식은 담고 있는 값을 변경하는 것이 아니라, 새로운 값을 담은 새로운 state를 만들어주는 방식이다. 즉, 이전 state와 새로운 state는 완전히 다른 객체이다.</p><p>state의 immutable은 강제되는 부분은 아니지만 (오류가 발생하지 않는다.) 의도한 대로 동작하게 하기 위해서는 immutable을 지켜주어야 한다.</p></blockquote><h3 id=\"3-State-and-Life-Cycle\"><a href=\"#3-State-and-Life-Cycle\" class=\"headerlink\" title=\"3) State and Life-Cycle\"></a>3) State and Life-Cycle</h3><p>지금까지 배운 바에 의하면, 렌더된 출력을 변경하기 위해 <code>ReactDOM.render()</code>를 호출할 수 있다. 아래는 Live 시계를 만드는 컴포넌트이다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tick</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> element = (</div><div class=\"line\">    &lt;div&gt;</div><div class=\"line\">      &lt;h1&gt;Hello, World!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">      &lt;h2&gt;It is &#123;<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().toLocaleTimeString()&#125;.&lt;<span class=\"regexp\">/h2&gt;</span></div><div class=\"line\"><span class=\"regexp\">    &lt;/</span>div&gt;</div><div class=\"line\">  );</div><div class=\"line\">  ReactDOM.render(</div><div class=\"line\">    element,</div><div class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</div><div class=\"line\">  );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">setInterval(tick, <span class=\"number\">1000</span>);</div></pre></td></tr></table></figure><p>위 <code>clock</code> 코드를 캡슐화하고 재사용하기 위해 컴포넌트화 할 수 있다. 먼저 위 함수는 크게 시계가 화면에 보이게 하는 것과 1초마다 시간이 갱신되게 하는 것으로 두 가지 일을 한다. 다음과 같이 분리할 수 있을 것이다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Clock</span>(<span class=\"params\">props</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (</div><div class=\"line\">    &lt;div&gt;</div><div class=\"line\">      &lt;h1&gt;Hello, World!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">      &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;<span class=\"regexp\">/h2&gt;</span></div><div class=\"line\"><span class=\"regexp\">    &lt;/</span>div&gt;</div><div class=\"line\">  )</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tick</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  ReactDOM.render(</div><div class=\"line\">    &lt;Clock data=&#123;<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()&#125; /&gt;,</div><div class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</div><div class=\"line\">  );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">setInterval(tick, <span class=\"number\">1000</span>);</div></pre></td></tr></table></figure><p>사실 이렇게 분리하는 것은 별로 좋은 방법이 아니다. 위 코드에서는 Clock 함수를 매 초마다 불러내 매번 새로 UI를 업데이트한다. 이상적인 것은 Clock을 한번만 작성하는 것이다. 한번만 작성하면 Clock 함수가 스스로 업데이트 하도록 하는 것이 좋다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  &lt;Clock /&gt;,</div><div class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</div><div class=\"line\">);</div></pre></td></tr></table></figure><p>이를 구현하려면 clock 구성 요소에 <code>state</code>를 추가해야 한다. State는 props와 유사하지만 private하며 제어권이 완전히 컴포넌트에 있다. 클래스로 정의된 컴포넌트는 몇 가지 추가 기능을 가지고 있다고 하였다. <strong>로컬(Local) state는 클래스 안에서만 사용할 수 있는 기능이다.</strong></p><h3 id=\"4-Converting-a-Function-to-a-Class\"><a href=\"#4-Converting-a-Function-to-a-Class\" class=\"headerlink\" title=\"4) Converting a Function to a Class\"></a>4) Converting a Function to a Class</h3><p>앞에서 정의한 <code>Clock</code>과 같은 함수형 컴포넌트를 클래스 컴포넌트로 변환할 수 있다. 다음 5단계를 거친다.</p><ol><li>React.Component로부터 extends한 동일한 이름의 ES6 클래스를 만든다.</li><li><code>render()</code> 메서드를 추가한다.</li><li>함수 바디를 <code>render()</code> 메서드 내부로 옮긴다.</li><li><code>render()</code> 내부에 정의된 <code>props</code>를 <code>this.props</code>로 바꾼다.</li><li>나머지 빈 함수 선언문을 지운다.</li></ol><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Clock</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;div&gt;</div><div class=\"line\">        &lt;h1&gt;Hello, world!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">        &lt;h2&gt;It is &#123;<span class=\"keyword\">this</span>.props.date.toLocaleTimeString()&#125;.&lt;<span class=\"regexp\">/h2&gt;</span></div><div class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p><code>Clock</code>함수가 class로 정의되었다. 이제 local state와 lifecycle hooks과 같은 추가 기능을 사용할 수 있다.</p><h3 id=\"5-Adding-Local-State-to-a-Class\"><a href=\"#5-Adding-Local-State-to-a-Class\" class=\"headerlink\" title=\"5) Adding Local State to a Class\"></a>5) Adding Local State to a Class</h3><p>이제 <code>date</code>를 props에서 state로 변환할 차례이다. 아래 3단계를 거친다.</p><p><strong>1.</strong> <code>render()</code>메서드 내부의 <code>this.props.date</code>를 <code>this.state.date</code>로 바꾼다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Clock</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;div&gt;</div><div class=\"line\">        &lt;h1&gt;Hello, world!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">        &lt;h2&gt;It is &#123;<span class=\"keyword\">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class=\"regexp\">/h2&gt;</span></div><div class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p><strong>2.</strong> <code>this.state</code>의 초기값을 할당하는 class constructor(생성자)를 추가한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Clock</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">date</span>: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;div&gt;</div><div class=\"line\">        &lt;h1&gt;Hello, world!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">        &lt;h2&gt;It is &#123;<span class=\"keyword\">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class=\"regexp\">/h2&gt;</span></div><div class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>기본 생성자에 <code>props</code> 값을 전달하는 방법은 아래와 같음을 기억해두자.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">  <span class=\"keyword\">super</span>(props);</div><div class=\"line\">  <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">date</span>: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()&#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>클래스 컴포넌트는 항상 <code>props</code>와 함께 기본 생성자(base constructor)를 호출해야 한다.</p><p><strong>3.</strong> <code>&lt;Clock /&gt;</code>요소에서 <code>date</code> prop를 제거한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  &lt;Clock /&gt;,</div><div class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</div><div class=\"line\">);</div></pre></td></tr></table></figure><p>타이머 코드는 나중에 컴포넌트에 다시 추가할 것이다.<br>지금까지의 결과는 아래와 같다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Clock</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">date</span>: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;div&gt;</div><div class=\"line\">        &lt;h1&gt;Hello, world!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">        &lt;h2&gt;It is &#123;<span class=\"keyword\">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class=\"regexp\">/h2&gt;</span></div><div class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  &lt;Clock /&gt;,</div><div class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</div><div class=\"line\">);</div></pre></td></tr></table></figure><p><br></p><h3 id=\"6-Adding-Lifecycle-Methods-to-a-Class\"><a href=\"#6-Adding-Lifecycle-Methods-to-a-Class\" class=\"headerlink\" title=\"6) Adding Lifecycle Methods to a Class\"></a>6) Adding Lifecycle Methods to a Class</h3><p>위에서는 <code>Clock</code>이 DOM 위에 그려졌다가 사라지는 것을 1초마다 반복한다. <code>Clock</code>이 렌더될 때마다 DOM 위에 타이머를 셋업(set up)하는 것을 리액트에서는 마운팅(Mounting)이라고 한다. 또 DOM 위에서 타이머가 <code>clear</code>될 때마다 <code>Clock</code>을 DOM에서 지우는데, 이를 리액트에서는 unmounting이라고 한다.</p><p>class 컴포넌트에는 마운트 또는 언마운트될 때 특정 코드를 실행하는 메서드가 있다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Clock</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">data</span>: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\">  componentDidMount() &#123;</div><div class=\"line\">    <span class=\"comment\">// 컴포넌트가 마운트 되었다는 의미의 메서드</span></div><div class=\"line\">    <span class=\"comment\">// 컴포넌트가 마운트된 후에 실행된다.</span></div><div class=\"line\"></div><div class=\"line\">  &#125;</div><div class=\"line\">  componentWillMount() &#123;</div><div class=\"line\">    <span class=\"comment\">// 컴포넌트가 마운트 될 것이라는 의미의 메서드</span></div><div class=\"line\">    <span class=\"comment\">// 컴포넌트가 마운트되기 전에 실행된다.</span></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;div&gt;</div><div class=\"line\">        &lt;h1&gt;Hello world!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">        &lt;h2&gt;It is &#123;<span class=\"keyword\">this</span>.state.data.toLocaleTimeString()&#125;.&lt;<span class=\"regexp\">/h2&gt;</span></div><div class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>위와 같은 방법을 ‘lifecycle hooks’라고 한다.</p><p><img src=\"https://cdn-images-1.medium.com/max/800/1*YD6sBv5Ly548pGl042z3DA.jpeg\" alt=\"React Lifecycle in ES6. Inspired by Simon Sturmer\"></p><p>위 그림은 Lifecycle API를 표현한 것이다. 컴포넌트 생성은 <code>constructor</code> -&gt; <code>componentWillMount</code> -&gt; <code>render</code> 순으로 실행되며, <code>componentDidMount</code>가 가장 마지막에 위치하는 것을 확인할 수 있다.</p><p>다시 타이머로 돌아와서, <code>componentDidMount()</code> hook은 컴포넌트 출력이 DOM에 렌더된 이후에 실행된다. 따라서 이 메서드에 타이머를 넣는 것이 좋은 방법일 것 같다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">componentDidMount() &#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.timerID = setInterval(</div><div class=\"line\">    () =&gt; <span class=\"keyword\">this</span>.tick(),</div><div class=\"line\">    <span class=\"number\">1000</span></div><div class=\"line\">  );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>timerID를 어떤 식으로 저장하는지 눈여겨 보자. <code>this.props</code>는 리액트가 자체적으로 설정하지만, <code>this.state</code>는 특별한 의미를 갖기 때문에, 자유롭게 부가적인 필드를 추가할 수 있다. 만약 state를 보이지 않게 하려는 경우라면, 클래스에 수동으로 아래와 같은 필드를 추가할 수 있다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">componentWillUnmount() &#123;</div><div class=\"line\">  clearInterval(<span class=\"keyword\">this</span>.timerID);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>마지막으로, 1초마다 실행되는 tick() 메서드를 구현해본다.<br><code>this.setState()</code>를 사용하여 컴포넌트의 local state 값을 업데이트할 수 있다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Clock</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">data</span>: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()&#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  componentDidMount() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.timerID = setInterval(</div><div class=\"line\">      () =&gt; <span class=\"keyword\">this</span>. tick(), <span class=\"number\">1000</span></div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  componentWillUnmount() &#123;</div><div class=\"line\">    clearInterval(<span class=\"keyword\">this</span>.timerID);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  tick() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</div><div class=\"line\">      date: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;div&gt;</div><div class=\"line\">        &lt;h1&gt;Hello, world!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></div><div class=\"line\">        &lt;h2&gt;It is &#123;<span class=\"keyword\">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class=\"regexp\">/h2&gt;</span></div><div class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">ReactDOM.render(</div><div class=\"line\">  &lt;Clock /&gt;,</div><div class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>);</div><div class=\"line\">);</div></pre></td></tr></table></figure><p>타이머가 완성되었다.</p><p>이제 진행중인 작업과 메서드가 호출되는 순서를 간단히 요약해보자.</p><p><strong>1)</strong> <code>&lt;Clock /&gt;</code>이 <code>ReactDOM.render()</code>에 전달되면 React가 <code>Clock</code> 구성 요소의 생성자를 호출한다. <code>Clock</code>은 현재 시간을 표시해야하므로 <code>this.state</code>를 현재 시간을 포함하는 객체로 초기화한다. 나중에 이 상태를 업데이트 할 것이다.</p><p><strong>2)</strong> 그런 다음 React는 Clock 구성 요소의 <code>render()</code> 메서드를 호출한다. 이 메서드를 통해 React는 화면에 무엇을 표시해야 하는지 알아낸다. 그런 다음 React가 <code>Clock</code>의 렌더링 결과와 일치하도록 DOM을 업데이트한다.</p><p><strong>3)</strong> <code>Clock</code> 출력이 DOM에 삽입되면 React는 <code>componentDidMount()</code> 라이프 사이클 후크를 호출한다. 내부에있는 Clock 컴포넌트는 브라우저에 <code>tick()</code>을 한 번씩 호출하는 타이머를 설정하도록 요청한다.</p><p><strong>4)</strong> 초마다 브라우저에서 <code>tick()</code> 메소드를 호출한다. 그 내부에서 Clock 구성 요소는 현재 시간을 포함하는 객체로 <code>setState()</code>를 호출하여 UI 업데이트를 예약한다. <code>setState()</code> 호출 덕분에 React는 상태가 변경된 것을 알아채고 <code>render()</code> 메서드를 다시 호출하여 화면에 무엇이 있어야 하는지를 파악한다. 이번에는 <code>render()</code> 메서드의 <code>this.state.date</code>가 달라 지므로 렌더 결과에 업데이트 된 시간이 포함된다. React는 그에 따라 DOM을 업데이트한다.</p><p><strong>5)</strong> <code>Clock</code> 컴포넌트가 DOM에서 제거되면 React가 <code>componentWillUnmount()</code> 라이프 사이클 후크를 호출하여 타이머가 중지된다.</p><p><br></p><hr><h3 id=\"What-is-“Mounting”-in-React-js\"><a href=\"#What-is-“Mounting”-in-React-js\" class=\"headerlink\" title=\"What is “Mounting” in React js?\"></a>What is “Mounting” in React js?</h3><p>React에서 작업하는 컴포넌트는 모두 React 노드와 DOM 노드로 나타낼 수 있다. React노드를 DOM노드로 표시하는 방식, 위치, 시기는 최상위 API에서 관리한다. 아래 예제를 통해 좀 더 쉽게 이해해보자.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> foo = React.createElement(FooComponent);</div></pre></td></tr></table></figure><p>foo는 무엇이고 저 객체로 무엇을 할 수 있는가? 지금 이 시점의 foo는 React 타입인 FooComponent의 인스턴스이다. 즉, 현 시점에서는 페이지 그 어디에도 존재하지 않는다. DOM 요소가 아니므로 DOM 트리 어디에도 존재하지 않는 (React 요소 노드를 제외하고) document 상에서 아무런 의미도 없는 객체이다.</p><p>이 상태에서 <code>React.findDOMNode(foo)</code>를 호출하면, falsy object를 반환할 것이다. 이유가 무엇일까? foo는 DOM 트리에 있을 필요가 없다. 따라서 DOM 표현(representation)을 가지고 있지 않다.</p><p>그러나 React 요소 노드를 document에 마운트(mount)하려고하면 DOM 노드를 만드는 컴포넌트 생명주기가 시작된다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">React.render(foo, container);</div></pre></td></tr></table></figure><p>이제 foo는 더이상 React 노드가 아니다. 연관되는 DOM 노드가 있으며 현재 document에 속하게 된다. 이제 실제 DOM 노드에서 어디서든지 foo를 찾을 수 있고 다른 DOM 요소들과 상호작용할 수 있으며, 높이나 너비를 계산하거나 스타일을 적용하거나, jQuery로 전달하는 등 일반적인 DOM 요소처럼 취급할 수 있게 된다.</p><p><br></p><hr><p><strong>Reference</strong></p><p><a href=\"https://facebook.github.io/react/tutorial/tutorial.html#what-is-react\" target=\"_blank\" rel=\"external\">React Document</a></p><p><a href=\"https://velopert.com/867\" target=\"_blank\" rel=\"external\">React Lecture Blog - Korean</a></p><p><a href=\"https://github.com/facebookincubator/create-react-app\" target=\"_blank\" rel=\"external\">create-react-app github</a></p><p><a href=\"https://stackoverflow.com/questions/31556450/what-is-mounting-in-react-js\" target=\"_blank\" rel=\"external\">stack overflow - What is “Mounting” in React js?</a></p>"},{"title":"Semantic-ui-react와 css-module을 같이 사용할 수 없을까?","date":"2017-10-02T07:31:11.000Z","_content":"\n## 삽질의 발단...\n\n[팀 프로젝트](https://github.com/huusz/Da-Da)를 시작하고 채택한 스타일링 방식은 CSS Framework인 semantic-ui-react로 큰 틀을 잡고, CSS로 세부적인 디자인을 하는 것이었다. 지금까지 css 작업을 누군가와 같이 해본 경험이 없었기 때문에, 몇 가지 우려되는 것이 있었다. 각각 다른 css파일에서 중복되는 클래스 네임이 존재하는 상황 같은 것 말이다 (...) 이런 상황을 사전에 방지하고자, className 앞에 파일명(컴포넌트 이름)을 붙이기로 하였다. 근데 ... 너무 귀찮을 것 같았다. 모든 클래스네임을 수동으로 `home-header` `home-header-search` 이런 식으로 지정해 주는, 이런 걸 반복 해야 하다니? \n\n***자동으로 해주는 게 없을까?***\n\n[css를 자동으로 모듈화 해주는 방법](https://velopert.com/3447)에 css-module이라는게 있다는 것을 알게 되었고, webpack에서 `css-loader`에 `module: true` 설정을 추가해주었다.  \n\n<br>\n\n## CSS 프레임워크와는 공존할 수 없다.\n\n`eject`로 webpack config에 직접 설정을 추가하는 방식이었는데, semantic-ui-css가 적용되지 않는 문제가 생겼다.\n\n![semantic이 적용된 원래 화면](https://lh3.googleusercontent.com/-3h309I9VX1w/WdIAFCTzKhI/AAAAAAAAAbU/9HlUNs0Qi6QkdvWJE7MmITLOZajR4jwIwCL0BGAs/w530-d-h305-n-rw/origin.png)\n\n![semantic이 사라진(!) 화면](https://lh3.googleusercontent.com/-WaXNae7NXz4/WdIAKqOlpOI/AAAAAAAAAbs/3t-AA4FnJqYOMFhdZzcF4YjDkhPx9OMSACL0BGAs/w530-d-h306-n-rw/error.png)\n\n<br>\n\n## `module: true` 때문이다.\n\n[How to use css-modules with other global css (discussion please don't merge it)](https://github.com/css-modules/css-modules/pull/65)\n\n웹팩 설정에서 css-loader 설정을 `module:true`로 바꾸면, node-modules에 있는 semantic-ui-css(global css)도 component에 따라 class 이름을 변경하기 때문에 전혀 다른 클래스가 되어버리므로 (ex. `.ui.icon-k1t4h#9`) 결국 semantic-ui-css와의 연결이 끊긴다. 이 때문에 에러는 안 나지만, 전혀 다른 클래스를 적용한 꼴이 되어버리므로 시맨틱 스타일 적용한 것들이 없어져 버린 것..\n\n윗 글에서는 css-loader에 두 가지로 분류해서 로딩하는 방식으로 약간의 꼼수(?)를 사용했다. global로 쓸 css는 (내 경우 semantic-ui-css) 그대로 하되, local 한 모듈들에 쓸 css들은 `app.module.css` 와 같이 명명하여 별도로 처리하게 하는 방식이다.\n\n<br>\n\n## 선택지는..\n\n**1. Semantic-ui를 쓴다.**\n\n1. semantic-ui + pure css를 쓴다. 클래스 네임을 직접. 수동으로. 명명해서 css를 모듈화 한다.\n2. semantic-ui + styled-components를 쓴다. (웹 팩 설정이 필요 없다.)\n3. 위 방법 처럼 꼼수(?)를 써서 css-module + semantic-ui를 쓴다.\n\n**2. Semnatic-ui를 안 쓴다.**\n\n1. 모든 것이 평화롭게 해결된다.\n\n\n사실 semantic-ui를 안 쓰고 싶지만, 당장 4일 내로 정적 페이지 제작이 끝나야 하므로 스타일링에 많은 시간을 쏟을 수 없었다. 프레임워크는 그대로 쓰기로 했다. 그러면 남은 선택지 중에서...\n\n<br>\n\n#### 2. styled-components?\n\nstyled-components는 기존의 css문법과 약간 다르다. react와 css를 섞어 놓은 듯한 문법이라 학습+적응 시간이 필요할 것 같은데, 빠르게 페이지를 만들어야 하는 지금 상황에서 그다지 좋은 선택지는 아닌 것 같다. 게다가 시맨틱도 컴포넌트이고 styled-components도 컴포넌트라서 시맨틱 컴포넌트 내부에 스타일링을 적용해야 하는 경우에는 결국 인라인스타일을 쓰게 된다. 이런게 많아지면, styled-components를 적용하는 의미가 없어지는 것 같았다. 그럴바엔 그냥 전부 inline style로 하면 되는 것 아닌가? 라는 생각이 들었다.\n\n#### 3. css-module + semantic-ui?\n\n어차피 css를 쓸거라면 위 방법을 써서 css-module을 사용하는 것도 좋겠지만, 사실 이것 하나 때문에 `eject`로 웹팩 config 파일 및 script 설정 파일 등등을 풀어헤친다는 게 석연치 않았다. (불안하기도 했고..)\n\n결국 처음 고민하던 시점으로 돌아가, **pure css + css 프레임워크**를 쓰기로 했다.\n\n<br>\n\n----\n\n#### 프로젝트가 끝나가는 시점에서..\n\n위에서도 말했듯, 처음 고민하던 시점으로 돌아가서 **pure css + css 프레임워크**를 쓰려고 하였고 적용해보려는 시도도 했다. 그런데 결국 채택한 방식은 **컴포넌트 인라인 스타일 + pure css + css 프레임워크** 방식이다. styled 컴포넌츠를 약간 (정말 약간) 모방하여 Styled***.js라는 이름으로 인라인 스타일 객체만 모아둔 파일을 각 페이지 폴더 내부에 하나씩 두는 방식으로 하였다. 여기까지 오기까지 나름 치열한(?) 고민을 했기 때문에, 기록해두려고 한다.\n\n### 인라인 스타일 방식을 선택한 이유는,\n\n일단 className을 부여하는 방식으로는 semantic의 기본 스타일을 커스터마이징하는 데 한계가 있었다. semantic ui가 스타일링 하는 방식을 개발자 도구로 열어보면, 아래처럼 클래스 여러개를 중첩하여 선언하는 방식이다.\n\n```css\n/* semantic-ui class(className) */\n.ui.icon.input input\n```\n\n여기다가 직접 커스텀한 className을 부여하여도, \n\n```js\n<Input className = \"foodSearchInput\" ... />\n```\n\n```css\n/* custom class(className) 추가하는 경우 */\n.foodSearchInput {\n  border-radius: 100px; /* 이 코드는 무시된다. */\n}\n\n/* 중첩 선언 방식이 명시도 면에서 더 우위를 가져간다. */\n.ui.icon.input input {\n  border-radius: .28571429rem; /* 이 코드가 적용된다. */\n}\n```\n\n결국 캐스캐이딩(cascading) 우선 순위에서 밀리기 때문에 (명시도 면에서 중첩 선언된 기존의 semantic 방식보다 더 하위가 된다.) 적용되지 않는 경우가 많았다.\n\n***커스텀 css의 캐스캐이딩 우선 순위가 semantic-ui 프레임워크보다 항상 우위에 있도록 할 수 있는 방법은 없을까?***\n\n일단 [cascading의 명시도](http://poiemaweb.com/css3-inheritance-cascading) 면에서 `!important > 인라인 스타일 > 아이디 선택자 > 클래스/어트리뷰트/가상 선택자 > 태그 선택자 > 전체 선택자 > 상위 요소에 의해 상속된 속성` 순으로 우선 순위에서 우위를 가져간다. 여기서, [`!important`를 사용하는 방법은 최대한 배제](https://speckyboy.com/good-bad-css-practices/)하기로 하였다. 그러면 남은 것은 인라인 스타일과 아이디 선택자를 사용하는 방법이 남는다.\n\n<br>\n\n#### 아이디 선택자 (X)\n\n* id 선택자는 단 하나의 요소에만 부여할 수 있는 고유한 것이다.\n* 따라서 코드의 재사용이 불가함은 물론이고, 유사 스타일에 대한 확장 가능성이 전혀 없기 때문에 인라인 스타일에 비해 비효율적이다.\n* 프로젝트 내에서 예를 들면, 검색창과 같은 경우, 유사한 스타일 코드를 다른 페이지의 input 요소들과 공유하게 되는데, id선택자를 이용하면 같은 스타일을 여러번 반복해서 선언해주어야 한다.\n\n```css\n/* 아이디 선택자를 사용할 경우 같은 혹은 유사 스타일 일지라도 반복해서 선언해주어야 한다. */\n#searchInput{\n  width: 400px;\n  margin: 20px 10px;\n  border-radius: 100px;\n  position: absolute;\n  left:300px;\n}\n\n#searchResultInput{\n  width: 800px;\n  margin: 20px 10px;\n  border-radius: 100px;\n  position: absolute;\n  left: 100px;\n  top: 400px;\n}\n```\n\n```js\n// 인라인 스타일의 경우 spread 문법을 이용한 스타일의 확장이 가능하다.\nexport const searchInput {\n  width: '400',\n  margin: '20 10',\n  borderRadius: '100',\n  position: 'absolute',\n  left: '300',\n}\n\nexport const searchResultInput {\n  ...searchInput,\n  width: '800',\n  left: '300',\n  top: '400'\n}\n```\n\n\n<br>\n\n#### 인라인 스타일 (O)\n\n인라인 스타일은 캐스캐이딩에서 `!important`를 제외하고 두 번째 우선순위를 갖는다. 따라서 중첩된 클래스보다 항상 우위에 있을 것이고, 위 예제처럼 아이디 선택자에 비해 재사용 및 확장이 용이하기 때문에 효율적이고 문제가 없을 것이라 생각했다. 그런데 여기에도 문제가 있었다.\n\n대부분의 컴포넌트가 `div`로 실제 시맨틱 태그를 감싸고 있어 인라인 스타일을 주어도 적용되지 않는 경우가 많았다. 예를 들어 `Input`이나 `Search` 컴포넌트의 경우, `<input>` 태그를 `<div></div>`가 감싸고 있다.\n\n```js\n<div>\n  <input type=\"text\"/>\n</div>\n```\n\n이런 식이라 인라인으로 스타일을 부여하면 `<input>`이 아니라 가장 바깥의 `<div>`로 스타일 코드가 적용되었다.\n\n```js\n<div style=\"border: 1px solid blue;\">\n  <input type=\"text\"/>\n</div>\n```\n\n따라서 상속이 되는 css 속성에 한해서만 (ex. font/color/text-align 등 비교적 레이아웃과 관련되지 않는 속성들) 적용이 되었고, 정작 필요한 `border` 속성이나 `margin`, `padding`, `position`과 같은 속성은 적용할 수 없었다.\n\n즉, 인라인 스타일이나 className 중 하나만 선택하는 방식으로는 발생하는 모든 문제를 해결할 수 없었다. 그래서, **그나마 문제가 거의 발생하지 않는 인라인 스타일을 주 스타일링 방식으로 채택하였다.** 그리고 인라인으로 해결되지 않는 **몇몇 문제들에 한해서만, semantic ui에서 정의한 클래스의 css를 아래와 같이 커스텀 css에서 재정의해주는 방식을 채택하였다.**\n\n```css\n/* search.css(custom css) */\n.ui.icon.input input{\n  border-radius: 100px /* 이 코드가 적용된다. */\n}\n\n/* semantic.min.css */\n.ui.icon.input input {\n  padding-right: 2.67142857em!important;\n  /* ... */\n  border-radius: .28571429rem /* 이 코드는 무시된다. */\n}\n```\n\n사실 Object 형태의 인라인 스타일 방식을 주 스타일링 방식으로 채택하게 되기까지 [React.js + CSS](https://blog.coderifleman.com/2015/07/12/learning-react-7/)라는 글이 꽤나 큰 동기 부여가 되기도 하였다. styled-components의 존재를 알게 된 시점부터 css-in-js 라는 스타일링 방식이 어떤 이유로 나오게 되었으며, 어떤 이점을 갖는 지에 대해 궁금했었고, 윗 글이 어느 정도 대답이 되었기 때문이다.\n\n이 방식을 채택함으로써 가장 큰 수혜(?)를 받은 부분이 Navigation 컴포넌트였다. 프로젝트의 디자인 시안 상으로, 페이지 상단 네비게이션(메뉴)바의 폰트와 보더(border) 색상을 적용함에 있어 두 가지 케이스가 있었다.\n\n* 흰 배경인 경우: `#16325c`\n* 사진이나 동영상이 배경인 경우: `#fff`\n\n```js\n// components/Navigation/index.js\n\n// default Props: 컬러 반전이 없는 일반 페이지의 default color\n// props를 전달하지 않는 경우 color: '#16325c'\nNavigation.defaultProps = {\n  color: '#16325c'\n}\n```\n\n디자인 상 대부분의 화면이 흰 배경이므로, 이를 기본으로 설정하기 위해 위와 같이 `defaultProps`로 `color` 스타일을 지정하였다. 그리고 아래처럼 특정 조건에 따라 `color`와 `borderColor`를 다르게 적용하도록 하였다.\n\n```js\n// pages/HomePage/index.js\n<Navigation color=\"#fff\" />\n```\n\n```js\n// components/Navigation/RightMenu/index.js\n\n<Menu.Item\n    style={\n      // active일때만 border-color 적용\n      isLinkMatched ?\n      {\n       ...linkTagWrap, // linkTagWrap은 아래 참고\n        borderColor: this.props.color, //#fff\n      } : {\n        linkTagWrap\n      }\n    active={isLinkMatched}\n>\n  <Link\n    style={{\n      ..linkTag,\n      color: this.props.color, // #fff\n    }}\n    to={route.linkTo}\n  >\n  {route.linkLabel}\n  </Link>\n</Menu.Item>\n```\n\n```js\n// components/Navigation/StyledNavigation.js\nexport const linkTagWrap = {\n  padding: '7px',\n  marginLeft: '37px',\n  marginBottom: '6px',\n}\n```\n\n이렇게 css를 변수(또는 props)로 직접 이식하는 부분이 굉장히 매력적이었다. 그리고 이런 방식은 굳이 css-in-js방식의 라이브러리를 사용하지 않아도 가능하였고, 이보다 더 복잡하고 많은 스타일링이 필요할만큼 앱이 거대하지도 않았다. 어찌됐든, 이러한 고민들을 거쳐 최종적으로 인라인 스타일 + css 방식을 사용하였다.\n\n언젠간 css와 js 스타일링 방식의 차이에 대해서 나름대로 정리한 내용을 기록하려고 한다. (언제가 될지는 모르겠다..) [css-in-js 방식을 차용한 스타일링 라이브러리들](https://www.ludovf.net/blog/comparing-css-in-js-solutions/)을 찾아보면서 Aphrodite, CSS in JS, Emotion.js 등등 다양한 라이브러리들을 알게 되었는데, 개인적으로 Emotion.js나 Styled-components를 꼭 한번 사용해보고 싶다.\n\n<br>\n","source":"_posts/Log/01.dada-log-01.md","raw":"---\ntitle: 'Semantic-ui-react와 css-module을 같이 사용할 수 없을까?'\ndate: 2017-10-02 16:31:11\ncategory: Log\ntags: semantic-ui-react\n---\n\n## 삽질의 발단...\n\n[팀 프로젝트](https://github.com/huusz/Da-Da)를 시작하고 채택한 스타일링 방식은 CSS Framework인 semantic-ui-react로 큰 틀을 잡고, CSS로 세부적인 디자인을 하는 것이었다. 지금까지 css 작업을 누군가와 같이 해본 경험이 없었기 때문에, 몇 가지 우려되는 것이 있었다. 각각 다른 css파일에서 중복되는 클래스 네임이 존재하는 상황 같은 것 말이다 (...) 이런 상황을 사전에 방지하고자, className 앞에 파일명(컴포넌트 이름)을 붙이기로 하였다. 근데 ... 너무 귀찮을 것 같았다. 모든 클래스네임을 수동으로 `home-header` `home-header-search` 이런 식으로 지정해 주는, 이런 걸 반복 해야 하다니? \n\n***자동으로 해주는 게 없을까?***\n\n[css를 자동으로 모듈화 해주는 방법](https://velopert.com/3447)에 css-module이라는게 있다는 것을 알게 되었고, webpack에서 `css-loader`에 `module: true` 설정을 추가해주었다.  \n\n<br>\n\n## CSS 프레임워크와는 공존할 수 없다.\n\n`eject`로 webpack config에 직접 설정을 추가하는 방식이었는데, semantic-ui-css가 적용되지 않는 문제가 생겼다.\n\n![semantic이 적용된 원래 화면](https://lh3.googleusercontent.com/-3h309I9VX1w/WdIAFCTzKhI/AAAAAAAAAbU/9HlUNs0Qi6QkdvWJE7MmITLOZajR4jwIwCL0BGAs/w530-d-h305-n-rw/origin.png)\n\n![semantic이 사라진(!) 화면](https://lh3.googleusercontent.com/-WaXNae7NXz4/WdIAKqOlpOI/AAAAAAAAAbs/3t-AA4FnJqYOMFhdZzcF4YjDkhPx9OMSACL0BGAs/w530-d-h306-n-rw/error.png)\n\n<br>\n\n## `module: true` 때문이다.\n\n[How to use css-modules with other global css (discussion please don't merge it)](https://github.com/css-modules/css-modules/pull/65)\n\n웹팩 설정에서 css-loader 설정을 `module:true`로 바꾸면, node-modules에 있는 semantic-ui-css(global css)도 component에 따라 class 이름을 변경하기 때문에 전혀 다른 클래스가 되어버리므로 (ex. `.ui.icon-k1t4h#9`) 결국 semantic-ui-css와의 연결이 끊긴다. 이 때문에 에러는 안 나지만, 전혀 다른 클래스를 적용한 꼴이 되어버리므로 시맨틱 스타일 적용한 것들이 없어져 버린 것..\n\n윗 글에서는 css-loader에 두 가지로 분류해서 로딩하는 방식으로 약간의 꼼수(?)를 사용했다. global로 쓸 css는 (내 경우 semantic-ui-css) 그대로 하되, local 한 모듈들에 쓸 css들은 `app.module.css` 와 같이 명명하여 별도로 처리하게 하는 방식이다.\n\n<br>\n\n## 선택지는..\n\n**1. Semantic-ui를 쓴다.**\n\n1. semantic-ui + pure css를 쓴다. 클래스 네임을 직접. 수동으로. 명명해서 css를 모듈화 한다.\n2. semantic-ui + styled-components를 쓴다. (웹 팩 설정이 필요 없다.)\n3. 위 방법 처럼 꼼수(?)를 써서 css-module + semantic-ui를 쓴다.\n\n**2. Semnatic-ui를 안 쓴다.**\n\n1. 모든 것이 평화롭게 해결된다.\n\n\n사실 semantic-ui를 안 쓰고 싶지만, 당장 4일 내로 정적 페이지 제작이 끝나야 하므로 스타일링에 많은 시간을 쏟을 수 없었다. 프레임워크는 그대로 쓰기로 했다. 그러면 남은 선택지 중에서...\n\n<br>\n\n#### 2. styled-components?\n\nstyled-components는 기존의 css문법과 약간 다르다. react와 css를 섞어 놓은 듯한 문법이라 학습+적응 시간이 필요할 것 같은데, 빠르게 페이지를 만들어야 하는 지금 상황에서 그다지 좋은 선택지는 아닌 것 같다. 게다가 시맨틱도 컴포넌트이고 styled-components도 컴포넌트라서 시맨틱 컴포넌트 내부에 스타일링을 적용해야 하는 경우에는 결국 인라인스타일을 쓰게 된다. 이런게 많아지면, styled-components를 적용하는 의미가 없어지는 것 같았다. 그럴바엔 그냥 전부 inline style로 하면 되는 것 아닌가? 라는 생각이 들었다.\n\n#### 3. css-module + semantic-ui?\n\n어차피 css를 쓸거라면 위 방법을 써서 css-module을 사용하는 것도 좋겠지만, 사실 이것 하나 때문에 `eject`로 웹팩 config 파일 및 script 설정 파일 등등을 풀어헤친다는 게 석연치 않았다. (불안하기도 했고..)\n\n결국 처음 고민하던 시점으로 돌아가, **pure css + css 프레임워크**를 쓰기로 했다.\n\n<br>\n\n----\n\n#### 프로젝트가 끝나가는 시점에서..\n\n위에서도 말했듯, 처음 고민하던 시점으로 돌아가서 **pure css + css 프레임워크**를 쓰려고 하였고 적용해보려는 시도도 했다. 그런데 결국 채택한 방식은 **컴포넌트 인라인 스타일 + pure css + css 프레임워크** 방식이다. styled 컴포넌츠를 약간 (정말 약간) 모방하여 Styled***.js라는 이름으로 인라인 스타일 객체만 모아둔 파일을 각 페이지 폴더 내부에 하나씩 두는 방식으로 하였다. 여기까지 오기까지 나름 치열한(?) 고민을 했기 때문에, 기록해두려고 한다.\n\n### 인라인 스타일 방식을 선택한 이유는,\n\n일단 className을 부여하는 방식으로는 semantic의 기본 스타일을 커스터마이징하는 데 한계가 있었다. semantic ui가 스타일링 하는 방식을 개발자 도구로 열어보면, 아래처럼 클래스 여러개를 중첩하여 선언하는 방식이다.\n\n```css\n/* semantic-ui class(className) */\n.ui.icon.input input\n```\n\n여기다가 직접 커스텀한 className을 부여하여도, \n\n```js\n<Input className = \"foodSearchInput\" ... />\n```\n\n```css\n/* custom class(className) 추가하는 경우 */\n.foodSearchInput {\n  border-radius: 100px; /* 이 코드는 무시된다. */\n}\n\n/* 중첩 선언 방식이 명시도 면에서 더 우위를 가져간다. */\n.ui.icon.input input {\n  border-radius: .28571429rem; /* 이 코드가 적용된다. */\n}\n```\n\n결국 캐스캐이딩(cascading) 우선 순위에서 밀리기 때문에 (명시도 면에서 중첩 선언된 기존의 semantic 방식보다 더 하위가 된다.) 적용되지 않는 경우가 많았다.\n\n***커스텀 css의 캐스캐이딩 우선 순위가 semantic-ui 프레임워크보다 항상 우위에 있도록 할 수 있는 방법은 없을까?***\n\n일단 [cascading의 명시도](http://poiemaweb.com/css3-inheritance-cascading) 면에서 `!important > 인라인 스타일 > 아이디 선택자 > 클래스/어트리뷰트/가상 선택자 > 태그 선택자 > 전체 선택자 > 상위 요소에 의해 상속된 속성` 순으로 우선 순위에서 우위를 가져간다. 여기서, [`!important`를 사용하는 방법은 최대한 배제](https://speckyboy.com/good-bad-css-practices/)하기로 하였다. 그러면 남은 것은 인라인 스타일과 아이디 선택자를 사용하는 방법이 남는다.\n\n<br>\n\n#### 아이디 선택자 (X)\n\n* id 선택자는 단 하나의 요소에만 부여할 수 있는 고유한 것이다.\n* 따라서 코드의 재사용이 불가함은 물론이고, 유사 스타일에 대한 확장 가능성이 전혀 없기 때문에 인라인 스타일에 비해 비효율적이다.\n* 프로젝트 내에서 예를 들면, 검색창과 같은 경우, 유사한 스타일 코드를 다른 페이지의 input 요소들과 공유하게 되는데, id선택자를 이용하면 같은 스타일을 여러번 반복해서 선언해주어야 한다.\n\n```css\n/* 아이디 선택자를 사용할 경우 같은 혹은 유사 스타일 일지라도 반복해서 선언해주어야 한다. */\n#searchInput{\n  width: 400px;\n  margin: 20px 10px;\n  border-radius: 100px;\n  position: absolute;\n  left:300px;\n}\n\n#searchResultInput{\n  width: 800px;\n  margin: 20px 10px;\n  border-radius: 100px;\n  position: absolute;\n  left: 100px;\n  top: 400px;\n}\n```\n\n```js\n// 인라인 스타일의 경우 spread 문법을 이용한 스타일의 확장이 가능하다.\nexport const searchInput {\n  width: '400',\n  margin: '20 10',\n  borderRadius: '100',\n  position: 'absolute',\n  left: '300',\n}\n\nexport const searchResultInput {\n  ...searchInput,\n  width: '800',\n  left: '300',\n  top: '400'\n}\n```\n\n\n<br>\n\n#### 인라인 스타일 (O)\n\n인라인 스타일은 캐스캐이딩에서 `!important`를 제외하고 두 번째 우선순위를 갖는다. 따라서 중첩된 클래스보다 항상 우위에 있을 것이고, 위 예제처럼 아이디 선택자에 비해 재사용 및 확장이 용이하기 때문에 효율적이고 문제가 없을 것이라 생각했다. 그런데 여기에도 문제가 있었다.\n\n대부분의 컴포넌트가 `div`로 실제 시맨틱 태그를 감싸고 있어 인라인 스타일을 주어도 적용되지 않는 경우가 많았다. 예를 들어 `Input`이나 `Search` 컴포넌트의 경우, `<input>` 태그를 `<div></div>`가 감싸고 있다.\n\n```js\n<div>\n  <input type=\"text\"/>\n</div>\n```\n\n이런 식이라 인라인으로 스타일을 부여하면 `<input>`이 아니라 가장 바깥의 `<div>`로 스타일 코드가 적용되었다.\n\n```js\n<div style=\"border: 1px solid blue;\">\n  <input type=\"text\"/>\n</div>\n```\n\n따라서 상속이 되는 css 속성에 한해서만 (ex. font/color/text-align 등 비교적 레이아웃과 관련되지 않는 속성들) 적용이 되었고, 정작 필요한 `border` 속성이나 `margin`, `padding`, `position`과 같은 속성은 적용할 수 없었다.\n\n즉, 인라인 스타일이나 className 중 하나만 선택하는 방식으로는 발생하는 모든 문제를 해결할 수 없었다. 그래서, **그나마 문제가 거의 발생하지 않는 인라인 스타일을 주 스타일링 방식으로 채택하였다.** 그리고 인라인으로 해결되지 않는 **몇몇 문제들에 한해서만, semantic ui에서 정의한 클래스의 css를 아래와 같이 커스텀 css에서 재정의해주는 방식을 채택하였다.**\n\n```css\n/* search.css(custom css) */\n.ui.icon.input input{\n  border-radius: 100px /* 이 코드가 적용된다. */\n}\n\n/* semantic.min.css */\n.ui.icon.input input {\n  padding-right: 2.67142857em!important;\n  /* ... */\n  border-radius: .28571429rem /* 이 코드는 무시된다. */\n}\n```\n\n사실 Object 형태의 인라인 스타일 방식을 주 스타일링 방식으로 채택하게 되기까지 [React.js + CSS](https://blog.coderifleman.com/2015/07/12/learning-react-7/)라는 글이 꽤나 큰 동기 부여가 되기도 하였다. styled-components의 존재를 알게 된 시점부터 css-in-js 라는 스타일링 방식이 어떤 이유로 나오게 되었으며, 어떤 이점을 갖는 지에 대해 궁금했었고, 윗 글이 어느 정도 대답이 되었기 때문이다.\n\n이 방식을 채택함으로써 가장 큰 수혜(?)를 받은 부분이 Navigation 컴포넌트였다. 프로젝트의 디자인 시안 상으로, 페이지 상단 네비게이션(메뉴)바의 폰트와 보더(border) 색상을 적용함에 있어 두 가지 케이스가 있었다.\n\n* 흰 배경인 경우: `#16325c`\n* 사진이나 동영상이 배경인 경우: `#fff`\n\n```js\n// components/Navigation/index.js\n\n// default Props: 컬러 반전이 없는 일반 페이지의 default color\n// props를 전달하지 않는 경우 color: '#16325c'\nNavigation.defaultProps = {\n  color: '#16325c'\n}\n```\n\n디자인 상 대부분의 화면이 흰 배경이므로, 이를 기본으로 설정하기 위해 위와 같이 `defaultProps`로 `color` 스타일을 지정하였다. 그리고 아래처럼 특정 조건에 따라 `color`와 `borderColor`를 다르게 적용하도록 하였다.\n\n```js\n// pages/HomePage/index.js\n<Navigation color=\"#fff\" />\n```\n\n```js\n// components/Navigation/RightMenu/index.js\n\n<Menu.Item\n    style={\n      // active일때만 border-color 적용\n      isLinkMatched ?\n      {\n       ...linkTagWrap, // linkTagWrap은 아래 참고\n        borderColor: this.props.color, //#fff\n      } : {\n        linkTagWrap\n      }\n    active={isLinkMatched}\n>\n  <Link\n    style={{\n      ..linkTag,\n      color: this.props.color, // #fff\n    }}\n    to={route.linkTo}\n  >\n  {route.linkLabel}\n  </Link>\n</Menu.Item>\n```\n\n```js\n// components/Navigation/StyledNavigation.js\nexport const linkTagWrap = {\n  padding: '7px',\n  marginLeft: '37px',\n  marginBottom: '6px',\n}\n```\n\n이렇게 css를 변수(또는 props)로 직접 이식하는 부분이 굉장히 매력적이었다. 그리고 이런 방식은 굳이 css-in-js방식의 라이브러리를 사용하지 않아도 가능하였고, 이보다 더 복잡하고 많은 스타일링이 필요할만큼 앱이 거대하지도 않았다. 어찌됐든, 이러한 고민들을 거쳐 최종적으로 인라인 스타일 + css 방식을 사용하였다.\n\n언젠간 css와 js 스타일링 방식의 차이에 대해서 나름대로 정리한 내용을 기록하려고 한다. (언제가 될지는 모르겠다..) [css-in-js 방식을 차용한 스타일링 라이브러리들](https://www.ludovf.net/blog/comparing-css-in-js-solutions/)을 찾아보면서 Aphrodite, CSS in JS, Emotion.js 등등 다양한 라이브러리들을 알게 되었는데, 개인적으로 Emotion.js나 Styled-components를 꼭 한번 사용해보고 싶다.\n\n<br>\n","slug":"Log/01.dada-log-01","published":1,"updated":"2017-11-16T16:13:11.788Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjai8h17t0009vb9q54ztmnqq","content":"<h2 id=\"삽질의-발단…\"><a href=\"#삽질의-발단…\" class=\"headerlink\" title=\"삽질의 발단…\"></a>삽질의 발단…</h2><p><a href=\"https://github.com/huusz/Da-Da\" target=\"_blank\" rel=\"external\">팀 프로젝트</a>를 시작하고 채택한 스타일링 방식은 CSS Framework인 semantic-ui-react로 큰 틀을 잡고, CSS로 세부적인 디자인을 하는 것이었다. 지금까지 css 작업을 누군가와 같이 해본 경험이 없었기 때문에, 몇 가지 우려되는 것이 있었다. 각각 다른 css파일에서 중복되는 클래스 네임이 존재하는 상황 같은 것 말이다 (…) 이런 상황을 사전에 방지하고자, className 앞에 파일명(컴포넌트 이름)을 붙이기로 하였다. 근데 … 너무 귀찮을 것 같았다. 모든 클래스네임을 수동으로 <code>home-header</code> <code>home-header-search</code> 이런 식으로 지정해 주는, 이런 걸 반복 해야 하다니?</p><p><strong><em>자동으로 해주는 게 없을까?</em></strong></p><p><a href=\"https://velopert.com/3447\" target=\"_blank\" rel=\"external\">css를 자동으로 모듈화 해주는 방법</a>에 css-module이라는게 있다는 것을 알게 되었고, webpack에서 <code>css-loader</code>에 <code>module: true</code> 설정을 추가해주었다.</p><p><br></p><h2 id=\"CSS-프레임워크와는-공존할-수-없다\"><a href=\"#CSS-프레임워크와는-공존할-수-없다\" class=\"headerlink\" title=\"CSS 프레임워크와는 공존할 수 없다.\"></a>CSS 프레임워크와는 공존할 수 없다.</h2><p><code>eject</code>로 webpack config에 직접 설정을 추가하는 방식이었는데, semantic-ui-css가 적용되지 않는 문제가 생겼다.</p><p><img src=\"https://lh3.googleusercontent.com/-3h309I9VX1w/WdIAFCTzKhI/AAAAAAAAAbU/9HlUNs0Qi6QkdvWJE7MmITLOZajR4jwIwCL0BGAs/w530-d-h305-n-rw/origin.png\" alt=\"semantic이 적용된 원래 화면\"></p><p><img src=\"https://lh3.googleusercontent.com/-WaXNae7NXz4/WdIAKqOlpOI/AAAAAAAAAbs/3t-AA4FnJqYOMFhdZzcF4YjDkhPx9OMSACL0BGAs/w530-d-h306-n-rw/error.png\" alt=\"semantic이 사라진(!) 화면\"></p><p><br></p><h2 id=\"module-true-때문이다\"><a href=\"#module-true-때문이다\" class=\"headerlink\" title=\"module: true 때문이다.\"></a><code>module: true</code> 때문이다.</h2><p><a href=\"https://github.com/css-modules/css-modules/pull/65\" target=\"_blank\" rel=\"external\">How to use css-modules with other global css (discussion please don’t merge it)</a></p><p>웹팩 설정에서 css-loader 설정을 <code>module:true</code>로 바꾸면, node-modules에 있는 semantic-ui-css(global css)도 component에 따라 class 이름을 변경하기 때문에 전혀 다른 클래스가 되어버리므로 (ex. <code>.ui.icon-k1t4h#9</code>) 결국 semantic-ui-css와의 연결이 끊긴다. 이 때문에 에러는 안 나지만, 전혀 다른 클래스를 적용한 꼴이 되어버리므로 시맨틱 스타일 적용한 것들이 없어져 버린 것..</p><p>윗 글에서는 css-loader에 두 가지로 분류해서 로딩하는 방식으로 약간의 꼼수(?)를 사용했다. global로 쓸 css는 (내 경우 semantic-ui-css) 그대로 하되, local 한 모듈들에 쓸 css들은 <code>app.module.css</code> 와 같이 명명하여 별도로 처리하게 하는 방식이다.</p><p><br></p><h2 id=\"선택지는\"><a href=\"#선택지는\" class=\"headerlink\" title=\"선택지는..\"></a>선택지는..</h2><p><strong>1. Semantic-ui를 쓴다.</strong></p><ol><li>semantic-ui + pure css를 쓴다. 클래스 네임을 직접. 수동으로. 명명해서 css를 모듈화 한다.</li><li>semantic-ui + styled-components를 쓴다. (웹 팩 설정이 필요 없다.)</li><li>위 방법 처럼 꼼수(?)를 써서 css-module + semantic-ui를 쓴다.</li></ol><p><strong>2. Semnatic-ui를 안 쓴다.</strong></p><ol><li>모든 것이 평화롭게 해결된다.</li></ol><p>사실 semantic-ui를 안 쓰고 싶지만, 당장 4일 내로 정적 페이지 제작이 끝나야 하므로 스타일링에 많은 시간을 쏟을 수 없었다. 프레임워크는 그대로 쓰기로 했다. 그러면 남은 선택지 중에서…</p><p><br></p><h4 id=\"2-styled-components\"><a href=\"#2-styled-components\" class=\"headerlink\" title=\"2. styled-components?\"></a>2. styled-components?</h4><p>styled-components는 기존의 css문법과 약간 다르다. react와 css를 섞어 놓은 듯한 문법이라 학습+적응 시간이 필요할 것 같은데, 빠르게 페이지를 만들어야 하는 지금 상황에서 그다지 좋은 선택지는 아닌 것 같다. 게다가 시맨틱도 컴포넌트이고 styled-components도 컴포넌트라서 시맨틱 컴포넌트 내부에 스타일링을 적용해야 하는 경우에는 결국 인라인스타일을 쓰게 된다. 이런게 많아지면, styled-components를 적용하는 의미가 없어지는 것 같았다. 그럴바엔 그냥 전부 inline style로 하면 되는 것 아닌가? 라는 생각이 들었다.</p><h4 id=\"3-css-module-semantic-ui\"><a href=\"#3-css-module-semantic-ui\" class=\"headerlink\" title=\"3. css-module + semantic-ui?\"></a>3. css-module + semantic-ui?</h4><p>어차피 css를 쓸거라면 위 방법을 써서 css-module을 사용하는 것도 좋겠지만, 사실 이것 하나 때문에 <code>eject</code>로 웹팩 config 파일 및 script 설정 파일 등등을 풀어헤친다는 게 석연치 않았다. (불안하기도 했고..)</p><p>결국 처음 고민하던 시점으로 돌아가, <strong>pure css + css 프레임워크</strong>를 쓰기로 했다.</p><p><br></p><hr><h4 id=\"프로젝트가-끝나가는-시점에서\"><a href=\"#프로젝트가-끝나가는-시점에서\" class=\"headerlink\" title=\"프로젝트가 끝나가는 시점에서..\"></a>프로젝트가 끝나가는 시점에서..</h4><p>위에서도 말했듯, 처음 고민하던 시점으로 돌아가서 <strong>pure css + css 프레임워크</strong>를 쓰려고 하였고 적용해보려는 시도도 했다. 그런데 결국 채택한 방식은 <strong>컴포넌트 인라인 스타일 + pure css + css 프레임워크</strong> 방식이다. styled 컴포넌츠를 약간 (정말 약간) 모방하여 Styled<em>*</em>.js라는 이름으로 인라인 스타일 객체만 모아둔 파일을 각 페이지 폴더 내부에 하나씩 두는 방식으로 하였다. 여기까지 오기까지 나름 치열한(?) 고민을 했기 때문에, 기록해두려고 한다.</p><h3 id=\"인라인-스타일-방식을-선택한-이유는\"><a href=\"#인라인-스타일-방식을-선택한-이유는\" class=\"headerlink\" title=\"인라인 스타일 방식을 선택한 이유는,\"></a>인라인 스타일 방식을 선택한 이유는,</h3><p>일단 className을 부여하는 방식으로는 semantic의 기본 스타일을 커스터마이징하는 데 한계가 있었다. semantic ui가 스타일링 하는 방식을 개발자 도구로 열어보면, 아래처럼 클래스 여러개를 중첩하여 선언하는 방식이다.</p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* semantic-ui class(className) */</span></div><div class=\"line\"><span class=\"selector-class\">.ui</span><span class=\"selector-class\">.icon</span><span class=\"selector-class\">.input</span> <span class=\"selector-tag\">input</span></div></pre></td></tr></table></figure><p>여기다가 직접 커스텀한 className을 부여하여도,</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;Input className = <span class=\"string\">\"foodSearchInput\"</span> ... /&gt;</div></pre></td></tr></table></figure><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* custom class(className) 추가하는 경우 */</span></div><div class=\"line\"><span class=\"selector-class\">.foodSearchInput</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">100px</span>; <span class=\"comment\">/* 이 코드는 무시된다. */</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 중첩 선언 방식이 명시도 면에서 더 우위를 가져간다. */</span></div><div class=\"line\"><span class=\"selector-class\">.ui</span><span class=\"selector-class\">.icon</span><span class=\"selector-class\">.input</span> <span class=\"selector-tag\">input</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">border-radius</span>: .<span class=\"number\">28571429rem</span>; <span class=\"comment\">/* 이 코드가 적용된다. */</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>결국 캐스캐이딩(cascading) 우선 순위에서 밀리기 때문에 (명시도 면에서 중첩 선언된 기존의 semantic 방식보다 더 하위가 된다.) 적용되지 않는 경우가 많았다.</p><p><strong><em>커스텀 css의 캐스캐이딩 우선 순위가 semantic-ui 프레임워크보다 항상 우위에 있도록 할 수 있는 방법은 없을까?</em></strong></p><p>일단 <a href=\"http://poiemaweb.com/css3-inheritance-cascading\" target=\"_blank\" rel=\"external\">cascading의 명시도</a> 면에서 <code>!important &gt; 인라인 스타일 &gt; 아이디 선택자 &gt; 클래스/어트리뷰트/가상 선택자 &gt; 태그 선택자 &gt; 전체 선택자 &gt; 상위 요소에 의해 상속된 속성</code> 순으로 우선 순위에서 우위를 가져간다. 여기서, <a href=\"https://speckyboy.com/good-bad-css-practices/\" target=\"_blank\" rel=\"external\"><code>!important</code>를 사용하는 방법은 최대한 배제</a>하기로 하였다. 그러면 남은 것은 인라인 스타일과 아이디 선택자를 사용하는 방법이 남는다.</p><p><br></p><h4 id=\"아이디-선택자-X\"><a href=\"#아이디-선택자-X\" class=\"headerlink\" title=\"아이디 선택자 (X)\"></a>아이디 선택자 (X)</h4><ul><li>id 선택자는 단 하나의 요소에만 부여할 수 있는 고유한 것이다.</li><li>따라서 코드의 재사용이 불가함은 물론이고, 유사 스타일에 대한 확장 가능성이 전혀 없기 때문에 인라인 스타일에 비해 비효율적이다.</li><li>프로젝트 내에서 예를 들면, 검색창과 같은 경우, 유사한 스타일 코드를 다른 페이지의 input 요소들과 공유하게 되는데, id선택자를 이용하면 같은 스타일을 여러번 반복해서 선언해주어야 한다.</li></ul><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* 아이디 선택자를 사용할 경우 같은 혹은 유사 스타일 일지라도 반복해서 선언해주어야 한다. */</span></div><div class=\"line\"><span class=\"selector-id\">#searchInput</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">400px</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">20px</span> <span class=\"number\">10px</span>;</div><div class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">  <span class=\"attribute\">left</span>:<span class=\"number\">300px</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-id\">#searchResultInput</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">800px</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">20px</span> <span class=\"number\">10px</span>;</div><div class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">400px</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 인라인 스타일의 경우 spread 문법을 이용한 스타일의 확장이 가능하다.</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> searchInput &#123;</div><div class=\"line\">  width: <span class=\"string\">'400'</span>,</div><div class=\"line\">  margin: <span class=\"string\">'20 10'</span>,</div><div class=\"line\">  borderRadius: <span class=\"string\">'100'</span>,</div><div class=\"line\">  position: <span class=\"string\">'absolute'</span>,</div><div class=\"line\">  left: <span class=\"string\">'300'</span>,</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> searchResultInput &#123;</div><div class=\"line\">  ...searchInput,</div><div class=\"line\">  width: <span class=\"string\">'800'</span>,</div><div class=\"line\">  left: <span class=\"string\">'300'</span>,</div><div class=\"line\">  top: <span class=\"string\">'400'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p><br></p><h4 id=\"인라인-스타일-O\"><a href=\"#인라인-스타일-O\" class=\"headerlink\" title=\"인라인 스타일 (O)\"></a>인라인 스타일 (O)</h4><p>인라인 스타일은 캐스캐이딩에서 <code>!important</code>를 제외하고 두 번째 우선순위를 갖는다. 따라서 중첩된 클래스보다 항상 우위에 있을 것이고, 위 예제처럼 아이디 선택자에 비해 재사용 및 확장이 용이하기 때문에 효율적이고 문제가 없을 것이라 생각했다. 그런데 여기에도 문제가 있었다.</p><p>대부분의 컴포넌트가 <code>div</code>로 실제 시맨틱 태그를 감싸고 있어 인라인 스타일을 주어도 적용되지 않는 경우가 많았다. 예를 들어 <code>Input</code>이나 <code>Search</code> 컴포넌트의 경우, <code>&lt;input&gt;</code> 태그를 <code>&lt;div&gt;&lt;/div&gt;</code>가 감싸고 있다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div&gt;</div><div class=\"line\">  &lt;input type=<span class=\"string\">\"text\"</span>/&gt;</div><div class=\"line\">&lt;<span class=\"regexp\">/div&gt;</span></div></pre></td></tr></table></figure><p>이런 식이라 인라인으로 스타일을 부여하면 <code>&lt;input&gt;</code>이 아니라 가장 바깥의 <code>&lt;div&gt;</code>로 스타일 코드가 적용되었다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div style=<span class=\"string\">\"border: 1px solid blue;\"</span>&gt;</div><div class=\"line\">  &lt;input type=<span class=\"string\">\"text\"</span>/&gt;</div><div class=\"line\">&lt;<span class=\"regexp\">/div&gt;</span></div></pre></td></tr></table></figure><p>따라서 상속이 되는 css 속성에 한해서만 (ex. font/color/text-align 등 비교적 레이아웃과 관련되지 않는 속성들) 적용이 되었고, 정작 필요한 <code>border</code> 속성이나 <code>margin</code>, <code>padding</code>, <code>position</code>과 같은 속성은 적용할 수 없었다.</p><p>즉, 인라인 스타일이나 className 중 하나만 선택하는 방식으로는 발생하는 모든 문제를 해결할 수 없었다. 그래서, <strong>그나마 문제가 거의 발생하지 않는 인라인 스타일을 주 스타일링 방식으로 채택하였다.</strong> 그리고 인라인으로 해결되지 않는 <strong>몇몇 문제들에 한해서만, semantic ui에서 정의한 클래스의 css를 아래와 같이 커스텀 css에서 재정의해주는 방식을 채택하였다.</strong></p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* search.css(custom css) */</span></div><div class=\"line\"><span class=\"selector-class\">.ui</span><span class=\"selector-class\">.icon</span><span class=\"selector-class\">.input</span> <span class=\"selector-tag\">input</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">100px</span> <span class=\"comment\">/* 이 코드가 적용된다. */</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* semantic.min.css */</span></div><div class=\"line\"><span class=\"selector-class\">.ui</span><span class=\"selector-class\">.icon</span><span class=\"selector-class\">.input</span> <span class=\"selector-tag\">input</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">padding-right</span>: <span class=\"number\">2.67142857em</span><span class=\"meta\">!important</span>;</div><div class=\"line\">  <span class=\"comment\">/* ... */</span></div><div class=\"line\">  <span class=\"attribute\">border-radius</span>: .<span class=\"number\">28571429rem</span> <span class=\"comment\">/* 이 코드는 무시된다. */</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>사실 Object 형태의 인라인 스타일 방식을 주 스타일링 방식으로 채택하게 되기까지 <a href=\"https://blog.coderifleman.com/2015/07/12/learning-react-7/\" target=\"_blank\" rel=\"external\">React.js + CSS</a>라는 글이 꽤나 큰 동기 부여가 되기도 하였다. styled-components의 존재를 알게 된 시점부터 css-in-js 라는 스타일링 방식이 어떤 이유로 나오게 되었으며, 어떤 이점을 갖는 지에 대해 궁금했었고, 윗 글이 어느 정도 대답이 되었기 때문이다.</p><p>이 방식을 채택함으로써 가장 큰 수혜(?)를 받은 부분이 Navigation 컴포넌트였다. 프로젝트의 디자인 시안 상으로, 페이지 상단 네비게이션(메뉴)바의 폰트와 보더(border) 색상을 적용함에 있어 두 가지 케이스가 있었다.</p><ul><li>흰 배경인 경우: <code>#16325c</code></li><li>사진이나 동영상이 배경인 경우: <code>#fff</code></li></ul><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// components/Navigation/index.js</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// default Props: 컬러 반전이 없는 일반 페이지의 default color</span></div><div class=\"line\"><span class=\"comment\">// props를 전달하지 않는 경우 color: '#16325c'</span></div><div class=\"line\">Navigation.defaultProps = &#123;</div><div class=\"line\">  color: <span class=\"string\">'#16325c'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>디자인 상 대부분의 화면이 흰 배경이므로, 이를 기본으로 설정하기 위해 위와 같이 <code>defaultProps</code>로 <code>color</code> 스타일을 지정하였다. 그리고 아래처럼 특정 조건에 따라 <code>color</code>와 <code>borderColor</code>를 다르게 적용하도록 하였다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// pages/HomePage/index.js</span></div><div class=\"line\">&lt;Navigation color=<span class=\"string\">\"#fff\"</span> /&gt;</div></pre></td></tr></table></figure><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// components/Navigation/RightMenu/index.js</span></div><div class=\"line\"></div><div class=\"line\">&lt;Menu.Item</div><div class=\"line\">    style=&#123;</div><div class=\"line\">      <span class=\"comment\">// active일때만 border-color 적용</span></div><div class=\"line\">      isLinkMatched ?</div><div class=\"line\">      &#123;</div><div class=\"line\">       ...linkTagWrap, <span class=\"comment\">// linkTagWrap은 아래 참고</span></div><div class=\"line\">        borderColor: <span class=\"keyword\">this</span>.props.color, <span class=\"comment\">//#fff</span></div><div class=\"line\">      &#125; : &#123;</div><div class=\"line\">        linkTagWrap</div><div class=\"line\">      &#125;</div><div class=\"line\">    active=&#123;isLinkMatched&#125;</div><div class=\"line\">&gt;</div><div class=\"line\">  &lt;Link</div><div class=\"line\">    style=&#123;&#123;</div><div class=\"line\">      ..linkTag,</div><div class=\"line\">      color: <span class=\"keyword\">this</span>.props.color, <span class=\"comment\">// #fff</span></div><div class=\"line\">    &#125;&#125;</div><div class=\"line\">    to=&#123;route.linkTo&#125;</div><div class=\"line\">  &gt;</div><div class=\"line\">  &#123;route.linkLabel&#125;</div><div class=\"line\">  &lt;<span class=\"regexp\">/Link&gt;</span></div><div class=\"line\"><span class=\"regexp\">&lt;/</span>Menu.Item&gt;</div></pre></td></tr></table></figure><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// components/Navigation/StyledNavigation.js</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> linkTagWrap = &#123;</div><div class=\"line\">  padding: <span class=\"string\">'7px'</span>,</div><div class=\"line\">  marginLeft: <span class=\"string\">'37px'</span>,</div><div class=\"line\">  marginBottom: <span class=\"string\">'6px'</span>,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>이렇게 css를 변수(또는 props)로 직접 이식하는 부분이 굉장히 매력적이었다. 그리고 이런 방식은 굳이 css-in-js방식의 라이브러리를 사용하지 않아도 가능하였고, 이보다 더 복잡하고 많은 스타일링이 필요할만큼 앱이 거대하지도 않았다. 어찌됐든, 이러한 고민들을 거쳐 최종적으로 인라인 스타일 + css 방식을 사용하였다.</p><p>언젠간 css와 js 스타일링 방식의 차이에 대해서 나름대로 정리한 내용을 기록하려고 한다. (언제가 될지는 모르겠다..) <a href=\"https://www.ludovf.net/blog/comparing-css-in-js-solutions/\" target=\"_blank\" rel=\"external\">css-in-js 방식을 차용한 스타일링 라이브러리들</a>을 찾아보면서 Aphrodite, CSS in JS, Emotion.js 등등 다양한 라이브러리들을 알게 되었는데, 개인적으로 Emotion.js나 Styled-components를 꼭 한번 사용해보고 싶다.</p><p><br></p>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"삽질의-발단…\"><a href=\"#삽질의-발단…\" class=\"headerlink\" title=\"삽질의 발단…\"></a>삽질의 발단…</h2><p><a href=\"https://github.com/huusz/Da-Da\" target=\"_blank\" rel=\"external\">팀 프로젝트</a>를 시작하고 채택한 스타일링 방식은 CSS Framework인 semantic-ui-react로 큰 틀을 잡고, CSS로 세부적인 디자인을 하는 것이었다. 지금까지 css 작업을 누군가와 같이 해본 경험이 없었기 때문에, 몇 가지 우려되는 것이 있었다. 각각 다른 css파일에서 중복되는 클래스 네임이 존재하는 상황 같은 것 말이다 (…) 이런 상황을 사전에 방지하고자, className 앞에 파일명(컴포넌트 이름)을 붙이기로 하였다. 근데 … 너무 귀찮을 것 같았다. 모든 클래스네임을 수동으로 <code>home-header</code> <code>home-header-search</code> 이런 식으로 지정해 주는, 이런 걸 반복 해야 하다니?</p><p><strong><em>자동으로 해주는 게 없을까?</em></strong></p><p><a href=\"https://velopert.com/3447\" target=\"_blank\" rel=\"external\">css를 자동으로 모듈화 해주는 방법</a>에 css-module이라는게 있다는 것을 알게 되었고, webpack에서 <code>css-loader</code>에 <code>module: true</code> 설정을 추가해주었다.</p><p><br></p><h2 id=\"CSS-프레임워크와는-공존할-수-없다\"><a href=\"#CSS-프레임워크와는-공존할-수-없다\" class=\"headerlink\" title=\"CSS 프레임워크와는 공존할 수 없다.\"></a>CSS 프레임워크와는 공존할 수 없다.</h2><p><code>eject</code>로 webpack config에 직접 설정을 추가하는 방식이었는데, semantic-ui-css가 적용되지 않는 문제가 생겼다.</p><p><img src=\"https://lh3.googleusercontent.com/-3h309I9VX1w/WdIAFCTzKhI/AAAAAAAAAbU/9HlUNs0Qi6QkdvWJE7MmITLOZajR4jwIwCL0BGAs/w530-d-h305-n-rw/origin.png\" alt=\"semantic이 적용된 원래 화면\"></p><p><img src=\"https://lh3.googleusercontent.com/-WaXNae7NXz4/WdIAKqOlpOI/AAAAAAAAAbs/3t-AA4FnJqYOMFhdZzcF4YjDkhPx9OMSACL0BGAs/w530-d-h306-n-rw/error.png\" alt=\"semantic이 사라진(!) 화면\"></p><p><br></p><h2 id=\"module-true-때문이다\"><a href=\"#module-true-때문이다\" class=\"headerlink\" title=\"module: true 때문이다.\"></a><code>module: true</code> 때문이다.</h2><p><a href=\"https://github.com/css-modules/css-modules/pull/65\" target=\"_blank\" rel=\"external\">How to use css-modules with other global css (discussion please don’t merge it)</a></p><p>웹팩 설정에서 css-loader 설정을 <code>module:true</code>로 바꾸면, node-modules에 있는 semantic-ui-css(global css)도 component에 따라 class 이름을 변경하기 때문에 전혀 다른 클래스가 되어버리므로 (ex. <code>.ui.icon-k1t4h#9</code>) 결국 semantic-ui-css와의 연결이 끊긴다. 이 때문에 에러는 안 나지만, 전혀 다른 클래스를 적용한 꼴이 되어버리므로 시맨틱 스타일 적용한 것들이 없어져 버린 것..</p><p>윗 글에서는 css-loader에 두 가지로 분류해서 로딩하는 방식으로 약간의 꼼수(?)를 사용했다. global로 쓸 css는 (내 경우 semantic-ui-css) 그대로 하되, local 한 모듈들에 쓸 css들은 <code>app.module.css</code> 와 같이 명명하여 별도로 처리하게 하는 방식이다.</p><p><br></p><h2 id=\"선택지는\"><a href=\"#선택지는\" class=\"headerlink\" title=\"선택지는..\"></a>선택지는..</h2><p><strong>1. Semantic-ui를 쓴다.</strong></p><ol><li>semantic-ui + pure css를 쓴다. 클래스 네임을 직접. 수동으로. 명명해서 css를 모듈화 한다.</li><li>semantic-ui + styled-components를 쓴다. (웹 팩 설정이 필요 없다.)</li><li>위 방법 처럼 꼼수(?)를 써서 css-module + semantic-ui를 쓴다.</li></ol><p><strong>2. Semnatic-ui를 안 쓴다.</strong></p><ol><li>모든 것이 평화롭게 해결된다.</li></ol><p>사실 semantic-ui를 안 쓰고 싶지만, 당장 4일 내로 정적 페이지 제작이 끝나야 하므로 스타일링에 많은 시간을 쏟을 수 없었다. 프레임워크는 그대로 쓰기로 했다. 그러면 남은 선택지 중에서…</p><p><br></p><h4 id=\"2-styled-components\"><a href=\"#2-styled-components\" class=\"headerlink\" title=\"2. styled-components?\"></a>2. styled-components?</h4><p>styled-components는 기존의 css문법과 약간 다르다. react와 css를 섞어 놓은 듯한 문법이라 학습+적응 시간이 필요할 것 같은데, 빠르게 페이지를 만들어야 하는 지금 상황에서 그다지 좋은 선택지는 아닌 것 같다. 게다가 시맨틱도 컴포넌트이고 styled-components도 컴포넌트라서 시맨틱 컴포넌트 내부에 스타일링을 적용해야 하는 경우에는 결국 인라인스타일을 쓰게 된다. 이런게 많아지면, styled-components를 적용하는 의미가 없어지는 것 같았다. 그럴바엔 그냥 전부 inline style로 하면 되는 것 아닌가? 라는 생각이 들었다.</p><h4 id=\"3-css-module-semantic-ui\"><a href=\"#3-css-module-semantic-ui\" class=\"headerlink\" title=\"3. css-module + semantic-ui?\"></a>3. css-module + semantic-ui?</h4><p>어차피 css를 쓸거라면 위 방법을 써서 css-module을 사용하는 것도 좋겠지만, 사실 이것 하나 때문에 <code>eject</code>로 웹팩 config 파일 및 script 설정 파일 등등을 풀어헤친다는 게 석연치 않았다. (불안하기도 했고..)</p><p>결국 처음 고민하던 시점으로 돌아가, <strong>pure css + css 프레임워크</strong>를 쓰기로 했다.</p><p><br></p><hr><h4 id=\"프로젝트가-끝나가는-시점에서\"><a href=\"#프로젝트가-끝나가는-시점에서\" class=\"headerlink\" title=\"프로젝트가 끝나가는 시점에서..\"></a>프로젝트가 끝나가는 시점에서..</h4><p>위에서도 말했듯, 처음 고민하던 시점으로 돌아가서 <strong>pure css + css 프레임워크</strong>를 쓰려고 하였고 적용해보려는 시도도 했다. 그런데 결국 채택한 방식은 <strong>컴포넌트 인라인 스타일 + pure css + css 프레임워크</strong> 방식이다. styled 컴포넌츠를 약간 (정말 약간) 모방하여 Styled<em>*</em>.js라는 이름으로 인라인 스타일 객체만 모아둔 파일을 각 페이지 폴더 내부에 하나씩 두는 방식으로 하였다. 여기까지 오기까지 나름 치열한(?) 고민을 했기 때문에, 기록해두려고 한다.</p><h3 id=\"인라인-스타일-방식을-선택한-이유는\"><a href=\"#인라인-스타일-방식을-선택한-이유는\" class=\"headerlink\" title=\"인라인 스타일 방식을 선택한 이유는,\"></a>인라인 스타일 방식을 선택한 이유는,</h3><p>일단 className을 부여하는 방식으로는 semantic의 기본 스타일을 커스터마이징하는 데 한계가 있었다. semantic ui가 스타일링 하는 방식을 개발자 도구로 열어보면, 아래처럼 클래스 여러개를 중첩하여 선언하는 방식이다.</p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* semantic-ui class(className) */</span></div><div class=\"line\"><span class=\"selector-class\">.ui</span><span class=\"selector-class\">.icon</span><span class=\"selector-class\">.input</span> <span class=\"selector-tag\">input</span></div></pre></td></tr></table></figure><p>여기다가 직접 커스텀한 className을 부여하여도,</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;Input className = <span class=\"string\">\"foodSearchInput\"</span> ... /&gt;</div></pre></td></tr></table></figure><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* custom class(className) 추가하는 경우 */</span></div><div class=\"line\"><span class=\"selector-class\">.foodSearchInput</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">100px</span>; <span class=\"comment\">/* 이 코드는 무시된다. */</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 중첩 선언 방식이 명시도 면에서 더 우위를 가져간다. */</span></div><div class=\"line\"><span class=\"selector-class\">.ui</span><span class=\"selector-class\">.icon</span><span class=\"selector-class\">.input</span> <span class=\"selector-tag\">input</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">border-radius</span>: .<span class=\"number\">28571429rem</span>; <span class=\"comment\">/* 이 코드가 적용된다. */</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>결국 캐스캐이딩(cascading) 우선 순위에서 밀리기 때문에 (명시도 면에서 중첩 선언된 기존의 semantic 방식보다 더 하위가 된다.) 적용되지 않는 경우가 많았다.</p><p><strong><em>커스텀 css의 캐스캐이딩 우선 순위가 semantic-ui 프레임워크보다 항상 우위에 있도록 할 수 있는 방법은 없을까?</em></strong></p><p>일단 <a href=\"http://poiemaweb.com/css3-inheritance-cascading\" target=\"_blank\" rel=\"external\">cascading의 명시도</a> 면에서 <code>!important &gt; 인라인 스타일 &gt; 아이디 선택자 &gt; 클래스/어트리뷰트/가상 선택자 &gt; 태그 선택자 &gt; 전체 선택자 &gt; 상위 요소에 의해 상속된 속성</code> 순으로 우선 순위에서 우위를 가져간다. 여기서, <a href=\"https://speckyboy.com/good-bad-css-practices/\" target=\"_blank\" rel=\"external\"><code>!important</code>를 사용하는 방법은 최대한 배제</a>하기로 하였다. 그러면 남은 것은 인라인 스타일과 아이디 선택자를 사용하는 방법이 남는다.</p><p><br></p><h4 id=\"아이디-선택자-X\"><a href=\"#아이디-선택자-X\" class=\"headerlink\" title=\"아이디 선택자 (X)\"></a>아이디 선택자 (X)</h4><ul><li>id 선택자는 단 하나의 요소에만 부여할 수 있는 고유한 것이다.</li><li>따라서 코드의 재사용이 불가함은 물론이고, 유사 스타일에 대한 확장 가능성이 전혀 없기 때문에 인라인 스타일에 비해 비효율적이다.</li><li>프로젝트 내에서 예를 들면, 검색창과 같은 경우, 유사한 스타일 코드를 다른 페이지의 input 요소들과 공유하게 되는데, id선택자를 이용하면 같은 스타일을 여러번 반복해서 선언해주어야 한다.</li></ul><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* 아이디 선택자를 사용할 경우 같은 혹은 유사 스타일 일지라도 반복해서 선언해주어야 한다. */</span></div><div class=\"line\"><span class=\"selector-id\">#searchInput</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">400px</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">20px</span> <span class=\"number\">10px</span>;</div><div class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">  <span class=\"attribute\">left</span>:<span class=\"number\">300px</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-id\">#searchResultInput</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">800px</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">20px</span> <span class=\"number\">10px</span>;</div><div class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">400px</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 인라인 스타일의 경우 spread 문법을 이용한 스타일의 확장이 가능하다.</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> searchInput &#123;</div><div class=\"line\">  width: <span class=\"string\">'400'</span>,</div><div class=\"line\">  margin: <span class=\"string\">'20 10'</span>,</div><div class=\"line\">  borderRadius: <span class=\"string\">'100'</span>,</div><div class=\"line\">  position: <span class=\"string\">'absolute'</span>,</div><div class=\"line\">  left: <span class=\"string\">'300'</span>,</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> searchResultInput &#123;</div><div class=\"line\">  ...searchInput,</div><div class=\"line\">  width: <span class=\"string\">'800'</span>,</div><div class=\"line\">  left: <span class=\"string\">'300'</span>,</div><div class=\"line\">  top: <span class=\"string\">'400'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p><br></p><h4 id=\"인라인-스타일-O\"><a href=\"#인라인-스타일-O\" class=\"headerlink\" title=\"인라인 스타일 (O)\"></a>인라인 스타일 (O)</h4><p>인라인 스타일은 캐스캐이딩에서 <code>!important</code>를 제외하고 두 번째 우선순위를 갖는다. 따라서 중첩된 클래스보다 항상 우위에 있을 것이고, 위 예제처럼 아이디 선택자에 비해 재사용 및 확장이 용이하기 때문에 효율적이고 문제가 없을 것이라 생각했다. 그런데 여기에도 문제가 있었다.</p><p>대부분의 컴포넌트가 <code>div</code>로 실제 시맨틱 태그를 감싸고 있어 인라인 스타일을 주어도 적용되지 않는 경우가 많았다. 예를 들어 <code>Input</code>이나 <code>Search</code> 컴포넌트의 경우, <code>&lt;input&gt;</code> 태그를 <code>&lt;div&gt;&lt;/div&gt;</code>가 감싸고 있다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div&gt;</div><div class=\"line\">  &lt;input type=<span class=\"string\">\"text\"</span>/&gt;</div><div class=\"line\">&lt;<span class=\"regexp\">/div&gt;</span></div></pre></td></tr></table></figure><p>이런 식이라 인라인으로 스타일을 부여하면 <code>&lt;input&gt;</code>이 아니라 가장 바깥의 <code>&lt;div&gt;</code>로 스타일 코드가 적용되었다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div style=<span class=\"string\">\"border: 1px solid blue;\"</span>&gt;</div><div class=\"line\">  &lt;input type=<span class=\"string\">\"text\"</span>/&gt;</div><div class=\"line\">&lt;<span class=\"regexp\">/div&gt;</span></div></pre></td></tr></table></figure><p>따라서 상속이 되는 css 속성에 한해서만 (ex. font/color/text-align 등 비교적 레이아웃과 관련되지 않는 속성들) 적용이 되었고, 정작 필요한 <code>border</code> 속성이나 <code>margin</code>, <code>padding</code>, <code>position</code>과 같은 속성은 적용할 수 없었다.</p><p>즉, 인라인 스타일이나 className 중 하나만 선택하는 방식으로는 발생하는 모든 문제를 해결할 수 없었다. 그래서, <strong>그나마 문제가 거의 발생하지 않는 인라인 스타일을 주 스타일링 방식으로 채택하였다.</strong> 그리고 인라인으로 해결되지 않는 <strong>몇몇 문제들에 한해서만, semantic ui에서 정의한 클래스의 css를 아래와 같이 커스텀 css에서 재정의해주는 방식을 채택하였다.</strong></p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* search.css(custom css) */</span></div><div class=\"line\"><span class=\"selector-class\">.ui</span><span class=\"selector-class\">.icon</span><span class=\"selector-class\">.input</span> <span class=\"selector-tag\">input</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">100px</span> <span class=\"comment\">/* 이 코드가 적용된다. */</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* semantic.min.css */</span></div><div class=\"line\"><span class=\"selector-class\">.ui</span><span class=\"selector-class\">.icon</span><span class=\"selector-class\">.input</span> <span class=\"selector-tag\">input</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">padding-right</span>: <span class=\"number\">2.67142857em</span><span class=\"meta\">!important</span>;</div><div class=\"line\">  <span class=\"comment\">/* ... */</span></div><div class=\"line\">  <span class=\"attribute\">border-radius</span>: .<span class=\"number\">28571429rem</span> <span class=\"comment\">/* 이 코드는 무시된다. */</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>사실 Object 형태의 인라인 스타일 방식을 주 스타일링 방식으로 채택하게 되기까지 <a href=\"https://blog.coderifleman.com/2015/07/12/learning-react-7/\" target=\"_blank\" rel=\"external\">React.js + CSS</a>라는 글이 꽤나 큰 동기 부여가 되기도 하였다. styled-components의 존재를 알게 된 시점부터 css-in-js 라는 스타일링 방식이 어떤 이유로 나오게 되었으며, 어떤 이점을 갖는 지에 대해 궁금했었고, 윗 글이 어느 정도 대답이 되었기 때문이다.</p><p>이 방식을 채택함으로써 가장 큰 수혜(?)를 받은 부분이 Navigation 컴포넌트였다. 프로젝트의 디자인 시안 상으로, 페이지 상단 네비게이션(메뉴)바의 폰트와 보더(border) 색상을 적용함에 있어 두 가지 케이스가 있었다.</p><ul><li>흰 배경인 경우: <code>#16325c</code></li><li>사진이나 동영상이 배경인 경우: <code>#fff</code></li></ul><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// components/Navigation/index.js</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// default Props: 컬러 반전이 없는 일반 페이지의 default color</span></div><div class=\"line\"><span class=\"comment\">// props를 전달하지 않는 경우 color: '#16325c'</span></div><div class=\"line\">Navigation.defaultProps = &#123;</div><div class=\"line\">  color: <span class=\"string\">'#16325c'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>디자인 상 대부분의 화면이 흰 배경이므로, 이를 기본으로 설정하기 위해 위와 같이 <code>defaultProps</code>로 <code>color</code> 스타일을 지정하였다. 그리고 아래처럼 특정 조건에 따라 <code>color</code>와 <code>borderColor</code>를 다르게 적용하도록 하였다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// pages/HomePage/index.js</span></div><div class=\"line\">&lt;Navigation color=<span class=\"string\">\"#fff\"</span> /&gt;</div></pre></td></tr></table></figure><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// components/Navigation/RightMenu/index.js</span></div><div class=\"line\"></div><div class=\"line\">&lt;Menu.Item</div><div class=\"line\">    style=&#123;</div><div class=\"line\">      <span class=\"comment\">// active일때만 border-color 적용</span></div><div class=\"line\">      isLinkMatched ?</div><div class=\"line\">      &#123;</div><div class=\"line\">       ...linkTagWrap, <span class=\"comment\">// linkTagWrap은 아래 참고</span></div><div class=\"line\">        borderColor: <span class=\"keyword\">this</span>.props.color, <span class=\"comment\">//#fff</span></div><div class=\"line\">      &#125; : &#123;</div><div class=\"line\">        linkTagWrap</div><div class=\"line\">      &#125;</div><div class=\"line\">    active=&#123;isLinkMatched&#125;</div><div class=\"line\">&gt;</div><div class=\"line\">  &lt;Link</div><div class=\"line\">    style=&#123;&#123;</div><div class=\"line\">      ..linkTag,</div><div class=\"line\">      color: <span class=\"keyword\">this</span>.props.color, <span class=\"comment\">// #fff</span></div><div class=\"line\">    &#125;&#125;</div><div class=\"line\">    to=&#123;route.linkTo&#125;</div><div class=\"line\">  &gt;</div><div class=\"line\">  &#123;route.linkLabel&#125;</div><div class=\"line\">  &lt;<span class=\"regexp\">/Link&gt;</span></div><div class=\"line\"><span class=\"regexp\">&lt;/</span>Menu.Item&gt;</div></pre></td></tr></table></figure><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// components/Navigation/StyledNavigation.js</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> linkTagWrap = &#123;</div><div class=\"line\">  padding: <span class=\"string\">'7px'</span>,</div><div class=\"line\">  marginLeft: <span class=\"string\">'37px'</span>,</div><div class=\"line\">  marginBottom: <span class=\"string\">'6px'</span>,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>이렇게 css를 변수(또는 props)로 직접 이식하는 부분이 굉장히 매력적이었다. 그리고 이런 방식은 굳이 css-in-js방식의 라이브러리를 사용하지 않아도 가능하였고, 이보다 더 복잡하고 많은 스타일링이 필요할만큼 앱이 거대하지도 않았다. 어찌됐든, 이러한 고민들을 거쳐 최종적으로 인라인 스타일 + css 방식을 사용하였다.</p><p>언젠간 css와 js 스타일링 방식의 차이에 대해서 나름대로 정리한 내용을 기록하려고 한다. (언제가 될지는 모르겠다..) <a href=\"https://www.ludovf.net/blog/comparing-css-in-js-solutions/\" target=\"_blank\" rel=\"external\">css-in-js 방식을 차용한 스타일링 라이브러리들</a>을 찾아보면서 Aphrodite, CSS in JS, Emotion.js 등등 다양한 라이브러리들을 알게 되었는데, 개인적으로 Emotion.js나 Styled-components를 꼭 한번 사용해보고 싶다.</p><p><br></p>"},{"title":"[JS] 객체 Object","date":"2017-08-05T11:16:16.000Z","_content":"\n![](https://www.bram.us/wordpress/wp-content/uploads/2016/06/javascript-logo-banner.jpg)\n\n# Object\n\n## 1. 객체(Object)란?\n\n자바스크립트는 객체(Object)기반의 스크립트 언어이며 자바스크립트를 이루고 있는 거의 \"모든 것\"은 객체이다. **기본 자료형(primitives)을 제외한** 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체이다. \n\n> **[primitives](https://developer.mozilla.org/ko/docs/Glossary/Primitive)**\n프리미티브: 객체도 아니고 메소드도 아닌 데이터. string/number/boolean/null/undefined/symbol로 6개의 기본 데이터 타입이 있다.  \nnull과 undefined를 제외하고 모든 프리미티브 값은 래퍼 객체를 갖는다.\n> * string을 위한 String객체\n> * number를 위한 Number객체\n> * boolean을 위한 Boolean객체\n> * Symbol을 위한 Symbol객체\n>  \n> 모두 Bulit-in Object(자바스크립트 내장객체)이다.\n\n객체는 데이터와 데이터 관련 동작을 모두 포함할 수 있는 개념적 존재이다. 이름(키)과 값으로 구성된 데이터를 의미하는 프로퍼티(property)와 동작을 나타내는 메서드(method)를 포함하고 있는 독립적 주체이다. \n\n객체는 흩어져있는 것들을 모은다는 관점에서 매우 유용하다. 객체 하나는 다른 객체를 포함할 수 있기 때문에 그래프나 트리와 같은 자료구조를 쉽게 표현할 수 있다.\n\n<br>\n\n\n### 1) 프로퍼티(property) \n\n객체는 프로퍼티들을 포함하는 컨테이너라고 할 수 있다. 프로퍼티는 객체의 속성을 나타내는 접근 가능한 이름과 활용 가능한 값을 가지는 특별한 형태이다. 프로퍼티는 객체를 활용함에 있어 매우 유용한 존재이다. 특정 객체가 가진 정보에 직접적으로 접근할 수 있게 해주기 때문이다.\n\n\n* 프로퍼티 이름 명명 규칙: 빈 문자열을 포함하는 문자열과 숫자\n* 프로퍼티 값: `undefined` 제외, 모든 값 가능\n\n프로퍼티는 기본적으로 이름과 값으로 구성된다. 프로퍼티에 대한 접근 연산자는 `.`이다. 이 연산자를 통해 프로퍼티에 접근할 수도 있고 프로퍼티를 추가할 수도 있다.\n\n***Q. 만약 프로퍼티에 아무런 값도 할당하지 않으면 어떻게 될까?***  \n변수는 값을 할당하지 않고 선언만 할 경우 자바스크립트 엔진이 강제로 `undefined` 를 할당한다. 하지만 프로퍼티는 값이 할당되지 않는다면 존재 이유가 없다. 객체의 정보를 담고 있어야 하는 요소가 아무 정보도 갖지 않는다면 객체로써는 이 프로퍼티가 쓸모가 없기 때문이다. 그렇기 때문에 프로퍼티를 추가하면서 값을 할당하지 않으면 `syntax error` 가 발생한다. 만약 값을 비워둬야 한다면 빈문자열(`''`)을 넣는 것이 바람직하다.\n\n<br>\n\n### 2) 메서드(Method)\n\n메서드는 **객체에 제한되어 있는 함수**를 의미한다. 따라서 메서드 함수의 호출은 객체에 의해서만 가능하다.(=메서드를 호출하는 주체가 해당 함수를 프로퍼티로 가지고 있는 객체이다.) _<sup>1)</sup>함수를 객체의 프로퍼티로 할당하고, 그 프로퍼티를 사용하여 참조에 의한 호출이 일어나면, 함수는 그 객체의 메서드로 호출된다._ 즉 **프로퍼티 값이 함수일 경우**, 일반 함수와 구분하기 위해 메서드라 칭한다.  \n\n```javascript\nvar foo = {}; //Object\nfoo.whatever = function(){}; //method of foo(Object)\nfoo.whatever(); \n```\n\n<br>\n\n## 2. 객체 생성 방법\n\n자바에서는 클래스를 사전에 정의하고 필요한 시점에 new 연산자를 사용하여 인스턴스를 생성하는 방식으로 객체를 생성한다. 하지만 자바스크립트는 클래스 개념이 없고 별도의 객체 생성 방법이 존재한다.\n\n### 1) 객체 리터럴\n가장 일반적이며 간편한 자바스크립트 객체 생성 방식이다. 중괄호(`{}`)를 이용하여 객체를 생성하는데 `{}` 내에 아무것도 기술하지 않으면 빈 객체가 생성된다. {} 내에 **`프로퍼티이름: 프로퍼티값`** 을 기술하면 해당 프로퍼티가 추가된 객체를 생성할 수 있다. 객체 리터럴 방식의 특징은 new 연산자를 사용할 필요없이 선언과 동시에 인스턴스가 생성된다는 것이다.\n\n>`{name:value}` 형태의 구성 방식을 **JSON(javascript object notation) 방식**이라고 한다. \n\n```javascript\nvar emptyObject = {};\nconsole.log(typeof emptyObject); // object\n\nvar person = {\n  name: 'Lee',\n  gender: 'male',\n  sayHello: function () {\n    console.log('Hi! My name is ' + this.name);\n  }\n};\n\nconsole.log(typeof person); // object\nconsole.log(person); // { name: 'Lee', gender: 'male', sayHello: [Function: sayHello] }\n\nperson.sayHello(); // Hi! My name is Lee\n````\n<br>\n\n### 2) Object() 생성자 함수\nobject를 만드는 함수이다. new 연산자를 반드시 함께 사용해야 한다. new 연산자와 함께 사용하여 빈 객체를 생성할 수 있다. 우선 빈 객체를 생성하고, 이후에 프로퍼티와 메서드를 추가하여 객체를 완성하는 방법이다.\n\n객체의 프로퍼티에 새로운 값을 할당하면, 프로퍼티 값은 갱신된다. 객체가 소유하고 있지 않은 프로퍼티에 값을 할당하면, 해당 객체에 프로퍼티 추가하고 값을 할당을 한다. 아래와 같은 방식으로 선언한다.\n```javascript\nvar obj = new Object();\n```\n\n```javascript\nvar person = new Object(); // obj에는 빈 객체가 들어온다.\n//프로퍼티 추가\nperson.name = 'Lee'; //name 프로퍼티에 'Lee'값을 할당한다.\nperson.gender = 'male';\nperson.sayHello = 'Hello';\n...\n```\n\n이 방식은 별로 유용하지 않아 보인다.\n반드시 new 연산자와 Object() 생성자 함수를 사용하여 빈객체를 생성해야 하는 것은 아니다. 객체를 생성하는 방법은 객체 리터럴을 사용하는 것이 더 간편하다.\n\n```javascript\nvar person = {};\nperson.name = 'Lee';\nperson.gender = 'male';\nperson.sayHello = function () {\n  console.log('Hi! My name is ' + this.name);\n};\n```\n\n위와 같이 객체를 생성할 수도 있기 때문에다. 사실 이렇게 선언해도 자바스크립트 엔진은 Object 생성자를 불러서 객체를 만든다. 그러니 위와 같은 선언 방식은 shorthand인 셈이다.\n\n>Object() 생성자는 사실 node에서 사용한다.\n\n<br>\n\n### 3) 생성자 함수\n객체 리터럴 방식과 Object() 생성자 함수 방식으로 객체를 생성하는 것은 프로퍼티 값만 다른 여러개의 객체 생성에 불편이 있다. 동일한 프로퍼티를 갖는 객체임에도 불구하고 매번 같은 프로퍼티를 기술해야한다.\n따라서, **유사 객체를 다량 생산 해야 할때, 생성자 함수가 매우 유용하게 쓰일 수 있다.**\n\n```javascript\nvar person1 = {\n  name: 'Lee',\n  gender: 'male',\n  sayHello: function () {\n    console.log('Hi! My name is ' + this.name);\n  }\n};\n\nvar person2 = {\n  name: 'Kim',\n  gender: 'female',\n  sayHello: function () {\n    console.log('Hi! My name is ' + this.name);\n  }\n};\n```\n생성자 함수를 사용하면 마치 객체를 생성하기 위한 탬플릿(클래스)처럼 사용하여 구성이 동일한 객체 여러개를 간편하게 생성할 수 있다.\n\n```javascript\n// 생성자 함수\nfunction Person(name, gender) {\n  this.name = name;\n  this.gender = gender;\n  this.sayHello = function(){\n    console.log('Hi! My name is ' + this.name);\n  };\n}\n\n// 인스턴스의 생성\nvar person1 = new Person('Lee', 'male');\nvar person2 = new Person('Kim', 'female');\n\nconsole.log('person1: ', typeof person1);\nconsole.log('person2: ', typeof person2);\nconsole.log('person1: ', person1);\nconsole.log('person2: ', person2);\n\nperson1.sayHello();\nperson2.sayHello();\n```\n\n> 생성자는 인스턴스를 찍어내는 공장이며, 인스턴스는 실제 객체이다.\n\n생성자는 일반 함수로 사용하지 않고, 객체를 찍어낼 때만 사용해야 한다. 따라서 첫 문자를 대문자로 하는 관습이 있다. 생성자 함수임을 인식하는데 도움을 주기 위함이다. 따라서 생성자를 만들때는 이 관습을 지켜 네이밍하도록 한다.\n\n프로퍼티 또는 메서드명 앞에 기술한 `this`는 생성자 함수로 생성될 인스턴스를 가리킨다. 따라서 `this`에 연결되어 있는 프로퍼티와 메서드는 `public`이다.\n\n---\n\n<br>\n\n\n## 3. 객체 프로퍼티 접근\n\n1) 프로퍼티 이름\n프로퍼티 이름에는 문자열(빈 문자열 포함)과 숫자가 올 수 있다. 프로퍼티 값은 undefined을 제외한 모든 값과 표현식이 올 수 있으며 프로퍼티 값이 함수인 경우 이를 메서드라 한다.\n\n프로퍼티 이름의 따옴표(‘’ 또는 ““)는 자바스크립트에서 사용할 수 있는 유효한 이름이고 예약어가 아닌 경우 생략할 수 있다. 반대로 말하면 **자바스크립트에서 사용할 수 있는 유효한 이름이 아닌 경우 반드시 따옴표를 사용**하여야 한다.\n\n```javascript\nvar person = {\n  'first-name': 'Ung-mo', /* 유효하지 않은 이름, 연산자가 있는 표현식 */\n  'last-name': 'Lee', /* 프로퍼티 이름에 따옴표를 쓰지 않으면, 연산을 수행한다. last라는 변수를 찾으려고 할 것이다. 이로 인해 에러가 발생한다. */\n  gender: 'male',\n  function: 1 /* OK. 하지만 예약어는 사용하지 말아야 한다. */\n};\n\nconsole.log(person.function);\n```\n\n> **명명 규칙**  \n\n- 스네이크케이스: 공백(space) 대신 _(언더라인) 사용 (e.g. `first_name`)\n- 케밥케이스: 공백 대신 - 사용 (e.g. `first-name`)\n- 카멜케이스: 공백 대신 앞 문자를 대문자로 (e.g. `firstName`)\n\n또한 예약어와 키워드는 사용하면 안 된다. 사용하여도 에러를 발생시키지는 않지만, 언제 에상치 못한 에러가 발생할지 모르기 때문이다.\n\n### 2) 프로퍼티 값 읽기\n객체의 프로퍼티에 접근하려면 아래 두 방법을 사용한다.\n* 마침표(.) 표기법\n* 대괄호([])표기법\n\n```javascript\nvar person = {\n  'first-name': 'Ung-mo',\n  'last-name': 'Lee',\n  gender: 'male',\n};\n\nconsole.log(person);\n\nconsole.log(person.first-name);     // NaN: undefined-name, first-name은 마이너스 연산을 하려고 하기 때문에 프로퍼티에 접근하기도 전에 프로퍼티 명에서부터 NaN을 반환한다.\nconsole.log(person[first-name]);   // ReferenceError: first is not defined\nconsole.log(person['first-name']); // 'Ung-mo'\n\nconsole.log(person.gender);    // 'male'\nconsole.log(person[gender]);   // ReferenceError: gender is not defined\nconsole.log(person['gender']); // 'male'\n```\n\n프로퍼티 이름이 유효한 자바스크립트 이름이고 예약어가 아닌 경우 프로퍼티 값은 마침표 표기법, 대괄호 표기법 모두 사용할 수 있다.\n\n프로퍼티 이름이 유효한 자바스크립트 이름이 아니거나 예약어인 경우 프로퍼티 값은 대괄호 표기법으로 읽어야 한다. 대괄호([]) 표기법을 사용하는 경우, **대괄호 내에 들어가는 프로퍼티 이름은 반드시 문자열**이어야 한다.\n\n객체에 존재하지 않는 프로퍼티를 참조하면 `undefined`를 반환한다.\n\n```javascript\nvar person = {\n  'first-name': 'Ung-mo',\n  'last-name': 'Lee',\n  gender: 'male',\n}\n\nconsole.log(person.age); // undefined\n````\n\n### 3) 프로퍼티 값 갱신\n\n객체가 소유하고 있는 프로퍼티에 새로운 값을 할당하면 프로퍼티 값은 새로운 값으로 갱신된다.\n\n```javascript\nvar person = {\n  'first-name': 'Ung-mo',\n  'last-name': 'Lee',\n  gender: 'male',\n};\n\nperson['first-name'] = 'Kim';\nconsole.log(person['first-name'] ); // 'Kim'\n```\n\n### 4) 프로퍼티 동적 생성\n객체가 소유하고 있지 않은 프로퍼티에 값을 할당하면 하면 해당 프로퍼티를 객체에 추가하고 값을 할당한다.\n\n```javascript\nvar person = {\n  'first-name': 'Ung-mo',\n  'last-name': 'Lee',\n  gender: 'male',\n};\n\nperson.age = 20;\nconsole.log(person.age); // 20\n```\n\n### 5) 프로퍼티 삭제\n`delete` 연산자를 사용하면 객체의 프로퍼티를 삭제할 수 있다. `delete` 연산자는 당연하게도, 객체가 소유하지 않는 프로퍼티에 적용할 수 없다.\n\n```javascript\nvar person = {\n  'first-name': 'Ung-mo',\n  'last-name': 'Lee',\n  gender: 'male',\n};\n\ndelete person.gender;\nconsole.log(person.gender); // undefined\n\ndelete person;\nconsole.log(person); // Object {first-name: 'Ung-mo', last-name: 'Lee'}\n```\n\n### 6) for-in문\n\n`for-in`문을 사용하면 객체에 포함된 모든 프로퍼티에 대해 루프를 수행할 수 있다.\n\n```javascript\nvar person = {\n  'first-name': 'Ung-mo',\n  'last-name': 'Lee',\n  gender: 'male'\n};\n\nfor(var prop in person) {\n  console.log(prop + ': ' + person[prop]);\n}\n\n/*\nfirst-name: Ung-mo\nlast-name: Lee\ngender: male\n*/\n```\nfor-in문은 여러가지 이유로 사용하지 않는다. 일단, 순서가 보장되지 않는다. es6에서 이를 보완한 for ~ of문이 나와있다. \n\n# 4. Pass-by-reference\n기본자료형 object를 객체형 또는 참조형이라 한다. 참조형이란 객체의 모든 연산이 실제값이 아닌 참조값으로 처리됨을 의미한다.\n이에 반해 기본자료형의 값은 값(value)으로 전달된다. 즉 복사되어 전달된다. 이를 pass-by-value라고 한다.\n기본자료형은 값이 한번 정해지면 변경할 수 없지만(immutable), 객체는 변경 가능한 프로퍼티들의 집합이라 할 수 있다.\n\n참조값을 준다는 것은 **단일 객체**를 사용한다는 의미이다.\n\n[immutable](http://poiemaweb.com/js-immutability)객체는 참조형이다. 객체에 객체를 할당했을 때, 결국 똑같은 객체를 가리킨다.\n\n# 5. Pass-by-value\n\n# 6. 객체의 분류\n\n![객체의 분류](http://poiemaweb.com/img/object.png)\n\nBulit-in Object(내장 객체)\n\n* Standard Built-in Object(or Global Objects)\n\n\n* Native Object\n  * BOM(Browser Object Model): 브라우저에 대한 것을 컨트롤하기 위한 객체 (e.g. 스크롤)\n  * DOM(Document Object Model): html과 css에 대한 정보를 담고 있는 객체\n\n\n\n\n---\n[참고]  \n[Poeima web](http://poiemaweb.com/js-data-type-variable)  \n[MDN ko](https://developer.mozilla.org/ko/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript)  \n[blog](http://insanehong.kr/post/javascript-object/)  \n[blog - this](https://hyunseob.github.io/2016/03/10/javascript-this/)\n","source":"_posts/Javascript/01.Object.md","raw":"---\ntitle: '[JS] 객체 Object'\ndate: 2017-08-05 20:16:16\ncategory: Javascript\ntags: object\n---\n\n![](https://www.bram.us/wordpress/wp-content/uploads/2016/06/javascript-logo-banner.jpg)\n\n# Object\n\n## 1. 객체(Object)란?\n\n자바스크립트는 객체(Object)기반의 스크립트 언어이며 자바스크립트를 이루고 있는 거의 \"모든 것\"은 객체이다. **기본 자료형(primitives)을 제외한** 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체이다. \n\n> **[primitives](https://developer.mozilla.org/ko/docs/Glossary/Primitive)**\n프리미티브: 객체도 아니고 메소드도 아닌 데이터. string/number/boolean/null/undefined/symbol로 6개의 기본 데이터 타입이 있다.  \nnull과 undefined를 제외하고 모든 프리미티브 값은 래퍼 객체를 갖는다.\n> * string을 위한 String객체\n> * number를 위한 Number객체\n> * boolean을 위한 Boolean객체\n> * Symbol을 위한 Symbol객체\n>  \n> 모두 Bulit-in Object(자바스크립트 내장객체)이다.\n\n객체는 데이터와 데이터 관련 동작을 모두 포함할 수 있는 개념적 존재이다. 이름(키)과 값으로 구성된 데이터를 의미하는 프로퍼티(property)와 동작을 나타내는 메서드(method)를 포함하고 있는 독립적 주체이다. \n\n객체는 흩어져있는 것들을 모은다는 관점에서 매우 유용하다. 객체 하나는 다른 객체를 포함할 수 있기 때문에 그래프나 트리와 같은 자료구조를 쉽게 표현할 수 있다.\n\n<br>\n\n\n### 1) 프로퍼티(property) \n\n객체는 프로퍼티들을 포함하는 컨테이너라고 할 수 있다. 프로퍼티는 객체의 속성을 나타내는 접근 가능한 이름과 활용 가능한 값을 가지는 특별한 형태이다. 프로퍼티는 객체를 활용함에 있어 매우 유용한 존재이다. 특정 객체가 가진 정보에 직접적으로 접근할 수 있게 해주기 때문이다.\n\n\n* 프로퍼티 이름 명명 규칙: 빈 문자열을 포함하는 문자열과 숫자\n* 프로퍼티 값: `undefined` 제외, 모든 값 가능\n\n프로퍼티는 기본적으로 이름과 값으로 구성된다. 프로퍼티에 대한 접근 연산자는 `.`이다. 이 연산자를 통해 프로퍼티에 접근할 수도 있고 프로퍼티를 추가할 수도 있다.\n\n***Q. 만약 프로퍼티에 아무런 값도 할당하지 않으면 어떻게 될까?***  \n변수는 값을 할당하지 않고 선언만 할 경우 자바스크립트 엔진이 강제로 `undefined` 를 할당한다. 하지만 프로퍼티는 값이 할당되지 않는다면 존재 이유가 없다. 객체의 정보를 담고 있어야 하는 요소가 아무 정보도 갖지 않는다면 객체로써는 이 프로퍼티가 쓸모가 없기 때문이다. 그렇기 때문에 프로퍼티를 추가하면서 값을 할당하지 않으면 `syntax error` 가 발생한다. 만약 값을 비워둬야 한다면 빈문자열(`''`)을 넣는 것이 바람직하다.\n\n<br>\n\n### 2) 메서드(Method)\n\n메서드는 **객체에 제한되어 있는 함수**를 의미한다. 따라서 메서드 함수의 호출은 객체에 의해서만 가능하다.(=메서드를 호출하는 주체가 해당 함수를 프로퍼티로 가지고 있는 객체이다.) _<sup>1)</sup>함수를 객체의 프로퍼티로 할당하고, 그 프로퍼티를 사용하여 참조에 의한 호출이 일어나면, 함수는 그 객체의 메서드로 호출된다._ 즉 **프로퍼티 값이 함수일 경우**, 일반 함수와 구분하기 위해 메서드라 칭한다.  \n\n```javascript\nvar foo = {}; //Object\nfoo.whatever = function(){}; //method of foo(Object)\nfoo.whatever(); \n```\n\n<br>\n\n## 2. 객체 생성 방법\n\n자바에서는 클래스를 사전에 정의하고 필요한 시점에 new 연산자를 사용하여 인스턴스를 생성하는 방식으로 객체를 생성한다. 하지만 자바스크립트는 클래스 개념이 없고 별도의 객체 생성 방법이 존재한다.\n\n### 1) 객체 리터럴\n가장 일반적이며 간편한 자바스크립트 객체 생성 방식이다. 중괄호(`{}`)를 이용하여 객체를 생성하는데 `{}` 내에 아무것도 기술하지 않으면 빈 객체가 생성된다. {} 내에 **`프로퍼티이름: 프로퍼티값`** 을 기술하면 해당 프로퍼티가 추가된 객체를 생성할 수 있다. 객체 리터럴 방식의 특징은 new 연산자를 사용할 필요없이 선언과 동시에 인스턴스가 생성된다는 것이다.\n\n>`{name:value}` 형태의 구성 방식을 **JSON(javascript object notation) 방식**이라고 한다. \n\n```javascript\nvar emptyObject = {};\nconsole.log(typeof emptyObject); // object\n\nvar person = {\n  name: 'Lee',\n  gender: 'male',\n  sayHello: function () {\n    console.log('Hi! My name is ' + this.name);\n  }\n};\n\nconsole.log(typeof person); // object\nconsole.log(person); // { name: 'Lee', gender: 'male', sayHello: [Function: sayHello] }\n\nperson.sayHello(); // Hi! My name is Lee\n````\n<br>\n\n### 2) Object() 생성자 함수\nobject를 만드는 함수이다. new 연산자를 반드시 함께 사용해야 한다. new 연산자와 함께 사용하여 빈 객체를 생성할 수 있다. 우선 빈 객체를 생성하고, 이후에 프로퍼티와 메서드를 추가하여 객체를 완성하는 방법이다.\n\n객체의 프로퍼티에 새로운 값을 할당하면, 프로퍼티 값은 갱신된다. 객체가 소유하고 있지 않은 프로퍼티에 값을 할당하면, 해당 객체에 프로퍼티 추가하고 값을 할당을 한다. 아래와 같은 방식으로 선언한다.\n```javascript\nvar obj = new Object();\n```\n\n```javascript\nvar person = new Object(); // obj에는 빈 객체가 들어온다.\n//프로퍼티 추가\nperson.name = 'Lee'; //name 프로퍼티에 'Lee'값을 할당한다.\nperson.gender = 'male';\nperson.sayHello = 'Hello';\n...\n```\n\n이 방식은 별로 유용하지 않아 보인다.\n반드시 new 연산자와 Object() 생성자 함수를 사용하여 빈객체를 생성해야 하는 것은 아니다. 객체를 생성하는 방법은 객체 리터럴을 사용하는 것이 더 간편하다.\n\n```javascript\nvar person = {};\nperson.name = 'Lee';\nperson.gender = 'male';\nperson.sayHello = function () {\n  console.log('Hi! My name is ' + this.name);\n};\n```\n\n위와 같이 객체를 생성할 수도 있기 때문에다. 사실 이렇게 선언해도 자바스크립트 엔진은 Object 생성자를 불러서 객체를 만든다. 그러니 위와 같은 선언 방식은 shorthand인 셈이다.\n\n>Object() 생성자는 사실 node에서 사용한다.\n\n<br>\n\n### 3) 생성자 함수\n객체 리터럴 방식과 Object() 생성자 함수 방식으로 객체를 생성하는 것은 프로퍼티 값만 다른 여러개의 객체 생성에 불편이 있다. 동일한 프로퍼티를 갖는 객체임에도 불구하고 매번 같은 프로퍼티를 기술해야한다.\n따라서, **유사 객체를 다량 생산 해야 할때, 생성자 함수가 매우 유용하게 쓰일 수 있다.**\n\n```javascript\nvar person1 = {\n  name: 'Lee',\n  gender: 'male',\n  sayHello: function () {\n    console.log('Hi! My name is ' + this.name);\n  }\n};\n\nvar person2 = {\n  name: 'Kim',\n  gender: 'female',\n  sayHello: function () {\n    console.log('Hi! My name is ' + this.name);\n  }\n};\n```\n생성자 함수를 사용하면 마치 객체를 생성하기 위한 탬플릿(클래스)처럼 사용하여 구성이 동일한 객체 여러개를 간편하게 생성할 수 있다.\n\n```javascript\n// 생성자 함수\nfunction Person(name, gender) {\n  this.name = name;\n  this.gender = gender;\n  this.sayHello = function(){\n    console.log('Hi! My name is ' + this.name);\n  };\n}\n\n// 인스턴스의 생성\nvar person1 = new Person('Lee', 'male');\nvar person2 = new Person('Kim', 'female');\n\nconsole.log('person1: ', typeof person1);\nconsole.log('person2: ', typeof person2);\nconsole.log('person1: ', person1);\nconsole.log('person2: ', person2);\n\nperson1.sayHello();\nperson2.sayHello();\n```\n\n> 생성자는 인스턴스를 찍어내는 공장이며, 인스턴스는 실제 객체이다.\n\n생성자는 일반 함수로 사용하지 않고, 객체를 찍어낼 때만 사용해야 한다. 따라서 첫 문자를 대문자로 하는 관습이 있다. 생성자 함수임을 인식하는데 도움을 주기 위함이다. 따라서 생성자를 만들때는 이 관습을 지켜 네이밍하도록 한다.\n\n프로퍼티 또는 메서드명 앞에 기술한 `this`는 생성자 함수로 생성될 인스턴스를 가리킨다. 따라서 `this`에 연결되어 있는 프로퍼티와 메서드는 `public`이다.\n\n---\n\n<br>\n\n\n## 3. 객체 프로퍼티 접근\n\n1) 프로퍼티 이름\n프로퍼티 이름에는 문자열(빈 문자열 포함)과 숫자가 올 수 있다. 프로퍼티 값은 undefined을 제외한 모든 값과 표현식이 올 수 있으며 프로퍼티 값이 함수인 경우 이를 메서드라 한다.\n\n프로퍼티 이름의 따옴표(‘’ 또는 ““)는 자바스크립트에서 사용할 수 있는 유효한 이름이고 예약어가 아닌 경우 생략할 수 있다. 반대로 말하면 **자바스크립트에서 사용할 수 있는 유효한 이름이 아닌 경우 반드시 따옴표를 사용**하여야 한다.\n\n```javascript\nvar person = {\n  'first-name': 'Ung-mo', /* 유효하지 않은 이름, 연산자가 있는 표현식 */\n  'last-name': 'Lee', /* 프로퍼티 이름에 따옴표를 쓰지 않으면, 연산을 수행한다. last라는 변수를 찾으려고 할 것이다. 이로 인해 에러가 발생한다. */\n  gender: 'male',\n  function: 1 /* OK. 하지만 예약어는 사용하지 말아야 한다. */\n};\n\nconsole.log(person.function);\n```\n\n> **명명 규칙**  \n\n- 스네이크케이스: 공백(space) 대신 _(언더라인) 사용 (e.g. `first_name`)\n- 케밥케이스: 공백 대신 - 사용 (e.g. `first-name`)\n- 카멜케이스: 공백 대신 앞 문자를 대문자로 (e.g. `firstName`)\n\n또한 예약어와 키워드는 사용하면 안 된다. 사용하여도 에러를 발생시키지는 않지만, 언제 에상치 못한 에러가 발생할지 모르기 때문이다.\n\n### 2) 프로퍼티 값 읽기\n객체의 프로퍼티에 접근하려면 아래 두 방법을 사용한다.\n* 마침표(.) 표기법\n* 대괄호([])표기법\n\n```javascript\nvar person = {\n  'first-name': 'Ung-mo',\n  'last-name': 'Lee',\n  gender: 'male',\n};\n\nconsole.log(person);\n\nconsole.log(person.first-name);     // NaN: undefined-name, first-name은 마이너스 연산을 하려고 하기 때문에 프로퍼티에 접근하기도 전에 프로퍼티 명에서부터 NaN을 반환한다.\nconsole.log(person[first-name]);   // ReferenceError: first is not defined\nconsole.log(person['first-name']); // 'Ung-mo'\n\nconsole.log(person.gender);    // 'male'\nconsole.log(person[gender]);   // ReferenceError: gender is not defined\nconsole.log(person['gender']); // 'male'\n```\n\n프로퍼티 이름이 유효한 자바스크립트 이름이고 예약어가 아닌 경우 프로퍼티 값은 마침표 표기법, 대괄호 표기법 모두 사용할 수 있다.\n\n프로퍼티 이름이 유효한 자바스크립트 이름이 아니거나 예약어인 경우 프로퍼티 값은 대괄호 표기법으로 읽어야 한다. 대괄호([]) 표기법을 사용하는 경우, **대괄호 내에 들어가는 프로퍼티 이름은 반드시 문자열**이어야 한다.\n\n객체에 존재하지 않는 프로퍼티를 참조하면 `undefined`를 반환한다.\n\n```javascript\nvar person = {\n  'first-name': 'Ung-mo',\n  'last-name': 'Lee',\n  gender: 'male',\n}\n\nconsole.log(person.age); // undefined\n````\n\n### 3) 프로퍼티 값 갱신\n\n객체가 소유하고 있는 프로퍼티에 새로운 값을 할당하면 프로퍼티 값은 새로운 값으로 갱신된다.\n\n```javascript\nvar person = {\n  'first-name': 'Ung-mo',\n  'last-name': 'Lee',\n  gender: 'male',\n};\n\nperson['first-name'] = 'Kim';\nconsole.log(person['first-name'] ); // 'Kim'\n```\n\n### 4) 프로퍼티 동적 생성\n객체가 소유하고 있지 않은 프로퍼티에 값을 할당하면 하면 해당 프로퍼티를 객체에 추가하고 값을 할당한다.\n\n```javascript\nvar person = {\n  'first-name': 'Ung-mo',\n  'last-name': 'Lee',\n  gender: 'male',\n};\n\nperson.age = 20;\nconsole.log(person.age); // 20\n```\n\n### 5) 프로퍼티 삭제\n`delete` 연산자를 사용하면 객체의 프로퍼티를 삭제할 수 있다. `delete` 연산자는 당연하게도, 객체가 소유하지 않는 프로퍼티에 적용할 수 없다.\n\n```javascript\nvar person = {\n  'first-name': 'Ung-mo',\n  'last-name': 'Lee',\n  gender: 'male',\n};\n\ndelete person.gender;\nconsole.log(person.gender); // undefined\n\ndelete person;\nconsole.log(person); // Object {first-name: 'Ung-mo', last-name: 'Lee'}\n```\n\n### 6) for-in문\n\n`for-in`문을 사용하면 객체에 포함된 모든 프로퍼티에 대해 루프를 수행할 수 있다.\n\n```javascript\nvar person = {\n  'first-name': 'Ung-mo',\n  'last-name': 'Lee',\n  gender: 'male'\n};\n\nfor(var prop in person) {\n  console.log(prop + ': ' + person[prop]);\n}\n\n/*\nfirst-name: Ung-mo\nlast-name: Lee\ngender: male\n*/\n```\nfor-in문은 여러가지 이유로 사용하지 않는다. 일단, 순서가 보장되지 않는다. es6에서 이를 보완한 for ~ of문이 나와있다. \n\n# 4. Pass-by-reference\n기본자료형 object를 객체형 또는 참조형이라 한다. 참조형이란 객체의 모든 연산이 실제값이 아닌 참조값으로 처리됨을 의미한다.\n이에 반해 기본자료형의 값은 값(value)으로 전달된다. 즉 복사되어 전달된다. 이를 pass-by-value라고 한다.\n기본자료형은 값이 한번 정해지면 변경할 수 없지만(immutable), 객체는 변경 가능한 프로퍼티들의 집합이라 할 수 있다.\n\n참조값을 준다는 것은 **단일 객체**를 사용한다는 의미이다.\n\n[immutable](http://poiemaweb.com/js-immutability)객체는 참조형이다. 객체에 객체를 할당했을 때, 결국 똑같은 객체를 가리킨다.\n\n# 5. Pass-by-value\n\n# 6. 객체의 분류\n\n![객체의 분류](http://poiemaweb.com/img/object.png)\n\nBulit-in Object(내장 객체)\n\n* Standard Built-in Object(or Global Objects)\n\n\n* Native Object\n  * BOM(Browser Object Model): 브라우저에 대한 것을 컨트롤하기 위한 객체 (e.g. 스크롤)\n  * DOM(Document Object Model): html과 css에 대한 정보를 담고 있는 객체\n\n\n\n\n---\n[참고]  \n[Poeima web](http://poiemaweb.com/js-data-type-variable)  \n[MDN ko](https://developer.mozilla.org/ko/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript)  \n[blog](http://insanehong.kr/post/javascript-object/)  \n[blog - this](https://hyunseob.github.io/2016/03/10/javascript-this/)\n","slug":"Javascript/01.Object","published":1,"updated":"2017-09-21T05:52:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjai8h17w000cvb9q5akg1lji","content":"<p><img src=\"https://www.bram.us/wordpress/wp-content/uploads/2016/06/javascript-logo-banner.jpg\" alt=\"\"></p><h1 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h1><h2 id=\"1-객체-Object-란\"><a href=\"#1-객체-Object-란\" class=\"headerlink\" title=\"1. 객체(Object)란?\"></a>1. 객체(Object)란?</h2><p>자바스크립트는 객체(Object)기반의 스크립트 언어이며 자바스크립트를 이루고 있는 거의 “모든 것”은 객체이다. <strong>기본 자료형(primitives)을 제외한</strong> 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체이다.</p><blockquote><p><strong><a href=\"https://developer.mozilla.org/ko/docs/Glossary/Primitive\" target=\"_blank\" rel=\"external\">primitives</a></strong><br>프리미티브: 객체도 아니고 메소드도 아닌 데이터. string/number/boolean/null/undefined/symbol로 6개의 기본 데이터 타입이 있다.<br>null과 undefined를 제외하고 모든 프리미티브 값은 래퍼 객체를 갖는다.</p><ul><li>string을 위한 String객체</li><li>number를 위한 Number객체</li><li>boolean을 위한 Boolean객체</li><li>Symbol을 위한 Symbol객체</li></ul><p>모두 Bulit-in Object(자바스크립트 내장객체)이다.</p></blockquote><p>객체는 데이터와 데이터 관련 동작을 모두 포함할 수 있는 개념적 존재이다. 이름(키)과 값으로 구성된 데이터를 의미하는 프로퍼티(property)와 동작을 나타내는 메서드(method)를 포함하고 있는 독립적 주체이다.</p><p>객체는 흩어져있는 것들을 모은다는 관점에서 매우 유용하다. 객체 하나는 다른 객체를 포함할 수 있기 때문에 그래프나 트리와 같은 자료구조를 쉽게 표현할 수 있다.</p><p><br></p><h3 id=\"1-프로퍼티-property\"><a href=\"#1-프로퍼티-property\" class=\"headerlink\" title=\"1) 프로퍼티(property)\"></a>1) 프로퍼티(property)</h3><p>객체는 프로퍼티들을 포함하는 컨테이너라고 할 수 있다. 프로퍼티는 객체의 속성을 나타내는 접근 가능한 이름과 활용 가능한 값을 가지는 특별한 형태이다. 프로퍼티는 객체를 활용함에 있어 매우 유용한 존재이다. 특정 객체가 가진 정보에 직접적으로 접근할 수 있게 해주기 때문이다.</p><ul><li>프로퍼티 이름 명명 규칙: 빈 문자열을 포함하는 문자열과 숫자</li><li>프로퍼티 값: <code>undefined</code> 제외, 모든 값 가능</li></ul><p>프로퍼티는 기본적으로 이름과 값으로 구성된다. 프로퍼티에 대한 접근 연산자는 <code>.</code>이다. 이 연산자를 통해 프로퍼티에 접근할 수도 있고 프로퍼티를 추가할 수도 있다.</p><p><strong><em>Q. 만약 프로퍼티에 아무런 값도 할당하지 않으면 어떻게 될까?</em></strong><br>변수는 값을 할당하지 않고 선언만 할 경우 자바스크립트 엔진이 강제로 <code>undefined</code> 를 할당한다. 하지만 프로퍼티는 값이 할당되지 않는다면 존재 이유가 없다. 객체의 정보를 담고 있어야 하는 요소가 아무 정보도 갖지 않는다면 객체로써는 이 프로퍼티가 쓸모가 없기 때문이다. 그렇기 때문에 프로퍼티를 추가하면서 값을 할당하지 않으면 <code>syntax error</code> 가 발생한다. 만약 값을 비워둬야 한다면 빈문자열(<code>&#39;&#39;</code>)을 넣는 것이 바람직하다.</p><p><br></p><h3 id=\"2-메서드-Method\"><a href=\"#2-메서드-Method\" class=\"headerlink\" title=\"2) 메서드(Method)\"></a>2) 메서드(Method)</h3><p>메서드는 <strong>객체에 제한되어 있는 함수</strong>를 의미한다. 따라서 메서드 함수의 호출은 객체에 의해서만 가능하다.(=메서드를 호출하는 주체가 해당 함수를 프로퍼티로 가지고 있는 객체이다.) <em><sup>1)</sup>함수를 객체의 프로퍼티로 할당하고, 그 프로퍼티를 사용하여 참조에 의한 호출이 일어나면, 함수는 그 객체의 메서드로 호출된다.</em> 즉 <strong>프로퍼티 값이 함수일 경우</strong>, 일반 함수와 구분하기 위해 메서드라 칭한다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> foo = &#123;&#125;; <span class=\"comment\">//Object</span></div><div class=\"line\">foo.whatever = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;; <span class=\"comment\">//method of foo(Object)</span></div><div class=\"line\">foo.whatever();</div></pre></td></tr></table></figure><p><br></p><h2 id=\"2-객체-생성-방법\"><a href=\"#2-객체-생성-방법\" class=\"headerlink\" title=\"2. 객체 생성 방법\"></a>2. 객체 생성 방법</h2><p>자바에서는 클래스를 사전에 정의하고 필요한 시점에 new 연산자를 사용하여 인스턴스를 생성하는 방식으로 객체를 생성한다. 하지만 자바스크립트는 클래스 개념이 없고 별도의 객체 생성 방법이 존재한다.</p><h3 id=\"1-객체-리터럴\"><a href=\"#1-객체-리터럴\" class=\"headerlink\" title=\"1) 객체 리터럴\"></a>1) 객체 리터럴</h3><p>가장 일반적이며 간편한 자바스크립트 객체 생성 방식이다. 중괄호(<code>{}</code>)를 이용하여 객체를 생성하는데 <code>{}</code> 내에 아무것도 기술하지 않으면 빈 객체가 생성된다. {} 내에 <strong><code>프로퍼티이름: 프로퍼티값</code></strong> 을 기술하면 해당 프로퍼티가 추가된 객체를 생성할 수 있다. 객체 리터럴 방식의 특징은 new 연산자를 사용할 필요없이 선언과 동시에 인스턴스가 생성된다는 것이다.</p><blockquote><p><code>{name:value}</code> 형태의 구성 방식을 <strong>JSON(javascript object notation) 방식</strong>이라고 한다.</p></blockquote><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> emptyObject = &#123;&#125;;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> emptyObject); <span class=\"comment\">// object</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;</div><div class=\"line\">  name: <span class=\"string\">'Lee'</span>,</div><div class=\"line\">  gender: <span class=\"string\">'male'</span>,</div><div class=\"line\">  sayHello: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi! My name is '</span> + <span class=\"keyword\">this</span>.name);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> person); <span class=\"comment\">// object</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person); <span class=\"comment\">// &#123; name: 'Lee', gender: 'male', sayHello: [Function: sayHello] &#125;</span></div><div class=\"line\"></div><div class=\"line\">person.sayHello(); <span class=\"comment\">// Hi! My name is Lee</span></div><div class=\"line\"><span class=\"string\">`</span></div></pre></td></tr></table></figure><p><br></p><h3 id=\"2-Object-생성자-함수\"><a href=\"#2-Object-생성자-함수\" class=\"headerlink\" title=\"2) Object() 생성자 함수\"></a>2) Object() 생성자 함수</h3><p>object를 만드는 함수이다. new 연산자를 반드시 함께 사용해야 한다. new 연산자와 함께 사용하여 빈 객체를 생성할 수 있다. 우선 빈 객체를 생성하고, 이후에 프로퍼티와 메서드를 추가하여 객체를 완성하는 방법이다.</p><p>객체의 프로퍼티에 새로운 값을 할당하면, 프로퍼티 값은 갱신된다. 객체가 소유하고 있지 않은 프로퍼티에 값을 할당하면, 해당 객체에 프로퍼티 추가하고 값을 할당을 한다. 아래와 같은 방식으로 선언한다.<br></p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div></pre></td></tr></table></figure><p></p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>(); <span class=\"comment\">// obj에는 빈 객체가 들어온다.</span></div><div class=\"line\"><span class=\"comment\">//프로퍼티 추가</span></div><div class=\"line\">person.name = <span class=\"string\">'Lee'</span>; <span class=\"comment\">//name 프로퍼티에 'Lee'값을 할당한다.</span></div><div class=\"line\">person.gender = <span class=\"string\">'male'</span>;</div><div class=\"line\">person.sayHello = <span class=\"string\">'Hello'</span>;</div><div class=\"line\">...</div></pre></td></tr></table></figure><p>이 방식은 별로 유용하지 않아 보인다.<br>반드시 new 연산자와 Object() 생성자 함수를 사용하여 빈객체를 생성해야 하는 것은 아니다. 객체를 생성하는 방법은 객체 리터럴을 사용하는 것이 더 간편하다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;&#125;;</div><div class=\"line\">person.name = <span class=\"string\">'Lee'</span>;</div><div class=\"line\">person.gender = <span class=\"string\">'male'</span>;</div><div class=\"line\">person.sayHello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi! My name is '</span> + <span class=\"keyword\">this</span>.name);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure><p>위와 같이 객체를 생성할 수도 있기 때문에다. 사실 이렇게 선언해도 자바스크립트 엔진은 Object 생성자를 불러서 객체를 만든다. 그러니 위와 같은 선언 방식은 shorthand인 셈이다.</p><blockquote><p>Object() 생성자는 사실 node에서 사용한다.</p></blockquote><p><br></p><h3 id=\"3-생성자-함수\"><a href=\"#3-생성자-함수\" class=\"headerlink\" title=\"3) 생성자 함수\"></a>3) 생성자 함수</h3><p>객체 리터럴 방식과 Object() 생성자 함수 방식으로 객체를 생성하는 것은 프로퍼티 값만 다른 여러개의 객체 생성에 불편이 있다. 동일한 프로퍼티를 갖는 객체임에도 불구하고 매번 같은 프로퍼티를 기술해야한다.<br>따라서, <strong>유사 객체를 다량 생산 해야 할때, 생성자 함수가 매우 유용하게 쓰일 수 있다.</strong></p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person1 = &#123;</div><div class=\"line\">  name: <span class=\"string\">'Lee'</span>,</div><div class=\"line\">  gender: <span class=\"string\">'male'</span>,</div><div class=\"line\">  sayHello: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi! My name is '</span> + <span class=\"keyword\">this</span>.name);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> person2 = &#123;</div><div class=\"line\">  name: <span class=\"string\">'Kim'</span>,</div><div class=\"line\">  gender: <span class=\"string\">'female'</span>,</div><div class=\"line\">  sayHello: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi! My name is '</span> + <span class=\"keyword\">this</span>.name);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure><p>생성자 함수를 사용하면 마치 객체를 생성하기 위한 탬플릿(클래스)처럼 사용하여 구성이 동일한 객체 여러개를 간편하게 생성할 수 있다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 생성자 함수</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, gender</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  <span class=\"keyword\">this</span>.gender = gender;</div><div class=\"line\">  <span class=\"keyword\">this</span>.sayHello = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi! My name is '</span> + <span class=\"keyword\">this</span>.name);</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 인스턴스의 생성</span></div><div class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Lee'</span>, <span class=\"string\">'male'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Kim'</span>, <span class=\"string\">'female'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'person1: '</span>, <span class=\"keyword\">typeof</span> person1);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'person2: '</span>, <span class=\"keyword\">typeof</span> person2);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'person1: '</span>, person1);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'person2: '</span>, person2);</div><div class=\"line\"></div><div class=\"line\">person1.sayHello();</div><div class=\"line\">person2.sayHello();</div></pre></td></tr></table></figure><blockquote><p>생성자는 인스턴스를 찍어내는 공장이며, 인스턴스는 실제 객체이다.</p></blockquote><p>생성자는 일반 함수로 사용하지 않고, 객체를 찍어낼 때만 사용해야 한다. 따라서 첫 문자를 대문자로 하는 관습이 있다. 생성자 함수임을 인식하는데 도움을 주기 위함이다. 따라서 생성자를 만들때는 이 관습을 지켜 네이밍하도록 한다.</p><p>프로퍼티 또는 메서드명 앞에 기술한 <code>this</code>는 생성자 함수로 생성될 인스턴스를 가리킨다. 따라서 <code>this</code>에 연결되어 있는 프로퍼티와 메서드는 <code>public</code>이다.</p><hr><p><br></p><h2 id=\"3-객체-프로퍼티-접근\"><a href=\"#3-객체-프로퍼티-접근\" class=\"headerlink\" title=\"3. 객체 프로퍼티 접근\"></a>3. 객체 프로퍼티 접근</h2><p>1) 프로퍼티 이름<br>프로퍼티 이름에는 문자열(빈 문자열 포함)과 숫자가 올 수 있다. 프로퍼티 값은 undefined을 제외한 모든 값과 표현식이 올 수 있으며 프로퍼티 값이 함수인 경우 이를 메서드라 한다.</p><p>프로퍼티 이름의 따옴표(‘’ 또는 ““)는 자바스크립트에서 사용할 수 있는 유효한 이름이고 예약어가 아닌 경우 생략할 수 있다. 반대로 말하면 <strong>자바스크립트에서 사용할 수 있는 유효한 이름이 아닌 경우 반드시 따옴표를 사용</strong>하여야 한다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;</div><div class=\"line\">  <span class=\"string\">'first-name'</span>: <span class=\"string\">'Ung-mo'</span>, <span class=\"comment\">/* 유효하지 않은 이름, 연산자가 있는 표현식 */</span></div><div class=\"line\">  <span class=\"string\">'last-name'</span>: <span class=\"string\">'Lee'</span>, <span class=\"comment\">/* 프로퍼티 이름에 따옴표를 쓰지 않으면, 연산을 수행한다. last라는 변수를 찾으려고 할 것이다. 이로 인해 에러가 발생한다. */</span></div><div class=\"line\">  gender: <span class=\"string\">'male'</span>,</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span>: 1 /* <span class=\"title\">OK</span>. 하지만 예약어는 사용하지 말아야 한다. */</span></div><div class=\"line\"><span class=\"function\">&#125;;</span></div><div class=\"line\"><span class=\"function\"></span></div><div class=\"line\"><span class=\"function\"><span class=\"title\">console</span>.<span class=\"title\">log</span>(<span class=\"params\">person.function</span>);</span></div></pre></td></tr></table></figure><blockquote><p><strong>명명 규칙</strong></p></blockquote><ul><li>스네이크케이스: 공백(space) 대신 _(언더라인) 사용 (e.g. <code>first_name</code>)</li><li>케밥케이스: 공백 대신 - 사용 (e.g. <code>first-name</code>)</li><li>카멜케이스: 공백 대신 앞 문자를 대문자로 (e.g. <code>firstName</code>)</li></ul><p>또한 예약어와 키워드는 사용하면 안 된다. 사용하여도 에러를 발생시키지는 않지만, 언제 에상치 못한 에러가 발생할지 모르기 때문이다.</p><h3 id=\"2-프로퍼티-값-읽기\"><a href=\"#2-프로퍼티-값-읽기\" class=\"headerlink\" title=\"2) 프로퍼티 값 읽기\"></a>2) 프로퍼티 값 읽기</h3><p>객체의 프로퍼티에 접근하려면 아래 두 방법을 사용한다.</p><ul><li>마침표(.) 표기법</li><li>대괄호([])표기법</li></ul><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;</div><div class=\"line\">  <span class=\"string\">'first-name'</span>: <span class=\"string\">'Ung-mo'</span>,</div><div class=\"line\">  <span class=\"string\">'last-name'</span>: <span class=\"string\">'Lee'</span>,</div><div class=\"line\">  gender: <span class=\"string\">'male'</span>,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person.first-name);     <span class=\"comment\">// NaN: undefined-name, first-name은 마이너스 연산을 하려고 하기 때문에 프로퍼티에 접근하기도 전에 프로퍼티 명에서부터 NaN을 반환한다.</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person[first-name]);   <span class=\"comment\">// ReferenceError: first is not defined</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person[<span class=\"string\">'first-name'</span>]); <span class=\"comment\">// 'Ung-mo'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person.gender);    <span class=\"comment\">// 'male'</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person[gender]);   <span class=\"comment\">// ReferenceError: gender is not defined</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person[<span class=\"string\">'gender'</span>]); <span class=\"comment\">// 'male'</span></div></pre></td></tr></table></figure><p>프로퍼티 이름이 유효한 자바스크립트 이름이고 예약어가 아닌 경우 프로퍼티 값은 마침표 표기법, 대괄호 표기법 모두 사용할 수 있다.</p><p>프로퍼티 이름이 유효한 자바스크립트 이름이 아니거나 예약어인 경우 프로퍼티 값은 대괄호 표기법으로 읽어야 한다. 대괄호([]) 표기법을 사용하는 경우, <strong>대괄호 내에 들어가는 프로퍼티 이름은 반드시 문자열</strong>이어야 한다.</p><p>객체에 존재하지 않는 프로퍼티를 참조하면 <code>undefined</code>를 반환한다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;</div><div class=\"line\">  <span class=\"string\">'first-name'</span>: <span class=\"string\">'Ung-mo'</span>,</div><div class=\"line\">  <span class=\"string\">'last-name'</span>: <span class=\"string\">'Lee'</span>,</div><div class=\"line\">  gender: <span class=\"string\">'male'</span>,</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person.age); <span class=\"comment\">// undefined</span></div><div class=\"line\"><span class=\"string\">`</span></div></pre></td></tr></table></figure><h3 id=\"3-프로퍼티-값-갱신\"><a href=\"#3-프로퍼티-값-갱신\" class=\"headerlink\" title=\"3) 프로퍼티 값 갱신\"></a>3) 프로퍼티 값 갱신</h3><p>객체가 소유하고 있는 프로퍼티에 새로운 값을 할당하면 프로퍼티 값은 새로운 값으로 갱신된다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;</div><div class=\"line\">  <span class=\"string\">'first-name'</span>: <span class=\"string\">'Ung-mo'</span>,</div><div class=\"line\">  <span class=\"string\">'last-name'</span>: <span class=\"string\">'Lee'</span>,</div><div class=\"line\">  gender: <span class=\"string\">'male'</span>,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">person[<span class=\"string\">'first-name'</span>] = <span class=\"string\">'Kim'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(person[<span class=\"string\">'first-name'</span>] ); <span class=\"comment\">// 'Kim'</span></div></pre></td></tr></table></figure><h3 id=\"4-프로퍼티-동적-생성\"><a href=\"#4-프로퍼티-동적-생성\" class=\"headerlink\" title=\"4) 프로퍼티 동적 생성\"></a>4) 프로퍼티 동적 생성</h3><p>객체가 소유하고 있지 않은 프로퍼티에 값을 할당하면 하면 해당 프로퍼티를 객체에 추가하고 값을 할당한다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;</div><div class=\"line\">  <span class=\"string\">'first-name'</span>: <span class=\"string\">'Ung-mo'</span>,</div><div class=\"line\">  <span class=\"string\">'last-name'</span>: <span class=\"string\">'Lee'</span>,</div><div class=\"line\">  gender: <span class=\"string\">'male'</span>,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">person.age = <span class=\"number\">20</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(person.age); <span class=\"comment\">// 20</span></div></pre></td></tr></table></figure><h3 id=\"5-프로퍼티-삭제\"><a href=\"#5-프로퍼티-삭제\" class=\"headerlink\" title=\"5) 프로퍼티 삭제\"></a>5) 프로퍼티 삭제</h3><p><code>delete</code> 연산자를 사용하면 객체의 프로퍼티를 삭제할 수 있다. <code>delete</code> 연산자는 당연하게도, 객체가 소유하지 않는 프로퍼티에 적용할 수 없다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;</div><div class=\"line\">  <span class=\"string\">'first-name'</span>: <span class=\"string\">'Ung-mo'</span>,</div><div class=\"line\">  <span class=\"string\">'last-name'</span>: <span class=\"string\">'Lee'</span>,</div><div class=\"line\">  gender: <span class=\"string\">'male'</span>,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">delete</span> person.gender;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(person.gender); <span class=\"comment\">// undefined</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">delete</span> person;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(person); <span class=\"comment\">// Object &#123;first-name: 'Ung-mo', last-name: 'Lee'&#125;</span></div></pre></td></tr></table></figure><h3 id=\"6-for-in문\"><a href=\"#6-for-in문\" class=\"headerlink\" title=\"6) for-in문\"></a>6) for-in문</h3><p><code>for-in</code>문을 사용하면 객체에 포함된 모든 프로퍼티에 대해 루프를 수행할 수 있다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;</div><div class=\"line\">  <span class=\"string\">'first-name'</span>: <span class=\"string\">'Ung-mo'</span>,</div><div class=\"line\">  <span class=\"string\">'last-name'</span>: <span class=\"string\">'Lee'</span>,</div><div class=\"line\">  gender: <span class=\"string\">'male'</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> prop <span class=\"keyword\">in</span> person) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(prop + <span class=\"string\">': '</span> + person[prop]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\"><span class=\"comment\">first-name: Ung-mo</span></div><div class=\"line\"><span class=\"comment\">last-name: Lee</span></div><div class=\"line\"><span class=\"comment\">gender: male</span></div><div class=\"line\"><span class=\"comment\">*/</span></div></pre></td></tr></table></figure><p>for-in문은 여러가지 이유로 사용하지 않는다. 일단, 순서가 보장되지 않는다. es6에서 이를 보완한 for ~ of문이 나와있다.</p><h1 id=\"4-Pass-by-reference\"><a href=\"#4-Pass-by-reference\" class=\"headerlink\" title=\"4. Pass-by-reference\"></a>4. Pass-by-reference</h1><p>기본자료형 object를 객체형 또는 참조형이라 한다. 참조형이란 객체의 모든 연산이 실제값이 아닌 참조값으로 처리됨을 의미한다.<br>이에 반해 기본자료형의 값은 값(value)으로 전달된다. 즉 복사되어 전달된다. 이를 pass-by-value라고 한다.<br>기본자료형은 값이 한번 정해지면 변경할 수 없지만(immutable), 객체는 변경 가능한 프로퍼티들의 집합이라 할 수 있다.</p><p>참조값을 준다는 것은 <strong>단일 객체</strong>를 사용한다는 의미이다.</p><p><a href=\"http://poiemaweb.com/js-immutability\" target=\"_blank\" rel=\"external\">immutable</a>객체는 참조형이다. 객체에 객체를 할당했을 때, 결국 똑같은 객체를 가리킨다.</p><h1 id=\"5-Pass-by-value\"><a href=\"#5-Pass-by-value\" class=\"headerlink\" title=\"5. Pass-by-value\"></a>5. Pass-by-value</h1><h1 id=\"6-객체의-분류\"><a href=\"#6-객체의-분류\" class=\"headerlink\" title=\"6. 객체의 분류\"></a>6. 객체의 분류</h1><p><img src=\"http://poiemaweb.com/img/object.png\" alt=\"객체의 분류\"></p><p>Bulit-in Object(내장 객체)</p><ul><li>Standard Built-in Object(or Global Objects)</li></ul><ul><li>Native Object<ul><li>BOM(Browser Object Model): 브라우저에 대한 것을 컨트롤하기 위한 객체 (e.g. 스크롤)</li><li>DOM(Document Object Model): html과 css에 대한 정보를 담고 있는 객체</li></ul></li></ul><hr><p>[참고]<br><a href=\"http://poiemaweb.com/js-data-type-variable\" target=\"_blank\" rel=\"external\">Poeima web</a><br><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript\" target=\"_blank\" rel=\"external\">MDN ko</a><br><a href=\"http://insanehong.kr/post/javascript-object/\" target=\"_blank\" rel=\"external\">blog</a><br><a href=\"https://hyunseob.github.io/2016/03/10/javascript-this/\" target=\"_blank\" rel=\"external\">blog - this</a></p>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://www.bram.us/wordpress/wp-content/uploads/2016/06/javascript-logo-banner.jpg\" alt=\"\"></p><h1 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h1><h2 id=\"1-객체-Object-란\"><a href=\"#1-객체-Object-란\" class=\"headerlink\" title=\"1. 객체(Object)란?\"></a>1. 객체(Object)란?</h2><p>자바스크립트는 객체(Object)기반의 스크립트 언어이며 자바스크립트를 이루고 있는 거의 “모든 것”은 객체이다. <strong>기본 자료형(primitives)을 제외한</strong> 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체이다.</p><blockquote><p><strong><a href=\"https://developer.mozilla.org/ko/docs/Glossary/Primitive\" target=\"_blank\" rel=\"external\">primitives</a></strong><br>프리미티브: 객체도 아니고 메소드도 아닌 데이터. string/number/boolean/null/undefined/symbol로 6개의 기본 데이터 타입이 있다.<br>null과 undefined를 제외하고 모든 프리미티브 값은 래퍼 객체를 갖는다.</p><ul><li>string을 위한 String객체</li><li>number를 위한 Number객체</li><li>boolean을 위한 Boolean객체</li><li>Symbol을 위한 Symbol객체</li></ul><p>모두 Bulit-in Object(자바스크립트 내장객체)이다.</p></blockquote><p>객체는 데이터와 데이터 관련 동작을 모두 포함할 수 있는 개념적 존재이다. 이름(키)과 값으로 구성된 데이터를 의미하는 프로퍼티(property)와 동작을 나타내는 메서드(method)를 포함하고 있는 독립적 주체이다.</p><p>객체는 흩어져있는 것들을 모은다는 관점에서 매우 유용하다. 객체 하나는 다른 객체를 포함할 수 있기 때문에 그래프나 트리와 같은 자료구조를 쉽게 표현할 수 있다.</p><p><br></p><h3 id=\"1-프로퍼티-property\"><a href=\"#1-프로퍼티-property\" class=\"headerlink\" title=\"1) 프로퍼티(property)\"></a>1) 프로퍼티(property)</h3><p>객체는 프로퍼티들을 포함하는 컨테이너라고 할 수 있다. 프로퍼티는 객체의 속성을 나타내는 접근 가능한 이름과 활용 가능한 값을 가지는 특별한 형태이다. 프로퍼티는 객체를 활용함에 있어 매우 유용한 존재이다. 특정 객체가 가진 정보에 직접적으로 접근할 수 있게 해주기 때문이다.</p><ul><li>프로퍼티 이름 명명 규칙: 빈 문자열을 포함하는 문자열과 숫자</li><li>프로퍼티 값: <code>undefined</code> 제외, 모든 값 가능</li></ul><p>프로퍼티는 기본적으로 이름과 값으로 구성된다. 프로퍼티에 대한 접근 연산자는 <code>.</code>이다. 이 연산자를 통해 프로퍼티에 접근할 수도 있고 프로퍼티를 추가할 수도 있다.</p><p><strong><em>Q. 만약 프로퍼티에 아무런 값도 할당하지 않으면 어떻게 될까?</em></strong><br>변수는 값을 할당하지 않고 선언만 할 경우 자바스크립트 엔진이 강제로 <code>undefined</code> 를 할당한다. 하지만 프로퍼티는 값이 할당되지 않는다면 존재 이유가 없다. 객체의 정보를 담고 있어야 하는 요소가 아무 정보도 갖지 않는다면 객체로써는 이 프로퍼티가 쓸모가 없기 때문이다. 그렇기 때문에 프로퍼티를 추가하면서 값을 할당하지 않으면 <code>syntax error</code> 가 발생한다. 만약 값을 비워둬야 한다면 빈문자열(<code>&#39;&#39;</code>)을 넣는 것이 바람직하다.</p><p><br></p><h3 id=\"2-메서드-Method\"><a href=\"#2-메서드-Method\" class=\"headerlink\" title=\"2) 메서드(Method)\"></a>2) 메서드(Method)</h3><p>메서드는 <strong>객체에 제한되어 있는 함수</strong>를 의미한다. 따라서 메서드 함수의 호출은 객체에 의해서만 가능하다.(=메서드를 호출하는 주체가 해당 함수를 프로퍼티로 가지고 있는 객체이다.) <em><sup>1)</sup>함수를 객체의 프로퍼티로 할당하고, 그 프로퍼티를 사용하여 참조에 의한 호출이 일어나면, 함수는 그 객체의 메서드로 호출된다.</em> 즉 <strong>프로퍼티 값이 함수일 경우</strong>, 일반 함수와 구분하기 위해 메서드라 칭한다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> foo = &#123;&#125;; <span class=\"comment\">//Object</span></div><div class=\"line\">foo.whatever = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;; <span class=\"comment\">//method of foo(Object)</span></div><div class=\"line\">foo.whatever();</div></pre></td></tr></table></figure><p><br></p><h2 id=\"2-객체-생성-방법\"><a href=\"#2-객체-생성-방법\" class=\"headerlink\" title=\"2. 객체 생성 방법\"></a>2. 객체 생성 방법</h2><p>자바에서는 클래스를 사전에 정의하고 필요한 시점에 new 연산자를 사용하여 인스턴스를 생성하는 방식으로 객체를 생성한다. 하지만 자바스크립트는 클래스 개념이 없고 별도의 객체 생성 방법이 존재한다.</p><h3 id=\"1-객체-리터럴\"><a href=\"#1-객체-리터럴\" class=\"headerlink\" title=\"1) 객체 리터럴\"></a>1) 객체 리터럴</h3><p>가장 일반적이며 간편한 자바스크립트 객체 생성 방식이다. 중괄호(<code>{}</code>)를 이용하여 객체를 생성하는데 <code>{}</code> 내에 아무것도 기술하지 않으면 빈 객체가 생성된다. {} 내에 <strong><code>프로퍼티이름: 프로퍼티값</code></strong> 을 기술하면 해당 프로퍼티가 추가된 객체를 생성할 수 있다. 객체 리터럴 방식의 특징은 new 연산자를 사용할 필요없이 선언과 동시에 인스턴스가 생성된다는 것이다.</p><blockquote><p><code>{name:value}</code> 형태의 구성 방식을 <strong>JSON(javascript object notation) 방식</strong>이라고 한다.</p></blockquote><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> emptyObject = &#123;&#125;;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> emptyObject); <span class=\"comment\">// object</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;</div><div class=\"line\">  name: <span class=\"string\">'Lee'</span>,</div><div class=\"line\">  gender: <span class=\"string\">'male'</span>,</div><div class=\"line\">  sayHello: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi! My name is '</span> + <span class=\"keyword\">this</span>.name);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> person); <span class=\"comment\">// object</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person); <span class=\"comment\">// &#123; name: 'Lee', gender: 'male', sayHello: [Function: sayHello] &#125;</span></div><div class=\"line\"></div><div class=\"line\">person.sayHello(); <span class=\"comment\">// Hi! My name is Lee</span></div><div class=\"line\"><span class=\"string\">`</span></div></pre></td></tr></table></figure><p><br></p><h3 id=\"2-Object-생성자-함수\"><a href=\"#2-Object-생성자-함수\" class=\"headerlink\" title=\"2) Object() 생성자 함수\"></a>2) Object() 생성자 함수</h3><p>object를 만드는 함수이다. new 연산자를 반드시 함께 사용해야 한다. new 연산자와 함께 사용하여 빈 객체를 생성할 수 있다. 우선 빈 객체를 생성하고, 이후에 프로퍼티와 메서드를 추가하여 객체를 완성하는 방법이다.</p><p>객체의 프로퍼티에 새로운 값을 할당하면, 프로퍼티 값은 갱신된다. 객체가 소유하고 있지 않은 프로퍼티에 값을 할당하면, 해당 객체에 프로퍼티 추가하고 값을 할당을 한다. 아래와 같은 방식으로 선언한다.<br></p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div></pre></td></tr></table></figure><p></p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>(); <span class=\"comment\">// obj에는 빈 객체가 들어온다.</span></div><div class=\"line\"><span class=\"comment\">//프로퍼티 추가</span></div><div class=\"line\">person.name = <span class=\"string\">'Lee'</span>; <span class=\"comment\">//name 프로퍼티에 'Lee'값을 할당한다.</span></div><div class=\"line\">person.gender = <span class=\"string\">'male'</span>;</div><div class=\"line\">person.sayHello = <span class=\"string\">'Hello'</span>;</div><div class=\"line\">...</div></pre></td></tr></table></figure><p>이 방식은 별로 유용하지 않아 보인다.<br>반드시 new 연산자와 Object() 생성자 함수를 사용하여 빈객체를 생성해야 하는 것은 아니다. 객체를 생성하는 방법은 객체 리터럴을 사용하는 것이 더 간편하다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;&#125;;</div><div class=\"line\">person.name = <span class=\"string\">'Lee'</span>;</div><div class=\"line\">person.gender = <span class=\"string\">'male'</span>;</div><div class=\"line\">person.sayHello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi! My name is '</span> + <span class=\"keyword\">this</span>.name);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure><p>위와 같이 객체를 생성할 수도 있기 때문에다. 사실 이렇게 선언해도 자바스크립트 엔진은 Object 생성자를 불러서 객체를 만든다. 그러니 위와 같은 선언 방식은 shorthand인 셈이다.</p><blockquote><p>Object() 생성자는 사실 node에서 사용한다.</p></blockquote><p><br></p><h3 id=\"3-생성자-함수\"><a href=\"#3-생성자-함수\" class=\"headerlink\" title=\"3) 생성자 함수\"></a>3) 생성자 함수</h3><p>객체 리터럴 방식과 Object() 생성자 함수 방식으로 객체를 생성하는 것은 프로퍼티 값만 다른 여러개의 객체 생성에 불편이 있다. 동일한 프로퍼티를 갖는 객체임에도 불구하고 매번 같은 프로퍼티를 기술해야한다.<br>따라서, <strong>유사 객체를 다량 생산 해야 할때, 생성자 함수가 매우 유용하게 쓰일 수 있다.</strong></p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person1 = &#123;</div><div class=\"line\">  name: <span class=\"string\">'Lee'</span>,</div><div class=\"line\">  gender: <span class=\"string\">'male'</span>,</div><div class=\"line\">  sayHello: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi! My name is '</span> + <span class=\"keyword\">this</span>.name);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> person2 = &#123;</div><div class=\"line\">  name: <span class=\"string\">'Kim'</span>,</div><div class=\"line\">  gender: <span class=\"string\">'female'</span>,</div><div class=\"line\">  sayHello: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi! My name is '</span> + <span class=\"keyword\">this</span>.name);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure><p>생성자 함수를 사용하면 마치 객체를 생성하기 위한 탬플릿(클래스)처럼 사용하여 구성이 동일한 객체 여러개를 간편하게 생성할 수 있다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 생성자 함수</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, gender</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  <span class=\"keyword\">this</span>.gender = gender;</div><div class=\"line\">  <span class=\"keyword\">this</span>.sayHello = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi! My name is '</span> + <span class=\"keyword\">this</span>.name);</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 인스턴스의 생성</span></div><div class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Lee'</span>, <span class=\"string\">'male'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Kim'</span>, <span class=\"string\">'female'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'person1: '</span>, <span class=\"keyword\">typeof</span> person1);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'person2: '</span>, <span class=\"keyword\">typeof</span> person2);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'person1: '</span>, person1);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'person2: '</span>, person2);</div><div class=\"line\"></div><div class=\"line\">person1.sayHello();</div><div class=\"line\">person2.sayHello();</div></pre></td></tr></table></figure><blockquote><p>생성자는 인스턴스를 찍어내는 공장이며, 인스턴스는 실제 객체이다.</p></blockquote><p>생성자는 일반 함수로 사용하지 않고, 객체를 찍어낼 때만 사용해야 한다. 따라서 첫 문자를 대문자로 하는 관습이 있다. 생성자 함수임을 인식하는데 도움을 주기 위함이다. 따라서 생성자를 만들때는 이 관습을 지켜 네이밍하도록 한다.</p><p>프로퍼티 또는 메서드명 앞에 기술한 <code>this</code>는 생성자 함수로 생성될 인스턴스를 가리킨다. 따라서 <code>this</code>에 연결되어 있는 프로퍼티와 메서드는 <code>public</code>이다.</p><hr><p><br></p><h2 id=\"3-객체-프로퍼티-접근\"><a href=\"#3-객체-프로퍼티-접근\" class=\"headerlink\" title=\"3. 객체 프로퍼티 접근\"></a>3. 객체 프로퍼티 접근</h2><p>1) 프로퍼티 이름<br>프로퍼티 이름에는 문자열(빈 문자열 포함)과 숫자가 올 수 있다. 프로퍼티 값은 undefined을 제외한 모든 값과 표현식이 올 수 있으며 프로퍼티 값이 함수인 경우 이를 메서드라 한다.</p><p>프로퍼티 이름의 따옴표(‘’ 또는 ““)는 자바스크립트에서 사용할 수 있는 유효한 이름이고 예약어가 아닌 경우 생략할 수 있다. 반대로 말하면 <strong>자바스크립트에서 사용할 수 있는 유효한 이름이 아닌 경우 반드시 따옴표를 사용</strong>하여야 한다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;</div><div class=\"line\">  <span class=\"string\">'first-name'</span>: <span class=\"string\">'Ung-mo'</span>, <span class=\"comment\">/* 유효하지 않은 이름, 연산자가 있는 표현식 */</span></div><div class=\"line\">  <span class=\"string\">'last-name'</span>: <span class=\"string\">'Lee'</span>, <span class=\"comment\">/* 프로퍼티 이름에 따옴표를 쓰지 않으면, 연산을 수행한다. last라는 변수를 찾으려고 할 것이다. 이로 인해 에러가 발생한다. */</span></div><div class=\"line\">  gender: <span class=\"string\">'male'</span>,</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span>: 1 /* <span class=\"title\">OK</span>. 하지만 예약어는 사용하지 말아야 한다. */</span></div><div class=\"line\"><span class=\"function\">&#125;;</span></div><div class=\"line\"><span class=\"function\"></span></div><div class=\"line\"><span class=\"function\"><span class=\"title\">console</span>.<span class=\"title\">log</span>(<span class=\"params\">person.function</span>);</span></div></pre></td></tr></table></figure><blockquote><p><strong>명명 규칙</strong></p></blockquote><ul><li>스네이크케이스: 공백(space) 대신 _(언더라인) 사용 (e.g. <code>first_name</code>)</li><li>케밥케이스: 공백 대신 - 사용 (e.g. <code>first-name</code>)</li><li>카멜케이스: 공백 대신 앞 문자를 대문자로 (e.g. <code>firstName</code>)</li></ul><p>또한 예약어와 키워드는 사용하면 안 된다. 사용하여도 에러를 발생시키지는 않지만, 언제 에상치 못한 에러가 발생할지 모르기 때문이다.</p><h3 id=\"2-프로퍼티-값-읽기\"><a href=\"#2-프로퍼티-값-읽기\" class=\"headerlink\" title=\"2) 프로퍼티 값 읽기\"></a>2) 프로퍼티 값 읽기</h3><p>객체의 프로퍼티에 접근하려면 아래 두 방법을 사용한다.</p><ul><li>마침표(.) 표기법</li><li>대괄호([])표기법</li></ul><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;</div><div class=\"line\">  <span class=\"string\">'first-name'</span>: <span class=\"string\">'Ung-mo'</span>,</div><div class=\"line\">  <span class=\"string\">'last-name'</span>: <span class=\"string\">'Lee'</span>,</div><div class=\"line\">  gender: <span class=\"string\">'male'</span>,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person.first-name);     <span class=\"comment\">// NaN: undefined-name, first-name은 마이너스 연산을 하려고 하기 때문에 프로퍼티에 접근하기도 전에 프로퍼티 명에서부터 NaN을 반환한다.</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person[first-name]);   <span class=\"comment\">// ReferenceError: first is not defined</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person[<span class=\"string\">'first-name'</span>]); <span class=\"comment\">// 'Ung-mo'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person.gender);    <span class=\"comment\">// 'male'</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person[gender]);   <span class=\"comment\">// ReferenceError: gender is not defined</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person[<span class=\"string\">'gender'</span>]); <span class=\"comment\">// 'male'</span></div></pre></td></tr></table></figure><p>프로퍼티 이름이 유효한 자바스크립트 이름이고 예약어가 아닌 경우 프로퍼티 값은 마침표 표기법, 대괄호 표기법 모두 사용할 수 있다.</p><p>프로퍼티 이름이 유효한 자바스크립트 이름이 아니거나 예약어인 경우 프로퍼티 값은 대괄호 표기법으로 읽어야 한다. 대괄호([]) 표기법을 사용하는 경우, <strong>대괄호 내에 들어가는 프로퍼티 이름은 반드시 문자열</strong>이어야 한다.</p><p>객체에 존재하지 않는 프로퍼티를 참조하면 <code>undefined</code>를 반환한다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;</div><div class=\"line\">  <span class=\"string\">'first-name'</span>: <span class=\"string\">'Ung-mo'</span>,</div><div class=\"line\">  <span class=\"string\">'last-name'</span>: <span class=\"string\">'Lee'</span>,</div><div class=\"line\">  gender: <span class=\"string\">'male'</span>,</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person.age); <span class=\"comment\">// undefined</span></div><div class=\"line\"><span class=\"string\">`</span></div></pre></td></tr></table></figure><h3 id=\"3-프로퍼티-값-갱신\"><a href=\"#3-프로퍼티-값-갱신\" class=\"headerlink\" title=\"3) 프로퍼티 값 갱신\"></a>3) 프로퍼티 값 갱신</h3><p>객체가 소유하고 있는 프로퍼티에 새로운 값을 할당하면 프로퍼티 값은 새로운 값으로 갱신된다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;</div><div class=\"line\">  <span class=\"string\">'first-name'</span>: <span class=\"string\">'Ung-mo'</span>,</div><div class=\"line\">  <span class=\"string\">'last-name'</span>: <span class=\"string\">'Lee'</span>,</div><div class=\"line\">  gender: <span class=\"string\">'male'</span>,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">person[<span class=\"string\">'first-name'</span>] = <span class=\"string\">'Kim'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(person[<span class=\"string\">'first-name'</span>] ); <span class=\"comment\">// 'Kim'</span></div></pre></td></tr></table></figure><h3 id=\"4-프로퍼티-동적-생성\"><a href=\"#4-프로퍼티-동적-생성\" class=\"headerlink\" title=\"4) 프로퍼티 동적 생성\"></a>4) 프로퍼티 동적 생성</h3><p>객체가 소유하고 있지 않은 프로퍼티에 값을 할당하면 하면 해당 프로퍼티를 객체에 추가하고 값을 할당한다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;</div><div class=\"line\">  <span class=\"string\">'first-name'</span>: <span class=\"string\">'Ung-mo'</span>,</div><div class=\"line\">  <span class=\"string\">'last-name'</span>: <span class=\"string\">'Lee'</span>,</div><div class=\"line\">  gender: <span class=\"string\">'male'</span>,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">person.age = <span class=\"number\">20</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(person.age); <span class=\"comment\">// 20</span></div></pre></td></tr></table></figure><h3 id=\"5-프로퍼티-삭제\"><a href=\"#5-프로퍼티-삭제\" class=\"headerlink\" title=\"5) 프로퍼티 삭제\"></a>5) 프로퍼티 삭제</h3><p><code>delete</code> 연산자를 사용하면 객체의 프로퍼티를 삭제할 수 있다. <code>delete</code> 연산자는 당연하게도, 객체가 소유하지 않는 프로퍼티에 적용할 수 없다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;</div><div class=\"line\">  <span class=\"string\">'first-name'</span>: <span class=\"string\">'Ung-mo'</span>,</div><div class=\"line\">  <span class=\"string\">'last-name'</span>: <span class=\"string\">'Lee'</span>,</div><div class=\"line\">  gender: <span class=\"string\">'male'</span>,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">delete</span> person.gender;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(person.gender); <span class=\"comment\">// undefined</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">delete</span> person;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(person); <span class=\"comment\">// Object &#123;first-name: 'Ung-mo', last-name: 'Lee'&#125;</span></div></pre></td></tr></table></figure><h3 id=\"6-for-in문\"><a href=\"#6-for-in문\" class=\"headerlink\" title=\"6) for-in문\"></a>6) for-in문</h3><p><code>for-in</code>문을 사용하면 객체에 포함된 모든 프로퍼티에 대해 루프를 수행할 수 있다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;</div><div class=\"line\">  <span class=\"string\">'first-name'</span>: <span class=\"string\">'Ung-mo'</span>,</div><div class=\"line\">  <span class=\"string\">'last-name'</span>: <span class=\"string\">'Lee'</span>,</div><div class=\"line\">  gender: <span class=\"string\">'male'</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> prop <span class=\"keyword\">in</span> person) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(prop + <span class=\"string\">': '</span> + person[prop]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\"><span class=\"comment\">first-name: Ung-mo</span></div><div class=\"line\"><span class=\"comment\">last-name: Lee</span></div><div class=\"line\"><span class=\"comment\">gender: male</span></div><div class=\"line\"><span class=\"comment\">*/</span></div></pre></td></tr></table></figure><p>for-in문은 여러가지 이유로 사용하지 않는다. 일단, 순서가 보장되지 않는다. es6에서 이를 보완한 for ~ of문이 나와있다.</p><h1 id=\"4-Pass-by-reference\"><a href=\"#4-Pass-by-reference\" class=\"headerlink\" title=\"4. Pass-by-reference\"></a>4. Pass-by-reference</h1><p>기본자료형 object를 객체형 또는 참조형이라 한다. 참조형이란 객체의 모든 연산이 실제값이 아닌 참조값으로 처리됨을 의미한다.<br>이에 반해 기본자료형의 값은 값(value)으로 전달된다. 즉 복사되어 전달된다. 이를 pass-by-value라고 한다.<br>기본자료형은 값이 한번 정해지면 변경할 수 없지만(immutable), 객체는 변경 가능한 프로퍼티들의 집합이라 할 수 있다.</p><p>참조값을 준다는 것은 <strong>단일 객체</strong>를 사용한다는 의미이다.</p><p><a href=\"http://poiemaweb.com/js-immutability\" target=\"_blank\" rel=\"external\">immutable</a>객체는 참조형이다. 객체에 객체를 할당했을 때, 결국 똑같은 객체를 가리킨다.</p><h1 id=\"5-Pass-by-value\"><a href=\"#5-Pass-by-value\" class=\"headerlink\" title=\"5. Pass-by-value\"></a>5. Pass-by-value</h1><h1 id=\"6-객체의-분류\"><a href=\"#6-객체의-분류\" class=\"headerlink\" title=\"6. 객체의 분류\"></a>6. 객체의 분류</h1><p><img src=\"http://poiemaweb.com/img/object.png\" alt=\"객체의 분류\"></p><p>Bulit-in Object(내장 객체)</p><ul><li>Standard Built-in Object(or Global Objects)</li></ul><ul><li>Native Object<ul><li>BOM(Browser Object Model): 브라우저에 대한 것을 컨트롤하기 위한 객체 (e.g. 스크롤)</li><li>DOM(Document Object Model): html과 css에 대한 정보를 담고 있는 객체</li></ul></li></ul><hr><p>[참고]<br><a href=\"http://poiemaweb.com/js-data-type-variable\" target=\"_blank\" rel=\"external\">Poeima web</a><br><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript\" target=\"_blank\" rel=\"external\">MDN ko</a><br><a href=\"http://insanehong.kr/post/javascript-object/\" target=\"_blank\" rel=\"external\">blog</a><br><a href=\"https://hyunseob.github.io/2016/03/10/javascript-this/\" target=\"_blank\" rel=\"external\">blog - this</a></p>"},{"title":"[JS] 프로토타입 Prototype","date":"2017-08-06T01:53:50.000Z","_content":"\n![](https://www.bram.us/wordpress/wp-content/uploads/2016/06/javascript-logo-banner.jpg)\n\n# Prototype 프로토타입과 객체지향\n\n### **객체(Object)**\n\n자바스크립트에서는 객체를 만드는 방법으로 객체리터럴 방식과 생성자(Object() 함수, 일반 생성자 함수)를 이용한 방식이 있다.  \n\n```javascript\nvar objectMadeByLiteral = {};\nvar objectMadeByConstructor = new Object();\n```\n\n리터럴은 Object 타입의 객체를 만들어내는 일종의 숏컷이고 두 번째 라인의 생성자를 이용한 코드 역시 Object 생성자이기 때문에 사실 위 예제는 구조면에서 동일한 객체를 만든다. 둘 다 Object타입을 갖는 객체로 Object타입의 메서드들을 사용할 수 있다. Object타입은 모든 객체의 최상위 타입이다. 사실 다른 객체지향언어의 관점에서 보면 위 코드는 Object객체의 인스턴스를 만든 것에 불과하니 상속받았다고 표현하기 어렵다. 하지만 자바스크립트에서는 조금 다른 개념으로 생각해야 한다. 지금 만들어진 객체가 Object 타입의 인스턴스 객체인 것도 맞지만 프로토 타입을 이용한 상속받은 객체라고 표현하는게 더 정확한 표현이다. 사실 상속이라는 표현도 OOP의 관점에서 사용하는 단어로 표현하고자 한 것일 뿐 실제로는 링크드 리스트 형태의 창조를 통한 객체끼리의 연결에 가깝고 클래스 매커니즘처럼 정적이지 않고 매우 동적이다.\n\n## 1. 프로토타입 객체\n\n자바스크립트의 모든 객체는 부모가 존재한다. 그런데 객체가 생성자 함수를 통해 생성되었다고 하여 객체의 부모가 생성자함수인 것은 아니다. 모든 객체의 부모는 prototype 객체이다. 함수도 객체이다. 다만 함수 객체는 일반 객체와 달리 prototype이라는 프로퍼티를 특별히 가지고 있다. 생성자 함수는 함수 객체이다. 따라서 prototype 프로퍼티가 존재한다. 생성자 함수의 prototype 프로퍼티는 생성자 함수가 생산한 객체의 부모가 되는 prototype 객체를 가리킨다.\n\n프로토타입은 자바의 객체지향의 상속 개념과 유사하다. 자바스크립트는 프로토타입 기반 객체지향언어이며 자바는 클래스 기반 객체지향언어이다. 따라서 둘은 같지 않다. 자바스크립트의 모든 객체는 자신의 부모 역할을 담당하는 객체와 연결되어 있다. 그리고 이것은 마치 객체 지향의 상속 개념과 같이 부모 객체의 프로퍼티 또는 메소드를 상속받아 사용할 수 있게 한다. 이러한 부모 객체를 Prototype(프로토타입) 객체 또는 줄여서 프로토타입이라 한다.\n\n프로토타입을 이용하면 객체와 객체를 연결하고 한쪽 방향으로 상속을 받는 형태를 만들 수가 있다. 자바스크립트에서 객체와 객체를 연결해서 상속 받는다는 것은 다른 말로 객체와 객체를 연결해 멤버 함수나 멤버 변수를 공유 한다는 뜻이다. 이런 점을 이용해 자바스크립트에서는 상속과 비슷한 효과를 얻는 것이다.\n\n```javascript\nvar student = {\n  name: 'Lee',\n  score: 90\n};\n\n// student에는 hasOwnProperty 메서드가 없지만 아래 구문은 동작한다.\nconsole.log(student.hasOwnProperty('name')); // true\n\nconsole.dir(student);\n```\n\n객체를 생성할 때 프로토타입은 결정된다. 결정된 프로토타입 객체는 다른 임의의 객체로 변경할 수 있다. 이것은 부모 객체인 프로토타입을 동적으로 변경할 수 있다는 것을 의미한다. 이러한 특징을 활용하여 객체의 상속을 구현할 수 있다.\n\n<br>\n\n## 2. [[Prototype]] 프로퍼티 VS prototype 프로퍼티\n\n\n***[함수 객체와 일반 객체의 차이]***  \n\n1. 함수 객체는 `prototype` 프로퍼티를 가지고 있다.\n(prototype 프로퍼티는 prototype Object를 가리키고 있다.)\n\n2. 함수 객체는 호출될 수 있다.\n\n자바스크립트 엔진은 객체를 일종의 키와 값을 가진 해쉬맵처럼 다룬다. 값에는 데이터나 함수가 들어갈 수 있으며 엔진 내부에 필요한 데이터를 임의로 만들어 넣기도 한다. 물론 그게 자바스크립트 단으로 노출이 될 수도, 안될 수도 있다. 프로토타입 체인의 핵심은 엔진이 사용하는 `__proto__`라는 속성이다. \n\n> `__proto__` 속성은 ECMAScript의 스펙 `[[prototype]]` 이 자바스크립트로 노출된 것인데 예전 스펙이 legacy처럼 남아있는 것이다. 모던 브라우저 개발자 도구에서도 디버깅 편의상 노출하고 있으나 코드에서 직접 접근하는 것은 피해야 한다.\n\n클래스를 통한 상속의 경우 클래스 상속 정보를 이용해 상속 구조의 모습을 가진 새로운 객체를 찍어내는 반면 프로토타입을 통한 상속구조는 존재하는 객체와 객체의 동적인 연결로 풀어낸다. 그렇다보니 이미 객체가 만들어진 상태라도 상속된 내용의 변경/추가/삭제가 가능하며 아예 상속 구조를 바꿀 수도 있게 된다. 이렇게 객체와 객체의 연결을 통한 단방향 공유 관계를 프로토타입 체인이라고 한다.\n\n## 3. constructor 프로퍼티\n\n프로토타입 객체는 `constructor` 프로퍼티를 갖는다. 이 **`constructor` 프로퍼티는 객체의 입장에서 자신을 생성한 객체**를 가리킨다. `Person()` 생성자 함수에 의해 생성된 객체를 생성한 객체는 `Person()` 생성자 함수이다. 따라서 `prototype` 객체의 `constructor` 프로퍼티는 객체를 생성하는 생성자 함수 객체를 가리킨다.\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n\nvar foo = new Person('Lee');\n\n// Person() 생성자 함수에 의해 생성된 객체를 생성한 객체는 Person() 생성자 함수이다.\nconsole.log(Person.prototype.constructor === Person);\n\n// foo 객체를 생성한 객체는 Person() 생성자 함수이다.\nconsole.log(foo.constructor === Person);\n\n// Person() 생성자 함수를 생성한 객체는 Function() 생성자 함수이다.\nconsole.log(Person.constructor === Function);\n```\n\n## 4. Prototype chain\n\n자바스크립트는 특정 객체의 프로퍼티나 메소드에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티 또는 메소드가 없다면 `[[Prototype]]` 프로퍼티가 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티나 메소드를 차례대로 검색한다. 이것을 프로토타입 체인이라 한다.\n\n```javascript\nvar student = {\n  name: 'Lee',\n  score: 90\n}\n\n// Object.prototype.hasOwnProperty()\nconsole.log(student.hasOwnProperty('name')); // true\n```\n\n### 1) 객체 리터럴 방식으로 생성된 객체의 프로토타입 체인\n\n객체 생성 방법은 3가지가 있다.\n\n* 객체 리터럴\n* 생성자 함수\n* `Object()` 생성자 함수\n\n객체 리터럴 방식으로 생성된 객체는 결국 내장 함수(Built-in)인 `Object()` 생성자 함수로 객체를 생성하는 것을 단순화시킨 것이다. 자바스크립트 엔진은 객체 리터럴로 객체를 생성하는 코드를 만나면 내부적으로 `Object()` 생성자 함수를 사용하여 객체를 생성한다.\n\n`Object()` 생성자 함수는 물론 함수이다. 따라서 함수 객체인 `Object()` 생성자 함수는 일반 객체와 달리 prototype 프로퍼티가 있다.\n\n* `prototype` 프로퍼티는 함수 객체가 생성자로 사용될 때 이 함수를 통해 생성된 객체의 부모 역할을 하는 객체를 가리킨다.\n* `[[Prototype]]` 프로퍼티는 객체의 입장에서 자신의 부모 역할을 하는 프로토타입 객체을 가리킨다.\n\n```javascript\nvar person = {\n  name: 'Lee',\n  gender: 'male',\n  sayHello: function(){\n    console.log('Hi! my name is ' + this.name);\n  }\n};\n\nconsole.dir(person);\n\nconsole.log(person.__proto__ === Object.prototype);   // ① true\nconsole.log(Object.prototype.constructor === Object); // ② true\nconsole.log(Object.__proto__ === Function.prototype); // ③ true\nconsole.log(Function.prototype.__proto__ === Object.prototype); // ④ true\n```\n\n![객체 리터럴로 생성한 객체의 프로토타입 체인](http://poiemaweb.com/img/object_literal_prototype_chaining.png)\n**결론적으로 객체 리터럴을 사용하여 객체를 생성한 경우, 그 객체의 프로토타입 객체는 `Object.prototype`이다.**\n\n### 2) 생성자 함수로 생성된 객체의 프로토타입 체인\n\n생성자 함수로 객체를 생성하기 위해서는 우선 생성자 함수를 정의하여야 한다.\n\n함수를 정의하는 방식은 3가지가 있다.\n\n* 함수선언식(Function declaration)\n* 함수표현식(Function expression)\n* `Function()` 생성자 함수  \n\n함수표현식으로 함수를 정의할 때 함수 리터럴 방식을 사용한다.\n\n3가지 함수 정의 방식은 결국 `Function()` 생성자 함수를 통해 함수 객체를 생성한다, 따라서 어떠한 방식으로 함수 객체를 생성하여도 모든 함수 객체의 `prototype` 객체는 `Function.prototype`이다. 생성자 함수도 함수 객체이므로 생성자 함수의 `prototype` 객체는 `Function.prototype`이다.\n\n이제 객체의 관점에서 `prototype` 객체를 살펴보자. 객체를 생성하는 방식은 3가지가 있다. 3가지 객체 생성 방식에 의해 생성된 객체의 `prototype` 객체를 정리해 보면 아래와 같다.\n\n```javascript\nfunction Person(name, gender) {\n  this.name = name;\n  this.gender = gender;\n  <!-- this.sayHello = function(){\n    console.log('Hi! my name is ' + this.name); -->\n  };\n}\n\nPerson.prototype = function sayHello(){\n    console.log('Hi! my name is ' + this.name);\n\nvar foo = new Person('Lee', 'male');\n\nconsole.dir(Person);\nconsole.dir(foo);\n\nconsole.log(foo.__proto__ === Person.prototype);                // ① true\nconsole.log(Person.prototype.__proto__ === Object.prototype);   // ② true\nconsole.log(Person.prototype.constructor === Person);           // ③ true\nconsole.log(Person.__proto__ === Function.prototype);           // ④ true\nconsole.log(Function.prototype.__proto__ === Object.prototype); // ⑤ true\n```\n\n![Person 생성자 프로토타입 체인](http://poiemaweb.com/img/constructor_function_prototype_chaining.png)\n\n`foo` 객체의 프로토타입 객체 `Person.prototype` 객체와 `Person()` 생성자 함수의 프로토타입 객체인 `Function.prototype`의 프로토타입 객체는 `Object.prototype` 객체이다.\n\n이는 객체 리터럴 방식이나 생성자 함수 방식이나 결국은 모든 객체의 부모 객체인 `Object.prototype` 객체에서 프로토타입 체인이 끝나기 때문이다. 이때 `Object.prototype` 객체를 프로토타입 체인의 종점(End of prototype chain)이라 한다.\n\n## 5. 프로토타입 객체의 확장\n프로토타입 객체도 객체이므로 일반 객체와 같이 프로퍼티를 추가/삭제할 수 있다. 그리고 이렇게 추가/삭제된 프로퍼티는 즉시 프로토타입 체인에 반영된다.\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n\nvar foo = new Person('Lee');\n\nPerson.prototype.sayHello = function(){\n  console.log('Hi! my name is ' + this.name);\n};\n\nfoo.sayHello();\n```\n\n생성자 함수 `Person`은 `prototype` 프로퍼티에 연결된 프로토타입 객체 `Person.prototype`를 갖는다. `Person.prototype` 객체는 일반 객체와 같이 프로퍼티를 추가/삭제가 가능하다. 위의 예에서는 `Person.prototype` 객체에 메소드 `sayHello`를 추가하였다. 이때 `sayHello` 메소드는 프로토타입 체인에 반영된다. 따라서 생성자 함수 `Person`에 의해 생성된 모든 객체는 프로토타입 체인에 의해 부모객체인 `Person.prototype`의 메소드를 사용할 수 있게 되었다.\n![생성자](http://poiemaweb.com/img/extension_prototype.png)\n\n<br>\n\n## 6. 기본자료형(Primitive data type)의 확장  \n\n자바스크립트에서 기본자료형(숫자, 문자열, boolean, null, undefined)을 제외한 모든것은 객체이다. 그런데 아래 예제를 살펴보면 기본자료형인 문자열이 흡사 객체와 같이 동작한다.\n\n```javascript\nvar str = 'test'; //리터럴 방식으로 객체 선언\nconsole.log(typeof str);                 // string\nconsole.log(str.constructor === String); // true\nconsole.dir(str);\n\nvar strObj = new String('test');\n//객체인 문자열을 생성한다.\nconsole.log(typeof strObj);                 // object\nconsole.log(strObj.constructor === String); // true\nconsole.dir(strObj);\n\nconsole.log(str.toUpperCase());    // TEST\nconsole.log(strObj.toUpperCase()); // TEST\n```\n\n* 기본자료형과 객체의 차이:\n기본자료형은 상속, 프로퍼티, 메서드 개념이 없다. 그저 데이터(값)그 자체이다.\n\n```javascript\nvar str = 'test';\n\n// 에러가 발생하지 않는다.\nstr.myMethod = function () {\n  console.log('str.myMethod');\n};\n\nstr.myMethod(); // Uncaught TypeError: str.myMethod is not a function\n```\n\n`String`은 래퍼객체이다. 문자열을 `String`의 객체로 선언하면 `String` 객체 내부의 메소드를 사용할 수 있다. 그런데 모든 문자열을 다룰 때, 항상 객체로 다시 선언해주기에는 큰 번거로움이 따른다. 따라서 문자열 기본자료형에 `.`을 붙이면 자동으로 자바스크립트 엔진이 래퍼 객체를 통해 일시적으로 문자열 객체로 변환해준다. 따라서 리터럴 방식으로 선언한 기본자료형 문자열도 `String`객체의 메소드를 사용할 수 있게 된다.\n\n```javascript\nvar str = 'test';\n\nString.prototype.myMethod = function () {\n  return 'myMethod';\n};\n\nconsole.log(str.myMethod());      // myMethod\nconsole.log('string'.myMethod()); // myMethod\nconsole.dir(String.prototype);\n```\n\n기본자료형 문자열과 `String()` 생성자 함수로 생성한 문자열 객체의 타입은 분명이 다르다. 기본 자료형은 객체가 아니므로 프로퍼티나 메소드를 가질수 없다. 하지만 기본자료형으로 프로퍼티나 메소드를 호출할 때 기본자료형과 연관된 객체로 일시적으로 변환되어 프로토타입 객체를 공유하게 된다.\n\n기본자료형은 객체가 아니므로 `.`을 통해 바로 프로퍼티나 메소드를 직접 추가할 수 없다. 기본자료형은 오직 참조만 할 수 있다.  \n\n만약 기본자료형으로 메소드를 추가하고자 한다면, `String` 객체의 프로토타입 객체 `String.prototype`에 메소드를 추가하는 방법이 있다. 하지만 이는 위험 부담이 따른다.\n\n앞선 방법으로 메소드를 추가하는 것은 `Built-in` 객체인 `String` 객체의 메소드들(표준)과 섞이거나 변수명의 중복으로 인해 기존 메소드가 지워지는 문제가 있을 수 있기 때문에 좋은 방식은 아니다. 이처럼 표준 이외의 메소드를 추가하는 것이 일종의 라이브러리인데, 라이브러리를 만들고자 할 때는 차라리 커스텀 객체를 따로 생성하는 것이 좋다.\n\n앞서 살펴본 바와 같이 모든 객체는 프로토타입 체인에 의해 `Object.prototype` 객체의 메소드를 사용할 수 있었다. `Object.prototype` 객체는 프로토타입 체인의 종점으로 모든 객체가 사용할 수 있는 메소드를 갖는다.\n\n이후 살펴보게 될 `Built-in object`(내장 객체)의 `Global objects` (Standard Built-in Objects)인 `String`, `Number`, `Array` 객체 등이 가지고 있는 표준 메소드는 프로토타입 객체인 `String.prototype`, `Number.prototype`, `Array.prototype` 등에 정의되어 있다. 이들 프로토타입 객체 또한 `Object.prototype`를 프로토타입 체인에 의해 자신의 프로토타입 객체로 연결한다.\n\n자바스크립트는 표준 내장 객체의 프로토타입 객체에 개발자가 정의한 메소드의 추가를 허용한다.\n\n```javascript\nvar str = 'test';\n\nString.prototype.myMethod = function() {\n  return 'myMethod';\n}\n\nconsole.log(str.myMethod());\nconsole.dir(String.prototype);\n\nconsole.log(str.__proto__ === String.prototype);                 // ① true\nconsole.log(String.prototype.__proto__  === Object.prototype);   // ② true\nconsole.log(String.prototype.constructor === String);            // ③ true\nconsole.log(String.__proto__ === Function.prototype);            // ④ true\nconsole.log(Function.prototype.__proto__  === Object.prototype); // ⑤ true\n```\n![](http://poiemaweb.com/img/string_constructor_function_prototype_chaining.png)\n\n<br>\n\n## 7. 프로토타입 객체의 변경\n\n객체를 생성할 때 프로토타입은 결정된다. 결정된 프로토타입 객체는 다른 임의의 객체로 변경할 수 있다. 이것은 부모 객체인 프로토타입을 동적으로 변경할 수 있다는 것을 의미한다. 이러한 특징을 활용하여 객체의 상속을 구현할 수 있다.\n\n이때 주의할 것은 프로토타입 객체를 변경하면\n\n프로토타입 객체 변경 시점 이전에 생성된 객체\n기존 프로토타입 객체를 `[[Prototype]]` 프로퍼티에 바인딩한다.\n프로토타입 객체 변경 시점 이후에 생성된 객체\n변경된 프로토타입 객체를 `[[Prototype]]` 프로퍼티에 바인딩한다.\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n\nvar foo = new Person('Lee');\n\n// 프로토타입 객체의 변경\nPerson.prototype = { gender: 'male' };\n\nvar bar = new Person('Kim');\n\nconsole.log(foo.gender); // undefined\nconsole.log(bar.gender); // 'male'\n\nconsole.log(foo.constructor); // ① Person(name)\nconsole.log(bar.constructor); // ② Object()\n```\n![](http://poiemaweb.com/img/changing_prototype.png)\n\n① constructor 프로퍼티는 `Person()` 생성자 함수를 가리킨다.\n\n② 프로토타입 객체 변경 후, `Person()` 생성자 함수의 `Prototype` 프로퍼티가 가리키는 프로토타입 객체를 일반 객체로 변경하면서 `Person.prototype.constructor` 프로퍼티도 삭제되었다. 따라서 프로토타입 체인에 의해 `bar.constructor`의 값은 프로토타입 체이닝에 의해 `Object.prototype.constructor` 즉 `Object()` 생성자 함수가 된다.  \n\n위 예제의 상속 방식은 물론 가능한 방식이지만, 문제점이 많기 때문에 사용하지 않는 방식이다.\n\n<br>\n\n### 8. 프로토타입 체인 동작\n\n기본적인 프로토타입 체인은 참조할 때 동작한다.  프로퍼티 동적 추가에서 객체에 프로퍼티가 존재하지 않으면 프로퍼티를 추가한다. \n\n객체의 프로퍼티에 값을 할당하는 경우, 프로토타입 체인이 동작하지 않는다. 이는 객체에 해당 프로퍼티가 있는 경우, 값을 재할당하고 해당 프로퍼티가 없는 경우는 해당 객체에 프로퍼티를 동적으로 추가하기 때문이다.\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.gender = 'male'; // ①\n\nvar foo = new Person('Lee');\nvar bar = new Person('Kim');\n\nconsole.log(foo.gender); // ① 'male'\nconsole.log(bar.gender); // ① 'male'\n\n// 1. foo 객체에 gender 프로퍼티가 없으면 프로퍼티 동적 추가\n// 2. foo 객체에 gender 프로퍼티가 있으면 해당 프로퍼티에 값 할당\nfoo.gender = 'female';   // ②\n\nconsole.log(foo.gender); // ② 'female'\nconsole.log(bar.gender); // ① 'male'\n```\n\n> 프로토 타입 체이닝은 **참조할 때 위로 올라가는 것**이다. **프로퍼티를 추가할 때는 자기 자신에게** 추가한다.\n\n---\n**Reference**  \n* [Poiemaweb](poiemaweb.com)\n* (서적)자바스크립트 닌자 비급, 인사이트, 2014\n* (서적) 인사이드 자바스크립트, 한빛, 2016\n","source":"_posts/Javascript/02.Prototype.md","raw":"---\ntitle: '[JS] 프로토타입 Prototype'\ndate: 2017-08-06 10:53:50\ncategory: Javascript\ntags: prototype\n---\n\n![](https://www.bram.us/wordpress/wp-content/uploads/2016/06/javascript-logo-banner.jpg)\n\n# Prototype 프로토타입과 객체지향\n\n### **객체(Object)**\n\n자바스크립트에서는 객체를 만드는 방법으로 객체리터럴 방식과 생성자(Object() 함수, 일반 생성자 함수)를 이용한 방식이 있다.  \n\n```javascript\nvar objectMadeByLiteral = {};\nvar objectMadeByConstructor = new Object();\n```\n\n리터럴은 Object 타입의 객체를 만들어내는 일종의 숏컷이고 두 번째 라인의 생성자를 이용한 코드 역시 Object 생성자이기 때문에 사실 위 예제는 구조면에서 동일한 객체를 만든다. 둘 다 Object타입을 갖는 객체로 Object타입의 메서드들을 사용할 수 있다. Object타입은 모든 객체의 최상위 타입이다. 사실 다른 객체지향언어의 관점에서 보면 위 코드는 Object객체의 인스턴스를 만든 것에 불과하니 상속받았다고 표현하기 어렵다. 하지만 자바스크립트에서는 조금 다른 개념으로 생각해야 한다. 지금 만들어진 객체가 Object 타입의 인스턴스 객체인 것도 맞지만 프로토 타입을 이용한 상속받은 객체라고 표현하는게 더 정확한 표현이다. 사실 상속이라는 표현도 OOP의 관점에서 사용하는 단어로 표현하고자 한 것일 뿐 실제로는 링크드 리스트 형태의 창조를 통한 객체끼리의 연결에 가깝고 클래스 매커니즘처럼 정적이지 않고 매우 동적이다.\n\n## 1. 프로토타입 객체\n\n자바스크립트의 모든 객체는 부모가 존재한다. 그런데 객체가 생성자 함수를 통해 생성되었다고 하여 객체의 부모가 생성자함수인 것은 아니다. 모든 객체의 부모는 prototype 객체이다. 함수도 객체이다. 다만 함수 객체는 일반 객체와 달리 prototype이라는 프로퍼티를 특별히 가지고 있다. 생성자 함수는 함수 객체이다. 따라서 prototype 프로퍼티가 존재한다. 생성자 함수의 prototype 프로퍼티는 생성자 함수가 생산한 객체의 부모가 되는 prototype 객체를 가리킨다.\n\n프로토타입은 자바의 객체지향의 상속 개념과 유사하다. 자바스크립트는 프로토타입 기반 객체지향언어이며 자바는 클래스 기반 객체지향언어이다. 따라서 둘은 같지 않다. 자바스크립트의 모든 객체는 자신의 부모 역할을 담당하는 객체와 연결되어 있다. 그리고 이것은 마치 객체 지향의 상속 개념과 같이 부모 객체의 프로퍼티 또는 메소드를 상속받아 사용할 수 있게 한다. 이러한 부모 객체를 Prototype(프로토타입) 객체 또는 줄여서 프로토타입이라 한다.\n\n프로토타입을 이용하면 객체와 객체를 연결하고 한쪽 방향으로 상속을 받는 형태를 만들 수가 있다. 자바스크립트에서 객체와 객체를 연결해서 상속 받는다는 것은 다른 말로 객체와 객체를 연결해 멤버 함수나 멤버 변수를 공유 한다는 뜻이다. 이런 점을 이용해 자바스크립트에서는 상속과 비슷한 효과를 얻는 것이다.\n\n```javascript\nvar student = {\n  name: 'Lee',\n  score: 90\n};\n\n// student에는 hasOwnProperty 메서드가 없지만 아래 구문은 동작한다.\nconsole.log(student.hasOwnProperty('name')); // true\n\nconsole.dir(student);\n```\n\n객체를 생성할 때 프로토타입은 결정된다. 결정된 프로토타입 객체는 다른 임의의 객체로 변경할 수 있다. 이것은 부모 객체인 프로토타입을 동적으로 변경할 수 있다는 것을 의미한다. 이러한 특징을 활용하여 객체의 상속을 구현할 수 있다.\n\n<br>\n\n## 2. [[Prototype]] 프로퍼티 VS prototype 프로퍼티\n\n\n***[함수 객체와 일반 객체의 차이]***  \n\n1. 함수 객체는 `prototype` 프로퍼티를 가지고 있다.\n(prototype 프로퍼티는 prototype Object를 가리키고 있다.)\n\n2. 함수 객체는 호출될 수 있다.\n\n자바스크립트 엔진은 객체를 일종의 키와 값을 가진 해쉬맵처럼 다룬다. 값에는 데이터나 함수가 들어갈 수 있으며 엔진 내부에 필요한 데이터를 임의로 만들어 넣기도 한다. 물론 그게 자바스크립트 단으로 노출이 될 수도, 안될 수도 있다. 프로토타입 체인의 핵심은 엔진이 사용하는 `__proto__`라는 속성이다. \n\n> `__proto__` 속성은 ECMAScript의 스펙 `[[prototype]]` 이 자바스크립트로 노출된 것인데 예전 스펙이 legacy처럼 남아있는 것이다. 모던 브라우저 개발자 도구에서도 디버깅 편의상 노출하고 있으나 코드에서 직접 접근하는 것은 피해야 한다.\n\n클래스를 통한 상속의 경우 클래스 상속 정보를 이용해 상속 구조의 모습을 가진 새로운 객체를 찍어내는 반면 프로토타입을 통한 상속구조는 존재하는 객체와 객체의 동적인 연결로 풀어낸다. 그렇다보니 이미 객체가 만들어진 상태라도 상속된 내용의 변경/추가/삭제가 가능하며 아예 상속 구조를 바꿀 수도 있게 된다. 이렇게 객체와 객체의 연결을 통한 단방향 공유 관계를 프로토타입 체인이라고 한다.\n\n## 3. constructor 프로퍼티\n\n프로토타입 객체는 `constructor` 프로퍼티를 갖는다. 이 **`constructor` 프로퍼티는 객체의 입장에서 자신을 생성한 객체**를 가리킨다. `Person()` 생성자 함수에 의해 생성된 객체를 생성한 객체는 `Person()` 생성자 함수이다. 따라서 `prototype` 객체의 `constructor` 프로퍼티는 객체를 생성하는 생성자 함수 객체를 가리킨다.\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n\nvar foo = new Person('Lee');\n\n// Person() 생성자 함수에 의해 생성된 객체를 생성한 객체는 Person() 생성자 함수이다.\nconsole.log(Person.prototype.constructor === Person);\n\n// foo 객체를 생성한 객체는 Person() 생성자 함수이다.\nconsole.log(foo.constructor === Person);\n\n// Person() 생성자 함수를 생성한 객체는 Function() 생성자 함수이다.\nconsole.log(Person.constructor === Function);\n```\n\n## 4. Prototype chain\n\n자바스크립트는 특정 객체의 프로퍼티나 메소드에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티 또는 메소드가 없다면 `[[Prototype]]` 프로퍼티가 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티나 메소드를 차례대로 검색한다. 이것을 프로토타입 체인이라 한다.\n\n```javascript\nvar student = {\n  name: 'Lee',\n  score: 90\n}\n\n// Object.prototype.hasOwnProperty()\nconsole.log(student.hasOwnProperty('name')); // true\n```\n\n### 1) 객체 리터럴 방식으로 생성된 객체의 프로토타입 체인\n\n객체 생성 방법은 3가지가 있다.\n\n* 객체 리터럴\n* 생성자 함수\n* `Object()` 생성자 함수\n\n객체 리터럴 방식으로 생성된 객체는 결국 내장 함수(Built-in)인 `Object()` 생성자 함수로 객체를 생성하는 것을 단순화시킨 것이다. 자바스크립트 엔진은 객체 리터럴로 객체를 생성하는 코드를 만나면 내부적으로 `Object()` 생성자 함수를 사용하여 객체를 생성한다.\n\n`Object()` 생성자 함수는 물론 함수이다. 따라서 함수 객체인 `Object()` 생성자 함수는 일반 객체와 달리 prototype 프로퍼티가 있다.\n\n* `prototype` 프로퍼티는 함수 객체가 생성자로 사용될 때 이 함수를 통해 생성된 객체의 부모 역할을 하는 객체를 가리킨다.\n* `[[Prototype]]` 프로퍼티는 객체의 입장에서 자신의 부모 역할을 하는 프로토타입 객체을 가리킨다.\n\n```javascript\nvar person = {\n  name: 'Lee',\n  gender: 'male',\n  sayHello: function(){\n    console.log('Hi! my name is ' + this.name);\n  }\n};\n\nconsole.dir(person);\n\nconsole.log(person.__proto__ === Object.prototype);   // ① true\nconsole.log(Object.prototype.constructor === Object); // ② true\nconsole.log(Object.__proto__ === Function.prototype); // ③ true\nconsole.log(Function.prototype.__proto__ === Object.prototype); // ④ true\n```\n\n![객체 리터럴로 생성한 객체의 프로토타입 체인](http://poiemaweb.com/img/object_literal_prototype_chaining.png)\n**결론적으로 객체 리터럴을 사용하여 객체를 생성한 경우, 그 객체의 프로토타입 객체는 `Object.prototype`이다.**\n\n### 2) 생성자 함수로 생성된 객체의 프로토타입 체인\n\n생성자 함수로 객체를 생성하기 위해서는 우선 생성자 함수를 정의하여야 한다.\n\n함수를 정의하는 방식은 3가지가 있다.\n\n* 함수선언식(Function declaration)\n* 함수표현식(Function expression)\n* `Function()` 생성자 함수  \n\n함수표현식으로 함수를 정의할 때 함수 리터럴 방식을 사용한다.\n\n3가지 함수 정의 방식은 결국 `Function()` 생성자 함수를 통해 함수 객체를 생성한다, 따라서 어떠한 방식으로 함수 객체를 생성하여도 모든 함수 객체의 `prototype` 객체는 `Function.prototype`이다. 생성자 함수도 함수 객체이므로 생성자 함수의 `prototype` 객체는 `Function.prototype`이다.\n\n이제 객체의 관점에서 `prototype` 객체를 살펴보자. 객체를 생성하는 방식은 3가지가 있다. 3가지 객체 생성 방식에 의해 생성된 객체의 `prototype` 객체를 정리해 보면 아래와 같다.\n\n```javascript\nfunction Person(name, gender) {\n  this.name = name;\n  this.gender = gender;\n  <!-- this.sayHello = function(){\n    console.log('Hi! my name is ' + this.name); -->\n  };\n}\n\nPerson.prototype = function sayHello(){\n    console.log('Hi! my name is ' + this.name);\n\nvar foo = new Person('Lee', 'male');\n\nconsole.dir(Person);\nconsole.dir(foo);\n\nconsole.log(foo.__proto__ === Person.prototype);                // ① true\nconsole.log(Person.prototype.__proto__ === Object.prototype);   // ② true\nconsole.log(Person.prototype.constructor === Person);           // ③ true\nconsole.log(Person.__proto__ === Function.prototype);           // ④ true\nconsole.log(Function.prototype.__proto__ === Object.prototype); // ⑤ true\n```\n\n![Person 생성자 프로토타입 체인](http://poiemaweb.com/img/constructor_function_prototype_chaining.png)\n\n`foo` 객체의 프로토타입 객체 `Person.prototype` 객체와 `Person()` 생성자 함수의 프로토타입 객체인 `Function.prototype`의 프로토타입 객체는 `Object.prototype` 객체이다.\n\n이는 객체 리터럴 방식이나 생성자 함수 방식이나 결국은 모든 객체의 부모 객체인 `Object.prototype` 객체에서 프로토타입 체인이 끝나기 때문이다. 이때 `Object.prototype` 객체를 프로토타입 체인의 종점(End of prototype chain)이라 한다.\n\n## 5. 프로토타입 객체의 확장\n프로토타입 객체도 객체이므로 일반 객체와 같이 프로퍼티를 추가/삭제할 수 있다. 그리고 이렇게 추가/삭제된 프로퍼티는 즉시 프로토타입 체인에 반영된다.\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n\nvar foo = new Person('Lee');\n\nPerson.prototype.sayHello = function(){\n  console.log('Hi! my name is ' + this.name);\n};\n\nfoo.sayHello();\n```\n\n생성자 함수 `Person`은 `prototype` 프로퍼티에 연결된 프로토타입 객체 `Person.prototype`를 갖는다. `Person.prototype` 객체는 일반 객체와 같이 프로퍼티를 추가/삭제가 가능하다. 위의 예에서는 `Person.prototype` 객체에 메소드 `sayHello`를 추가하였다. 이때 `sayHello` 메소드는 프로토타입 체인에 반영된다. 따라서 생성자 함수 `Person`에 의해 생성된 모든 객체는 프로토타입 체인에 의해 부모객체인 `Person.prototype`의 메소드를 사용할 수 있게 되었다.\n![생성자](http://poiemaweb.com/img/extension_prototype.png)\n\n<br>\n\n## 6. 기본자료형(Primitive data type)의 확장  \n\n자바스크립트에서 기본자료형(숫자, 문자열, boolean, null, undefined)을 제외한 모든것은 객체이다. 그런데 아래 예제를 살펴보면 기본자료형인 문자열이 흡사 객체와 같이 동작한다.\n\n```javascript\nvar str = 'test'; //리터럴 방식으로 객체 선언\nconsole.log(typeof str);                 // string\nconsole.log(str.constructor === String); // true\nconsole.dir(str);\n\nvar strObj = new String('test');\n//객체인 문자열을 생성한다.\nconsole.log(typeof strObj);                 // object\nconsole.log(strObj.constructor === String); // true\nconsole.dir(strObj);\n\nconsole.log(str.toUpperCase());    // TEST\nconsole.log(strObj.toUpperCase()); // TEST\n```\n\n* 기본자료형과 객체의 차이:\n기본자료형은 상속, 프로퍼티, 메서드 개념이 없다. 그저 데이터(값)그 자체이다.\n\n```javascript\nvar str = 'test';\n\n// 에러가 발생하지 않는다.\nstr.myMethod = function () {\n  console.log('str.myMethod');\n};\n\nstr.myMethod(); // Uncaught TypeError: str.myMethod is not a function\n```\n\n`String`은 래퍼객체이다. 문자열을 `String`의 객체로 선언하면 `String` 객체 내부의 메소드를 사용할 수 있다. 그런데 모든 문자열을 다룰 때, 항상 객체로 다시 선언해주기에는 큰 번거로움이 따른다. 따라서 문자열 기본자료형에 `.`을 붙이면 자동으로 자바스크립트 엔진이 래퍼 객체를 통해 일시적으로 문자열 객체로 변환해준다. 따라서 리터럴 방식으로 선언한 기본자료형 문자열도 `String`객체의 메소드를 사용할 수 있게 된다.\n\n```javascript\nvar str = 'test';\n\nString.prototype.myMethod = function () {\n  return 'myMethod';\n};\n\nconsole.log(str.myMethod());      // myMethod\nconsole.log('string'.myMethod()); // myMethod\nconsole.dir(String.prototype);\n```\n\n기본자료형 문자열과 `String()` 생성자 함수로 생성한 문자열 객체의 타입은 분명이 다르다. 기본 자료형은 객체가 아니므로 프로퍼티나 메소드를 가질수 없다. 하지만 기본자료형으로 프로퍼티나 메소드를 호출할 때 기본자료형과 연관된 객체로 일시적으로 변환되어 프로토타입 객체를 공유하게 된다.\n\n기본자료형은 객체가 아니므로 `.`을 통해 바로 프로퍼티나 메소드를 직접 추가할 수 없다. 기본자료형은 오직 참조만 할 수 있다.  \n\n만약 기본자료형으로 메소드를 추가하고자 한다면, `String` 객체의 프로토타입 객체 `String.prototype`에 메소드를 추가하는 방법이 있다. 하지만 이는 위험 부담이 따른다.\n\n앞선 방법으로 메소드를 추가하는 것은 `Built-in` 객체인 `String` 객체의 메소드들(표준)과 섞이거나 변수명의 중복으로 인해 기존 메소드가 지워지는 문제가 있을 수 있기 때문에 좋은 방식은 아니다. 이처럼 표준 이외의 메소드를 추가하는 것이 일종의 라이브러리인데, 라이브러리를 만들고자 할 때는 차라리 커스텀 객체를 따로 생성하는 것이 좋다.\n\n앞서 살펴본 바와 같이 모든 객체는 프로토타입 체인에 의해 `Object.prototype` 객체의 메소드를 사용할 수 있었다. `Object.prototype` 객체는 프로토타입 체인의 종점으로 모든 객체가 사용할 수 있는 메소드를 갖는다.\n\n이후 살펴보게 될 `Built-in object`(내장 객체)의 `Global objects` (Standard Built-in Objects)인 `String`, `Number`, `Array` 객체 등이 가지고 있는 표준 메소드는 프로토타입 객체인 `String.prototype`, `Number.prototype`, `Array.prototype` 등에 정의되어 있다. 이들 프로토타입 객체 또한 `Object.prototype`를 프로토타입 체인에 의해 자신의 프로토타입 객체로 연결한다.\n\n자바스크립트는 표준 내장 객체의 프로토타입 객체에 개발자가 정의한 메소드의 추가를 허용한다.\n\n```javascript\nvar str = 'test';\n\nString.prototype.myMethod = function() {\n  return 'myMethod';\n}\n\nconsole.log(str.myMethod());\nconsole.dir(String.prototype);\n\nconsole.log(str.__proto__ === String.prototype);                 // ① true\nconsole.log(String.prototype.__proto__  === Object.prototype);   // ② true\nconsole.log(String.prototype.constructor === String);            // ③ true\nconsole.log(String.__proto__ === Function.prototype);            // ④ true\nconsole.log(Function.prototype.__proto__  === Object.prototype); // ⑤ true\n```\n![](http://poiemaweb.com/img/string_constructor_function_prototype_chaining.png)\n\n<br>\n\n## 7. 프로토타입 객체의 변경\n\n객체를 생성할 때 프로토타입은 결정된다. 결정된 프로토타입 객체는 다른 임의의 객체로 변경할 수 있다. 이것은 부모 객체인 프로토타입을 동적으로 변경할 수 있다는 것을 의미한다. 이러한 특징을 활용하여 객체의 상속을 구현할 수 있다.\n\n이때 주의할 것은 프로토타입 객체를 변경하면\n\n프로토타입 객체 변경 시점 이전에 생성된 객체\n기존 프로토타입 객체를 `[[Prototype]]` 프로퍼티에 바인딩한다.\n프로토타입 객체 변경 시점 이후에 생성된 객체\n변경된 프로토타입 객체를 `[[Prototype]]` 프로퍼티에 바인딩한다.\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n\nvar foo = new Person('Lee');\n\n// 프로토타입 객체의 변경\nPerson.prototype = { gender: 'male' };\n\nvar bar = new Person('Kim');\n\nconsole.log(foo.gender); // undefined\nconsole.log(bar.gender); // 'male'\n\nconsole.log(foo.constructor); // ① Person(name)\nconsole.log(bar.constructor); // ② Object()\n```\n![](http://poiemaweb.com/img/changing_prototype.png)\n\n① constructor 프로퍼티는 `Person()` 생성자 함수를 가리킨다.\n\n② 프로토타입 객체 변경 후, `Person()` 생성자 함수의 `Prototype` 프로퍼티가 가리키는 프로토타입 객체를 일반 객체로 변경하면서 `Person.prototype.constructor` 프로퍼티도 삭제되었다. 따라서 프로토타입 체인에 의해 `bar.constructor`의 값은 프로토타입 체이닝에 의해 `Object.prototype.constructor` 즉 `Object()` 생성자 함수가 된다.  \n\n위 예제의 상속 방식은 물론 가능한 방식이지만, 문제점이 많기 때문에 사용하지 않는 방식이다.\n\n<br>\n\n### 8. 프로토타입 체인 동작\n\n기본적인 프로토타입 체인은 참조할 때 동작한다.  프로퍼티 동적 추가에서 객체에 프로퍼티가 존재하지 않으면 프로퍼티를 추가한다. \n\n객체의 프로퍼티에 값을 할당하는 경우, 프로토타입 체인이 동작하지 않는다. 이는 객체에 해당 프로퍼티가 있는 경우, 값을 재할당하고 해당 프로퍼티가 없는 경우는 해당 객체에 프로퍼티를 동적으로 추가하기 때문이다.\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.gender = 'male'; // ①\n\nvar foo = new Person('Lee');\nvar bar = new Person('Kim');\n\nconsole.log(foo.gender); // ① 'male'\nconsole.log(bar.gender); // ① 'male'\n\n// 1. foo 객체에 gender 프로퍼티가 없으면 프로퍼티 동적 추가\n// 2. foo 객체에 gender 프로퍼티가 있으면 해당 프로퍼티에 값 할당\nfoo.gender = 'female';   // ②\n\nconsole.log(foo.gender); // ② 'female'\nconsole.log(bar.gender); // ① 'male'\n```\n\n> 프로토 타입 체이닝은 **참조할 때 위로 올라가는 것**이다. **프로퍼티를 추가할 때는 자기 자신에게** 추가한다.\n\n---\n**Reference**  \n* [Poiemaweb](poiemaweb.com)\n* (서적)자바스크립트 닌자 비급, 인사이트, 2014\n* (서적) 인사이드 자바스크립트, 한빛, 2016\n","slug":"Javascript/02.Prototype","published":1,"updated":"2017-09-21T05:53:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjai8h17y000evb9q5hx79lzv","content":"<p><img src=\"https://www.bram.us/wordpress/wp-content/uploads/2016/06/javascript-logo-banner.jpg\" alt=\"\"></p><h1 id=\"Prototype-프로토타입과-객체지향\"><a href=\"#Prototype-프로토타입과-객체지향\" class=\"headerlink\" title=\"Prototype 프로토타입과 객체지향\"></a>Prototype 프로토타입과 객체지향</h1><h3 id=\"객체-Object\"><a href=\"#객체-Object\" class=\"headerlink\" title=\"객체(Object)\"></a><strong>객체(Object)</strong></h3><p>자바스크립트에서는 객체를 만드는 방법으로 객체리터럴 방식과 생성자(Object() 함수, 일반 생성자 함수)를 이용한 방식이 있다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> objectMadeByLiteral = &#123;&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> objectMadeByConstructor = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div></pre></td></tr></table></figure><p>리터럴은 Object 타입의 객체를 만들어내는 일종의 숏컷이고 두 번째 라인의 생성자를 이용한 코드 역시 Object 생성자이기 때문에 사실 위 예제는 구조면에서 동일한 객체를 만든다. 둘 다 Object타입을 갖는 객체로 Object타입의 메서드들을 사용할 수 있다. Object타입은 모든 객체의 최상위 타입이다. 사실 다른 객체지향언어의 관점에서 보면 위 코드는 Object객체의 인스턴스를 만든 것에 불과하니 상속받았다고 표현하기 어렵다. 하지만 자바스크립트에서는 조금 다른 개념으로 생각해야 한다. 지금 만들어진 객체가 Object 타입의 인스턴스 객체인 것도 맞지만 프로토 타입을 이용한 상속받은 객체라고 표현하는게 더 정확한 표현이다. 사실 상속이라는 표현도 OOP의 관점에서 사용하는 단어로 표현하고자 한 것일 뿐 실제로는 링크드 리스트 형태의 창조를 통한 객체끼리의 연결에 가깝고 클래스 매커니즘처럼 정적이지 않고 매우 동적이다.</p><h2 id=\"1-프로토타입-객체\"><a href=\"#1-프로토타입-객체\" class=\"headerlink\" title=\"1. 프로토타입 객체\"></a>1. 프로토타입 객체</h2><p>자바스크립트의 모든 객체는 부모가 존재한다. 그런데 객체가 생성자 함수를 통해 생성되었다고 하여 객체의 부모가 생성자함수인 것은 아니다. 모든 객체의 부모는 prototype 객체이다. 함수도 객체이다. 다만 함수 객체는 일반 객체와 달리 prototype이라는 프로퍼티를 특별히 가지고 있다. 생성자 함수는 함수 객체이다. 따라서 prototype 프로퍼티가 존재한다. 생성자 함수의 prototype 프로퍼티는 생성자 함수가 생산한 객체의 부모가 되는 prototype 객체를 가리킨다.</p><p>프로토타입은 자바의 객체지향의 상속 개념과 유사하다. 자바스크립트는 프로토타입 기반 객체지향언어이며 자바는 클래스 기반 객체지향언어이다. 따라서 둘은 같지 않다. 자바스크립트의 모든 객체는 자신의 부모 역할을 담당하는 객체와 연결되어 있다. 그리고 이것은 마치 객체 지향의 상속 개념과 같이 부모 객체의 프로퍼티 또는 메소드를 상속받아 사용할 수 있게 한다. 이러한 부모 객체를 Prototype(프로토타입) 객체 또는 줄여서 프로토타입이라 한다.</p><p>프로토타입을 이용하면 객체와 객체를 연결하고 한쪽 방향으로 상속을 받는 형태를 만들 수가 있다. 자바스크립트에서 객체와 객체를 연결해서 상속 받는다는 것은 다른 말로 객체와 객체를 연결해 멤버 함수나 멤버 변수를 공유 한다는 뜻이다. 이런 점을 이용해 자바스크립트에서는 상속과 비슷한 효과를 얻는 것이다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> student = &#123;</div><div class=\"line\">  name: <span class=\"string\">'Lee'</span>,</div><div class=\"line\">  score: <span class=\"number\">90</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// student에는 hasOwnProperty 메서드가 없지만 아래 구문은 동작한다.</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(student.hasOwnProperty(<span class=\"string\">'name'</span>)); <span class=\"comment\">// true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.dir(student);</div></pre></td></tr></table></figure><p>객체를 생성할 때 프로토타입은 결정된다. 결정된 프로토타입 객체는 다른 임의의 객체로 변경할 수 있다. 이것은 부모 객체인 프로토타입을 동적으로 변경할 수 있다는 것을 의미한다. 이러한 특징을 활용하여 객체의 상속을 구현할 수 있다.</p><p><br></p><h2 id=\"2-Prototype-프로퍼티-VS-prototype-프로퍼티\"><a href=\"#2-Prototype-프로퍼티-VS-prototype-프로퍼티\" class=\"headerlink\" title=\"2. [[Prototype]] 프로퍼티 VS prototype 프로퍼티\"></a>2. [[Prototype]] 프로퍼티 VS prototype 프로퍼티</h2><p><strong><em>[함수 객체와 일반 객체의 차이]</em></strong></p><ol><li><p>함수 객체는 <code>prototype</code> 프로퍼티를 가지고 있다.<br>(prototype 프로퍼티는 prototype Object를 가리키고 있다.)</p></li><li><p>함수 객체는 호출될 수 있다.</p></li></ol><p>자바스크립트 엔진은 객체를 일종의 키와 값을 가진 해쉬맵처럼 다룬다. 값에는 데이터나 함수가 들어갈 수 있으며 엔진 내부에 필요한 데이터를 임의로 만들어 넣기도 한다. 물론 그게 자바스크립트 단으로 노출이 될 수도, 안될 수도 있다. 프로토타입 체인의 핵심은 엔진이 사용하는 <code>__proto__</code>라는 속성이다.</p><blockquote><p><code>__proto__</code> 속성은 ECMAScript의 스펙 <code>[[prototype]]</code> 이 자바스크립트로 노출된 것인데 예전 스펙이 legacy처럼 남아있는 것이다. 모던 브라우저 개발자 도구에서도 디버깅 편의상 노출하고 있으나 코드에서 직접 접근하는 것은 피해야 한다.</p></blockquote><p>클래스를 통한 상속의 경우 클래스 상속 정보를 이용해 상속 구조의 모습을 가진 새로운 객체를 찍어내는 반면 프로토타입을 통한 상속구조는 존재하는 객체와 객체의 동적인 연결로 풀어낸다. 그렇다보니 이미 객체가 만들어진 상태라도 상속된 내용의 변경/추가/삭제가 가능하며 아예 상속 구조를 바꿀 수도 있게 된다. 이렇게 객체와 객체의 연결을 통한 단방향 공유 관계를 프로토타입 체인이라고 한다.</p><h2 id=\"3-constructor-프로퍼티\"><a href=\"#3-constructor-프로퍼티\" class=\"headerlink\" title=\"3. constructor 프로퍼티\"></a>3. constructor 프로퍼티</h2><p>프로토타입 객체는 <code>constructor</code> 프로퍼티를 갖는다. 이 <strong><code>constructor</code> 프로퍼티는 객체의 입장에서 자신을 생성한 객체</strong>를 가리킨다. <code>Person()</code> 생성자 함수에 의해 생성된 객체를 생성한 객체는 <code>Person()</code> 생성자 함수이다. 따라서 <code>prototype</code> 객체의 <code>constructor</code> 프로퍼티는 객체를 생성하는 생성자 함수 객체를 가리킨다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Lee'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Person() 생성자 함수에 의해 생성된 객체를 생성한 객체는 Person() 생성자 함수이다.</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype.constructor === Person);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// foo 객체를 생성한 객체는 Person() 생성자 함수이다.</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(foo.constructor === Person);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Person() 생성자 함수를 생성한 객체는 Function() 생성자 함수이다.</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(Person.constructor === <span class=\"built_in\">Function</span>);</div></pre></td></tr></table></figure><h2 id=\"4-Prototype-chain\"><a href=\"#4-Prototype-chain\" class=\"headerlink\" title=\"4. Prototype chain\"></a>4. Prototype chain</h2><p>자바스크립트는 특정 객체의 프로퍼티나 메소드에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티 또는 메소드가 없다면 <code>[[Prototype]]</code> 프로퍼티가 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티나 메소드를 차례대로 검색한다. 이것을 프로토타입 체인이라 한다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> student = &#123;</div><div class=\"line\">  name: <span class=\"string\">'Lee'</span>,</div><div class=\"line\">  score: <span class=\"number\">90</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Object.prototype.hasOwnProperty()</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(student.hasOwnProperty(<span class=\"string\">'name'</span>)); <span class=\"comment\">// true</span></div></pre></td></tr></table></figure><h3 id=\"1-객체-리터럴-방식으로-생성된-객체의-프로토타입-체인\"><a href=\"#1-객체-리터럴-방식으로-생성된-객체의-프로토타입-체인\" class=\"headerlink\" title=\"1) 객체 리터럴 방식으로 생성된 객체의 프로토타입 체인\"></a>1) 객체 리터럴 방식으로 생성된 객체의 프로토타입 체인</h3><p>객체 생성 방법은 3가지가 있다.</p><ul><li>객체 리터럴</li><li>생성자 함수</li><li><code>Object()</code> 생성자 함수</li></ul><p>객체 리터럴 방식으로 생성된 객체는 결국 내장 함수(Built-in)인 <code>Object()</code> 생성자 함수로 객체를 생성하는 것을 단순화시킨 것이다. 자바스크립트 엔진은 객체 리터럴로 객체를 생성하는 코드를 만나면 내부적으로 <code>Object()</code> 생성자 함수를 사용하여 객체를 생성한다.</p><p><code>Object()</code> 생성자 함수는 물론 함수이다. 따라서 함수 객체인 <code>Object()</code> 생성자 함수는 일반 객체와 달리 prototype 프로퍼티가 있다.</p><ul><li><code>prototype</code> 프로퍼티는 함수 객체가 생성자로 사용될 때 이 함수를 통해 생성된 객체의 부모 역할을 하는 객체를 가리킨다.</li><li><code>[[Prototype]]</code> 프로퍼티는 객체의 입장에서 자신의 부모 역할을 하는 프로토타입 객체을 가리킨다.</li></ul><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;</div><div class=\"line\">  name: <span class=\"string\">'Lee'</span>,</div><div class=\"line\">  gender: <span class=\"string\">'male'</span>,</div><div class=\"line\">  sayHello: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi! my name is '</span> + <span class=\"keyword\">this</span>.name);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.dir(person);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person.__proto__ === <span class=\"built_in\">Object</span>.prototype);   <span class=\"comment\">// ① true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.prototype.constructor === <span class=\"built_in\">Object</span>); <span class=\"comment\">// ② true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.__proto__ === <span class=\"built_in\">Function</span>.prototype); <span class=\"comment\">// ③ true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Function</span>.prototype.__proto__ === <span class=\"built_in\">Object</span>.prototype); <span class=\"comment\">// ④ true</span></div></pre></td></tr></table></figure><p><img src=\"http://poiemaweb.com/img/object_literal_prototype_chaining.png\" alt=\"객체 리터럴로 생성한 객체의 프로토타입 체인\"><br><strong>결론적으로 객체 리터럴을 사용하여 객체를 생성한 경우, 그 객체의 프로토타입 객체는 <code>Object.prototype</code>이다.</strong></p><h3 id=\"2-생성자-함수로-생성된-객체의-프로토타입-체인\"><a href=\"#2-생성자-함수로-생성된-객체의-프로토타입-체인\" class=\"headerlink\" title=\"2) 생성자 함수로 생성된 객체의 프로토타입 체인\"></a>2) 생성자 함수로 생성된 객체의 프로토타입 체인</h3><p>생성자 함수로 객체를 생성하기 위해서는 우선 생성자 함수를 정의하여야 한다.</p><p>함수를 정의하는 방식은 3가지가 있다.</p><ul><li>함수선언식(Function declaration)</li><li>함수표현식(Function expression)</li><li><code>Function()</code> 생성자 함수</li></ul><p>함수표현식으로 함수를 정의할 때 함수 리터럴 방식을 사용한다.</p><p>3가지 함수 정의 방식은 결국 <code>Function()</code> 생성자 함수를 통해 함수 객체를 생성한다, 따라서 어떠한 방식으로 함수 객체를 생성하여도 모든 함수 객체의 <code>prototype</code> 객체는 <code>Function.prototype</code>이다. 생성자 함수도 함수 객체이므로 생성자 함수의 <code>prototype</code> 객체는 <code>Function.prototype</code>이다.</p><p>이제 객체의 관점에서 <code>prototype</code> 객체를 살펴보자. 객체를 생성하는 방식은 3가지가 있다. 3가지 객체 생성 방식에 의해 생성된 객체의 <code>prototype</code> 객체를 정리해 보면 아래와 같다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, gender</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  <span class=\"keyword\">this</span>.gender = gender;</div><div class=\"line\">  &lt;!-- <span class=\"keyword\">this</span>.sayHello = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi! my name is '</span> + <span class=\"keyword\">this</span>.name); --&gt;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Person.prototype = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHello</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi! my name is '</span> + <span class=\"keyword\">this</span>.name);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Lee'</span>, <span class=\"string\">'male'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.dir(Person);</div><div class=\"line\"><span class=\"built_in\">console</span>.dir(foo);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(foo.__proto__ === Person.prototype);                <span class=\"comment\">// ① true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype.__proto__ === <span class=\"built_in\">Object</span>.prototype);   <span class=\"comment\">// ② true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype.constructor === Person);           <span class=\"comment\">// ③ true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(Person.__proto__ === <span class=\"built_in\">Function</span>.prototype);           <span class=\"comment\">// ④ true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Function</span>.prototype.__proto__ === <span class=\"built_in\">Object</span>.prototype); <span class=\"comment\">// ⑤ true</span></div></pre></td></tr></table></figure><p><img src=\"http://poiemaweb.com/img/constructor_function_prototype_chaining.png\" alt=\"Person 생성자 프로토타입 체인\"></p><p><code>foo</code> 객체의 프로토타입 객체 <code>Person.prototype</code> 객체와 <code>Person()</code> 생성자 함수의 프로토타입 객체인 <code>Function.prototype</code>의 프로토타입 객체는 <code>Object.prototype</code> 객체이다.</p><p>이는 객체 리터럴 방식이나 생성자 함수 방식이나 결국은 모든 객체의 부모 객체인 <code>Object.prototype</code> 객체에서 프로토타입 체인이 끝나기 때문이다. 이때 <code>Object.prototype</code> 객체를 프로토타입 체인의 종점(End of prototype chain)이라 한다.</p><h2 id=\"5-프로토타입-객체의-확장\"><a href=\"#5-프로토타입-객체의-확장\" class=\"headerlink\" title=\"5. 프로토타입 객체의 확장\"></a>5. 프로토타입 객체의 확장</h2><p>프로토타입 객체도 객체이므로 일반 객체와 같이 프로퍼티를 추가/삭제할 수 있다. 그리고 이렇게 추가/삭제된 프로퍼티는 즉시 프로토타입 체인에 반영된다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Lee'</span>);</div><div class=\"line\"></div><div class=\"line\">Person.prototype.sayHello = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi! my name is '</span> + <span class=\"keyword\">this</span>.name);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">foo.sayHello();</div></pre></td></tr></table></figure><p>생성자 함수 <code>Person</code>은 <code>prototype</code> 프로퍼티에 연결된 프로토타입 객체 <code>Person.prototype</code>를 갖는다. <code>Person.prototype</code> 객체는 일반 객체와 같이 프로퍼티를 추가/삭제가 가능하다. 위의 예에서는 <code>Person.prototype</code> 객체에 메소드 <code>sayHello</code>를 추가하였다. 이때 <code>sayHello</code> 메소드는 프로토타입 체인에 반영된다. 따라서 생성자 함수 <code>Person</code>에 의해 생성된 모든 객체는 프로토타입 체인에 의해 부모객체인 <code>Person.prototype</code>의 메소드를 사용할 수 있게 되었다.<br><img src=\"http://poiemaweb.com/img/extension_prototype.png\" alt=\"생성자\"></p><p><br></p><h2 id=\"6-기본자료형-Primitive-data-type-의-확장\"><a href=\"#6-기본자료형-Primitive-data-type-의-확장\" class=\"headerlink\" title=\"6. 기본자료형(Primitive data type)의 확장\"></a>6. 기본자료형(Primitive data type)의 확장</h2><p>자바스크립트에서 기본자료형(숫자, 문자열, boolean, null, undefined)을 제외한 모든것은 객체이다. 그런데 아래 예제를 살펴보면 기본자료형인 문자열이 흡사 객체와 같이 동작한다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'test'</span>; <span class=\"comment\">//리터럴 방식으로 객체 선언</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> str);                 <span class=\"comment\">// string</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.constructor === <span class=\"built_in\">String</span>); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.dir(str);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> strObj = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">'test'</span>);</div><div class=\"line\"><span class=\"comment\">//객체인 문자열을 생성한다.</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> strObj);                 <span class=\"comment\">// object</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(strObj.constructor === <span class=\"built_in\">String</span>); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.dir(strObj);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.toUpperCase());    <span class=\"comment\">// TEST</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(strObj.toUpperCase()); <span class=\"comment\">// TEST</span></div></pre></td></tr></table></figure><ul><li>기본자료형과 객체의 차이:<br>기본자료형은 상속, 프로퍼티, 메서드 개념이 없다. 그저 데이터(값)그 자체이다.</li></ul><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'test'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 에러가 발생하지 않는다.</span></div><div class=\"line\">str.myMethod = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'str.myMethod'</span>);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">str.myMethod(); <span class=\"comment\">// Uncaught TypeError: str.myMethod is not a function</span></div></pre></td></tr></table></figure><p><code>String</code>은 래퍼객체이다. 문자열을 <code>String</code>의 객체로 선언하면 <code>String</code> 객체 내부의 메소드를 사용할 수 있다. 그런데 모든 문자열을 다룰 때, 항상 객체로 다시 선언해주기에는 큰 번거로움이 따른다. 따라서 문자열 기본자료형에 <code>.</code>을 붙이면 자동으로 자바스크립트 엔진이 래퍼 객체를 통해 일시적으로 문자열 객체로 변환해준다. 따라서 리터럴 방식으로 선언한 기본자료형 문자열도 <code>String</code>객체의 메소드를 사용할 수 있게 된다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'test'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">String</span>.prototype.myMethod = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'myMethod'</span>;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.myMethod());      <span class=\"comment\">// myMethod</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'string'</span>.myMethod()); <span class=\"comment\">// myMethod</span></div><div class=\"line\"><span class=\"built_in\">console</span>.dir(<span class=\"built_in\">String</span>.prototype);</div></pre></td></tr></table></figure><p>기본자료형 문자열과 <code>String()</code> 생성자 함수로 생성한 문자열 객체의 타입은 분명이 다르다. 기본 자료형은 객체가 아니므로 프로퍼티나 메소드를 가질수 없다. 하지만 기본자료형으로 프로퍼티나 메소드를 호출할 때 기본자료형과 연관된 객체로 일시적으로 변환되어 프로토타입 객체를 공유하게 된다.</p><p>기본자료형은 객체가 아니므로 <code>.</code>을 통해 바로 프로퍼티나 메소드를 직접 추가할 수 없다. 기본자료형은 오직 참조만 할 수 있다.</p><p>만약 기본자료형으로 메소드를 추가하고자 한다면, <code>String</code> 객체의 프로토타입 객체 <code>String.prototype</code>에 메소드를 추가하는 방법이 있다. 하지만 이는 위험 부담이 따른다.</p><p>앞선 방법으로 메소드를 추가하는 것은 <code>Built-in</code> 객체인 <code>String</code> 객체의 메소드들(표준)과 섞이거나 변수명의 중복으로 인해 기존 메소드가 지워지는 문제가 있을 수 있기 때문에 좋은 방식은 아니다. 이처럼 표준 이외의 메소드를 추가하는 것이 일종의 라이브러리인데, 라이브러리를 만들고자 할 때는 차라리 커스텀 객체를 따로 생성하는 것이 좋다.</p><p>앞서 살펴본 바와 같이 모든 객체는 프로토타입 체인에 의해 <code>Object.prototype</code> 객체의 메소드를 사용할 수 있었다. <code>Object.prototype</code> 객체는 프로토타입 체인의 종점으로 모든 객체가 사용할 수 있는 메소드를 갖는다.</p><p>이후 살펴보게 될 <code>Built-in object</code>(내장 객체)의 <code>Global objects</code> (Standard Built-in Objects)인 <code>String</code>, <code>Number</code>, <code>Array</code> 객체 등이 가지고 있는 표준 메소드는 프로토타입 객체인 <code>String.prototype</code>, <code>Number.prototype</code>, <code>Array.prototype</code> 등에 정의되어 있다. 이들 프로토타입 객체 또한 <code>Object.prototype</code>를 프로토타입 체인에 의해 자신의 프로토타입 객체로 연결한다.</p><p>자바스크립트는 표준 내장 객체의 프로토타입 객체에 개발자가 정의한 메소드의 추가를 허용한다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'test'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">String</span>.prototype.myMethod = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'myMethod'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.myMethod());</div><div class=\"line\"><span class=\"built_in\">console</span>.dir(<span class=\"built_in\">String</span>.prototype);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.__proto__ === <span class=\"built_in\">String</span>.prototype);                 <span class=\"comment\">// ① true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">String</span>.prototype.__proto__  === <span class=\"built_in\">Object</span>.prototype);   <span class=\"comment\">// ② true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">String</span>.prototype.constructor === <span class=\"built_in\">String</span>);            <span class=\"comment\">// ③ true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">String</span>.__proto__ === <span class=\"built_in\">Function</span>.prototype);            <span class=\"comment\">// ④ true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Function</span>.prototype.__proto__  === <span class=\"built_in\">Object</span>.prototype); <span class=\"comment\">// ⑤ true</span></div></pre></td></tr></table></figure><p><img src=\"http://poiemaweb.com/img/string_constructor_function_prototype_chaining.png\" alt=\"\"></p><p><br></p><h2 id=\"7-프로토타입-객체의-변경\"><a href=\"#7-프로토타입-객체의-변경\" class=\"headerlink\" title=\"7. 프로토타입 객체의 변경\"></a>7. 프로토타입 객체의 변경</h2><p>객체를 생성할 때 프로토타입은 결정된다. 결정된 프로토타입 객체는 다른 임의의 객체로 변경할 수 있다. 이것은 부모 객체인 프로토타입을 동적으로 변경할 수 있다는 것을 의미한다. 이러한 특징을 활용하여 객체의 상속을 구현할 수 있다.</p><p>이때 주의할 것은 프로토타입 객체를 변경하면</p><p>프로토타입 객체 변경 시점 이전에 생성된 객체<br>기존 프로토타입 객체를 <code>[[Prototype]]</code> 프로퍼티에 바인딩한다.<br>프로토타입 객체 변경 시점 이후에 생성된 객체<br>변경된 프로토타입 객체를 <code>[[Prototype]]</code> 프로퍼티에 바인딩한다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Lee'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 프로토타입 객체의 변경</span></div><div class=\"line\">Person.prototype = &#123; <span class=\"attr\">gender</span>: <span class=\"string\">'male'</span> &#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Kim'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(foo.gender); <span class=\"comment\">// undefined</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(bar.gender); <span class=\"comment\">// 'male'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(foo.constructor); <span class=\"comment\">// ① Person(name)</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(bar.constructor); <span class=\"comment\">// ② Object()</span></div></pre></td></tr></table></figure><p><img src=\"http://poiemaweb.com/img/changing_prototype.png\" alt=\"\"></p><p>① constructor 프로퍼티는 <code>Person()</code> 생성자 함수를 가리킨다.</p><p>② 프로토타입 객체 변경 후, <code>Person()</code> 생성자 함수의 <code>Prototype</code> 프로퍼티가 가리키는 프로토타입 객체를 일반 객체로 변경하면서 <code>Person.prototype.constructor</code> 프로퍼티도 삭제되었다. 따라서 프로토타입 체인에 의해 <code>bar.constructor</code>의 값은 프로토타입 체이닝에 의해 <code>Object.prototype.constructor</code> 즉 <code>Object()</code> 생성자 함수가 된다.</p><p>위 예제의 상속 방식은 물론 가능한 방식이지만, 문제점이 많기 때문에 사용하지 않는 방식이다.</p><p><br></p><h3 id=\"8-프로토타입-체인-동작\"><a href=\"#8-프로토타입-체인-동작\" class=\"headerlink\" title=\"8. 프로토타입 체인 동작\"></a>8. 프로토타입 체인 동작</h3><p>기본적인 프로토타입 체인은 참조할 때 동작한다. 프로퍼티 동적 추가에서 객체에 프로퍼티가 존재하지 않으면 프로퍼티를 추가한다.</p><p>객체의 프로퍼티에 값을 할당하는 경우, 프로토타입 체인이 동작하지 않는다. 이는 객체에 해당 프로퍼티가 있는 경우, 값을 재할당하고 해당 프로퍼티가 없는 경우는 해당 객체에 프로퍼티를 동적으로 추가하기 때문이다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Person.prototype.gender = <span class=\"string\">'male'</span>; <span class=\"comment\">// ①</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Lee'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Kim'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(foo.gender); <span class=\"comment\">// ① 'male'</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(bar.gender); <span class=\"comment\">// ① 'male'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 1. foo 객체에 gender 프로퍼티가 없으면 프로퍼티 동적 추가</span></div><div class=\"line\"><span class=\"comment\">// 2. foo 객체에 gender 프로퍼티가 있으면 해당 프로퍼티에 값 할당</span></div><div class=\"line\">foo.gender = <span class=\"string\">'female'</span>;   <span class=\"comment\">// ②</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(foo.gender); <span class=\"comment\">// ② 'female'</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(bar.gender); <span class=\"comment\">// ① 'male'</span></div></pre></td></tr></table></figure><blockquote><p>프로토 타입 체이닝은 <strong>참조할 때 위로 올라가는 것</strong>이다. <strong>프로퍼티를 추가할 때는 자기 자신에게</strong> 추가한다.</p></blockquote><hr><p><strong>Reference</strong></p><ul><li><a href=\"poiemaweb.com\">Poiemaweb</a></li><li>(서적)자바스크립트 닌자 비급, 인사이트, 2014</li><li>(서적) 인사이드 자바스크립트, 한빛, 2016</li></ul>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://www.bram.us/wordpress/wp-content/uploads/2016/06/javascript-logo-banner.jpg\" alt=\"\"></p><h1 id=\"Prototype-프로토타입과-객체지향\"><a href=\"#Prototype-프로토타입과-객체지향\" class=\"headerlink\" title=\"Prototype 프로토타입과 객체지향\"></a>Prototype 프로토타입과 객체지향</h1><h3 id=\"객체-Object\"><a href=\"#객체-Object\" class=\"headerlink\" title=\"객체(Object)\"></a><strong>객체(Object)</strong></h3><p>자바스크립트에서는 객체를 만드는 방법으로 객체리터럴 방식과 생성자(Object() 함수, 일반 생성자 함수)를 이용한 방식이 있다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> objectMadeByLiteral = &#123;&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> objectMadeByConstructor = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div></pre></td></tr></table></figure><p>리터럴은 Object 타입의 객체를 만들어내는 일종의 숏컷이고 두 번째 라인의 생성자를 이용한 코드 역시 Object 생성자이기 때문에 사실 위 예제는 구조면에서 동일한 객체를 만든다. 둘 다 Object타입을 갖는 객체로 Object타입의 메서드들을 사용할 수 있다. Object타입은 모든 객체의 최상위 타입이다. 사실 다른 객체지향언어의 관점에서 보면 위 코드는 Object객체의 인스턴스를 만든 것에 불과하니 상속받았다고 표현하기 어렵다. 하지만 자바스크립트에서는 조금 다른 개념으로 생각해야 한다. 지금 만들어진 객체가 Object 타입의 인스턴스 객체인 것도 맞지만 프로토 타입을 이용한 상속받은 객체라고 표현하는게 더 정확한 표현이다. 사실 상속이라는 표현도 OOP의 관점에서 사용하는 단어로 표현하고자 한 것일 뿐 실제로는 링크드 리스트 형태의 창조를 통한 객체끼리의 연결에 가깝고 클래스 매커니즘처럼 정적이지 않고 매우 동적이다.</p><h2 id=\"1-프로토타입-객체\"><a href=\"#1-프로토타입-객체\" class=\"headerlink\" title=\"1. 프로토타입 객체\"></a>1. 프로토타입 객체</h2><p>자바스크립트의 모든 객체는 부모가 존재한다. 그런데 객체가 생성자 함수를 통해 생성되었다고 하여 객체의 부모가 생성자함수인 것은 아니다. 모든 객체의 부모는 prototype 객체이다. 함수도 객체이다. 다만 함수 객체는 일반 객체와 달리 prototype이라는 프로퍼티를 특별히 가지고 있다. 생성자 함수는 함수 객체이다. 따라서 prototype 프로퍼티가 존재한다. 생성자 함수의 prototype 프로퍼티는 생성자 함수가 생산한 객체의 부모가 되는 prototype 객체를 가리킨다.</p><p>프로토타입은 자바의 객체지향의 상속 개념과 유사하다. 자바스크립트는 프로토타입 기반 객체지향언어이며 자바는 클래스 기반 객체지향언어이다. 따라서 둘은 같지 않다. 자바스크립트의 모든 객체는 자신의 부모 역할을 담당하는 객체와 연결되어 있다. 그리고 이것은 마치 객체 지향의 상속 개념과 같이 부모 객체의 프로퍼티 또는 메소드를 상속받아 사용할 수 있게 한다. 이러한 부모 객체를 Prototype(프로토타입) 객체 또는 줄여서 프로토타입이라 한다.</p><p>프로토타입을 이용하면 객체와 객체를 연결하고 한쪽 방향으로 상속을 받는 형태를 만들 수가 있다. 자바스크립트에서 객체와 객체를 연결해서 상속 받는다는 것은 다른 말로 객체와 객체를 연결해 멤버 함수나 멤버 변수를 공유 한다는 뜻이다. 이런 점을 이용해 자바스크립트에서는 상속과 비슷한 효과를 얻는 것이다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> student = &#123;</div><div class=\"line\">  name: <span class=\"string\">'Lee'</span>,</div><div class=\"line\">  score: <span class=\"number\">90</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// student에는 hasOwnProperty 메서드가 없지만 아래 구문은 동작한다.</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(student.hasOwnProperty(<span class=\"string\">'name'</span>)); <span class=\"comment\">// true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.dir(student);</div></pre></td></tr></table></figure><p>객체를 생성할 때 프로토타입은 결정된다. 결정된 프로토타입 객체는 다른 임의의 객체로 변경할 수 있다. 이것은 부모 객체인 프로토타입을 동적으로 변경할 수 있다는 것을 의미한다. 이러한 특징을 활용하여 객체의 상속을 구현할 수 있다.</p><p><br></p><h2 id=\"2-Prototype-프로퍼티-VS-prototype-프로퍼티\"><a href=\"#2-Prototype-프로퍼티-VS-prototype-프로퍼티\" class=\"headerlink\" title=\"2. [[Prototype]] 프로퍼티 VS prototype 프로퍼티\"></a>2. [[Prototype]] 프로퍼티 VS prototype 프로퍼티</h2><p><strong><em>[함수 객체와 일반 객체의 차이]</em></strong></p><ol><li><p>함수 객체는 <code>prototype</code> 프로퍼티를 가지고 있다.<br>(prototype 프로퍼티는 prototype Object를 가리키고 있다.)</p></li><li><p>함수 객체는 호출될 수 있다.</p></li></ol><p>자바스크립트 엔진은 객체를 일종의 키와 값을 가진 해쉬맵처럼 다룬다. 값에는 데이터나 함수가 들어갈 수 있으며 엔진 내부에 필요한 데이터를 임의로 만들어 넣기도 한다. 물론 그게 자바스크립트 단으로 노출이 될 수도, 안될 수도 있다. 프로토타입 체인의 핵심은 엔진이 사용하는 <code>__proto__</code>라는 속성이다.</p><blockquote><p><code>__proto__</code> 속성은 ECMAScript의 스펙 <code>[[prototype]]</code> 이 자바스크립트로 노출된 것인데 예전 스펙이 legacy처럼 남아있는 것이다. 모던 브라우저 개발자 도구에서도 디버깅 편의상 노출하고 있으나 코드에서 직접 접근하는 것은 피해야 한다.</p></blockquote><p>클래스를 통한 상속의 경우 클래스 상속 정보를 이용해 상속 구조의 모습을 가진 새로운 객체를 찍어내는 반면 프로토타입을 통한 상속구조는 존재하는 객체와 객체의 동적인 연결로 풀어낸다. 그렇다보니 이미 객체가 만들어진 상태라도 상속된 내용의 변경/추가/삭제가 가능하며 아예 상속 구조를 바꿀 수도 있게 된다. 이렇게 객체와 객체의 연결을 통한 단방향 공유 관계를 프로토타입 체인이라고 한다.</p><h2 id=\"3-constructor-프로퍼티\"><a href=\"#3-constructor-프로퍼티\" class=\"headerlink\" title=\"3. constructor 프로퍼티\"></a>3. constructor 프로퍼티</h2><p>프로토타입 객체는 <code>constructor</code> 프로퍼티를 갖는다. 이 <strong><code>constructor</code> 프로퍼티는 객체의 입장에서 자신을 생성한 객체</strong>를 가리킨다. <code>Person()</code> 생성자 함수에 의해 생성된 객체를 생성한 객체는 <code>Person()</code> 생성자 함수이다. 따라서 <code>prototype</code> 객체의 <code>constructor</code> 프로퍼티는 객체를 생성하는 생성자 함수 객체를 가리킨다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Lee'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Person() 생성자 함수에 의해 생성된 객체를 생성한 객체는 Person() 생성자 함수이다.</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype.constructor === Person);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// foo 객체를 생성한 객체는 Person() 생성자 함수이다.</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(foo.constructor === Person);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Person() 생성자 함수를 생성한 객체는 Function() 생성자 함수이다.</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(Person.constructor === <span class=\"built_in\">Function</span>);</div></pre></td></tr></table></figure><h2 id=\"4-Prototype-chain\"><a href=\"#4-Prototype-chain\" class=\"headerlink\" title=\"4. Prototype chain\"></a>4. Prototype chain</h2><p>자바스크립트는 특정 객체의 프로퍼티나 메소드에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티 또는 메소드가 없다면 <code>[[Prototype]]</code> 프로퍼티가 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티나 메소드를 차례대로 검색한다. 이것을 프로토타입 체인이라 한다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> student = &#123;</div><div class=\"line\">  name: <span class=\"string\">'Lee'</span>,</div><div class=\"line\">  score: <span class=\"number\">90</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Object.prototype.hasOwnProperty()</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(student.hasOwnProperty(<span class=\"string\">'name'</span>)); <span class=\"comment\">// true</span></div></pre></td></tr></table></figure><h3 id=\"1-객체-리터럴-방식으로-생성된-객체의-프로토타입-체인\"><a href=\"#1-객체-리터럴-방식으로-생성된-객체의-프로토타입-체인\" class=\"headerlink\" title=\"1) 객체 리터럴 방식으로 생성된 객체의 프로토타입 체인\"></a>1) 객체 리터럴 방식으로 생성된 객체의 프로토타입 체인</h3><p>객체 생성 방법은 3가지가 있다.</p><ul><li>객체 리터럴</li><li>생성자 함수</li><li><code>Object()</code> 생성자 함수</li></ul><p>객체 리터럴 방식으로 생성된 객체는 결국 내장 함수(Built-in)인 <code>Object()</code> 생성자 함수로 객체를 생성하는 것을 단순화시킨 것이다. 자바스크립트 엔진은 객체 리터럴로 객체를 생성하는 코드를 만나면 내부적으로 <code>Object()</code> 생성자 함수를 사용하여 객체를 생성한다.</p><p><code>Object()</code> 생성자 함수는 물론 함수이다. 따라서 함수 객체인 <code>Object()</code> 생성자 함수는 일반 객체와 달리 prototype 프로퍼티가 있다.</p><ul><li><code>prototype</code> 프로퍼티는 함수 객체가 생성자로 사용될 때 이 함수를 통해 생성된 객체의 부모 역할을 하는 객체를 가리킨다.</li><li><code>[[Prototype]]</code> 프로퍼티는 객체의 입장에서 자신의 부모 역할을 하는 프로토타입 객체을 가리킨다.</li></ul><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;</div><div class=\"line\">  name: <span class=\"string\">'Lee'</span>,</div><div class=\"line\">  gender: <span class=\"string\">'male'</span>,</div><div class=\"line\">  sayHello: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi! my name is '</span> + <span class=\"keyword\">this</span>.name);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.dir(person);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person.__proto__ === <span class=\"built_in\">Object</span>.prototype);   <span class=\"comment\">// ① true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.prototype.constructor === <span class=\"built_in\">Object</span>); <span class=\"comment\">// ② true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.__proto__ === <span class=\"built_in\">Function</span>.prototype); <span class=\"comment\">// ③ true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Function</span>.prototype.__proto__ === <span class=\"built_in\">Object</span>.prototype); <span class=\"comment\">// ④ true</span></div></pre></td></tr></table></figure><p><img src=\"http://poiemaweb.com/img/object_literal_prototype_chaining.png\" alt=\"객체 리터럴로 생성한 객체의 프로토타입 체인\"><br><strong>결론적으로 객체 리터럴을 사용하여 객체를 생성한 경우, 그 객체의 프로토타입 객체는 <code>Object.prototype</code>이다.</strong></p><h3 id=\"2-생성자-함수로-생성된-객체의-프로토타입-체인\"><a href=\"#2-생성자-함수로-생성된-객체의-프로토타입-체인\" class=\"headerlink\" title=\"2) 생성자 함수로 생성된 객체의 프로토타입 체인\"></a>2) 생성자 함수로 생성된 객체의 프로토타입 체인</h3><p>생성자 함수로 객체를 생성하기 위해서는 우선 생성자 함수를 정의하여야 한다.</p><p>함수를 정의하는 방식은 3가지가 있다.</p><ul><li>함수선언식(Function declaration)</li><li>함수표현식(Function expression)</li><li><code>Function()</code> 생성자 함수</li></ul><p>함수표현식으로 함수를 정의할 때 함수 리터럴 방식을 사용한다.</p><p>3가지 함수 정의 방식은 결국 <code>Function()</code> 생성자 함수를 통해 함수 객체를 생성한다, 따라서 어떠한 방식으로 함수 객체를 생성하여도 모든 함수 객체의 <code>prototype</code> 객체는 <code>Function.prototype</code>이다. 생성자 함수도 함수 객체이므로 생성자 함수의 <code>prototype</code> 객체는 <code>Function.prototype</code>이다.</p><p>이제 객체의 관점에서 <code>prototype</code> 객체를 살펴보자. 객체를 생성하는 방식은 3가지가 있다. 3가지 객체 생성 방식에 의해 생성된 객체의 <code>prototype</code> 객체를 정리해 보면 아래와 같다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, gender</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  <span class=\"keyword\">this</span>.gender = gender;</div><div class=\"line\">  &lt;!-- <span class=\"keyword\">this</span>.sayHello = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi! my name is '</span> + <span class=\"keyword\">this</span>.name); --&gt;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Person.prototype = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHello</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi! my name is '</span> + <span class=\"keyword\">this</span>.name);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Lee'</span>, <span class=\"string\">'male'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.dir(Person);</div><div class=\"line\"><span class=\"built_in\">console</span>.dir(foo);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(foo.__proto__ === Person.prototype);                <span class=\"comment\">// ① true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype.__proto__ === <span class=\"built_in\">Object</span>.prototype);   <span class=\"comment\">// ② true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype.constructor === Person);           <span class=\"comment\">// ③ true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(Person.__proto__ === <span class=\"built_in\">Function</span>.prototype);           <span class=\"comment\">// ④ true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Function</span>.prototype.__proto__ === <span class=\"built_in\">Object</span>.prototype); <span class=\"comment\">// ⑤ true</span></div></pre></td></tr></table></figure><p><img src=\"http://poiemaweb.com/img/constructor_function_prototype_chaining.png\" alt=\"Person 생성자 프로토타입 체인\"></p><p><code>foo</code> 객체의 프로토타입 객체 <code>Person.prototype</code> 객체와 <code>Person()</code> 생성자 함수의 프로토타입 객체인 <code>Function.prototype</code>의 프로토타입 객체는 <code>Object.prototype</code> 객체이다.</p><p>이는 객체 리터럴 방식이나 생성자 함수 방식이나 결국은 모든 객체의 부모 객체인 <code>Object.prototype</code> 객체에서 프로토타입 체인이 끝나기 때문이다. 이때 <code>Object.prototype</code> 객체를 프로토타입 체인의 종점(End of prototype chain)이라 한다.</p><h2 id=\"5-프로토타입-객체의-확장\"><a href=\"#5-프로토타입-객체의-확장\" class=\"headerlink\" title=\"5. 프로토타입 객체의 확장\"></a>5. 프로토타입 객체의 확장</h2><p>프로토타입 객체도 객체이므로 일반 객체와 같이 프로퍼티를 추가/삭제할 수 있다. 그리고 이렇게 추가/삭제된 프로퍼티는 즉시 프로토타입 체인에 반영된다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Lee'</span>);</div><div class=\"line\"></div><div class=\"line\">Person.prototype.sayHello = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi! my name is '</span> + <span class=\"keyword\">this</span>.name);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">foo.sayHello();</div></pre></td></tr></table></figure><p>생성자 함수 <code>Person</code>은 <code>prototype</code> 프로퍼티에 연결된 프로토타입 객체 <code>Person.prototype</code>를 갖는다. <code>Person.prototype</code> 객체는 일반 객체와 같이 프로퍼티를 추가/삭제가 가능하다. 위의 예에서는 <code>Person.prototype</code> 객체에 메소드 <code>sayHello</code>를 추가하였다. 이때 <code>sayHello</code> 메소드는 프로토타입 체인에 반영된다. 따라서 생성자 함수 <code>Person</code>에 의해 생성된 모든 객체는 프로토타입 체인에 의해 부모객체인 <code>Person.prototype</code>의 메소드를 사용할 수 있게 되었다.<br><img src=\"http://poiemaweb.com/img/extension_prototype.png\" alt=\"생성자\"></p><p><br></p><h2 id=\"6-기본자료형-Primitive-data-type-의-확장\"><a href=\"#6-기본자료형-Primitive-data-type-의-확장\" class=\"headerlink\" title=\"6. 기본자료형(Primitive data type)의 확장\"></a>6. 기본자료형(Primitive data type)의 확장</h2><p>자바스크립트에서 기본자료형(숫자, 문자열, boolean, null, undefined)을 제외한 모든것은 객체이다. 그런데 아래 예제를 살펴보면 기본자료형인 문자열이 흡사 객체와 같이 동작한다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'test'</span>; <span class=\"comment\">//리터럴 방식으로 객체 선언</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> str);                 <span class=\"comment\">// string</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.constructor === <span class=\"built_in\">String</span>); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.dir(str);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> strObj = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">'test'</span>);</div><div class=\"line\"><span class=\"comment\">//객체인 문자열을 생성한다.</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> strObj);                 <span class=\"comment\">// object</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(strObj.constructor === <span class=\"built_in\">String</span>); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.dir(strObj);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.toUpperCase());    <span class=\"comment\">// TEST</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(strObj.toUpperCase()); <span class=\"comment\">// TEST</span></div></pre></td></tr></table></figure><ul><li>기본자료형과 객체의 차이:<br>기본자료형은 상속, 프로퍼티, 메서드 개념이 없다. 그저 데이터(값)그 자체이다.</li></ul><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'test'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 에러가 발생하지 않는다.</span></div><div class=\"line\">str.myMethod = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'str.myMethod'</span>);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">str.myMethod(); <span class=\"comment\">// Uncaught TypeError: str.myMethod is not a function</span></div></pre></td></tr></table></figure><p><code>String</code>은 래퍼객체이다. 문자열을 <code>String</code>의 객체로 선언하면 <code>String</code> 객체 내부의 메소드를 사용할 수 있다. 그런데 모든 문자열을 다룰 때, 항상 객체로 다시 선언해주기에는 큰 번거로움이 따른다. 따라서 문자열 기본자료형에 <code>.</code>을 붙이면 자동으로 자바스크립트 엔진이 래퍼 객체를 통해 일시적으로 문자열 객체로 변환해준다. 따라서 리터럴 방식으로 선언한 기본자료형 문자열도 <code>String</code>객체의 메소드를 사용할 수 있게 된다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'test'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">String</span>.prototype.myMethod = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'myMethod'</span>;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.myMethod());      <span class=\"comment\">// myMethod</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'string'</span>.myMethod()); <span class=\"comment\">// myMethod</span></div><div class=\"line\"><span class=\"built_in\">console</span>.dir(<span class=\"built_in\">String</span>.prototype);</div></pre></td></tr></table></figure><p>기본자료형 문자열과 <code>String()</code> 생성자 함수로 생성한 문자열 객체의 타입은 분명이 다르다. 기본 자료형은 객체가 아니므로 프로퍼티나 메소드를 가질수 없다. 하지만 기본자료형으로 프로퍼티나 메소드를 호출할 때 기본자료형과 연관된 객체로 일시적으로 변환되어 프로토타입 객체를 공유하게 된다.</p><p>기본자료형은 객체가 아니므로 <code>.</code>을 통해 바로 프로퍼티나 메소드를 직접 추가할 수 없다. 기본자료형은 오직 참조만 할 수 있다.</p><p>만약 기본자료형으로 메소드를 추가하고자 한다면, <code>String</code> 객체의 프로토타입 객체 <code>String.prototype</code>에 메소드를 추가하는 방법이 있다. 하지만 이는 위험 부담이 따른다.</p><p>앞선 방법으로 메소드를 추가하는 것은 <code>Built-in</code> 객체인 <code>String</code> 객체의 메소드들(표준)과 섞이거나 변수명의 중복으로 인해 기존 메소드가 지워지는 문제가 있을 수 있기 때문에 좋은 방식은 아니다. 이처럼 표준 이외의 메소드를 추가하는 것이 일종의 라이브러리인데, 라이브러리를 만들고자 할 때는 차라리 커스텀 객체를 따로 생성하는 것이 좋다.</p><p>앞서 살펴본 바와 같이 모든 객체는 프로토타입 체인에 의해 <code>Object.prototype</code> 객체의 메소드를 사용할 수 있었다. <code>Object.prototype</code> 객체는 프로토타입 체인의 종점으로 모든 객체가 사용할 수 있는 메소드를 갖는다.</p><p>이후 살펴보게 될 <code>Built-in object</code>(내장 객체)의 <code>Global objects</code> (Standard Built-in Objects)인 <code>String</code>, <code>Number</code>, <code>Array</code> 객체 등이 가지고 있는 표준 메소드는 프로토타입 객체인 <code>String.prototype</code>, <code>Number.prototype</code>, <code>Array.prototype</code> 등에 정의되어 있다. 이들 프로토타입 객체 또한 <code>Object.prototype</code>를 프로토타입 체인에 의해 자신의 프로토타입 객체로 연결한다.</p><p>자바스크립트는 표준 내장 객체의 프로토타입 객체에 개발자가 정의한 메소드의 추가를 허용한다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'test'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">String</span>.prototype.myMethod = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'myMethod'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.myMethod());</div><div class=\"line\"><span class=\"built_in\">console</span>.dir(<span class=\"built_in\">String</span>.prototype);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.__proto__ === <span class=\"built_in\">String</span>.prototype);                 <span class=\"comment\">// ① true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">String</span>.prototype.__proto__  === <span class=\"built_in\">Object</span>.prototype);   <span class=\"comment\">// ② true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">String</span>.prototype.constructor === <span class=\"built_in\">String</span>);            <span class=\"comment\">// ③ true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">String</span>.__proto__ === <span class=\"built_in\">Function</span>.prototype);            <span class=\"comment\">// ④ true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Function</span>.prototype.__proto__  === <span class=\"built_in\">Object</span>.prototype); <span class=\"comment\">// ⑤ true</span></div></pre></td></tr></table></figure><p><img src=\"http://poiemaweb.com/img/string_constructor_function_prototype_chaining.png\" alt=\"\"></p><p><br></p><h2 id=\"7-프로토타입-객체의-변경\"><a href=\"#7-프로토타입-객체의-변경\" class=\"headerlink\" title=\"7. 프로토타입 객체의 변경\"></a>7. 프로토타입 객체의 변경</h2><p>객체를 생성할 때 프로토타입은 결정된다. 결정된 프로토타입 객체는 다른 임의의 객체로 변경할 수 있다. 이것은 부모 객체인 프로토타입을 동적으로 변경할 수 있다는 것을 의미한다. 이러한 특징을 활용하여 객체의 상속을 구현할 수 있다.</p><p>이때 주의할 것은 프로토타입 객체를 변경하면</p><p>프로토타입 객체 변경 시점 이전에 생성된 객체<br>기존 프로토타입 객체를 <code>[[Prototype]]</code> 프로퍼티에 바인딩한다.<br>프로토타입 객체 변경 시점 이후에 생성된 객체<br>변경된 프로토타입 객체를 <code>[[Prototype]]</code> 프로퍼티에 바인딩한다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Lee'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 프로토타입 객체의 변경</span></div><div class=\"line\">Person.prototype = &#123; <span class=\"attr\">gender</span>: <span class=\"string\">'male'</span> &#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Kim'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(foo.gender); <span class=\"comment\">// undefined</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(bar.gender); <span class=\"comment\">// 'male'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(foo.constructor); <span class=\"comment\">// ① Person(name)</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(bar.constructor); <span class=\"comment\">// ② Object()</span></div></pre></td></tr></table></figure><p><img src=\"http://poiemaweb.com/img/changing_prototype.png\" alt=\"\"></p><p>① constructor 프로퍼티는 <code>Person()</code> 생성자 함수를 가리킨다.</p><p>② 프로토타입 객체 변경 후, <code>Person()</code> 생성자 함수의 <code>Prototype</code> 프로퍼티가 가리키는 프로토타입 객체를 일반 객체로 변경하면서 <code>Person.prototype.constructor</code> 프로퍼티도 삭제되었다. 따라서 프로토타입 체인에 의해 <code>bar.constructor</code>의 값은 프로토타입 체이닝에 의해 <code>Object.prototype.constructor</code> 즉 <code>Object()</code> 생성자 함수가 된다.</p><p>위 예제의 상속 방식은 물론 가능한 방식이지만, 문제점이 많기 때문에 사용하지 않는 방식이다.</p><p><br></p><h3 id=\"8-프로토타입-체인-동작\"><a href=\"#8-프로토타입-체인-동작\" class=\"headerlink\" title=\"8. 프로토타입 체인 동작\"></a>8. 프로토타입 체인 동작</h3><p>기본적인 프로토타입 체인은 참조할 때 동작한다. 프로퍼티 동적 추가에서 객체에 프로퍼티가 존재하지 않으면 프로퍼티를 추가한다.</p><p>객체의 프로퍼티에 값을 할당하는 경우, 프로토타입 체인이 동작하지 않는다. 이는 객체에 해당 프로퍼티가 있는 경우, 값을 재할당하고 해당 프로퍼티가 없는 경우는 해당 객체에 프로퍼티를 동적으로 추가하기 때문이다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Person.prototype.gender = <span class=\"string\">'male'</span>; <span class=\"comment\">// ①</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Lee'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Kim'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(foo.gender); <span class=\"comment\">// ① 'male'</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(bar.gender); <span class=\"comment\">// ① 'male'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 1. foo 객체에 gender 프로퍼티가 없으면 프로퍼티 동적 추가</span></div><div class=\"line\"><span class=\"comment\">// 2. foo 객체에 gender 프로퍼티가 있으면 해당 프로퍼티에 값 할당</span></div><div class=\"line\">foo.gender = <span class=\"string\">'female'</span>;   <span class=\"comment\">// ②</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(foo.gender); <span class=\"comment\">// ② 'female'</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(bar.gender); <span class=\"comment\">// ① 'male'</span></div></pre></td></tr></table></figure><blockquote><p>프로토 타입 체이닝은 <strong>참조할 때 위로 올라가는 것</strong>이다. <strong>프로퍼티를 추가할 때는 자기 자신에게</strong> 추가한다.</p></blockquote><hr><p><strong>Reference</strong></p><ul><li><a href=\"poiemaweb.com\">Poiemaweb</a></li><li>(서적)자바스크립트 닌자 비급, 인사이트, 2014</li><li>(서적) 인사이드 자바스크립트, 한빛, 2016</li></ul>"},{"title":"[JS] 클로져 Closure","date":"2017-08-07T15:35:42.000Z","_content":"\n![](https://www.bram.us/wordpress/wp-content/uploads/2016/06/javascript-logo-banner.jpg)\n\n# 클로저\n\n## 1. 클로저의 개념\n\n클로저는 자바스크립트에서 중요한 개념 중 하나이다. 클로저는 자바스크립트 고유의 개념이 아니라 함수를 일급 객체로 취급하는 함수형 언어에서 사용되는 중요한 속성이다. 클로저란, 이미 생명 주기가 끝난 외부 함수의 변수를 참조하는 함수이다.\n\n```javascript\nfunction outerFunc() {  //...(1)\n  var x = 10; \n  var innerFunc = function() { //...(2)\n    console.log(x); //...(3)\n  };\n  innerFunc();\n}\nouterFunc();\n```\n\n위 예제를 통해 살펴보면, outerFunc 함수가 선언되었고 ...(1)  \n그 내부 함수로 innerFunc가 선언되었다. ...(2)  \ninnerFunc는 자신을 포함하고 있는 outerFunc의 지역 변수 x에 접근할 수 있다. ...(3)  \n\n자바스크립트 엔진은 Scope-chain을 통해 중첩된 함수의 scope 레퍼런스를 차례대로 검색한다.  \n\n1. innerFunc 함수 내에서 변수 x를 검색한다. x가 존재하지 않는다. 검색 실패.\n2. innerFunc 함수의 외부 함수 outerFunc 함수에서 변수 x를 검색한다. x가 존재한다. 검색 성공!\n\n이번에는 innerFunc를 outerFunc에서 반환하는 코드로 변경해보자.  \n\n```javascript\nfunction outerFunc(){ // ...(1)\n  var x = 10;\n  var innerFunc = function () { //...(2)\n    console.log(x);\n  };\n  return innerFunc; //...(3)\n}\n\nvar inner = outerFunc(); // ...(4)\ninner(); //...(5)\n```\n\n(1), (2) 과정은 위와 동일하고, innerFunc를 반환하는 outerFunc를 정의하였다. ...(3)  \ninner 변수에 outerFunc() 함수의 실행 결과를 저장한다. outerFunc의 실행 결과로 innerFunc의 참조가 반환된다. 결론적으로 innerFunc 함수의 참조가 변수 inner에 할당된다. 그리고 이때, outerFunc 함수가 종료되면서 life-cycle이 종료된다. ...(4)  \n변수 inner에 할당된 참조값을 통해 innerFunc 함수를 실행한다....(5)  \n즉 outerFunc는 실행된 이후 콜스택(call stack)에서 제거되었으므로 함수 outerFunc의 지역변수 x 또한 더이상 유효하지 않게 되어 변수 x에 접근할 수 있는 방법이 없어 보인다. 하지만 위 코드의 실행 결과는 변수 x의 값인 10이다. \n\n원래대로라면 외부 함수 내에 있는 지역 변수는 외부함수의 실행 컨텍스트에 구속되어 있는 존재이기 때문에 외부함수가 사라지면 함께 사라져야 한다. 하지만 지역 변수가 외부 함수 내부에, 같은 유효범위 내에 선안된 내부 함수에 의해 참조되면, 그 변수의 life cycle은 외부 함수보다 길어진다. 외부 함수의 참조는 끊어지지만, 외부 함수의 지역 변수는 내부 함수가 호출되면서 함께 계속 참조되므로 <sup>1)</sup>가비지 컬렉션의 수집 대상에서 벗어난다. 그리고 지역 변수의 라이프 사이클은 내부 함수와 함께 가게 된다. 즉, 내부 함수가 종료될 때 까지 살아있는 변수로 남게 되는 것이다.\n\n> <sup>1)</sup> 가비지컬렉션: 자바스크립트는 변수나 함수를 선언할 때 메모리를 할당한다. 그리고 할당된 메모리가 필요하지 않게 되면, 즉 어떤 변수나 함수에서도 더이상 참조하지 않게 되면 자바스크립트의 [가비지 컬렉션](https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management)이 메모리를 해제한다.\n\n* 내부 함수가 외부 함수의 지역변수에 접근할 수 있다.\n* 외부 함수는 외부 함수의 지역변수를 사용하는 내부 함수가 소멸될 때까지 소멸되지 못하고 상태가 유지되며, 내부 함수에 의해 소멸하게 된다.\n\n### 위와 같은 특성을 **클로저(Closure)**라고 부른다.\n\n> 외부 함수 내에서 내부 함수를 선언할 때, 함수만 정의되는 것이 아니라, 그 시점에 같은 유효 범위에 있는 모든 변수를 포함하는 클로저도 생성된다. 그 다음, 내부 함수를 실행하면 함수가 속해있던 유효 범위가 사라진 후에 실행됨에도 클로저를 통해 정의된 원래 유효범위에 접근하게 된다. 이것이 클로저의 핵심이다. 클로저는 **보호막**을 만든다. 보호막은 함수가 선언된 시점의 유효범위 내에 있는 모든 함수와 변수를 가지고 있으며 필요할 때 그것들을 사용할 수 있다. 이 보호막은 함수가 동작하는 한 관련 정보를 유지한다. <자바스크립트 닌자 비급, p.118, 인사이트, 2014>\n\n### 1) 자유변수(Free variable)\n\n클로저에 의해 참조되는 외부 함수의 변수\n\n```javascript\nfunction outerFunc(){\n  var x = 10; // 자유변수\n  var innerFunc = function () {\n    console.log(x);\n  };\n  return innerFunc;\n}\n\nvar inner = outerFunc();\ninner();\n```\n\n예제의 outerFunc 함수의 지역 변수 x가 자유변수에 해당한다. 클로저라는 이름은 '자유변수에 함수가 닫혀있다(closed)'라는 의미로, 의역하자면 자유변수에 엮여있는 함수라는 뜻이다.  \n\n실행컨텍스트의 관점에서,  \n\n내부 함수가 유효한 상태에서 외부 함수가 종료된 경우를 생각해보자. 외부 함수의 실행 컨텍스트가 반환되어도, 그 내부의 Activation object(AO)는 유효하다. 다시 말해, 내부 함수가 Scope-chain을 통해 AO를 참조할 수 있다. 즉 외부함수가 이미 반환되었어도 외부함수 내의 변수는 자신을 필요로 하는 내부 함수가 하나 이상 존재하는 경우 계속 유지될 수 있다는 것이다. 이때 내부 함수가 외부 함수에 있는 변수의 **복사본이 아니라 실제** 변수에 접근한다는 것에 주의해야 한다.  \n\n![실행 컨텍스트의 Activation object와 클로저](http://poiemaweb.com/img/closure.png)\n\n<br>\n\n## 2. 클로저의 활용\n\n그렇다면 클로저는 언제 사용하는가?  \n\n클로저 정보를 저장하고 참조하는 데는 직접적인 비용이 발생한다. 클로저 정보를 따로 보관해두는 명시적인 \"closure\"객체 같은 것은 존재하지 않기 때문에 클로저를 이용해 정보에 접근하는 함수는 계속해서 관련된 정보를 가지고 다녀야 한다. 클로저는 정말 유용하지만, 오버헤드에서 자유롭다고 할 수 없다. 클로저에 관한 모든 정보는 더이상 사용하는 곳이 없을 때, 혹은 페이지가 언로드 될 때까지 메모리에 남아있는다. 따라서 클로저가 의도되지 않은 상황이었다면 이는 리소스 낭비일 뿐이다. 클로저는 의도된 상황에서 활용되어야 한다.\n\n### 1) 전역 변수의 사용 억제\n\n클로저의 필요성을 이해하기 위해, 버튼이 클릭될 때마다 클릭 횟수가 누적되어 화면에 표시되는 코드를 만들어보자.\n\n```html\n<!DOCTYPE html>\n<html>\n<body>\n  <p>전역 변수를 사용한 Counting</p>\n\n  <button type=\"button\" onclick=\"myFunction()\">Count!</button>\n\n  <p id=\"demo\">0</p>\n\n  <script>\n    var counter = 0; \n    // 전역변수의 사용은 그다지 좋지 못하다. 전역 변수를 쓰지 않는 방법을 찾아야 한다.\n\n    function add() {\n      return counter += 1;\n    }\n\n    function myFunction(){\n      document.getElementById('demo').innerHTML = add();\n    }\n  </script>\n</body>\n</html>\n```\n\n위 코드는 동작에는 전혀 무리가 없다. 다만 add 함수만을 위한 전역 변수를 사용하고 있다. 전역 변수는 어디서나 접근할 수 있어 의도치 않게 변수명이 중복되거나 값이 변경되었을 때 문제가 발생할 소지가 다분하다. 따라서 전역 변수를 쓰지 않는 방법을 강구해야 한다.\n\n```html\n<!DOCTYPE html>\n<html>\n<body>\n  <p>지역 변수를 사용한 Counting</p>\n\n  <button type=\"button\" onclick=\"myFunction()\">Count!</button>\n\n  <p id=\"demo\">0</p>\n\n  <script>\n    function add() {\n      var counter = 0; // 전역 변수에서 add 함수 내부의 지역 변수로 이동시켰다.\n      return counter += 1;\n    }\n\n    function myFunction(){\n      document.getElementById('demo').innerHTML = add();\n    }\n  </script>\n  </body>\n</html>\n```\n\n전역 변수를 피하기 위해 add 함수 내부로 이동시켜, 지역 변수로 다시 선언하였다. 그런데 이번엔 함수의 작동 방식에서 문제가 발생하였다. counter가 함수가 호출될 때마다 0으로 리셋되어 0 -> 1 -> 함수호출 -> 0 -> 1 을 반복하게 되어, 화면 상에는 1만 표시된다. 처음 의도했던 동작을 수행하지 못하여, 결국 이 방법도 해결책이 되지 못한다.\n\n```html\n<!DOCTYPE html>\n<html>\n  <body>\n  <p>클로저를 사용한 Counting</p>\n\n  <button type=\"button\" onclick=\"myFunction()\">Count!</button>\n\n  <p id=\"demo\">0</p>\n\n  <script>\n    var add = (function () { // 외부 함수 ...(1)\n      var counter = 0; // 외부 함수의 지역 변수 ...(2)\n      return function () { // 내부 함수 ...(3)\n        return counter += 1; // 외부 함수의 지역 변수 참조\n      }\n    })(); // 즉시 실행 함수\n\n    function myFunction(){\n      document.getElementById('demo').innerHTML = add(); //...(4)\n    }\n  </script>\n  </body>\n</html>\n```\n\n위 예제에서는 클로저를 활용하였다. 변수 `add`에 즉시실행함수가 외부함수로 호출되었다...(1)  \n`add()`를 실행하면 변수 `add`에 담긴 즉시실행함수가 실행되어...(4)  \n무명함수 `function () { return counter +=1; }`가 반환(return)된다...(3)  \n\n*즉시실행함수는 단 한번만 실행된다.* 따라서 `add`에 담긴 함수가 호출될 때마다 변수 `counter`가 초기화되는 일은 없을 것이다. 중요한 것은 `add`에 담겨 있는 내부 함수(3)는 변수 `counter`(2)에 접근할 수 있고 변수 `counter`는 `add`에 담겨 있는 내부 함수(3)가 소멸될 때까지 유지된다는 것이다. 이것이 클로저이다.\n\n변수 `counter`는 외부에서 직접 접근할 수 없는 `private`변수이므로 전역 변수를 사용했을 때와 같이 의도되지 않은 변경을 걱정할 필요도 없다.\n\n### 2) setTimeout()의 콜백 함수\n\n```html\n<!DOCTYPE html>\n<html>\n<body>\n  <p>새로고침으로 다시 실행해 보세요</p>\n  <script>\n    var fade = function (node) {\n      // 자유변수\n      var level = 1; // ②\n      var step = function() {\n        var hex = level.toString(16); // ④\n        \n        // hex: '1' ~ 'f'\n        node.style.backgroundColor = '#ff' + hex; // ⑤\n\n        if(level < 15) { // ⑥\n          level += 1;\n          setTimeout(step, 100); // ⑦\n        }\n      };\n      // setTimeout 호출 이후 fade 함수는 종료한다. 100ms 후 함수 step은 호출된다.\n      // 즉 외부 함수 fade보다 내부 함수 step이 더 오래 유지된다.\n      setTimeout(step, 100); // ③\n    };\n\n    fade(document.body); // ①\n  </script>\n</body>\n</html>\n```\n\nsetTimeout() 함수는 첫번째 파라미터에 콜백 함수를 전달하고, 파라미터에 ms(1/1000초)단위의 시간 간격을 지정한다. 즉 지정된 시간 간격으로 콜백 함수를 호출한다.\n\n① 함수 fade는 document.body를 인자로 전달받아 호출된다.  \n② 함수 fade의 지역변수 level은 1로 초기화되어 있다. 함수 step은 내부함수이며 외부함수 fade의 지역변수 level을 사용한다. level은 자유변수이다.  \n③ setTimeout 호출 이후 fade 함수는 종료한다. 100ms 후 함수 step은 호출된다. 즉 외부 함수 fade보다 내부 함수 step이 더 오래 유지된다.  \n④ 함수 step은 지역변수 hex을 갖는다. 이것은 16진수 문자열을 값으로 갖는다.   \n⑤ 함수 fade의 매개변수 node(document.body)의 배경색을 변경한다.  \n⑥ 변수 level이 15(f)보다 작은지 다시말해 16진수 범위 내(1~f)인지 확인한다.  \n⑦ level을 1 증가시키고 다시 함수 step을 호출하여 같은 작업을 반복한다.  \n\n이때 fade 함수는 이미 반환되었지만 외부함수 fade 내의 변수는 이를 필요로 하는 내부함수가 하나 이상 존재하는 경우 계속 유지된다. 이때 내부함수가 외부함수에 있는 변수의 복사본이 아니라 실제 변수에 접근한다는 것에 주의하여야 한다.  \n\n### 3) 자주 발생하는 실수\n\n아래 예제는 클로저 사용시 자주 발생하는 실수에 관한 예제이다.\n\n```javascript\nvar arr = [];\n\nfor (var i = 0; i < 5; i++) {\n  arr[i] = function () {\n    return i;\n  };\n}\n\nfor (var index = 0; index < arr.length; index++) {\n  console.log(arr[index]());\n}\n```\n\n배열 arr에 5개의 함수가 할당되고 각각의 함수는 순차적으로 0, 1, 2, 3, 4를 반환할 것으로 기대하겠지만 결과는 그렇지않다. 이유는 변수 i는 외부함수의 변수가 아닌 전역 변수이기 때문이다. 바르게 동작하는 코드는 아래와 같다.\n\n```javascript\nvar arr = [];\n\nfor (var i = 0; i < 5; i++){\n  arr[i] = (function (id) { // ②\n    return function () {\n      return id; // ③\n    };\n  })(i); // ①\n}\n\nfor (var index = 0; index < arr.length; index++) {\n  console.log(arr[index]());\n}\n```\n\n① 배열 arr에는 즉시실행함수에 의해 함수가 반환된다.\n\n② 이때 즉시실행함수는 i를 인자로 전달받고 매개변수 id에 할당한 후 내부 함수를 반환하고 life-cycle이 종료된다. 매개변수 id는 자유변수가 된다.\n\n③ 배열 arr에 할당된 함수는 id를 반환한다. 이때 id는 상위 스코프의 자유변수이므로 그 값이 유지된다.\n\n위 예제는 자바스크립트의 함수 레벨 스코프 특성으로 인해 for 루프의 초기문에서 사용된 변수의 스코프가 전역이 되기 때문에 발생하는 현상이다. ES6의 let 키워드를 사용하면 이와 같은 문제는 말끔히 해결된다.\n\n```javascript\nconst arr = [];\n\nfor (let i = 0; i < 5; i++) {\n  arr[i] = function () {\n    return i;\n  };\n}\n\nfor (let i = 0; i < arr.length; i++) {\n  console.log(arr[i]());\n}\n```\n\n---\nReference\n\n[Poiema Web](http://poiemaweb.com/js-closure)  \n[MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management)  \n[blog](http://chanlee.github.io/2013/12/10/understand-javascript-closure/)\n","source":"_posts/Javascript/03.Closure.md","raw":"---\ntitle: '[JS] 클로져 Closure'\ndate: 2017-08-08 00:35:42\ncategory: Javascript\ntags: closure\n---\n\n![](https://www.bram.us/wordpress/wp-content/uploads/2016/06/javascript-logo-banner.jpg)\n\n# 클로저\n\n## 1. 클로저의 개념\n\n클로저는 자바스크립트에서 중요한 개념 중 하나이다. 클로저는 자바스크립트 고유의 개념이 아니라 함수를 일급 객체로 취급하는 함수형 언어에서 사용되는 중요한 속성이다. 클로저란, 이미 생명 주기가 끝난 외부 함수의 변수를 참조하는 함수이다.\n\n```javascript\nfunction outerFunc() {  //...(1)\n  var x = 10; \n  var innerFunc = function() { //...(2)\n    console.log(x); //...(3)\n  };\n  innerFunc();\n}\nouterFunc();\n```\n\n위 예제를 통해 살펴보면, outerFunc 함수가 선언되었고 ...(1)  \n그 내부 함수로 innerFunc가 선언되었다. ...(2)  \ninnerFunc는 자신을 포함하고 있는 outerFunc의 지역 변수 x에 접근할 수 있다. ...(3)  \n\n자바스크립트 엔진은 Scope-chain을 통해 중첩된 함수의 scope 레퍼런스를 차례대로 검색한다.  \n\n1. innerFunc 함수 내에서 변수 x를 검색한다. x가 존재하지 않는다. 검색 실패.\n2. innerFunc 함수의 외부 함수 outerFunc 함수에서 변수 x를 검색한다. x가 존재한다. 검색 성공!\n\n이번에는 innerFunc를 outerFunc에서 반환하는 코드로 변경해보자.  \n\n```javascript\nfunction outerFunc(){ // ...(1)\n  var x = 10;\n  var innerFunc = function () { //...(2)\n    console.log(x);\n  };\n  return innerFunc; //...(3)\n}\n\nvar inner = outerFunc(); // ...(4)\ninner(); //...(5)\n```\n\n(1), (2) 과정은 위와 동일하고, innerFunc를 반환하는 outerFunc를 정의하였다. ...(3)  \ninner 변수에 outerFunc() 함수의 실행 결과를 저장한다. outerFunc의 실행 결과로 innerFunc의 참조가 반환된다. 결론적으로 innerFunc 함수의 참조가 변수 inner에 할당된다. 그리고 이때, outerFunc 함수가 종료되면서 life-cycle이 종료된다. ...(4)  \n변수 inner에 할당된 참조값을 통해 innerFunc 함수를 실행한다....(5)  \n즉 outerFunc는 실행된 이후 콜스택(call stack)에서 제거되었으므로 함수 outerFunc의 지역변수 x 또한 더이상 유효하지 않게 되어 변수 x에 접근할 수 있는 방법이 없어 보인다. 하지만 위 코드의 실행 결과는 변수 x의 값인 10이다. \n\n원래대로라면 외부 함수 내에 있는 지역 변수는 외부함수의 실행 컨텍스트에 구속되어 있는 존재이기 때문에 외부함수가 사라지면 함께 사라져야 한다. 하지만 지역 변수가 외부 함수 내부에, 같은 유효범위 내에 선안된 내부 함수에 의해 참조되면, 그 변수의 life cycle은 외부 함수보다 길어진다. 외부 함수의 참조는 끊어지지만, 외부 함수의 지역 변수는 내부 함수가 호출되면서 함께 계속 참조되므로 <sup>1)</sup>가비지 컬렉션의 수집 대상에서 벗어난다. 그리고 지역 변수의 라이프 사이클은 내부 함수와 함께 가게 된다. 즉, 내부 함수가 종료될 때 까지 살아있는 변수로 남게 되는 것이다.\n\n> <sup>1)</sup> 가비지컬렉션: 자바스크립트는 변수나 함수를 선언할 때 메모리를 할당한다. 그리고 할당된 메모리가 필요하지 않게 되면, 즉 어떤 변수나 함수에서도 더이상 참조하지 않게 되면 자바스크립트의 [가비지 컬렉션](https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management)이 메모리를 해제한다.\n\n* 내부 함수가 외부 함수의 지역변수에 접근할 수 있다.\n* 외부 함수는 외부 함수의 지역변수를 사용하는 내부 함수가 소멸될 때까지 소멸되지 못하고 상태가 유지되며, 내부 함수에 의해 소멸하게 된다.\n\n### 위와 같은 특성을 **클로저(Closure)**라고 부른다.\n\n> 외부 함수 내에서 내부 함수를 선언할 때, 함수만 정의되는 것이 아니라, 그 시점에 같은 유효 범위에 있는 모든 변수를 포함하는 클로저도 생성된다. 그 다음, 내부 함수를 실행하면 함수가 속해있던 유효 범위가 사라진 후에 실행됨에도 클로저를 통해 정의된 원래 유효범위에 접근하게 된다. 이것이 클로저의 핵심이다. 클로저는 **보호막**을 만든다. 보호막은 함수가 선언된 시점의 유효범위 내에 있는 모든 함수와 변수를 가지고 있으며 필요할 때 그것들을 사용할 수 있다. 이 보호막은 함수가 동작하는 한 관련 정보를 유지한다. <자바스크립트 닌자 비급, p.118, 인사이트, 2014>\n\n### 1) 자유변수(Free variable)\n\n클로저에 의해 참조되는 외부 함수의 변수\n\n```javascript\nfunction outerFunc(){\n  var x = 10; // 자유변수\n  var innerFunc = function () {\n    console.log(x);\n  };\n  return innerFunc;\n}\n\nvar inner = outerFunc();\ninner();\n```\n\n예제의 outerFunc 함수의 지역 변수 x가 자유변수에 해당한다. 클로저라는 이름은 '자유변수에 함수가 닫혀있다(closed)'라는 의미로, 의역하자면 자유변수에 엮여있는 함수라는 뜻이다.  \n\n실행컨텍스트의 관점에서,  \n\n내부 함수가 유효한 상태에서 외부 함수가 종료된 경우를 생각해보자. 외부 함수의 실행 컨텍스트가 반환되어도, 그 내부의 Activation object(AO)는 유효하다. 다시 말해, 내부 함수가 Scope-chain을 통해 AO를 참조할 수 있다. 즉 외부함수가 이미 반환되었어도 외부함수 내의 변수는 자신을 필요로 하는 내부 함수가 하나 이상 존재하는 경우 계속 유지될 수 있다는 것이다. 이때 내부 함수가 외부 함수에 있는 변수의 **복사본이 아니라 실제** 변수에 접근한다는 것에 주의해야 한다.  \n\n![실행 컨텍스트의 Activation object와 클로저](http://poiemaweb.com/img/closure.png)\n\n<br>\n\n## 2. 클로저의 활용\n\n그렇다면 클로저는 언제 사용하는가?  \n\n클로저 정보를 저장하고 참조하는 데는 직접적인 비용이 발생한다. 클로저 정보를 따로 보관해두는 명시적인 \"closure\"객체 같은 것은 존재하지 않기 때문에 클로저를 이용해 정보에 접근하는 함수는 계속해서 관련된 정보를 가지고 다녀야 한다. 클로저는 정말 유용하지만, 오버헤드에서 자유롭다고 할 수 없다. 클로저에 관한 모든 정보는 더이상 사용하는 곳이 없을 때, 혹은 페이지가 언로드 될 때까지 메모리에 남아있는다. 따라서 클로저가 의도되지 않은 상황이었다면 이는 리소스 낭비일 뿐이다. 클로저는 의도된 상황에서 활용되어야 한다.\n\n### 1) 전역 변수의 사용 억제\n\n클로저의 필요성을 이해하기 위해, 버튼이 클릭될 때마다 클릭 횟수가 누적되어 화면에 표시되는 코드를 만들어보자.\n\n```html\n<!DOCTYPE html>\n<html>\n<body>\n  <p>전역 변수를 사용한 Counting</p>\n\n  <button type=\"button\" onclick=\"myFunction()\">Count!</button>\n\n  <p id=\"demo\">0</p>\n\n  <script>\n    var counter = 0; \n    // 전역변수의 사용은 그다지 좋지 못하다. 전역 변수를 쓰지 않는 방법을 찾아야 한다.\n\n    function add() {\n      return counter += 1;\n    }\n\n    function myFunction(){\n      document.getElementById('demo').innerHTML = add();\n    }\n  </script>\n</body>\n</html>\n```\n\n위 코드는 동작에는 전혀 무리가 없다. 다만 add 함수만을 위한 전역 변수를 사용하고 있다. 전역 변수는 어디서나 접근할 수 있어 의도치 않게 변수명이 중복되거나 값이 변경되었을 때 문제가 발생할 소지가 다분하다. 따라서 전역 변수를 쓰지 않는 방법을 강구해야 한다.\n\n```html\n<!DOCTYPE html>\n<html>\n<body>\n  <p>지역 변수를 사용한 Counting</p>\n\n  <button type=\"button\" onclick=\"myFunction()\">Count!</button>\n\n  <p id=\"demo\">0</p>\n\n  <script>\n    function add() {\n      var counter = 0; // 전역 변수에서 add 함수 내부의 지역 변수로 이동시켰다.\n      return counter += 1;\n    }\n\n    function myFunction(){\n      document.getElementById('demo').innerHTML = add();\n    }\n  </script>\n  </body>\n</html>\n```\n\n전역 변수를 피하기 위해 add 함수 내부로 이동시켜, 지역 변수로 다시 선언하였다. 그런데 이번엔 함수의 작동 방식에서 문제가 발생하였다. counter가 함수가 호출될 때마다 0으로 리셋되어 0 -> 1 -> 함수호출 -> 0 -> 1 을 반복하게 되어, 화면 상에는 1만 표시된다. 처음 의도했던 동작을 수행하지 못하여, 결국 이 방법도 해결책이 되지 못한다.\n\n```html\n<!DOCTYPE html>\n<html>\n  <body>\n  <p>클로저를 사용한 Counting</p>\n\n  <button type=\"button\" onclick=\"myFunction()\">Count!</button>\n\n  <p id=\"demo\">0</p>\n\n  <script>\n    var add = (function () { // 외부 함수 ...(1)\n      var counter = 0; // 외부 함수의 지역 변수 ...(2)\n      return function () { // 내부 함수 ...(3)\n        return counter += 1; // 외부 함수의 지역 변수 참조\n      }\n    })(); // 즉시 실행 함수\n\n    function myFunction(){\n      document.getElementById('demo').innerHTML = add(); //...(4)\n    }\n  </script>\n  </body>\n</html>\n```\n\n위 예제에서는 클로저를 활용하였다. 변수 `add`에 즉시실행함수가 외부함수로 호출되었다...(1)  \n`add()`를 실행하면 변수 `add`에 담긴 즉시실행함수가 실행되어...(4)  \n무명함수 `function () { return counter +=1; }`가 반환(return)된다...(3)  \n\n*즉시실행함수는 단 한번만 실행된다.* 따라서 `add`에 담긴 함수가 호출될 때마다 변수 `counter`가 초기화되는 일은 없을 것이다. 중요한 것은 `add`에 담겨 있는 내부 함수(3)는 변수 `counter`(2)에 접근할 수 있고 변수 `counter`는 `add`에 담겨 있는 내부 함수(3)가 소멸될 때까지 유지된다는 것이다. 이것이 클로저이다.\n\n변수 `counter`는 외부에서 직접 접근할 수 없는 `private`변수이므로 전역 변수를 사용했을 때와 같이 의도되지 않은 변경을 걱정할 필요도 없다.\n\n### 2) setTimeout()의 콜백 함수\n\n```html\n<!DOCTYPE html>\n<html>\n<body>\n  <p>새로고침으로 다시 실행해 보세요</p>\n  <script>\n    var fade = function (node) {\n      // 자유변수\n      var level = 1; // ②\n      var step = function() {\n        var hex = level.toString(16); // ④\n        \n        // hex: '1' ~ 'f'\n        node.style.backgroundColor = '#ff' + hex; // ⑤\n\n        if(level < 15) { // ⑥\n          level += 1;\n          setTimeout(step, 100); // ⑦\n        }\n      };\n      // setTimeout 호출 이후 fade 함수는 종료한다. 100ms 후 함수 step은 호출된다.\n      // 즉 외부 함수 fade보다 내부 함수 step이 더 오래 유지된다.\n      setTimeout(step, 100); // ③\n    };\n\n    fade(document.body); // ①\n  </script>\n</body>\n</html>\n```\n\nsetTimeout() 함수는 첫번째 파라미터에 콜백 함수를 전달하고, 파라미터에 ms(1/1000초)단위의 시간 간격을 지정한다. 즉 지정된 시간 간격으로 콜백 함수를 호출한다.\n\n① 함수 fade는 document.body를 인자로 전달받아 호출된다.  \n② 함수 fade의 지역변수 level은 1로 초기화되어 있다. 함수 step은 내부함수이며 외부함수 fade의 지역변수 level을 사용한다. level은 자유변수이다.  \n③ setTimeout 호출 이후 fade 함수는 종료한다. 100ms 후 함수 step은 호출된다. 즉 외부 함수 fade보다 내부 함수 step이 더 오래 유지된다.  \n④ 함수 step은 지역변수 hex을 갖는다. 이것은 16진수 문자열을 값으로 갖는다.   \n⑤ 함수 fade의 매개변수 node(document.body)의 배경색을 변경한다.  \n⑥ 변수 level이 15(f)보다 작은지 다시말해 16진수 범위 내(1~f)인지 확인한다.  \n⑦ level을 1 증가시키고 다시 함수 step을 호출하여 같은 작업을 반복한다.  \n\n이때 fade 함수는 이미 반환되었지만 외부함수 fade 내의 변수는 이를 필요로 하는 내부함수가 하나 이상 존재하는 경우 계속 유지된다. 이때 내부함수가 외부함수에 있는 변수의 복사본이 아니라 실제 변수에 접근한다는 것에 주의하여야 한다.  \n\n### 3) 자주 발생하는 실수\n\n아래 예제는 클로저 사용시 자주 발생하는 실수에 관한 예제이다.\n\n```javascript\nvar arr = [];\n\nfor (var i = 0; i < 5; i++) {\n  arr[i] = function () {\n    return i;\n  };\n}\n\nfor (var index = 0; index < arr.length; index++) {\n  console.log(arr[index]());\n}\n```\n\n배열 arr에 5개의 함수가 할당되고 각각의 함수는 순차적으로 0, 1, 2, 3, 4를 반환할 것으로 기대하겠지만 결과는 그렇지않다. 이유는 변수 i는 외부함수의 변수가 아닌 전역 변수이기 때문이다. 바르게 동작하는 코드는 아래와 같다.\n\n```javascript\nvar arr = [];\n\nfor (var i = 0; i < 5; i++){\n  arr[i] = (function (id) { // ②\n    return function () {\n      return id; // ③\n    };\n  })(i); // ①\n}\n\nfor (var index = 0; index < arr.length; index++) {\n  console.log(arr[index]());\n}\n```\n\n① 배열 arr에는 즉시실행함수에 의해 함수가 반환된다.\n\n② 이때 즉시실행함수는 i를 인자로 전달받고 매개변수 id에 할당한 후 내부 함수를 반환하고 life-cycle이 종료된다. 매개변수 id는 자유변수가 된다.\n\n③ 배열 arr에 할당된 함수는 id를 반환한다. 이때 id는 상위 스코프의 자유변수이므로 그 값이 유지된다.\n\n위 예제는 자바스크립트의 함수 레벨 스코프 특성으로 인해 for 루프의 초기문에서 사용된 변수의 스코프가 전역이 되기 때문에 발생하는 현상이다. ES6의 let 키워드를 사용하면 이와 같은 문제는 말끔히 해결된다.\n\n```javascript\nconst arr = [];\n\nfor (let i = 0; i < 5; i++) {\n  arr[i] = function () {\n    return i;\n  };\n}\n\nfor (let i = 0; i < arr.length; i++) {\n  console.log(arr[i]());\n}\n```\n\n---\nReference\n\n[Poiema Web](http://poiemaweb.com/js-closure)  \n[MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management)  \n[blog](http://chanlee.github.io/2013/12/10/understand-javascript-closure/)\n","slug":"Javascript/03.Closure","published":1,"updated":"2017-09-21T05:52:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjai8h180000hvb9qsuoujbly","content":"<p><img src=\"https://www.bram.us/wordpress/wp-content/uploads/2016/06/javascript-logo-banner.jpg\" alt=\"\"></p><h1 id=\"클로저\"><a href=\"#클로저\" class=\"headerlink\" title=\"클로저\"></a>클로저</h1><h2 id=\"1-클로저의-개념\"><a href=\"#1-클로저의-개념\" class=\"headerlink\" title=\"1. 클로저의 개념\"></a>1. 클로저의 개념</h2><p>클로저는 자바스크립트에서 중요한 개념 중 하나이다. 클로저는 자바스크립트 고유의 개념이 아니라 함수를 일급 객체로 취급하는 함수형 언어에서 사용되는 중요한 속성이다. 클로저란, 이미 생명 주기가 끝난 외부 함수의 변수를 참조하는 함수이다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">outerFunc</span>(<span class=\"params\"></span>) </span>&#123;  <span class=\"comment\">//...(1)</span></div><div class=\"line\">  <span class=\"keyword\">var</span> x = <span class=\"number\">10</span>; </div><div class=\"line\">  <span class=\"keyword\">var</span> innerFunc = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">//...(2)</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(x); <span class=\"comment\">//...(3)</span></div><div class=\"line\">  &#125;;</div><div class=\"line\">  innerFunc();</div><div class=\"line\">&#125;</div><div class=\"line\">outerFunc();</div></pre></td></tr></table></figure><p>위 예제를 통해 살펴보면, outerFunc 함수가 선언되었고 …(1)<br>그 내부 함수로 innerFunc가 선언되었다. …(2)<br>innerFunc는 자신을 포함하고 있는 outerFunc의 지역 변수 x에 접근할 수 있다. …(3)</p><p>자바스크립트 엔진은 Scope-chain을 통해 중첩된 함수의 scope 레퍼런스를 차례대로 검색한다.</p><ol><li>innerFunc 함수 내에서 변수 x를 검색한다. x가 존재하지 않는다. 검색 실패.</li><li>innerFunc 함수의 외부 함수 outerFunc 함수에서 변수 x를 검색한다. x가 존재한다. 검색 성공!</li></ol><p>이번에는 innerFunc를 outerFunc에서 반환하는 코드로 변경해보자.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">outerFunc</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">// ...(1)</span></div><div class=\"line\">  <span class=\"keyword\">var</span> x = <span class=\"number\">10</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> innerFunc = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">//...(2)</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(x);</div><div class=\"line\">  &#125;;</div><div class=\"line\">  <span class=\"keyword\">return</span> innerFunc; <span class=\"comment\">//...(3)</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> inner = outerFunc(); <span class=\"comment\">// ...(4)</span></div><div class=\"line\">inner(); <span class=\"comment\">//...(5)</span></div></pre></td></tr></table></figure><p>(1), (2) 과정은 위와 동일하고, innerFunc를 반환하는 outerFunc를 정의하였다. …(3)<br>inner 변수에 outerFunc() 함수의 실행 결과를 저장한다. outerFunc의 실행 결과로 innerFunc의 참조가 반환된다. 결론적으로 innerFunc 함수의 참조가 변수 inner에 할당된다. 그리고 이때, outerFunc 함수가 종료되면서 life-cycle이 종료된다. …(4)<br>변수 inner에 할당된 참조값을 통해 innerFunc 함수를 실행한다….(5)<br>즉 outerFunc는 실행된 이후 콜스택(call stack)에서 제거되었으므로 함수 outerFunc의 지역변수 x 또한 더이상 유효하지 않게 되어 변수 x에 접근할 수 있는 방법이 없어 보인다. 하지만 위 코드의 실행 결과는 변수 x의 값인 10이다.</p><p>원래대로라면 외부 함수 내에 있는 지역 변수는 외부함수의 실행 컨텍스트에 구속되어 있는 존재이기 때문에 외부함수가 사라지면 함께 사라져야 한다. 하지만 지역 변수가 외부 함수 내부에, 같은 유효범위 내에 선안된 내부 함수에 의해 참조되면, 그 변수의 life cycle은 외부 함수보다 길어진다. 외부 함수의 참조는 끊어지지만, 외부 함수의 지역 변수는 내부 함수가 호출되면서 함께 계속 참조되므로 <sup>1)</sup>가비지 컬렉션의 수집 대상에서 벗어난다. 그리고 지역 변수의 라이프 사이클은 내부 함수와 함께 가게 된다. 즉, 내부 함수가 종료될 때 까지 살아있는 변수로 남게 되는 것이다.</p><blockquote><p><sup>1)</sup> 가비지컬렉션: 자바스크립트는 변수나 함수를 선언할 때 메모리를 할당한다. 그리고 할당된 메모리가 필요하지 않게 되면, 즉 어떤 변수나 함수에서도 더이상 참조하지 않게 되면 자바스크립트의 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management\" target=\"_blank\" rel=\"external\">가비지 컬렉션</a>이 메모리를 해제한다.</p></blockquote><ul><li>내부 함수가 외부 함수의 지역변수에 접근할 수 있다.</li><li>외부 함수는 외부 함수의 지역변수를 사용하는 내부 함수가 소멸될 때까지 소멸되지 못하고 상태가 유지되며, 내부 함수에 의해 소멸하게 된다.</li></ul><h3 id=\"위와-같은-특성을-클로저-Closure-라고-부른다\"><a href=\"#위와-같은-특성을-클로저-Closure-라고-부른다\" class=\"headerlink\" title=\"위와 같은 특성을 클로저(Closure)라고 부른다.\"></a>위와 같은 특성을 <strong>클로저(Closure)</strong>라고 부른다.</h3><blockquote><p>외부 함수 내에서 내부 함수를 선언할 때, 함수만 정의되는 것이 아니라, 그 시점에 같은 유효 범위에 있는 모든 변수를 포함하는 클로저도 생성된다. 그 다음, 내부 함수를 실행하면 함수가 속해있던 유효 범위가 사라진 후에 실행됨에도 클로저를 통해 정의된 원래 유효범위에 접근하게 된다. 이것이 클로저의 핵심이다. 클로저는 <strong>보호막</strong>을 만든다. 보호막은 함수가 선언된 시점의 유효범위 내에 있는 모든 함수와 변수를 가지고 있으며 필요할 때 그것들을 사용할 수 있다. 이 보호막은 함수가 동작하는 한 관련 정보를 유지한다. &lt;자바스크립트 닌자 비급, p.118, 인사이트, 2014&gt;</p></blockquote><h3 id=\"1-자유변수-Free-variable\"><a href=\"#1-자유변수-Free-variable\" class=\"headerlink\" title=\"1) 자유변수(Free variable)\"></a>1) 자유변수(Free variable)</h3><p>클로저에 의해 참조되는 외부 함수의 변수</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">outerFunc</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> x = <span class=\"number\">10</span>; <span class=\"comment\">// 자유변수</span></div><div class=\"line\">  <span class=\"keyword\">var</span> innerFunc = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(x);</div><div class=\"line\">  &#125;;</div><div class=\"line\">  <span class=\"keyword\">return</span> innerFunc;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> inner = outerFunc();</div><div class=\"line\">inner();</div></pre></td></tr></table></figure><p>예제의 outerFunc 함수의 지역 변수 x가 자유변수에 해당한다. 클로저라는 이름은 ‘자유변수에 함수가 닫혀있다(closed)’라는 의미로, 의역하자면 자유변수에 엮여있는 함수라는 뜻이다.</p><p>실행컨텍스트의 관점에서,</p><p>내부 함수가 유효한 상태에서 외부 함수가 종료된 경우를 생각해보자. 외부 함수의 실행 컨텍스트가 반환되어도, 그 내부의 Activation object(AO)는 유효하다. 다시 말해, 내부 함수가 Scope-chain을 통해 AO를 참조할 수 있다. 즉 외부함수가 이미 반환되었어도 외부함수 내의 변수는 자신을 필요로 하는 내부 함수가 하나 이상 존재하는 경우 계속 유지될 수 있다는 것이다. 이때 내부 함수가 외부 함수에 있는 변수의 <strong>복사본이 아니라 실제</strong> 변수에 접근한다는 것에 주의해야 한다.</p><p><img src=\"http://poiemaweb.com/img/closure.png\" alt=\"실행 컨텍스트의 Activation object와 클로저\"></p><p><br></p><h2 id=\"2-클로저의-활용\"><a href=\"#2-클로저의-활용\" class=\"headerlink\" title=\"2. 클로저의 활용\"></a>2. 클로저의 활용</h2><p>그렇다면 클로저는 언제 사용하는가?</p><p>클로저 정보를 저장하고 참조하는 데는 직접적인 비용이 발생한다. 클로저 정보를 따로 보관해두는 명시적인 “closure”객체 같은 것은 존재하지 않기 때문에 클로저를 이용해 정보에 접근하는 함수는 계속해서 관련된 정보를 가지고 다녀야 한다. 클로저는 정말 유용하지만, 오버헤드에서 자유롭다고 할 수 없다. 클로저에 관한 모든 정보는 더이상 사용하는 곳이 없을 때, 혹은 페이지가 언로드 될 때까지 메모리에 남아있는다. 따라서 클로저가 의도되지 않은 상황이었다면 이는 리소스 낭비일 뿐이다. 클로저는 의도된 상황에서 활용되어야 한다.</p><h3 id=\"1-전역-변수의-사용-억제\"><a href=\"#1-전역-변수의-사용-억제\" class=\"headerlink\" title=\"1) 전역 변수의 사용 억제\"></a>1) 전역 변수의 사용 억제</h3><p>클로저의 필요성을 이해하기 위해, 버튼이 클릭될 때마다 클릭 횟수가 누적되어 화면에 표시되는 코드를 만들어보자.</p><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>전역 변수를 사용한 Counting<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"myFunction()\"</span>&gt;</span>Count!<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">id</span>=<span class=\"string\">\"demo\"</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> counter = <span class=\"number\">0</span>; </span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 전역변수의 사용은 그다지 좋지 못하다. 전역 변수를 쓰지 않는 방법을 찾아야 한다.</span></span></div><div class=\"line\"><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\"></span>) </span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">return</span> counter += <span class=\"number\">1</span>;</span></div><div class=\"line\"><span class=\"undefined\">    &#125;</span></div><div class=\"line\"><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>)</span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'demo'</span>).innerHTML = add();</span></div><div class=\"line\"><span class=\"undefined\">    &#125;</span></div><div class=\"line\"><span class=\"undefined\">  </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure><p>위 코드는 동작에는 전혀 무리가 없다. 다만 add 함수만을 위한 전역 변수를 사용하고 있다. 전역 변수는 어디서나 접근할 수 있어 의도치 않게 변수명이 중복되거나 값이 변경되었을 때 문제가 발생할 소지가 다분하다. 따라서 전역 변수를 쓰지 않는 방법을 강구해야 한다.</p><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>지역 변수를 사용한 Counting<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"myFunction()\"</span>&gt;</span>Count!<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">id</span>=<span class=\"string\">\"demo\"</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\"></span>) </span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">var</span> counter = <span class=\"number\">0</span>; <span class=\"comment\">// 전역 변수에서 add 함수 내부의 지역 변수로 이동시켰다.</span></span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">return</span> counter += <span class=\"number\">1</span>;</span></div><div class=\"line\"><span class=\"undefined\">    &#125;</span></div><div class=\"line\"><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>)</span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'demo'</span>).innerHTML = add();</span></div><div class=\"line\"><span class=\"undefined\">    &#125;</span></div><div class=\"line\"><span class=\"undefined\">  </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure><p>전역 변수를 피하기 위해 add 함수 내부로 이동시켜, 지역 변수로 다시 선언하였다. 그런데 이번엔 함수의 작동 방식에서 문제가 발생하였다. counter가 함수가 호출될 때마다 0으로 리셋되어 0 -&gt; 1 -&gt; 함수호출 -&gt; 0 -&gt; 1 을 반복하게 되어, 화면 상에는 1만 표시된다. 처음 의도했던 동작을 수행하지 못하여, 결국 이 방법도 해결책이 되지 못한다.</p><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>클로저를 사용한 Counting<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"myFunction()\"</span>&gt;</span>Count!<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">id</span>=<span class=\"string\">\"demo\"</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> add = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 외부 함수 ...(1)</span></span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">var</span> counter = <span class=\"number\">0</span>; <span class=\"comment\">// 외부 함수의 지역 변수 ...(2)</span></span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 내부 함수 ...(3)</span></span></div><div class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">return</span> counter += <span class=\"number\">1</span>; <span class=\"comment\">// 외부 함수의 지역 변수 참조</span></span></div><div class=\"line\"><span class=\"undefined\">      &#125;</span></div><div class=\"line\"><span class=\"javascript\">    &#125;)(); <span class=\"comment\">// 즉시 실행 함수</span></span></div><div class=\"line\"><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>)</span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'demo'</span>).innerHTML = add(); <span class=\"comment\">//...(4)</span></span></div><div class=\"line\"><span class=\"undefined\">    &#125;</span></div><div class=\"line\"><span class=\"undefined\">  </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure><p>위 예제에서는 클로저를 활용하였다. 변수 <code>add</code>에 즉시실행함수가 외부함수로 호출되었다…(1)<br><code>add()</code>를 실행하면 변수 <code>add</code>에 담긴 즉시실행함수가 실행되어…(4)<br>무명함수 <code>function () { return counter +=1; }</code>가 반환(return)된다…(3)</p><p><em>즉시실행함수는 단 한번만 실행된다.</em> 따라서 <code>add</code>에 담긴 함수가 호출될 때마다 변수 <code>counter</code>가 초기화되는 일은 없을 것이다. 중요한 것은 <code>add</code>에 담겨 있는 내부 함수(3)는 변수 <code>counter</code>(2)에 접근할 수 있고 변수 <code>counter</code>는 <code>add</code>에 담겨 있는 내부 함수(3)가 소멸될 때까지 유지된다는 것이다. 이것이 클로저이다.</p><p>변수 <code>counter</code>는 외부에서 직접 접근할 수 없는 <code>private</code>변수이므로 전역 변수를 사용했을 때와 같이 의도되지 않은 변경을 걱정할 필요도 없다.</p><h3 id=\"2-setTimeout-의-콜백-함수\"><a href=\"#2-setTimeout-의-콜백-함수\" class=\"headerlink\" title=\"2) setTimeout()의 콜백 함수\"></a>2) setTimeout()의 콜백 함수</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>새로고침으로 다시 실행해 보세요<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> fade = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">node</span>) </span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"comment\">// 자유변수</span></span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">var</span> level = <span class=\"number\">1</span>; <span class=\"comment\">// ②</span></span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">var</span> step = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> hex = level.toString(<span class=\"number\">16</span>); <span class=\"comment\">// ④</span></span></div><div class=\"line\"><span class=\"undefined\">        </span></div><div class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// hex: '1' ~ 'f'</span></span></div><div class=\"line\"><span class=\"javascript\">        node.style.backgroundColor = <span class=\"string\">'#ff'</span> + hex; <span class=\"comment\">// ⑤</span></span></div><div class=\"line\"><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">if</span>(level &lt; <span class=\"number\">15</span>) &#123; <span class=\"comment\">// ⑥</span></span></div><div class=\"line\"><span class=\"undefined\">          level += 1;</span></div><div class=\"line\"><span class=\"javascript\">          setTimeout(step, <span class=\"number\">100</span>); <span class=\"comment\">// ⑦</span></span></div><div class=\"line\"><span class=\"undefined\">        &#125;</span></div><div class=\"line\"><span class=\"undefined\">      &#125;;</span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"comment\">// setTimeout 호출 이후 fade 함수는 종료한다. 100ms 후 함수 step은 호출된다.</span></span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"comment\">// 즉 외부 함수 fade보다 내부 함수 step이 더 오래 유지된다.</span></span></div><div class=\"line\"><span class=\"javascript\">      setTimeout(step, <span class=\"number\">100</span>); <span class=\"comment\">// ③</span></span></div><div class=\"line\"><span class=\"undefined\">    &#125;;</span></div><div class=\"line\"><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">    fade(<span class=\"built_in\">document</span>.body); <span class=\"comment\">// ①</span></span></div><div class=\"line\"><span class=\"undefined\">  </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure><p>setTimeout() 함수는 첫번째 파라미터에 콜백 함수를 전달하고, 파라미터에 ms(1/1000초)단위의 시간 간격을 지정한다. 즉 지정된 시간 간격으로 콜백 함수를 호출한다.</p><p>① 함수 fade는 document.body를 인자로 전달받아 호출된다.<br>② 함수 fade의 지역변수 level은 1로 초기화되어 있다. 함수 step은 내부함수이며 외부함수 fade의 지역변수 level을 사용한다. level은 자유변수이다.<br>③ setTimeout 호출 이후 fade 함수는 종료한다. 100ms 후 함수 step은 호출된다. 즉 외부 함수 fade보다 내부 함수 step이 더 오래 유지된다.<br>④ 함수 step은 지역변수 hex을 갖는다. 이것은 16진수 문자열을 값으로 갖는다.<br>⑤ 함수 fade의 매개변수 node(document.body)의 배경색을 변경한다.<br>⑥ 변수 level이 15(f)보다 작은지 다시말해 16진수 범위 내(1~f)인지 확인한다.<br>⑦ level을 1 증가시키고 다시 함수 step을 호출하여 같은 작업을 반복한다.</p><p>이때 fade 함수는 이미 반환되었지만 외부함수 fade 내의 변수는 이를 필요로 하는 내부함수가 하나 이상 존재하는 경우 계속 유지된다. 이때 내부함수가 외부함수에 있는 변수의 복사본이 아니라 실제 변수에 접근한다는 것에 주의하여야 한다.</p><h3 id=\"3-자주-발생하는-실수\"><a href=\"#3-자주-발생하는-실수\" class=\"headerlink\" title=\"3) 자주 발생하는 실수\"></a>3) 자주 발생하는 실수</h3><p>아래 예제는 클로저 사용시 자주 발생하는 실수에 관한 예제이다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</div><div class=\"line\">  arr[i] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> i;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> index = <span class=\"number\">0</span>; index &lt; arr.length; index++) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(arr[index]());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>배열 arr에 5개의 함수가 할당되고 각각의 함수는 순차적으로 0, 1, 2, 3, 4를 반환할 것으로 기대하겠지만 결과는 그렇지않다. 이유는 변수 i는 외부함수의 변수가 아닌 전역 변수이기 때문이다. 바르게 동작하는 코드는 아래와 같다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)&#123;</div><div class=\"line\">  arr[i] = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123; <span class=\"comment\">// ②</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> id; <span class=\"comment\">// ③</span></div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;)(i); <span class=\"comment\">// ①</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> index = <span class=\"number\">0</span>; index &lt; arr.length; index++) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(arr[index]());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>① 배열 arr에는 즉시실행함수에 의해 함수가 반환된다.</p><p>② 이때 즉시실행함수는 i를 인자로 전달받고 매개변수 id에 할당한 후 내부 함수를 반환하고 life-cycle이 종료된다. 매개변수 id는 자유변수가 된다.</p><p>③ 배열 arr에 할당된 함수는 id를 반환한다. 이때 id는 상위 스코프의 자유변수이므로 그 값이 유지된다.</p><p>위 예제는 자바스크립트의 함수 레벨 스코프 특성으로 인해 for 루프의 초기문에서 사용된 변수의 스코프가 전역이 되기 때문에 발생하는 현상이다. ES6의 let 키워드를 사용하면 이와 같은 문제는 말끔히 해결된다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> arr = [];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</div><div class=\"line\">  arr[i] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> i;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(arr[i]());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><hr><p>Reference</p><p><a href=\"http://poiemaweb.com/js-closure\" target=\"_blank\" rel=\"external\">Poiema Web</a><br><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management\" target=\"_blank\" rel=\"external\">MDN</a><br><a href=\"http://chanlee.github.io/2013/12/10/understand-javascript-closure/\" target=\"_blank\" rel=\"external\">blog</a></p>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://www.bram.us/wordpress/wp-content/uploads/2016/06/javascript-logo-banner.jpg\" alt=\"\"></p><h1 id=\"클로저\"><a href=\"#클로저\" class=\"headerlink\" title=\"클로저\"></a>클로저</h1><h2 id=\"1-클로저의-개념\"><a href=\"#1-클로저의-개념\" class=\"headerlink\" title=\"1. 클로저의 개념\"></a>1. 클로저의 개념</h2><p>클로저는 자바스크립트에서 중요한 개념 중 하나이다. 클로저는 자바스크립트 고유의 개념이 아니라 함수를 일급 객체로 취급하는 함수형 언어에서 사용되는 중요한 속성이다. 클로저란, 이미 생명 주기가 끝난 외부 함수의 변수를 참조하는 함수이다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">outerFunc</span>(<span class=\"params\"></span>) </span>&#123;  <span class=\"comment\">//...(1)</span></div><div class=\"line\">  <span class=\"keyword\">var</span> x = <span class=\"number\">10</span>; </div><div class=\"line\">  <span class=\"keyword\">var</span> innerFunc = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">//...(2)</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(x); <span class=\"comment\">//...(3)</span></div><div class=\"line\">  &#125;;</div><div class=\"line\">  innerFunc();</div><div class=\"line\">&#125;</div><div class=\"line\">outerFunc();</div></pre></td></tr></table></figure><p>위 예제를 통해 살펴보면, outerFunc 함수가 선언되었고 …(1)<br>그 내부 함수로 innerFunc가 선언되었다. …(2)<br>innerFunc는 자신을 포함하고 있는 outerFunc의 지역 변수 x에 접근할 수 있다. …(3)</p><p>자바스크립트 엔진은 Scope-chain을 통해 중첩된 함수의 scope 레퍼런스를 차례대로 검색한다.</p><ol><li>innerFunc 함수 내에서 변수 x를 검색한다. x가 존재하지 않는다. 검색 실패.</li><li>innerFunc 함수의 외부 함수 outerFunc 함수에서 변수 x를 검색한다. x가 존재한다. 검색 성공!</li></ol><p>이번에는 innerFunc를 outerFunc에서 반환하는 코드로 변경해보자.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">outerFunc</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">// ...(1)</span></div><div class=\"line\">  <span class=\"keyword\">var</span> x = <span class=\"number\">10</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> innerFunc = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">//...(2)</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(x);</div><div class=\"line\">  &#125;;</div><div class=\"line\">  <span class=\"keyword\">return</span> innerFunc; <span class=\"comment\">//...(3)</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> inner = outerFunc(); <span class=\"comment\">// ...(4)</span></div><div class=\"line\">inner(); <span class=\"comment\">//...(5)</span></div></pre></td></tr></table></figure><p>(1), (2) 과정은 위와 동일하고, innerFunc를 반환하는 outerFunc를 정의하였다. …(3)<br>inner 변수에 outerFunc() 함수의 실행 결과를 저장한다. outerFunc의 실행 결과로 innerFunc의 참조가 반환된다. 결론적으로 innerFunc 함수의 참조가 변수 inner에 할당된다. 그리고 이때, outerFunc 함수가 종료되면서 life-cycle이 종료된다. …(4)<br>변수 inner에 할당된 참조값을 통해 innerFunc 함수를 실행한다….(5)<br>즉 outerFunc는 실행된 이후 콜스택(call stack)에서 제거되었으므로 함수 outerFunc의 지역변수 x 또한 더이상 유효하지 않게 되어 변수 x에 접근할 수 있는 방법이 없어 보인다. 하지만 위 코드의 실행 결과는 변수 x의 값인 10이다.</p><p>원래대로라면 외부 함수 내에 있는 지역 변수는 외부함수의 실행 컨텍스트에 구속되어 있는 존재이기 때문에 외부함수가 사라지면 함께 사라져야 한다. 하지만 지역 변수가 외부 함수 내부에, 같은 유효범위 내에 선안된 내부 함수에 의해 참조되면, 그 변수의 life cycle은 외부 함수보다 길어진다. 외부 함수의 참조는 끊어지지만, 외부 함수의 지역 변수는 내부 함수가 호출되면서 함께 계속 참조되므로 <sup>1)</sup>가비지 컬렉션의 수집 대상에서 벗어난다. 그리고 지역 변수의 라이프 사이클은 내부 함수와 함께 가게 된다. 즉, 내부 함수가 종료될 때 까지 살아있는 변수로 남게 되는 것이다.</p><blockquote><p><sup>1)</sup> 가비지컬렉션: 자바스크립트는 변수나 함수를 선언할 때 메모리를 할당한다. 그리고 할당된 메모리가 필요하지 않게 되면, 즉 어떤 변수나 함수에서도 더이상 참조하지 않게 되면 자바스크립트의 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management\" target=\"_blank\" rel=\"external\">가비지 컬렉션</a>이 메모리를 해제한다.</p></blockquote><ul><li>내부 함수가 외부 함수의 지역변수에 접근할 수 있다.</li><li>외부 함수는 외부 함수의 지역변수를 사용하는 내부 함수가 소멸될 때까지 소멸되지 못하고 상태가 유지되며, 내부 함수에 의해 소멸하게 된다.</li></ul><h3 id=\"위와-같은-특성을-클로저-Closure-라고-부른다\"><a href=\"#위와-같은-특성을-클로저-Closure-라고-부른다\" class=\"headerlink\" title=\"위와 같은 특성을 클로저(Closure)라고 부른다.\"></a>위와 같은 특성을 <strong>클로저(Closure)</strong>라고 부른다.</h3><blockquote><p>외부 함수 내에서 내부 함수를 선언할 때, 함수만 정의되는 것이 아니라, 그 시점에 같은 유효 범위에 있는 모든 변수를 포함하는 클로저도 생성된다. 그 다음, 내부 함수를 실행하면 함수가 속해있던 유효 범위가 사라진 후에 실행됨에도 클로저를 통해 정의된 원래 유효범위에 접근하게 된다. 이것이 클로저의 핵심이다. 클로저는 <strong>보호막</strong>을 만든다. 보호막은 함수가 선언된 시점의 유효범위 내에 있는 모든 함수와 변수를 가지고 있으며 필요할 때 그것들을 사용할 수 있다. 이 보호막은 함수가 동작하는 한 관련 정보를 유지한다. &lt;자바스크립트 닌자 비급, p.118, 인사이트, 2014&gt;</p></blockquote><h3 id=\"1-자유변수-Free-variable\"><a href=\"#1-자유변수-Free-variable\" class=\"headerlink\" title=\"1) 자유변수(Free variable)\"></a>1) 자유변수(Free variable)</h3><p>클로저에 의해 참조되는 외부 함수의 변수</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">outerFunc</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> x = <span class=\"number\">10</span>; <span class=\"comment\">// 자유변수</span></div><div class=\"line\">  <span class=\"keyword\">var</span> innerFunc = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(x);</div><div class=\"line\">  &#125;;</div><div class=\"line\">  <span class=\"keyword\">return</span> innerFunc;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> inner = outerFunc();</div><div class=\"line\">inner();</div></pre></td></tr></table></figure><p>예제의 outerFunc 함수의 지역 변수 x가 자유변수에 해당한다. 클로저라는 이름은 ‘자유변수에 함수가 닫혀있다(closed)’라는 의미로, 의역하자면 자유변수에 엮여있는 함수라는 뜻이다.</p><p>실행컨텍스트의 관점에서,</p><p>내부 함수가 유효한 상태에서 외부 함수가 종료된 경우를 생각해보자. 외부 함수의 실행 컨텍스트가 반환되어도, 그 내부의 Activation object(AO)는 유효하다. 다시 말해, 내부 함수가 Scope-chain을 통해 AO를 참조할 수 있다. 즉 외부함수가 이미 반환되었어도 외부함수 내의 변수는 자신을 필요로 하는 내부 함수가 하나 이상 존재하는 경우 계속 유지될 수 있다는 것이다. 이때 내부 함수가 외부 함수에 있는 변수의 <strong>복사본이 아니라 실제</strong> 변수에 접근한다는 것에 주의해야 한다.</p><p><img src=\"http://poiemaweb.com/img/closure.png\" alt=\"실행 컨텍스트의 Activation object와 클로저\"></p><p><br></p><h2 id=\"2-클로저의-활용\"><a href=\"#2-클로저의-활용\" class=\"headerlink\" title=\"2. 클로저의 활용\"></a>2. 클로저의 활용</h2><p>그렇다면 클로저는 언제 사용하는가?</p><p>클로저 정보를 저장하고 참조하는 데는 직접적인 비용이 발생한다. 클로저 정보를 따로 보관해두는 명시적인 “closure”객체 같은 것은 존재하지 않기 때문에 클로저를 이용해 정보에 접근하는 함수는 계속해서 관련된 정보를 가지고 다녀야 한다. 클로저는 정말 유용하지만, 오버헤드에서 자유롭다고 할 수 없다. 클로저에 관한 모든 정보는 더이상 사용하는 곳이 없을 때, 혹은 페이지가 언로드 될 때까지 메모리에 남아있는다. 따라서 클로저가 의도되지 않은 상황이었다면 이는 리소스 낭비일 뿐이다. 클로저는 의도된 상황에서 활용되어야 한다.</p><h3 id=\"1-전역-변수의-사용-억제\"><a href=\"#1-전역-변수의-사용-억제\" class=\"headerlink\" title=\"1) 전역 변수의 사용 억제\"></a>1) 전역 변수의 사용 억제</h3><p>클로저의 필요성을 이해하기 위해, 버튼이 클릭될 때마다 클릭 횟수가 누적되어 화면에 표시되는 코드를 만들어보자.</p><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>전역 변수를 사용한 Counting<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"myFunction()\"</span>&gt;</span>Count!<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">id</span>=<span class=\"string\">\"demo\"</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> counter = <span class=\"number\">0</span>; </span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 전역변수의 사용은 그다지 좋지 못하다. 전역 변수를 쓰지 않는 방법을 찾아야 한다.</span></span></div><div class=\"line\"><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\"></span>) </span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">return</span> counter += <span class=\"number\">1</span>;</span></div><div class=\"line\"><span class=\"undefined\">    &#125;</span></div><div class=\"line\"><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>)</span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'demo'</span>).innerHTML = add();</span></div><div class=\"line\"><span class=\"undefined\">    &#125;</span></div><div class=\"line\"><span class=\"undefined\">  </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure><p>위 코드는 동작에는 전혀 무리가 없다. 다만 add 함수만을 위한 전역 변수를 사용하고 있다. 전역 변수는 어디서나 접근할 수 있어 의도치 않게 변수명이 중복되거나 값이 변경되었을 때 문제가 발생할 소지가 다분하다. 따라서 전역 변수를 쓰지 않는 방법을 강구해야 한다.</p><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>지역 변수를 사용한 Counting<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"myFunction()\"</span>&gt;</span>Count!<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">id</span>=<span class=\"string\">\"demo\"</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\"></span>) </span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">var</span> counter = <span class=\"number\">0</span>; <span class=\"comment\">// 전역 변수에서 add 함수 내부의 지역 변수로 이동시켰다.</span></span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">return</span> counter += <span class=\"number\">1</span>;</span></div><div class=\"line\"><span class=\"undefined\">    &#125;</span></div><div class=\"line\"><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>)</span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'demo'</span>).innerHTML = add();</span></div><div class=\"line\"><span class=\"undefined\">    &#125;</span></div><div class=\"line\"><span class=\"undefined\">  </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure><p>전역 변수를 피하기 위해 add 함수 내부로 이동시켜, 지역 변수로 다시 선언하였다. 그런데 이번엔 함수의 작동 방식에서 문제가 발생하였다. counter가 함수가 호출될 때마다 0으로 리셋되어 0 -&gt; 1 -&gt; 함수호출 -&gt; 0 -&gt; 1 을 반복하게 되어, 화면 상에는 1만 표시된다. 처음 의도했던 동작을 수행하지 못하여, 결국 이 방법도 해결책이 되지 못한다.</p><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>클로저를 사용한 Counting<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"myFunction()\"</span>&gt;</span>Count!<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">id</span>=<span class=\"string\">\"demo\"</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> add = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 외부 함수 ...(1)</span></span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">var</span> counter = <span class=\"number\">0</span>; <span class=\"comment\">// 외부 함수의 지역 변수 ...(2)</span></span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 내부 함수 ...(3)</span></span></div><div class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">return</span> counter += <span class=\"number\">1</span>; <span class=\"comment\">// 외부 함수의 지역 변수 참조</span></span></div><div class=\"line\"><span class=\"undefined\">      &#125;</span></div><div class=\"line\"><span class=\"javascript\">    &#125;)(); <span class=\"comment\">// 즉시 실행 함수</span></span></div><div class=\"line\"><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>)</span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'demo'</span>).innerHTML = add(); <span class=\"comment\">//...(4)</span></span></div><div class=\"line\"><span class=\"undefined\">    &#125;</span></div><div class=\"line\"><span class=\"undefined\">  </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure><p>위 예제에서는 클로저를 활용하였다. 변수 <code>add</code>에 즉시실행함수가 외부함수로 호출되었다…(1)<br><code>add()</code>를 실행하면 변수 <code>add</code>에 담긴 즉시실행함수가 실행되어…(4)<br>무명함수 <code>function () { return counter +=1; }</code>가 반환(return)된다…(3)</p><p><em>즉시실행함수는 단 한번만 실행된다.</em> 따라서 <code>add</code>에 담긴 함수가 호출될 때마다 변수 <code>counter</code>가 초기화되는 일은 없을 것이다. 중요한 것은 <code>add</code>에 담겨 있는 내부 함수(3)는 변수 <code>counter</code>(2)에 접근할 수 있고 변수 <code>counter</code>는 <code>add</code>에 담겨 있는 내부 함수(3)가 소멸될 때까지 유지된다는 것이다. 이것이 클로저이다.</p><p>변수 <code>counter</code>는 외부에서 직접 접근할 수 없는 <code>private</code>변수이므로 전역 변수를 사용했을 때와 같이 의도되지 않은 변경을 걱정할 필요도 없다.</p><h3 id=\"2-setTimeout-의-콜백-함수\"><a href=\"#2-setTimeout-의-콜백-함수\" class=\"headerlink\" title=\"2) setTimeout()의 콜백 함수\"></a>2) setTimeout()의 콜백 함수</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>새로고침으로 다시 실행해 보세요<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> fade = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">node</span>) </span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"comment\">// 자유변수</span></span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">var</span> level = <span class=\"number\">1</span>; <span class=\"comment\">// ②</span></span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">var</span> step = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> hex = level.toString(<span class=\"number\">16</span>); <span class=\"comment\">// ④</span></span></div><div class=\"line\"><span class=\"undefined\">        </span></div><div class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// hex: '1' ~ 'f'</span></span></div><div class=\"line\"><span class=\"javascript\">        node.style.backgroundColor = <span class=\"string\">'#ff'</span> + hex; <span class=\"comment\">// ⑤</span></span></div><div class=\"line\"><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">if</span>(level &lt; <span class=\"number\">15</span>) &#123; <span class=\"comment\">// ⑥</span></span></div><div class=\"line\"><span class=\"undefined\">          level += 1;</span></div><div class=\"line\"><span class=\"javascript\">          setTimeout(step, <span class=\"number\">100</span>); <span class=\"comment\">// ⑦</span></span></div><div class=\"line\"><span class=\"undefined\">        &#125;</span></div><div class=\"line\"><span class=\"undefined\">      &#125;;</span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"comment\">// setTimeout 호출 이후 fade 함수는 종료한다. 100ms 후 함수 step은 호출된다.</span></span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"comment\">// 즉 외부 함수 fade보다 내부 함수 step이 더 오래 유지된다.</span></span></div><div class=\"line\"><span class=\"javascript\">      setTimeout(step, <span class=\"number\">100</span>); <span class=\"comment\">// ③</span></span></div><div class=\"line\"><span class=\"undefined\">    &#125;;</span></div><div class=\"line\"><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">    fade(<span class=\"built_in\">document</span>.body); <span class=\"comment\">// ①</span></span></div><div class=\"line\"><span class=\"undefined\">  </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure><p>setTimeout() 함수는 첫번째 파라미터에 콜백 함수를 전달하고, 파라미터에 ms(1/1000초)단위의 시간 간격을 지정한다. 즉 지정된 시간 간격으로 콜백 함수를 호출한다.</p><p>① 함수 fade는 document.body를 인자로 전달받아 호출된다.<br>② 함수 fade의 지역변수 level은 1로 초기화되어 있다. 함수 step은 내부함수이며 외부함수 fade의 지역변수 level을 사용한다. level은 자유변수이다.<br>③ setTimeout 호출 이후 fade 함수는 종료한다. 100ms 후 함수 step은 호출된다. 즉 외부 함수 fade보다 내부 함수 step이 더 오래 유지된다.<br>④ 함수 step은 지역변수 hex을 갖는다. 이것은 16진수 문자열을 값으로 갖는다.<br>⑤ 함수 fade의 매개변수 node(document.body)의 배경색을 변경한다.<br>⑥ 변수 level이 15(f)보다 작은지 다시말해 16진수 범위 내(1~f)인지 확인한다.<br>⑦ level을 1 증가시키고 다시 함수 step을 호출하여 같은 작업을 반복한다.</p><p>이때 fade 함수는 이미 반환되었지만 외부함수 fade 내의 변수는 이를 필요로 하는 내부함수가 하나 이상 존재하는 경우 계속 유지된다. 이때 내부함수가 외부함수에 있는 변수의 복사본이 아니라 실제 변수에 접근한다는 것에 주의하여야 한다.</p><h3 id=\"3-자주-발생하는-실수\"><a href=\"#3-자주-발생하는-실수\" class=\"headerlink\" title=\"3) 자주 발생하는 실수\"></a>3) 자주 발생하는 실수</h3><p>아래 예제는 클로저 사용시 자주 발생하는 실수에 관한 예제이다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</div><div class=\"line\">  arr[i] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> i;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> index = <span class=\"number\">0</span>; index &lt; arr.length; index++) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(arr[index]());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>배열 arr에 5개의 함수가 할당되고 각각의 함수는 순차적으로 0, 1, 2, 3, 4를 반환할 것으로 기대하겠지만 결과는 그렇지않다. 이유는 변수 i는 외부함수의 변수가 아닌 전역 변수이기 때문이다. 바르게 동작하는 코드는 아래와 같다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)&#123;</div><div class=\"line\">  arr[i] = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123; <span class=\"comment\">// ②</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> id; <span class=\"comment\">// ③</span></div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;)(i); <span class=\"comment\">// ①</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> index = <span class=\"number\">0</span>; index &lt; arr.length; index++) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(arr[index]());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>① 배열 arr에는 즉시실행함수에 의해 함수가 반환된다.</p><p>② 이때 즉시실행함수는 i를 인자로 전달받고 매개변수 id에 할당한 후 내부 함수를 반환하고 life-cycle이 종료된다. 매개변수 id는 자유변수가 된다.</p><p>③ 배열 arr에 할당된 함수는 id를 반환한다. 이때 id는 상위 스코프의 자유변수이므로 그 값이 유지된다.</p><p>위 예제는 자바스크립트의 함수 레벨 스코프 특성으로 인해 for 루프의 초기문에서 사용된 변수의 스코프가 전역이 되기 때문에 발생하는 현상이다. ES6의 let 키워드를 사용하면 이와 같은 문제는 말끔히 해결된다.</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> arr = [];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</div><div class=\"line\">  arr[i] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> i;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(arr[i]());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><hr><p>Reference</p><p><a href=\"http://poiemaweb.com/js-closure\" target=\"_blank\" rel=\"external\">Poiema Web</a><br><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management\" target=\"_blank\" rel=\"external\">MDN</a><br><a href=\"http://chanlee.github.io/2013/12/10/understand-javascript-closure/\" target=\"_blank\" rel=\"external\">blog</a></p>"},{"title":"[JS] 비동기모델과 이벤트루프","date":"2017-08-29T15:35:42.000Z","_content":"\n![](https://www.bram.us/wordpress/wp-content/uploads/2016/06/javascript-logo-banner.jpg)\n\n# 비동기식 처리 모델과 이벤트 루프\n\n## 1. 브라우저 동작 원리\n\n### 1) 브라우저의 주요 기능\n\n브라우저의 주요 기능은 사용자가 참조하고자 하는 자원을 (또는 웹페이지를) 서버에 요청(Request)하고 응답(Response)을 받아 브라우저에 표시하는 것이다. 브라우저가 서버로부터 받는 자원은 보통 HTML 문서이지만, PDF나 이미지 또는 다른 형태일 수 있다. 일반적으로 브라우저는 서버로부터 HTML, CSS, Javascript 파일을 응답받는다. (자원의 주소는 URI에 의해 정해진다.)  \n브라우저는 W3C(웹 표준화 기구)에서 정한 HTML과 CSS 표준 명세에 따라 HTML 파일을 해석해서 표시한다.\n\n<br>\n\n### 2) 브라우저의 기본 구조\n\n![브라우저의 구성 요소](http://d2.naver.com/content/images/2015/06/helloworld-59361-1.png)\n\n1. 사용자 인터페이스: 주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등. 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분이다.\n\n2. 브라우저 엔진: 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어.\n\n3. 렌더링 엔진: 요청한 콘텐츠를 표시한다. 예를 들어 HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시한다.\n\n4. 통신: HTTP 요청과 같은 네트워크 호출에 사용된다. 플랫폼 독립적인 인터페이스이고 각 플랫폼 하부에서 실행된다.\n\n5. UI 백엔드: 콤보 박스와 창 같은 기본적인 장치를 그린다. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, OS 사용자 인터페이스 체계를 사용한다.\n\n6. 자바스크립트 해석: 자바스크립트 코드를 해석하고 실행한다.\n\n7. 자료 저장소: 자료를 저장하는 계층이다. 쿠키를 저장하는 것과 같이 모든 종류의 자원을 하드 디스크에 저장할 필요가 있다. HTML5 명세에는 브라우저가 지원하는 [웹 데이터베이스](http://www.html5rocks.com/en/features/storage)가 정의되어 있다.\n\n크롬 브라우저는 각 탭마다 별도의 렌더링 엔진 인스턴스를 유지한다. 따라서 각 탭은 독립된 프로세스로 처리된다.\n\n<br>\n\n### 3) 렌더링 엔진\n\n렌더링 엔진의 역할은 요청 받은 콘텐츠를 브라우저에 표시하는 일이다. HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시한다. HTML, CSS 파일은 렌더링 엔진의 HTML 파서와 CSS 파서에 의해 파싱되어 DOM, CSSOM 트리로 변환되고 렌더 트리로 결합된다.\n\n렌더링 엔진은 XML 문서와 이미지도 표시할 수 있다. 물론 플러그인이나 브라우저 확장 기능을 이용해 PDF 같은 다른 유형도 표시할 수 있다. 여기서는 HTML과 이미지를 CSS로 표시하는 주된 사용 패턴에 초점을 둘 것이다.\n\n> 렌더링 엔진은 브라우저마다 다르다. 파이어폭스는 게코(Gecko) 엔진을 사용하며 사파리와 크롬은 웹킷(Webkit) 엔진을 사용한다.\n\n### 렌더링 엔진 동작 과정\n\n렌더링 엔진은 통신으로부터 요청한 문서의 콘텐츠를 얻는 것으로 시작한다. 문서 내용은 보통 8KB 단위로 전송된다.\n\n![렌더링 엔진 동작 과정](http://d2.naver.com/content/images/2015/06/helloworld-59361-2.png)\n\n![브라우저 동작 원리](http://poiemaweb.com/img/client-server.png)\n\n* 렌더링 엔진은 HTML 문서를 파싱하고, 콘텐츠 트리 내부에서 태그를 DOM 노드로 변환한다. 그다음 외부 CSS 파일과 함께 포함된 스타일 요소도 파싱한다. 파싱된 스타일 정보는 CSSOM 노드로 변환한다.  \n\n* 스타일 정보(CSSOM)와 HTML 표시 규칙(DOM)으로 **렌더 트리**라는 또 다른 트리를 생성한다. 렌더트리는 색상이나 면적같은 시각적 속성이 있는 박스를 포함하고 있는데, 정해진 순서대로 화면에 표시된다.\n\n* 렌더 트리의 각 노드가 화면의 정확한 위치에 배치되어 표시된다. 다음은 UI 백엔드에서 렌더 트리의 각 노드를 가로지르며 형상을 만들어내는 그리기 과정이다.\n\n일련의 과정들이 점진적으로 진행된다는 것을 아는 것이 중요하다. 렌더링 엔진은 좀 더 나은 사용자 경험을 위해 가능하면 빠르게 내용을 표시하는데 **모든 HTML을 파싱할 때까지 기다리지 않고 배치와 그리기 과정을 시작한다.** 네트워크로부터 나머지 내용이 전송되기를 기다리는 동시에 받은 내용의 일부를 먼저 화면에 표시하는 것이다.\n\n![웹킷 렌더링 엔진](http://d2.naver.com/content/images/2015/06/helloworld-59361-3.png)\n\n![게코 렌더링 엔진](http://d2.naver.com/content/images/2015/06/helloworld-59361-4.png)\n\n---\n**[참고]** [브라우저는 어떻게 동작하는가](http://d2.naver.com/helloworld/59361), [Poiema web](http://poiemaweb.com/js-async)  \n\nHTML 파서는 script 태그를 만나면 DOM 생성 프로세스를 중지하고 자바스크립트 엔진에 제어 권한을 넘긴다. 자바스크립트 엔진의 실행이 완료된 후 브라우저가 중지했던 시점부터 DOM 생성을 재개한다. 이것은 script 태그의 위치에 의해 DOM의 생성이 지연될 수 있음을 의미한다.\n\n<br>\n\n## 2. Ajax\n\n브라우저에서 웹페이지를 요청하거나 링크를 클릭하면 화면 전환이 발생한다. 이것은 브라우저와 서버와의 통신에 의한 것이다.\n\n![](http://poiemaweb.com/img/req_res.png)\n\n서버는 요청받은 페이지(HTML)를 반환하는데 이때 HTML에서 로드하는 CSS나 JavaScript 파일들도 같이 반환된다. 클라이언트의 요청에 따라 서버는 정적인 파일을 반환할 수도 있고 서버 사이드 프로그램이 만들어낸 파일이나 데이터를 반환할 수도 있다. 서버로부터 웹페이지가 반환되면 클라이언트(브라우저)는 이를 렌더링하여 화면에 표시한다.\n\n![Traditional Web Page Lifecycle](http://poiemaweb.com/img/traditional-webpage-lifecycle.png)\n\n### Ajax(Asynchronous JavaScript and XML)는 자바스크립트를 이용해서 비동기적(Asynchronous)으로 서버와 브라우저가 데이터를 교환할 수 있는 통신 방식을 의미한다.\n\n서버로부터 웹페이지가 반환되면 화면 전체를 갱신해야 하는데, AJAX는 페이지 일부만을 갱신하고도 동일한 효과를 볼 수 있도록 한다. 페이지 전체를 로드하여 렌더링할 필요가 없고 갱신이 필요한 일부만 로드하여 갱신하면 되므로 **빠른 퍼포먼스와 부드러운 화면 표시 효과**를 기대할 수 있다.\n\n![AJAX Lifecycle](http://poiemaweb.com/img/ajax-webpage-lifecycle.png)\n\n서버는 HTML, XML, JSON등을 반환하는데, Ajax을 위한 데이터 형식은 **JSON(JavaScript Object Notation)** 을 사용하는 것이 일반적이다.\n\n<br>\n\n## 3. 동기식 처리 모델 VS 비동기식 처리 모델\n\n### 동기식 처리 모델(Synchronous processing model)  \n\n작업이 순차적으로 실행된다. 어떤 작업이 수행 중이면 다음 작업은 대기한다. 예를 들어 서버에서 데이터를 가져와 화면에 표시하는 작업을 수행할 경우 서버에 데이터를 요청하고 데이터가 전달될 때까지 이후 작업들은 중단(Blocking)된다.\n![동기식 처리 모델](http://poiemaweb.com/img/synchronous.png) \n\n### 비동기식 처리 모델(Asynchronous processing model or Non-Blocking processing model)  \n\n작업이 종료되지 않은 상태라도 대기하지 않고 다음 작업을 실행한다. 예를 들어 서버에서 데이터를 가져와 화면에 표시하는 작업을 수행할 경우 서버에 데이터를 요청한 이후 서버로부터 데이터가 전달될 때까지 **대기하지 않고(Non-Blocking) 즉시 다음 작업을 수행한다.** 이후 서버로부터 데이터가 전달되면 이벤트가 발생되고 이벤트 핸들러가 데이터를 가지고 수행할 작업을 계속하여 수행한다.\n\n**자바스크립트의 대부분의 DOM 이벤트와 Timer 함수(setTimeout, setInterval), Ajax 요청은 비동기적으로 동작한다.**\n\n![비동기적 처리 모델](http://poiemaweb.com/img/asynchronous.png)\n\n<br>\n\n## 4. 이벤트 루프와 동시성(Concurrency)\n\n***브라우저는 단일 쓰레드(single-thread)에서 이벤트 드리븐(event-driven) 방식으로 동작한다.***\n\n자바스크립트는 본래 단일스레드 기반의 언어이다. 한번에 하나의 작업(task)만을 처리할 수 있다는 의미이다. 하지만 실제 웹 애플리케이션들을 보면 여러 task가 동시에 처리되는 것처럼 보인다. 이는 자바스크립트가 이벤트 루프를 이용해서 비동기 방식으로 동시성을 지원하기 때문이다.\n\n### 브라우저 환경\n\n![이벤트 루프(Event Loop)와 브라우저의 환경](http://poiemaweb.com/img/event-loop.png)\n\n자바스크립트 엔진은 크게 콜 스택 영역과 힙 영역으로 나뉜다. 흔히 비동기 호출을 위해 사용하는 `setTimeout`이나 `XMLHttpRequest`와 같은 함수들은 자바스크립트 엔진이 아닌 Web API 영역에 따로 정의되어 있음을 확인할 수 있다. 비동기 방식을 가능하게 하는 이벤트 루프와 태스트 큐(이벤트 큐) 또한 자바스크립트 엔진 외부에 구현되어있다.\n\n***1. Call Stack(호출 스택)***  \n작업이 요청되면(함수가 실행되면) 요청된 작업은 순차적으로 Call Stack에 쌓이게 되고 순차적으로 실행된다. 자바스크립트는 단 하나의 Call Stack을 사용하기 때문에 해당 task가 종료하기 전까지는 다른 어떤 task도 수행될 수 없다.\n\n***2. Heap***  \n힙은 동적으로 생성된 객체 인스턴스가 할당되는 영역이다.\n\n이와 같이 자바스크립트 엔진은 단순히 작업이 요청되면 요청된 작업을 Call Stack을 사용하여 순차적으로 실행할 뿐이다. 앞에서 언급한 동시성(Concurrency)을 지원하기 위해 필요한 *비동기 요청(이벤트를 포함) 처리는 자바스크립트 엔진을 구동하는 환경, 즉 브라우저(또는 Node.js)가 담당한다.*\n\n***3. Event Queue(Task Queue)***  \n비동기 처리 함수의 콜백 함수, 비동기식 이벤트 핸들러, Timer 함수(setTimeout(), setInterval())가 보관되는 영역이다. **이벤트 루프(Event Loop)에 의해 특정 시점(Call Stack이 비어졌을 때)에 순차적으로 Call Stack으로 이동되어 실행된다.**\n\n***4. Event Loop(이벤트 루프)***  \nCall Stack내에서 1) 현재 실행중인 task가 있는지, 그리고 2) Event Queue에 task가 있는지 반복하여 확인한다.\n\n아래의 예제가 어떻게 동작할지 살펴보자.\n\n```js\nfunction func1() {\n  console.log('func1');\n  func2();\n}\n\nfunction func2() {\n  setTimeout(function() {\n    console.log('func2');\n  }, 0);\n\n  func3();\n}\n\nfunction func3() {\n  console.log('func3');\n}\n\nfunc1();\n```\n\n함수 func1이 호출되면 함수 func1은 Call Stack에 쌓인다. 그리고 함수 func1은 함수 func2을 호출하므로 함수 func2가 Call Stack에 쌓이고 setTimeout가 호출된다. setTimeout의 핸들러는 즉시 실행되지 않고 지정 대기 시간만큼 기다리다가 이벤트 큐로 이동한 후 Call Stack이 비어졌을 때 Call Stack으로 이동되어 실행된다.\n\n![이벤트 루프(Event Loop)에 의한 setTimeout 핸들러의 실행](http://poiemaweb.com/img/event-loop.gif)\n\nDOM 이벤트도 이와 같이 동작한다.\n\n```js\nfunction func1() {\n  console.log('func1');\n  func2();\n}\n\nfunction func2() {\n  // <button id=\"foo\">foo</button>\n  var elem = document.getElementById('foo');\n\n  elem.addEventListener('click', function () {\n    this.style.backgroundColor = 'indigo';\n    console.log('func2');\n  });\n\n  func3();\n}\n\nfunction func3() {\n  console.log('func3');\n}\n\nfunc1();\n```\n\n함수 func1이 호출되면 함수 func1은 Call Stack에 쌓인다. 그리고 함수 func1은 함수 func2을 호출하므로 함수 func2가 Call Stack에 쌓이고 addEventListener가 호출된다. addEventListener의 콜백함수는 foo 버튼이 클릭되어 “onclick” 이벤트가 발생하면 이벤트 큐로 이동한 후 Call Stack이 비어졌을 때 Call Stack으로 이동되어 실행된다.\n\n\n### Nodejs 환경\n![nodejs 환경](https://camo.githubusercontent.com/cb45689d053b03f76965aa02fff3b049ce79e533/68747470733a2f2f7062732e7477696d672e636f6d2f6d656469612f42743579774a72494541414b4a51742e6a7067)\n\nNode.js는 비동기 IO를 지원하기 위해 libuv 라이브러리를 사용하며, 이 libuv가 이벤트 루프를 제공한다. 자바스크립트 엔진은 비동기 작업을 위해 Node.js의 API를 호출하며, 이때 넘겨진 콜백은 libuv의 이벤트 루프를 통해 스케쥴되고 실행된다.\n\n---\n\n결론적으로, 자바스크립트가 단일 스레드 기반의 언어라는 말은 **자바스크립트 엔진이 단일 호출 스택을 사용한다**는 관점에서만 사실이다. 실제 자바스크립트가 구동되는 환경(브라우저, nodejs 등)에서는 주로 여러개의 스레드가 사용되며 이러한 구동 환경이 단일 호출 스택을 사용하는 자바스크립트 엔진과 상호 연동하기 위해 사용하는 장치가 바로 이벤트 루프이다.\n\n---\n\nReference\n\n[Poiemaweb](http://poiemaweb.com/js-async)  \n\n[nhnent/github](https://github.com/nhnent/fe.javascript/wiki/June-13-June-17,-2016)\n","source":"_posts/Javascript/04.Async,EventLoop.md","raw":"---\ntitle: '[JS] 비동기모델과 이벤트루프'\ndate: 2017-08-30 00:35:42\ncategory: Javascript\ntags: asynchronous\n---\n\n![](https://www.bram.us/wordpress/wp-content/uploads/2016/06/javascript-logo-banner.jpg)\n\n# 비동기식 처리 모델과 이벤트 루프\n\n## 1. 브라우저 동작 원리\n\n### 1) 브라우저의 주요 기능\n\n브라우저의 주요 기능은 사용자가 참조하고자 하는 자원을 (또는 웹페이지를) 서버에 요청(Request)하고 응답(Response)을 받아 브라우저에 표시하는 것이다. 브라우저가 서버로부터 받는 자원은 보통 HTML 문서이지만, PDF나 이미지 또는 다른 형태일 수 있다. 일반적으로 브라우저는 서버로부터 HTML, CSS, Javascript 파일을 응답받는다. (자원의 주소는 URI에 의해 정해진다.)  \n브라우저는 W3C(웹 표준화 기구)에서 정한 HTML과 CSS 표준 명세에 따라 HTML 파일을 해석해서 표시한다.\n\n<br>\n\n### 2) 브라우저의 기본 구조\n\n![브라우저의 구성 요소](http://d2.naver.com/content/images/2015/06/helloworld-59361-1.png)\n\n1. 사용자 인터페이스: 주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등. 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분이다.\n\n2. 브라우저 엔진: 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어.\n\n3. 렌더링 엔진: 요청한 콘텐츠를 표시한다. 예를 들어 HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시한다.\n\n4. 통신: HTTP 요청과 같은 네트워크 호출에 사용된다. 플랫폼 독립적인 인터페이스이고 각 플랫폼 하부에서 실행된다.\n\n5. UI 백엔드: 콤보 박스와 창 같은 기본적인 장치를 그린다. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, OS 사용자 인터페이스 체계를 사용한다.\n\n6. 자바스크립트 해석: 자바스크립트 코드를 해석하고 실행한다.\n\n7. 자료 저장소: 자료를 저장하는 계층이다. 쿠키를 저장하는 것과 같이 모든 종류의 자원을 하드 디스크에 저장할 필요가 있다. HTML5 명세에는 브라우저가 지원하는 [웹 데이터베이스](http://www.html5rocks.com/en/features/storage)가 정의되어 있다.\n\n크롬 브라우저는 각 탭마다 별도의 렌더링 엔진 인스턴스를 유지한다. 따라서 각 탭은 독립된 프로세스로 처리된다.\n\n<br>\n\n### 3) 렌더링 엔진\n\n렌더링 엔진의 역할은 요청 받은 콘텐츠를 브라우저에 표시하는 일이다. HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시한다. HTML, CSS 파일은 렌더링 엔진의 HTML 파서와 CSS 파서에 의해 파싱되어 DOM, CSSOM 트리로 변환되고 렌더 트리로 결합된다.\n\n렌더링 엔진은 XML 문서와 이미지도 표시할 수 있다. 물론 플러그인이나 브라우저 확장 기능을 이용해 PDF 같은 다른 유형도 표시할 수 있다. 여기서는 HTML과 이미지를 CSS로 표시하는 주된 사용 패턴에 초점을 둘 것이다.\n\n> 렌더링 엔진은 브라우저마다 다르다. 파이어폭스는 게코(Gecko) 엔진을 사용하며 사파리와 크롬은 웹킷(Webkit) 엔진을 사용한다.\n\n### 렌더링 엔진 동작 과정\n\n렌더링 엔진은 통신으로부터 요청한 문서의 콘텐츠를 얻는 것으로 시작한다. 문서 내용은 보통 8KB 단위로 전송된다.\n\n![렌더링 엔진 동작 과정](http://d2.naver.com/content/images/2015/06/helloworld-59361-2.png)\n\n![브라우저 동작 원리](http://poiemaweb.com/img/client-server.png)\n\n* 렌더링 엔진은 HTML 문서를 파싱하고, 콘텐츠 트리 내부에서 태그를 DOM 노드로 변환한다. 그다음 외부 CSS 파일과 함께 포함된 스타일 요소도 파싱한다. 파싱된 스타일 정보는 CSSOM 노드로 변환한다.  \n\n* 스타일 정보(CSSOM)와 HTML 표시 규칙(DOM)으로 **렌더 트리**라는 또 다른 트리를 생성한다. 렌더트리는 색상이나 면적같은 시각적 속성이 있는 박스를 포함하고 있는데, 정해진 순서대로 화면에 표시된다.\n\n* 렌더 트리의 각 노드가 화면의 정확한 위치에 배치되어 표시된다. 다음은 UI 백엔드에서 렌더 트리의 각 노드를 가로지르며 형상을 만들어내는 그리기 과정이다.\n\n일련의 과정들이 점진적으로 진행된다는 것을 아는 것이 중요하다. 렌더링 엔진은 좀 더 나은 사용자 경험을 위해 가능하면 빠르게 내용을 표시하는데 **모든 HTML을 파싱할 때까지 기다리지 않고 배치와 그리기 과정을 시작한다.** 네트워크로부터 나머지 내용이 전송되기를 기다리는 동시에 받은 내용의 일부를 먼저 화면에 표시하는 것이다.\n\n![웹킷 렌더링 엔진](http://d2.naver.com/content/images/2015/06/helloworld-59361-3.png)\n\n![게코 렌더링 엔진](http://d2.naver.com/content/images/2015/06/helloworld-59361-4.png)\n\n---\n**[참고]** [브라우저는 어떻게 동작하는가](http://d2.naver.com/helloworld/59361), [Poiema web](http://poiemaweb.com/js-async)  \n\nHTML 파서는 script 태그를 만나면 DOM 생성 프로세스를 중지하고 자바스크립트 엔진에 제어 권한을 넘긴다. 자바스크립트 엔진의 실행이 완료된 후 브라우저가 중지했던 시점부터 DOM 생성을 재개한다. 이것은 script 태그의 위치에 의해 DOM의 생성이 지연될 수 있음을 의미한다.\n\n<br>\n\n## 2. Ajax\n\n브라우저에서 웹페이지를 요청하거나 링크를 클릭하면 화면 전환이 발생한다. 이것은 브라우저와 서버와의 통신에 의한 것이다.\n\n![](http://poiemaweb.com/img/req_res.png)\n\n서버는 요청받은 페이지(HTML)를 반환하는데 이때 HTML에서 로드하는 CSS나 JavaScript 파일들도 같이 반환된다. 클라이언트의 요청에 따라 서버는 정적인 파일을 반환할 수도 있고 서버 사이드 프로그램이 만들어낸 파일이나 데이터를 반환할 수도 있다. 서버로부터 웹페이지가 반환되면 클라이언트(브라우저)는 이를 렌더링하여 화면에 표시한다.\n\n![Traditional Web Page Lifecycle](http://poiemaweb.com/img/traditional-webpage-lifecycle.png)\n\n### Ajax(Asynchronous JavaScript and XML)는 자바스크립트를 이용해서 비동기적(Asynchronous)으로 서버와 브라우저가 데이터를 교환할 수 있는 통신 방식을 의미한다.\n\n서버로부터 웹페이지가 반환되면 화면 전체를 갱신해야 하는데, AJAX는 페이지 일부만을 갱신하고도 동일한 효과를 볼 수 있도록 한다. 페이지 전체를 로드하여 렌더링할 필요가 없고 갱신이 필요한 일부만 로드하여 갱신하면 되므로 **빠른 퍼포먼스와 부드러운 화면 표시 효과**를 기대할 수 있다.\n\n![AJAX Lifecycle](http://poiemaweb.com/img/ajax-webpage-lifecycle.png)\n\n서버는 HTML, XML, JSON등을 반환하는데, Ajax을 위한 데이터 형식은 **JSON(JavaScript Object Notation)** 을 사용하는 것이 일반적이다.\n\n<br>\n\n## 3. 동기식 처리 모델 VS 비동기식 처리 모델\n\n### 동기식 처리 모델(Synchronous processing model)  \n\n작업이 순차적으로 실행된다. 어떤 작업이 수행 중이면 다음 작업은 대기한다. 예를 들어 서버에서 데이터를 가져와 화면에 표시하는 작업을 수행할 경우 서버에 데이터를 요청하고 데이터가 전달될 때까지 이후 작업들은 중단(Blocking)된다.\n![동기식 처리 모델](http://poiemaweb.com/img/synchronous.png) \n\n### 비동기식 처리 모델(Asynchronous processing model or Non-Blocking processing model)  \n\n작업이 종료되지 않은 상태라도 대기하지 않고 다음 작업을 실행한다. 예를 들어 서버에서 데이터를 가져와 화면에 표시하는 작업을 수행할 경우 서버에 데이터를 요청한 이후 서버로부터 데이터가 전달될 때까지 **대기하지 않고(Non-Blocking) 즉시 다음 작업을 수행한다.** 이후 서버로부터 데이터가 전달되면 이벤트가 발생되고 이벤트 핸들러가 데이터를 가지고 수행할 작업을 계속하여 수행한다.\n\n**자바스크립트의 대부분의 DOM 이벤트와 Timer 함수(setTimeout, setInterval), Ajax 요청은 비동기적으로 동작한다.**\n\n![비동기적 처리 모델](http://poiemaweb.com/img/asynchronous.png)\n\n<br>\n\n## 4. 이벤트 루프와 동시성(Concurrency)\n\n***브라우저는 단일 쓰레드(single-thread)에서 이벤트 드리븐(event-driven) 방식으로 동작한다.***\n\n자바스크립트는 본래 단일스레드 기반의 언어이다. 한번에 하나의 작업(task)만을 처리할 수 있다는 의미이다. 하지만 실제 웹 애플리케이션들을 보면 여러 task가 동시에 처리되는 것처럼 보인다. 이는 자바스크립트가 이벤트 루프를 이용해서 비동기 방식으로 동시성을 지원하기 때문이다.\n\n### 브라우저 환경\n\n![이벤트 루프(Event Loop)와 브라우저의 환경](http://poiemaweb.com/img/event-loop.png)\n\n자바스크립트 엔진은 크게 콜 스택 영역과 힙 영역으로 나뉜다. 흔히 비동기 호출을 위해 사용하는 `setTimeout`이나 `XMLHttpRequest`와 같은 함수들은 자바스크립트 엔진이 아닌 Web API 영역에 따로 정의되어 있음을 확인할 수 있다. 비동기 방식을 가능하게 하는 이벤트 루프와 태스트 큐(이벤트 큐) 또한 자바스크립트 엔진 외부에 구현되어있다.\n\n***1. Call Stack(호출 스택)***  \n작업이 요청되면(함수가 실행되면) 요청된 작업은 순차적으로 Call Stack에 쌓이게 되고 순차적으로 실행된다. 자바스크립트는 단 하나의 Call Stack을 사용하기 때문에 해당 task가 종료하기 전까지는 다른 어떤 task도 수행될 수 없다.\n\n***2. Heap***  \n힙은 동적으로 생성된 객체 인스턴스가 할당되는 영역이다.\n\n이와 같이 자바스크립트 엔진은 단순히 작업이 요청되면 요청된 작업을 Call Stack을 사용하여 순차적으로 실행할 뿐이다. 앞에서 언급한 동시성(Concurrency)을 지원하기 위해 필요한 *비동기 요청(이벤트를 포함) 처리는 자바스크립트 엔진을 구동하는 환경, 즉 브라우저(또는 Node.js)가 담당한다.*\n\n***3. Event Queue(Task Queue)***  \n비동기 처리 함수의 콜백 함수, 비동기식 이벤트 핸들러, Timer 함수(setTimeout(), setInterval())가 보관되는 영역이다. **이벤트 루프(Event Loop)에 의해 특정 시점(Call Stack이 비어졌을 때)에 순차적으로 Call Stack으로 이동되어 실행된다.**\n\n***4. Event Loop(이벤트 루프)***  \nCall Stack내에서 1) 현재 실행중인 task가 있는지, 그리고 2) Event Queue에 task가 있는지 반복하여 확인한다.\n\n아래의 예제가 어떻게 동작할지 살펴보자.\n\n```js\nfunction func1() {\n  console.log('func1');\n  func2();\n}\n\nfunction func2() {\n  setTimeout(function() {\n    console.log('func2');\n  }, 0);\n\n  func3();\n}\n\nfunction func3() {\n  console.log('func3');\n}\n\nfunc1();\n```\n\n함수 func1이 호출되면 함수 func1은 Call Stack에 쌓인다. 그리고 함수 func1은 함수 func2을 호출하므로 함수 func2가 Call Stack에 쌓이고 setTimeout가 호출된다. setTimeout의 핸들러는 즉시 실행되지 않고 지정 대기 시간만큼 기다리다가 이벤트 큐로 이동한 후 Call Stack이 비어졌을 때 Call Stack으로 이동되어 실행된다.\n\n![이벤트 루프(Event Loop)에 의한 setTimeout 핸들러의 실행](http://poiemaweb.com/img/event-loop.gif)\n\nDOM 이벤트도 이와 같이 동작한다.\n\n```js\nfunction func1() {\n  console.log('func1');\n  func2();\n}\n\nfunction func2() {\n  // <button id=\"foo\">foo</button>\n  var elem = document.getElementById('foo');\n\n  elem.addEventListener('click', function () {\n    this.style.backgroundColor = 'indigo';\n    console.log('func2');\n  });\n\n  func3();\n}\n\nfunction func3() {\n  console.log('func3');\n}\n\nfunc1();\n```\n\n함수 func1이 호출되면 함수 func1은 Call Stack에 쌓인다. 그리고 함수 func1은 함수 func2을 호출하므로 함수 func2가 Call Stack에 쌓이고 addEventListener가 호출된다. addEventListener의 콜백함수는 foo 버튼이 클릭되어 “onclick” 이벤트가 발생하면 이벤트 큐로 이동한 후 Call Stack이 비어졌을 때 Call Stack으로 이동되어 실행된다.\n\n\n### Nodejs 환경\n![nodejs 환경](https://camo.githubusercontent.com/cb45689d053b03f76965aa02fff3b049ce79e533/68747470733a2f2f7062732e7477696d672e636f6d2f6d656469612f42743579774a72494541414b4a51742e6a7067)\n\nNode.js는 비동기 IO를 지원하기 위해 libuv 라이브러리를 사용하며, 이 libuv가 이벤트 루프를 제공한다. 자바스크립트 엔진은 비동기 작업을 위해 Node.js의 API를 호출하며, 이때 넘겨진 콜백은 libuv의 이벤트 루프를 통해 스케쥴되고 실행된다.\n\n---\n\n결론적으로, 자바스크립트가 단일 스레드 기반의 언어라는 말은 **자바스크립트 엔진이 단일 호출 스택을 사용한다**는 관점에서만 사실이다. 실제 자바스크립트가 구동되는 환경(브라우저, nodejs 등)에서는 주로 여러개의 스레드가 사용되며 이러한 구동 환경이 단일 호출 스택을 사용하는 자바스크립트 엔진과 상호 연동하기 위해 사용하는 장치가 바로 이벤트 루프이다.\n\n---\n\nReference\n\n[Poiemaweb](http://poiemaweb.com/js-async)  \n\n[nhnent/github](https://github.com/nhnent/fe.javascript/wiki/June-13-June-17,-2016)\n","slug":"Javascript/04.Async,EventLoop","published":1,"updated":"2017-09-21T05:52:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjai8h182000jvb9q3xx88nd9","content":"<p><img src=\"https://www.bram.us/wordpress/wp-content/uploads/2016/06/javascript-logo-banner.jpg\" alt=\"\"></p><h1 id=\"비동기식-처리-모델과-이벤트-루프\"><a href=\"#비동기식-처리-모델과-이벤트-루프\" class=\"headerlink\" title=\"비동기식 처리 모델과 이벤트 루프\"></a>비동기식 처리 모델과 이벤트 루프</h1><h2 id=\"1-브라우저-동작-원리\"><a href=\"#1-브라우저-동작-원리\" class=\"headerlink\" title=\"1. 브라우저 동작 원리\"></a>1. 브라우저 동작 원리</h2><h3 id=\"1-브라우저의-주요-기능\"><a href=\"#1-브라우저의-주요-기능\" class=\"headerlink\" title=\"1) 브라우저의 주요 기능\"></a>1) 브라우저의 주요 기능</h3><p>브라우저의 주요 기능은 사용자가 참조하고자 하는 자원을 (또는 웹페이지를) 서버에 요청(Request)하고 응답(Response)을 받아 브라우저에 표시하는 것이다. 브라우저가 서버로부터 받는 자원은 보통 HTML 문서이지만, PDF나 이미지 또는 다른 형태일 수 있다. 일반적으로 브라우저는 서버로부터 HTML, CSS, Javascript 파일을 응답받는다. (자원의 주소는 URI에 의해 정해진다.)<br>브라우저는 W3C(웹 표준화 기구)에서 정한 HTML과 CSS 표준 명세에 따라 HTML 파일을 해석해서 표시한다.</p><p><br></p><h3 id=\"2-브라우저의-기본-구조\"><a href=\"#2-브라우저의-기본-구조\" class=\"headerlink\" title=\"2) 브라우저의 기본 구조\"></a>2) 브라우저의 기본 구조</h3><p><img src=\"http://d2.naver.com/content/images/2015/06/helloworld-59361-1.png\" alt=\"브라우저의 구성 요소\"></p><ol><li><p>사용자 인터페이스: 주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등. 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분이다.</p></li><li><p>브라우저 엔진: 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어.</p></li><li><p>렌더링 엔진: 요청한 콘텐츠를 표시한다. 예를 들어 HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시한다.</p></li><li><p>통신: HTTP 요청과 같은 네트워크 호출에 사용된다. 플랫폼 독립적인 인터페이스이고 각 플랫폼 하부에서 실행된다.</p></li><li><p>UI 백엔드: 콤보 박스와 창 같은 기본적인 장치를 그린다. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, OS 사용자 인터페이스 체계를 사용한다.</p></li><li><p>자바스크립트 해석: 자바스크립트 코드를 해석하고 실행한다.</p></li><li><p>자료 저장소: 자료를 저장하는 계층이다. 쿠키를 저장하는 것과 같이 모든 종류의 자원을 하드 디스크에 저장할 필요가 있다. HTML5 명세에는 브라우저가 지원하는 <a href=\"http://www.html5rocks.com/en/features/storage\" target=\"_blank\" rel=\"external\">웹 데이터베이스</a>가 정의되어 있다.</p></li></ol><p>크롬 브라우저는 각 탭마다 별도의 렌더링 엔진 인스턴스를 유지한다. 따라서 각 탭은 독립된 프로세스로 처리된다.</p><p><br></p><h3 id=\"3-렌더링-엔진\"><a href=\"#3-렌더링-엔진\" class=\"headerlink\" title=\"3) 렌더링 엔진\"></a>3) 렌더링 엔진</h3><p>렌더링 엔진의 역할은 요청 받은 콘텐츠를 브라우저에 표시하는 일이다. HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시한다. HTML, CSS 파일은 렌더링 엔진의 HTML 파서와 CSS 파서에 의해 파싱되어 DOM, CSSOM 트리로 변환되고 렌더 트리로 결합된다.</p><p>렌더링 엔진은 XML 문서와 이미지도 표시할 수 있다. 물론 플러그인이나 브라우저 확장 기능을 이용해 PDF 같은 다른 유형도 표시할 수 있다. 여기서는 HTML과 이미지를 CSS로 표시하는 주된 사용 패턴에 초점을 둘 것이다.</p><blockquote><p>렌더링 엔진은 브라우저마다 다르다. 파이어폭스는 게코(Gecko) 엔진을 사용하며 사파리와 크롬은 웹킷(Webkit) 엔진을 사용한다.</p></blockquote><h3 id=\"렌더링-엔진-동작-과정\"><a href=\"#렌더링-엔진-동작-과정\" class=\"headerlink\" title=\"렌더링 엔진 동작 과정\"></a>렌더링 엔진 동작 과정</h3><p>렌더링 엔진은 통신으로부터 요청한 문서의 콘텐츠를 얻는 것으로 시작한다. 문서 내용은 보통 8KB 단위로 전송된다.</p><p><img src=\"http://d2.naver.com/content/images/2015/06/helloworld-59361-2.png\" alt=\"렌더링 엔진 동작 과정\"></p><p><img src=\"http://poiemaweb.com/img/client-server.png\" alt=\"브라우저 동작 원리\"></p><ul><li><p>렌더링 엔진은 HTML 문서를 파싱하고, 콘텐츠 트리 내부에서 태그를 DOM 노드로 변환한다. 그다음 외부 CSS 파일과 함께 포함된 스타일 요소도 파싱한다. 파싱된 스타일 정보는 CSSOM 노드로 변환한다.</p></li><li><p>스타일 정보(CSSOM)와 HTML 표시 규칙(DOM)으로 <strong>렌더 트리</strong>라는 또 다른 트리를 생성한다. 렌더트리는 색상이나 면적같은 시각적 속성이 있는 박스를 포함하고 있는데, 정해진 순서대로 화면에 표시된다.</p></li><li><p>렌더 트리의 각 노드가 화면의 정확한 위치에 배치되어 표시된다. 다음은 UI 백엔드에서 렌더 트리의 각 노드를 가로지르며 형상을 만들어내는 그리기 과정이다.</p></li></ul><p>일련의 과정들이 점진적으로 진행된다는 것을 아는 것이 중요하다. 렌더링 엔진은 좀 더 나은 사용자 경험을 위해 가능하면 빠르게 내용을 표시하는데 <strong>모든 HTML을 파싱할 때까지 기다리지 않고 배치와 그리기 과정을 시작한다.</strong> 네트워크로부터 나머지 내용이 전송되기를 기다리는 동시에 받은 내용의 일부를 먼저 화면에 표시하는 것이다.</p><p><img src=\"http://d2.naver.com/content/images/2015/06/helloworld-59361-3.png\" alt=\"웹킷 렌더링 엔진\"></p><p><img src=\"http://d2.naver.com/content/images/2015/06/helloworld-59361-4.png\" alt=\"게코 렌더링 엔진\"></p><hr><p><strong>[참고]</strong> <a href=\"http://d2.naver.com/helloworld/59361\" target=\"_blank\" rel=\"external\">브라우저는 어떻게 동작하는가</a>, <a href=\"http://poiemaweb.com/js-async\" target=\"_blank\" rel=\"external\">Poiema web</a></p><p>HTML 파서는 script 태그를 만나면 DOM 생성 프로세스를 중지하고 자바스크립트 엔진에 제어 권한을 넘긴다. 자바스크립트 엔진의 실행이 완료된 후 브라우저가 중지했던 시점부터 DOM 생성을 재개한다. 이것은 script 태그의 위치에 의해 DOM의 생성이 지연될 수 있음을 의미한다.</p><p><br></p><h2 id=\"2-Ajax\"><a href=\"#2-Ajax\" class=\"headerlink\" title=\"2. Ajax\"></a>2. Ajax</h2><p>브라우저에서 웹페이지를 요청하거나 링크를 클릭하면 화면 전환이 발생한다. 이것은 브라우저와 서버와의 통신에 의한 것이다.</p><p><img src=\"http://poiemaweb.com/img/req_res.png\" alt=\"\"></p><p>서버는 요청받은 페이지(HTML)를 반환하는데 이때 HTML에서 로드하는 CSS나 JavaScript 파일들도 같이 반환된다. 클라이언트의 요청에 따라 서버는 정적인 파일을 반환할 수도 있고 서버 사이드 프로그램이 만들어낸 파일이나 데이터를 반환할 수도 있다. 서버로부터 웹페이지가 반환되면 클라이언트(브라우저)는 이를 렌더링하여 화면에 표시한다.</p><p><img src=\"http://poiemaweb.com/img/traditional-webpage-lifecycle.png\" alt=\"Traditional Web Page Lifecycle\"></p><h3 id=\"Ajax-Asynchronous-JavaScript-and-XML-는-자바스크립트를-이용해서-비동기적-Asynchronous-으로-서버와-브라우저가-데이터를-교환할-수-있는-통신-방식을-의미한다\"><a href=\"#Ajax-Asynchronous-JavaScript-and-XML-는-자바스크립트를-이용해서-비동기적-Asynchronous-으로-서버와-브라우저가-데이터를-교환할-수-있는-통신-방식을-의미한다\" class=\"headerlink\" title=\"Ajax(Asynchronous JavaScript and XML)는 자바스크립트를 이용해서 비동기적(Asynchronous)으로 서버와 브라우저가 데이터를 교환할 수 있는 통신 방식을 의미한다.\"></a>Ajax(Asynchronous JavaScript and XML)는 자바스크립트를 이용해서 비동기적(Asynchronous)으로 서버와 브라우저가 데이터를 교환할 수 있는 통신 방식을 의미한다.</h3><p>서버로부터 웹페이지가 반환되면 화면 전체를 갱신해야 하는데, AJAX는 페이지 일부만을 갱신하고도 동일한 효과를 볼 수 있도록 한다. 페이지 전체를 로드하여 렌더링할 필요가 없고 갱신이 필요한 일부만 로드하여 갱신하면 되므로 <strong>빠른 퍼포먼스와 부드러운 화면 표시 효과</strong>를 기대할 수 있다.</p><p><img src=\"http://poiemaweb.com/img/ajax-webpage-lifecycle.png\" alt=\"AJAX Lifecycle\"></p><p>서버는 HTML, XML, JSON등을 반환하는데, Ajax을 위한 데이터 형식은 <strong>JSON(JavaScript Object Notation)</strong> 을 사용하는 것이 일반적이다.</p><p><br></p><h2 id=\"3-동기식-처리-모델-VS-비동기식-처리-모델\"><a href=\"#3-동기식-처리-모델-VS-비동기식-처리-모델\" class=\"headerlink\" title=\"3. 동기식 처리 모델 VS 비동기식 처리 모델\"></a>3. 동기식 처리 모델 VS 비동기식 처리 모델</h2><h3 id=\"동기식-처리-모델-Synchronous-processing-model\"><a href=\"#동기식-처리-모델-Synchronous-processing-model\" class=\"headerlink\" title=\"동기식 처리 모델(Synchronous processing model)\"></a>동기식 처리 모델(Synchronous processing model)</h3><p>작업이 순차적으로 실행된다. 어떤 작업이 수행 중이면 다음 작업은 대기한다. 예를 들어 서버에서 데이터를 가져와 화면에 표시하는 작업을 수행할 경우 서버에 데이터를 요청하고 데이터가 전달될 때까지 이후 작업들은 중단(Blocking)된다.<br><img src=\"http://poiemaweb.com/img/synchronous.png\" alt=\"동기식 처리 모델\"></p><h3 id=\"비동기식-처리-모델-Asynchronous-processing-model-or-Non-Blocking-processing-model\"><a href=\"#비동기식-처리-모델-Asynchronous-processing-model-or-Non-Blocking-processing-model\" class=\"headerlink\" title=\"비동기식 처리 모델(Asynchronous processing model or Non-Blocking processing model)\"></a>비동기식 처리 모델(Asynchronous processing model or Non-Blocking processing model)</h3><p>작업이 종료되지 않은 상태라도 대기하지 않고 다음 작업을 실행한다. 예를 들어 서버에서 데이터를 가져와 화면에 표시하는 작업을 수행할 경우 서버에 데이터를 요청한 이후 서버로부터 데이터가 전달될 때까지 <strong>대기하지 않고(Non-Blocking) 즉시 다음 작업을 수행한다.</strong> 이후 서버로부터 데이터가 전달되면 이벤트가 발생되고 이벤트 핸들러가 데이터를 가지고 수행할 작업을 계속하여 수행한다.</p><p><strong>자바스크립트의 대부분의 DOM 이벤트와 Timer 함수(setTimeout, setInterval), Ajax 요청은 비동기적으로 동작한다.</strong></p><p><img src=\"http://poiemaweb.com/img/asynchronous.png\" alt=\"비동기적 처리 모델\"></p><p><br></p><h2 id=\"4-이벤트-루프와-동시성-Concurrency\"><a href=\"#4-이벤트-루프와-동시성-Concurrency\" class=\"headerlink\" title=\"4. 이벤트 루프와 동시성(Concurrency)\"></a>4. 이벤트 루프와 동시성(Concurrency)</h2><p><strong><em>브라우저는 단일 쓰레드(single-thread)에서 이벤트 드리븐(event-driven) 방식으로 동작한다.</em></strong></p><p>자바스크립트는 본래 단일스레드 기반의 언어이다. 한번에 하나의 작업(task)만을 처리할 수 있다는 의미이다. 하지만 실제 웹 애플리케이션들을 보면 여러 task가 동시에 처리되는 것처럼 보인다. 이는 자바스크립트가 이벤트 루프를 이용해서 비동기 방식으로 동시성을 지원하기 때문이다.</p><h3 id=\"브라우저-환경\"><a href=\"#브라우저-환경\" class=\"headerlink\" title=\"브라우저 환경\"></a>브라우저 환경</h3><p><img src=\"http://poiemaweb.com/img/event-loop.png\" alt=\"이벤트 루프(Event Loop)와 브라우저의 환경\"></p><p>자바스크립트 엔진은 크게 콜 스택 영역과 힙 영역으로 나뉜다. 흔히 비동기 호출을 위해 사용하는 <code>setTimeout</code>이나 <code>XMLHttpRequest</code>와 같은 함수들은 자바스크립트 엔진이 아닌 Web API 영역에 따로 정의되어 있음을 확인할 수 있다. 비동기 방식을 가능하게 하는 이벤트 루프와 태스트 큐(이벤트 큐) 또한 자바스크립트 엔진 외부에 구현되어있다.</p><p><strong><em>1. Call Stack(호출 스택)</em></strong><br>작업이 요청되면(함수가 실행되면) 요청된 작업은 순차적으로 Call Stack에 쌓이게 되고 순차적으로 실행된다. 자바스크립트는 단 하나의 Call Stack을 사용하기 때문에 해당 task가 종료하기 전까지는 다른 어떤 task도 수행될 수 없다.</p><p><strong><em>2. Heap</em></strong><br>힙은 동적으로 생성된 객체 인스턴스가 할당되는 영역이다.</p><p>이와 같이 자바스크립트 엔진은 단순히 작업이 요청되면 요청된 작업을 Call Stack을 사용하여 순차적으로 실행할 뿐이다. 앞에서 언급한 동시성(Concurrency)을 지원하기 위해 필요한 <em>비동기 요청(이벤트를 포함) 처리는 자바스크립트 엔진을 구동하는 환경, 즉 브라우저(또는 Node.js)가 담당한다.</em></p><p><strong><em>3. Event Queue(Task Queue)</em></strong><br>비동기 처리 함수의 콜백 함수, 비동기식 이벤트 핸들러, Timer 함수(setTimeout(), setInterval())가 보관되는 영역이다. <strong>이벤트 루프(Event Loop)에 의해 특정 시점(Call Stack이 비어졌을 때)에 순차적으로 Call Stack으로 이동되어 실행된다.</strong></p><p><strong><em>4. Event Loop(이벤트 루프)</em></strong><br>Call Stack내에서 1) 현재 실행중인 task가 있는지, 그리고 2) Event Queue에 task가 있는지 반복하여 확인한다.</p><p>아래의 예제가 어떻게 동작할지 살펴보자.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func1</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'func1'</span>);</div><div class=\"line\">  func2();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func2</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'func2'</span>);</div><div class=\"line\">  &#125;, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">  func3();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func3</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'func3'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func1();</div></pre></td></tr></table></figure><p>함수 func1이 호출되면 함수 func1은 Call Stack에 쌓인다. 그리고 함수 func1은 함수 func2을 호출하므로 함수 func2가 Call Stack에 쌓이고 setTimeout가 호출된다. setTimeout의 핸들러는 즉시 실행되지 않고 지정 대기 시간만큼 기다리다가 이벤트 큐로 이동한 후 Call Stack이 비어졌을 때 Call Stack으로 이동되어 실행된다.</p><p><img src=\"http://poiemaweb.com/img/event-loop.gif\" alt=\"이벤트 루프(Event Loop)에 의한 setTimeout 핸들러의 실행\"></p><p>DOM 이벤트도 이와 같이 동작한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func1</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'func1'</span>);</div><div class=\"line\">  func2();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func2</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// &lt;button id=\"foo\"&gt;foo&lt;/button&gt;</span></div><div class=\"line\">  <span class=\"keyword\">var</span> elem = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'foo'</span>);</div><div class=\"line\"></div><div class=\"line\">  elem.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.style.backgroundColor = <span class=\"string\">'indigo'</span>;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'func2'</span>);</div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">  func3();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func3</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'func3'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func1();</div></pre></td></tr></table></figure><p>함수 func1이 호출되면 함수 func1은 Call Stack에 쌓인다. 그리고 함수 func1은 함수 func2을 호출하므로 함수 func2가 Call Stack에 쌓이고 addEventListener가 호출된다. addEventListener의 콜백함수는 foo 버튼이 클릭되어 “onclick” 이벤트가 발생하면 이벤트 큐로 이동한 후 Call Stack이 비어졌을 때 Call Stack으로 이동되어 실행된다.</p><h3 id=\"Nodejs-환경\"><a href=\"#Nodejs-환경\" class=\"headerlink\" title=\"Nodejs 환경\"></a>Nodejs 환경</h3><p><img src=\"https://camo.githubusercontent.com/cb45689d053b03f76965aa02fff3b049ce79e533/68747470733a2f2f7062732e7477696d672e636f6d2f6d656469612f42743579774a72494541414b4a51742e6a7067\" alt=\"nodejs 환경\"></p><p>Node.js는 비동기 IO를 지원하기 위해 libuv 라이브러리를 사용하며, 이 libuv가 이벤트 루프를 제공한다. 자바스크립트 엔진은 비동기 작업을 위해 Node.js의 API를 호출하며, 이때 넘겨진 콜백은 libuv의 이벤트 루프를 통해 스케쥴되고 실행된다.</p><hr><p>결론적으로, 자바스크립트가 단일 스레드 기반의 언어라는 말은 <strong>자바스크립트 엔진이 단일 호출 스택을 사용한다</strong>는 관점에서만 사실이다. 실제 자바스크립트가 구동되는 환경(브라우저, nodejs 등)에서는 주로 여러개의 스레드가 사용되며 이러한 구동 환경이 단일 호출 스택을 사용하는 자바스크립트 엔진과 상호 연동하기 위해 사용하는 장치가 바로 이벤트 루프이다.</p><hr><p>Reference</p><p><a href=\"http://poiemaweb.com/js-async\" target=\"_blank\" rel=\"external\">Poiemaweb</a></p><p><a href=\"https://github.com/nhnent/fe.javascript/wiki/June-13-June-17,-2016\" target=\"_blank\" rel=\"external\">nhnent/github</a></p>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://www.bram.us/wordpress/wp-content/uploads/2016/06/javascript-logo-banner.jpg\" alt=\"\"></p><h1 id=\"비동기식-처리-모델과-이벤트-루프\"><a href=\"#비동기식-처리-모델과-이벤트-루프\" class=\"headerlink\" title=\"비동기식 처리 모델과 이벤트 루프\"></a>비동기식 처리 모델과 이벤트 루프</h1><h2 id=\"1-브라우저-동작-원리\"><a href=\"#1-브라우저-동작-원리\" class=\"headerlink\" title=\"1. 브라우저 동작 원리\"></a>1. 브라우저 동작 원리</h2><h3 id=\"1-브라우저의-주요-기능\"><a href=\"#1-브라우저의-주요-기능\" class=\"headerlink\" title=\"1) 브라우저의 주요 기능\"></a>1) 브라우저의 주요 기능</h3><p>브라우저의 주요 기능은 사용자가 참조하고자 하는 자원을 (또는 웹페이지를) 서버에 요청(Request)하고 응답(Response)을 받아 브라우저에 표시하는 것이다. 브라우저가 서버로부터 받는 자원은 보통 HTML 문서이지만, PDF나 이미지 또는 다른 형태일 수 있다. 일반적으로 브라우저는 서버로부터 HTML, CSS, Javascript 파일을 응답받는다. (자원의 주소는 URI에 의해 정해진다.)<br>브라우저는 W3C(웹 표준화 기구)에서 정한 HTML과 CSS 표준 명세에 따라 HTML 파일을 해석해서 표시한다.</p><p><br></p><h3 id=\"2-브라우저의-기본-구조\"><a href=\"#2-브라우저의-기본-구조\" class=\"headerlink\" title=\"2) 브라우저의 기본 구조\"></a>2) 브라우저의 기본 구조</h3><p><img src=\"http://d2.naver.com/content/images/2015/06/helloworld-59361-1.png\" alt=\"브라우저의 구성 요소\"></p><ol><li><p>사용자 인터페이스: 주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등. 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분이다.</p></li><li><p>브라우저 엔진: 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어.</p></li><li><p>렌더링 엔진: 요청한 콘텐츠를 표시한다. 예를 들어 HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시한다.</p></li><li><p>통신: HTTP 요청과 같은 네트워크 호출에 사용된다. 플랫폼 독립적인 인터페이스이고 각 플랫폼 하부에서 실행된다.</p></li><li><p>UI 백엔드: 콤보 박스와 창 같은 기본적인 장치를 그린다. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, OS 사용자 인터페이스 체계를 사용한다.</p></li><li><p>자바스크립트 해석: 자바스크립트 코드를 해석하고 실행한다.</p></li><li><p>자료 저장소: 자료를 저장하는 계층이다. 쿠키를 저장하는 것과 같이 모든 종류의 자원을 하드 디스크에 저장할 필요가 있다. HTML5 명세에는 브라우저가 지원하는 <a href=\"http://www.html5rocks.com/en/features/storage\" target=\"_blank\" rel=\"external\">웹 데이터베이스</a>가 정의되어 있다.</p></li></ol><p>크롬 브라우저는 각 탭마다 별도의 렌더링 엔진 인스턴스를 유지한다. 따라서 각 탭은 독립된 프로세스로 처리된다.</p><p><br></p><h3 id=\"3-렌더링-엔진\"><a href=\"#3-렌더링-엔진\" class=\"headerlink\" title=\"3) 렌더링 엔진\"></a>3) 렌더링 엔진</h3><p>렌더링 엔진의 역할은 요청 받은 콘텐츠를 브라우저에 표시하는 일이다. HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시한다. HTML, CSS 파일은 렌더링 엔진의 HTML 파서와 CSS 파서에 의해 파싱되어 DOM, CSSOM 트리로 변환되고 렌더 트리로 결합된다.</p><p>렌더링 엔진은 XML 문서와 이미지도 표시할 수 있다. 물론 플러그인이나 브라우저 확장 기능을 이용해 PDF 같은 다른 유형도 표시할 수 있다. 여기서는 HTML과 이미지를 CSS로 표시하는 주된 사용 패턴에 초점을 둘 것이다.</p><blockquote><p>렌더링 엔진은 브라우저마다 다르다. 파이어폭스는 게코(Gecko) 엔진을 사용하며 사파리와 크롬은 웹킷(Webkit) 엔진을 사용한다.</p></blockquote><h3 id=\"렌더링-엔진-동작-과정\"><a href=\"#렌더링-엔진-동작-과정\" class=\"headerlink\" title=\"렌더링 엔진 동작 과정\"></a>렌더링 엔진 동작 과정</h3><p>렌더링 엔진은 통신으로부터 요청한 문서의 콘텐츠를 얻는 것으로 시작한다. 문서 내용은 보통 8KB 단위로 전송된다.</p><p><img src=\"http://d2.naver.com/content/images/2015/06/helloworld-59361-2.png\" alt=\"렌더링 엔진 동작 과정\"></p><p><img src=\"http://poiemaweb.com/img/client-server.png\" alt=\"브라우저 동작 원리\"></p><ul><li><p>렌더링 엔진은 HTML 문서를 파싱하고, 콘텐츠 트리 내부에서 태그를 DOM 노드로 변환한다. 그다음 외부 CSS 파일과 함께 포함된 스타일 요소도 파싱한다. 파싱된 스타일 정보는 CSSOM 노드로 변환한다.</p></li><li><p>스타일 정보(CSSOM)와 HTML 표시 규칙(DOM)으로 <strong>렌더 트리</strong>라는 또 다른 트리를 생성한다. 렌더트리는 색상이나 면적같은 시각적 속성이 있는 박스를 포함하고 있는데, 정해진 순서대로 화면에 표시된다.</p></li><li><p>렌더 트리의 각 노드가 화면의 정확한 위치에 배치되어 표시된다. 다음은 UI 백엔드에서 렌더 트리의 각 노드를 가로지르며 형상을 만들어내는 그리기 과정이다.</p></li></ul><p>일련의 과정들이 점진적으로 진행된다는 것을 아는 것이 중요하다. 렌더링 엔진은 좀 더 나은 사용자 경험을 위해 가능하면 빠르게 내용을 표시하는데 <strong>모든 HTML을 파싱할 때까지 기다리지 않고 배치와 그리기 과정을 시작한다.</strong> 네트워크로부터 나머지 내용이 전송되기를 기다리는 동시에 받은 내용의 일부를 먼저 화면에 표시하는 것이다.</p><p><img src=\"http://d2.naver.com/content/images/2015/06/helloworld-59361-3.png\" alt=\"웹킷 렌더링 엔진\"></p><p><img src=\"http://d2.naver.com/content/images/2015/06/helloworld-59361-4.png\" alt=\"게코 렌더링 엔진\"></p><hr><p><strong>[참고]</strong> <a href=\"http://d2.naver.com/helloworld/59361\" target=\"_blank\" rel=\"external\">브라우저는 어떻게 동작하는가</a>, <a href=\"http://poiemaweb.com/js-async\" target=\"_blank\" rel=\"external\">Poiema web</a></p><p>HTML 파서는 script 태그를 만나면 DOM 생성 프로세스를 중지하고 자바스크립트 엔진에 제어 권한을 넘긴다. 자바스크립트 엔진의 실행이 완료된 후 브라우저가 중지했던 시점부터 DOM 생성을 재개한다. 이것은 script 태그의 위치에 의해 DOM의 생성이 지연될 수 있음을 의미한다.</p><p><br></p><h2 id=\"2-Ajax\"><a href=\"#2-Ajax\" class=\"headerlink\" title=\"2. Ajax\"></a>2. Ajax</h2><p>브라우저에서 웹페이지를 요청하거나 링크를 클릭하면 화면 전환이 발생한다. 이것은 브라우저와 서버와의 통신에 의한 것이다.</p><p><img src=\"http://poiemaweb.com/img/req_res.png\" alt=\"\"></p><p>서버는 요청받은 페이지(HTML)를 반환하는데 이때 HTML에서 로드하는 CSS나 JavaScript 파일들도 같이 반환된다. 클라이언트의 요청에 따라 서버는 정적인 파일을 반환할 수도 있고 서버 사이드 프로그램이 만들어낸 파일이나 데이터를 반환할 수도 있다. 서버로부터 웹페이지가 반환되면 클라이언트(브라우저)는 이를 렌더링하여 화면에 표시한다.</p><p><img src=\"http://poiemaweb.com/img/traditional-webpage-lifecycle.png\" alt=\"Traditional Web Page Lifecycle\"></p><h3 id=\"Ajax-Asynchronous-JavaScript-and-XML-는-자바스크립트를-이용해서-비동기적-Asynchronous-으로-서버와-브라우저가-데이터를-교환할-수-있는-통신-방식을-의미한다\"><a href=\"#Ajax-Asynchronous-JavaScript-and-XML-는-자바스크립트를-이용해서-비동기적-Asynchronous-으로-서버와-브라우저가-데이터를-교환할-수-있는-통신-방식을-의미한다\" class=\"headerlink\" title=\"Ajax(Asynchronous JavaScript and XML)는 자바스크립트를 이용해서 비동기적(Asynchronous)으로 서버와 브라우저가 데이터를 교환할 수 있는 통신 방식을 의미한다.\"></a>Ajax(Asynchronous JavaScript and XML)는 자바스크립트를 이용해서 비동기적(Asynchronous)으로 서버와 브라우저가 데이터를 교환할 수 있는 통신 방식을 의미한다.</h3><p>서버로부터 웹페이지가 반환되면 화면 전체를 갱신해야 하는데, AJAX는 페이지 일부만을 갱신하고도 동일한 효과를 볼 수 있도록 한다. 페이지 전체를 로드하여 렌더링할 필요가 없고 갱신이 필요한 일부만 로드하여 갱신하면 되므로 <strong>빠른 퍼포먼스와 부드러운 화면 표시 효과</strong>를 기대할 수 있다.</p><p><img src=\"http://poiemaweb.com/img/ajax-webpage-lifecycle.png\" alt=\"AJAX Lifecycle\"></p><p>서버는 HTML, XML, JSON등을 반환하는데, Ajax을 위한 데이터 형식은 <strong>JSON(JavaScript Object Notation)</strong> 을 사용하는 것이 일반적이다.</p><p><br></p><h2 id=\"3-동기식-처리-모델-VS-비동기식-처리-모델\"><a href=\"#3-동기식-처리-모델-VS-비동기식-처리-모델\" class=\"headerlink\" title=\"3. 동기식 처리 모델 VS 비동기식 처리 모델\"></a>3. 동기식 처리 모델 VS 비동기식 처리 모델</h2><h3 id=\"동기식-처리-모델-Synchronous-processing-model\"><a href=\"#동기식-처리-모델-Synchronous-processing-model\" class=\"headerlink\" title=\"동기식 처리 모델(Synchronous processing model)\"></a>동기식 처리 모델(Synchronous processing model)</h3><p>작업이 순차적으로 실행된다. 어떤 작업이 수행 중이면 다음 작업은 대기한다. 예를 들어 서버에서 데이터를 가져와 화면에 표시하는 작업을 수행할 경우 서버에 데이터를 요청하고 데이터가 전달될 때까지 이후 작업들은 중단(Blocking)된다.<br><img src=\"http://poiemaweb.com/img/synchronous.png\" alt=\"동기식 처리 모델\"></p><h3 id=\"비동기식-처리-모델-Asynchronous-processing-model-or-Non-Blocking-processing-model\"><a href=\"#비동기식-처리-모델-Asynchronous-processing-model-or-Non-Blocking-processing-model\" class=\"headerlink\" title=\"비동기식 처리 모델(Asynchronous processing model or Non-Blocking processing model)\"></a>비동기식 처리 모델(Asynchronous processing model or Non-Blocking processing model)</h3><p>작업이 종료되지 않은 상태라도 대기하지 않고 다음 작업을 실행한다. 예를 들어 서버에서 데이터를 가져와 화면에 표시하는 작업을 수행할 경우 서버에 데이터를 요청한 이후 서버로부터 데이터가 전달될 때까지 <strong>대기하지 않고(Non-Blocking) 즉시 다음 작업을 수행한다.</strong> 이후 서버로부터 데이터가 전달되면 이벤트가 발생되고 이벤트 핸들러가 데이터를 가지고 수행할 작업을 계속하여 수행한다.</p><p><strong>자바스크립트의 대부분의 DOM 이벤트와 Timer 함수(setTimeout, setInterval), Ajax 요청은 비동기적으로 동작한다.</strong></p><p><img src=\"http://poiemaweb.com/img/asynchronous.png\" alt=\"비동기적 처리 모델\"></p><p><br></p><h2 id=\"4-이벤트-루프와-동시성-Concurrency\"><a href=\"#4-이벤트-루프와-동시성-Concurrency\" class=\"headerlink\" title=\"4. 이벤트 루프와 동시성(Concurrency)\"></a>4. 이벤트 루프와 동시성(Concurrency)</h2><p><strong><em>브라우저는 단일 쓰레드(single-thread)에서 이벤트 드리븐(event-driven) 방식으로 동작한다.</em></strong></p><p>자바스크립트는 본래 단일스레드 기반의 언어이다. 한번에 하나의 작업(task)만을 처리할 수 있다는 의미이다. 하지만 실제 웹 애플리케이션들을 보면 여러 task가 동시에 처리되는 것처럼 보인다. 이는 자바스크립트가 이벤트 루프를 이용해서 비동기 방식으로 동시성을 지원하기 때문이다.</p><h3 id=\"브라우저-환경\"><a href=\"#브라우저-환경\" class=\"headerlink\" title=\"브라우저 환경\"></a>브라우저 환경</h3><p><img src=\"http://poiemaweb.com/img/event-loop.png\" alt=\"이벤트 루프(Event Loop)와 브라우저의 환경\"></p><p>자바스크립트 엔진은 크게 콜 스택 영역과 힙 영역으로 나뉜다. 흔히 비동기 호출을 위해 사용하는 <code>setTimeout</code>이나 <code>XMLHttpRequest</code>와 같은 함수들은 자바스크립트 엔진이 아닌 Web API 영역에 따로 정의되어 있음을 확인할 수 있다. 비동기 방식을 가능하게 하는 이벤트 루프와 태스트 큐(이벤트 큐) 또한 자바스크립트 엔진 외부에 구현되어있다.</p><p><strong><em>1. Call Stack(호출 스택)</em></strong><br>작업이 요청되면(함수가 실행되면) 요청된 작업은 순차적으로 Call Stack에 쌓이게 되고 순차적으로 실행된다. 자바스크립트는 단 하나의 Call Stack을 사용하기 때문에 해당 task가 종료하기 전까지는 다른 어떤 task도 수행될 수 없다.</p><p><strong><em>2. Heap</em></strong><br>힙은 동적으로 생성된 객체 인스턴스가 할당되는 영역이다.</p><p>이와 같이 자바스크립트 엔진은 단순히 작업이 요청되면 요청된 작업을 Call Stack을 사용하여 순차적으로 실행할 뿐이다. 앞에서 언급한 동시성(Concurrency)을 지원하기 위해 필요한 <em>비동기 요청(이벤트를 포함) 처리는 자바스크립트 엔진을 구동하는 환경, 즉 브라우저(또는 Node.js)가 담당한다.</em></p><p><strong><em>3. Event Queue(Task Queue)</em></strong><br>비동기 처리 함수의 콜백 함수, 비동기식 이벤트 핸들러, Timer 함수(setTimeout(), setInterval())가 보관되는 영역이다. <strong>이벤트 루프(Event Loop)에 의해 특정 시점(Call Stack이 비어졌을 때)에 순차적으로 Call Stack으로 이동되어 실행된다.</strong></p><p><strong><em>4. Event Loop(이벤트 루프)</em></strong><br>Call Stack내에서 1) 현재 실행중인 task가 있는지, 그리고 2) Event Queue에 task가 있는지 반복하여 확인한다.</p><p>아래의 예제가 어떻게 동작할지 살펴보자.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func1</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'func1'</span>);</div><div class=\"line\">  func2();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func2</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'func2'</span>);</div><div class=\"line\">  &#125;, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">  func3();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func3</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'func3'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func1();</div></pre></td></tr></table></figure><p>함수 func1이 호출되면 함수 func1은 Call Stack에 쌓인다. 그리고 함수 func1은 함수 func2을 호출하므로 함수 func2가 Call Stack에 쌓이고 setTimeout가 호출된다. setTimeout의 핸들러는 즉시 실행되지 않고 지정 대기 시간만큼 기다리다가 이벤트 큐로 이동한 후 Call Stack이 비어졌을 때 Call Stack으로 이동되어 실행된다.</p><p><img src=\"http://poiemaweb.com/img/event-loop.gif\" alt=\"이벤트 루프(Event Loop)에 의한 setTimeout 핸들러의 실행\"></p><p>DOM 이벤트도 이와 같이 동작한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func1</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'func1'</span>);</div><div class=\"line\">  func2();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func2</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// &lt;button id=\"foo\"&gt;foo&lt;/button&gt;</span></div><div class=\"line\">  <span class=\"keyword\">var</span> elem = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'foo'</span>);</div><div class=\"line\"></div><div class=\"line\">  elem.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.style.backgroundColor = <span class=\"string\">'indigo'</span>;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'func2'</span>);</div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">  func3();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func3</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'func3'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func1();</div></pre></td></tr></table></figure><p>함수 func1이 호출되면 함수 func1은 Call Stack에 쌓인다. 그리고 함수 func1은 함수 func2을 호출하므로 함수 func2가 Call Stack에 쌓이고 addEventListener가 호출된다. addEventListener의 콜백함수는 foo 버튼이 클릭되어 “onclick” 이벤트가 발생하면 이벤트 큐로 이동한 후 Call Stack이 비어졌을 때 Call Stack으로 이동되어 실행된다.</p><h3 id=\"Nodejs-환경\"><a href=\"#Nodejs-환경\" class=\"headerlink\" title=\"Nodejs 환경\"></a>Nodejs 환경</h3><p><img src=\"https://camo.githubusercontent.com/cb45689d053b03f76965aa02fff3b049ce79e533/68747470733a2f2f7062732e7477696d672e636f6d2f6d656469612f42743579774a72494541414b4a51742e6a7067\" alt=\"nodejs 환경\"></p><p>Node.js는 비동기 IO를 지원하기 위해 libuv 라이브러리를 사용하며, 이 libuv가 이벤트 루프를 제공한다. 자바스크립트 엔진은 비동기 작업을 위해 Node.js의 API를 호출하며, 이때 넘겨진 콜백은 libuv의 이벤트 루프를 통해 스케쥴되고 실행된다.</p><hr><p>결론적으로, 자바스크립트가 단일 스레드 기반의 언어라는 말은 <strong>자바스크립트 엔진이 단일 호출 스택을 사용한다</strong>는 관점에서만 사실이다. 실제 자바스크립트가 구동되는 환경(브라우저, nodejs 등)에서는 주로 여러개의 스레드가 사용되며 이러한 구동 환경이 단일 호출 스택을 사용하는 자바스크립트 엔진과 상호 연동하기 위해 사용하는 장치가 바로 이벤트 루프이다.</p><hr><p>Reference</p><p><a href=\"http://poiemaweb.com/js-async\" target=\"_blank\" rel=\"external\">Poiemaweb</a></p><p><a href=\"https://github.com/nhnent/fe.javascript/wiki/June-13-June-17,-2016\" target=\"_blank\" rel=\"external\">nhnent/github</a></p>"},{"title":"[SASS] Extensions","date":"2017-08-07T05:03:41.000Z","_content":"\n![](http://www.unixstickers.com/image/data/stickers/sass/sass.sh.png)\n\n# Extensions\n\n## 1. Nesting\n\nSass의 유용한 확장 기능으로 중첩(Nesting)이 있다. CSS는 후손 셀렉터의 경우 부모요소를 기술하여야 한다.\n\n```css\n#navbar {\n  width: 80%;\n  height: 23px;\n}\n\n#navbar ul {\n  list-style-type: none;\n}\n\n#navbar li {\n  float: left;\n}\n\n#navbar li a {\n  font-weight: bold;\n}\n```\n\nSass의 Nesting은 후손 셀렉터를 간단히 기술이 가능하다. ***또한 HTML의 구조를 반영한 CSS를 기술할 수 있다.***\n\n```scss\n#navbar {\n  width: 80%;\n  height: 23px;\n\n  ul { list-style-type: none; }\n\n  li {\n    float: left;\n    a { font-weight: bold; }\n  }\n}\n```\n\n너무 깊은 Nesting은 가독성을 나쁘게 하고 셀렉터를 복잡하게 만든다. 따라서 Nesting은 3단계 이상 들어가지 않도록 한다. 만약 3단계 이상 들어가야 할 경우에는, 네스팅 하지 않고 차라리 클래스로 꺼내두는게 낫다.\n\n```scss\n// Bad case\ndiv#main {\n  #sidebar {\n    #navbar {\n      width: 80%;\n      height: 23px;\n\n      aside {\n        div {\n          ul {\n            list-style-type: none;\n\n            li {\n              float: left;\n\n              a {\n                font-weight: bold;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n부모요소의 참조가 필요한 경우 `&`를 사용한다. 예를 들어 `:hover` 또는 `:before` 등의 가상 클래스 선택자(Pseudo-Class Selector)를 지정하는 경우 부모요소의 참조가 필요하다.\n\n```scss\na.myAnchor {\n  color: blue;\n  &:hover {\n    text-decoration: underline;\n  }\n  &:visited {\n    color: purple;\n  }\n}\n```\n\nNesting은 프로퍼티에도 사용할 수 있다.\n\n```scss\n.funky {\n  font: {\n    family: fantasy;\n    size: 30em;\n    weight: bold;\n  }\n}\n```\n\n위 코드의 컴파일 결과는 아래와 같다.\n\n```css\n.funky {\n  font-family: fantasy;\n  font-size: 30em;\n  font-weight: bold;\n}\n```\n\n<br>\n\n## 2. @-Rules and Directives\n\n### 1) @import\n\n1개의 CSS파일에 모든 스타일을 기술하는 것은 가독성을 나쁘게 한다. 또한 기능에따라 CSS파일을 분리하면 재사용 및 유지보수 측면에서 유리하다. 따라서 룰을 정하여 파일을 분리하여 개발하는 것은 효과적인 방법이다.\n\nSass는 @import directive를 사용하여 분리된 stylesheet 파일을 import할 수 있다. 기존의 CSS @import보다 편리한 기능을 제공한다.\n\n```scss\n@import \"foo.scss\";\n\n//확장자는 생략 가능하다.\n@import \"foo\";\n\n//import multiple files\n@import \"rounded-corners\", \"text-shadow\";\n\n$family: unquote(\"Droid+Sans\");\n@import url(\"https://fonts.googleapis.com/css?family=#{$family}\")\n```\n\n여러개의 파일로 분할하는 것 또는 분할된 파일을 **partial**이라 하며 partial된 Sass 파일명의 선두에는 underscore(_)를 붙인다. (_reset.scss, _module.scss, _print.scss)\n\n예를 들어 \"_foo.scss\"라는 partial된 Sass 파일이 있고 이 파일을 import 하는 경우 아래와 같이 기술한다. 파일명 선두의 _와 확장자는 생략할 수 있다.\n\n```sass\n@import \"foo\";\n```\n\npartial된 Sass 파일명 선두에 붙인 _의 의미는 import는 수행하되 CSS로의 컴파일은 수행하지 말라는 의미를 갖는다. 따라서 partial은 import시에는 CSS파일로 컴파일되지 않기 때문에 최종적으로 CSS로 컴파일을 수행할 Sass 파일에서 import한다. \n\n![partial](http://poiemaweb.com/img/partial.png)  \n\n@import는 top-level에서 사용하는 것이 일반적이지만 CSS rule 또는 @media rule 내에 포함시키는 것도 가능하다.\n\n```scss\n//_example.scss\n.example {\n  color: red;\n}\n```\n\n```scss\n#main {\n  @import \"example\";\n}\n```\n\n위 코드는 컴파일 결과는 아래와 같다.\n\n```css\n#main .example {\n  color: red;\n}\n```\n\n<br>\n\n### 2) @extend\n\n기존 스타일을 상속하고자 경우 @extend를 사용한다.\n\n```html\n<div class=\"error seriousError\">\n  Oh no! You've been hacked!\n</div>\n```\n\n기존에 선언되어 있는 error class를 사용하면서 일부 rule set에 대해서는 다른 선언이 필요한 경우 자주 사용하는 방법이다.\n\n이러한 경우 사용할 수 있는 방법이 상속이다. 상속되는 rule set을 그대로 상속받아 다른 부분만 별도 선언하면 된다.\n\n```scss\n.error {\n  border: 1px #f00;\n}\n\n.seriousError {\n  @extend .error;\n\n  border-width: 3px;\n  border-color: darkblue;\n}\n```\n\n위 코드의 컴파일 결과는 아래와 같다. `.error`과 `.seriousError`가 공통으로 사용하는 프로퍼티를 묶어 *나름 합리적인* 룰셋을 생성한다.\n\n```css\n.error, .serousError {\n  border: 1px #f00;\n  background-color: blue;\n}\n\n.seriousError {\n  border-width: 3px;\n  border-color: darkblue;\n}\n```\n\n이제 하나의 클래스만 적용시키면 된다.\n\n```html\n<div calss=\"seriousError\">\n  Oh no! You've been hacked!\n</div>\n```\n\n@extend를 @media블록과 같이 사용하는 경우, 제대로 작동하지 않는다. 다시말해 @media 안에서 외부 선택자를 @extend할 수 없다.\n\n```scss\n.foo {\n  color: red;\n}\n\n@media print {\n  .bar {\n    //ERROR\n    @extend .foo;\n  }\n}\n```\n\n> 컴파일 후 자신의 셀렉터가 어디에 첨부될 것인지 **예상하기 어렵고, 예상치 못했던 부작용이 발생할 수 있다.** 따라서 @Extend의 사용은 **가급적 자제**하고 Mixin을 사용하는 것을 추천한다.  \n\n[@extend의 부작용](https://sass-guidelin.es/ko/#extend)\n\n<br>\n\n### 3) Placeholder Selectors\n\nPlaceholder Selector는 Sass3.2부터 제공되는 기능으로 재이용 가능한 Rule set을 %키워드로 지정하는 **@extend 전용 Selector**이다. (그러니, extend를 사용하지 않는다면 별로 기억하지 않아도 된다.)\n\nPlaceholder Selector는 상속만을 위한 rule set으로 자신은 컴파일되지 않는다.\n\n```scss\n%input-style {\n  font-size: 14px;\n}\n\n.input-black {\n  @extend %input-style;\n\n  colr: black;\n}\n\n.input-red {\n  @extend %input-style;\n\n  color: red;\n}\n```\n\n컴파일 결과는 아래와 같다.\n\n```css\n.input-black, .input-red {\n  font-size: 14px;\n}\n\n.input-black {\n  color: black;\n}\n\n.input-red {\n  color: red;\n}\n```\n\n<br>\n\n## 3. 조건과 반복\n\nSass는 Javascript 같은 프로그래밍 언어와 같이 제어문(Control flow statement)을 사용할 수 있는 기능을 제공한다.\n\n<br>\n\n### 1) if()\n\nbuilt-in if()함수는 주어진 조건읊 판단하여 결과를 리턴한다. Javascript의 삼항 연산자와 유사하게 동작한다.\n\n```scss\nif(condition, if_true, if_false)\n```\n\ncondition이 true이면 if_true를, false이면 if_false를 반환한다.\n\n```scss\n$type: ocean;\n\np {\n  color: if($type == ocean, blue, black); // color: blue;\n}\n```\n\n<br>\n\n### 2) @if\n\n@if를 사용하면 조건분기가 가능하다.\n\n```scss\n$type: monster;\n\np {\n  @if $type == ocean {\n    color: blue;\n  } @else if $type == matador {\n    color: red;\n  } @else if $type == monster {\n    color: green;\n  } @else {\n    color: black;\n  }\n}\n```\n\n컴파일 결과는 아래와 같다.\n\n```css\np {\n  color: green;\n}\n```\n\n<br>\n\n### 3) @for\n\n@for으로 반복문을 사용할 수 있다.\n\n```scss\n@for $i from 1 though 3 {\n  .item-#{$1} { width: 2em * $i; }\n}\n```\n\n컴파일 결과는 아래와 같다.\n\n```css\n.item-1 {\n  width: 2em;\n}\n.item-2 {\n  width: 4em;\n}\n.item-3 {\n  width: 6em;\n}\n```\n\n<br>\n\n### 4) @each\n\n@each와 list 또는 map의 요소에 대해 반복을 실시한다.\n\n```scss\n//List\n@each $animal in puma, sea-slug, egret, salamander {\n\n  .#{$animal}-icon {\n    background-image: url('/image/#{$animal}.png');\n  }\n}\n\n// Map\n// $header; h1, $size: 2em\n// $header; h2, $size: 1.5em\n// $header; h3, $size: 1.2em\n@each $header, $size in (h1: 2em, h2: 1.5em, h3: 1.2em) {\n  #{$header} {\n    font-size: $size;\n  }\n}\n```\n\n컴파일 결과는 아래와 같다.\n\n```css\n.puma-icon {\n  background-image: url(\"/image/puma.png\");\n}\n\n.sea-slug-icon {\n  background-image: url(\"/images/sea-slug.png\");\n}\n\n.salamander-icon {\n  background-image: url(\"/image/salamander.png\");\n}\n\nh1 {\n  font-size: 2em;\n}\n\nh2 {\n  font-size: 1.5em;\n}\n\nh3 {\n  font-size: 1.2em;\n}\n```\n\n<br>\n\n### 5) @while\n\n@while로 반복문을 사용할 수 있다.\n\n```scss\n$i: 6;\n@while $i > 0 {\n  .item-#{$i} { width: 2em * $i; }\n  $i: $i - 2;\n}\n\n컴파일 결과는 아래와 같다.\n\n```css\n\n.item-6{\n  width: 12em;\n}\n\n.item-4 {\n  width: 8em;\n}\n\n.item-2 {\n  width: 4em;\n}\n```\n\n<br>\n\n## 4. Mixin\n\nMixin은 Sass의 매우 유용한 기능으로 중복 기술을 방직하기 위해 사용 빈도가 높은 마크업을 사전에 정의하여 필요할 때 불러 사용하는 방법이다.\n\n@extend와 유사하나 프로그래밍 언어의 함수와 같이 argument를 받을 수 있다. 사용법은 매우 간단하다. `@mixin` 선언하고 `@include`로 불러들인다.\n\n```scss\n//지름이 50px인 원\n@mixin circle {\n  width: 50px;\n  height: 50px;\n  border-radius: 50%;\n}\n\n//지름이 50px인 원을 위한 mixin을 include한 후, 배경을 추가 지정\n.box {\n  @include circle;\n\n  background: #f00;\n}\n```\n\n컴파일 결과는 아래와 같다. 배경이 red이고 지름이 50px인 원을 표시한다.\n\n```css\n.box {\n  width: 50px;\n  height: 50px;\n  border-radius: 50%;\n  background: #f00;\n}\n```\n\n@extend와 차이가 없어 보이나 Mixin은 함수처럼 argument를 사용할 수 있다.\n\n```scss\n@mixin circle($size) {\n  width: $size;\n  height: $size;\n  border-radius: 50%;\n}\n\n.box {\n  @include circle(100px);\n\n  background: #f00;\n}\n```\n\n컴파일 결과는 아래와 같다.\n\n```css\n.box{\n  width: 100px;\n  height: 100px;\n  border-radius: 50%;\n  background: #f00;\n}\n```\n\n","source":"_posts/SCSS/02.extensions.md","raw":"---\ntitle: '[SASS] Extensions'\ndate: 2017-08-07 14:03:41\ncategory: Sass\ntags: nesting\n---\n\n![](http://www.unixstickers.com/image/data/stickers/sass/sass.sh.png)\n\n# Extensions\n\n## 1. Nesting\n\nSass의 유용한 확장 기능으로 중첩(Nesting)이 있다. CSS는 후손 셀렉터의 경우 부모요소를 기술하여야 한다.\n\n```css\n#navbar {\n  width: 80%;\n  height: 23px;\n}\n\n#navbar ul {\n  list-style-type: none;\n}\n\n#navbar li {\n  float: left;\n}\n\n#navbar li a {\n  font-weight: bold;\n}\n```\n\nSass의 Nesting은 후손 셀렉터를 간단히 기술이 가능하다. ***또한 HTML의 구조를 반영한 CSS를 기술할 수 있다.***\n\n```scss\n#navbar {\n  width: 80%;\n  height: 23px;\n\n  ul { list-style-type: none; }\n\n  li {\n    float: left;\n    a { font-weight: bold; }\n  }\n}\n```\n\n너무 깊은 Nesting은 가독성을 나쁘게 하고 셀렉터를 복잡하게 만든다. 따라서 Nesting은 3단계 이상 들어가지 않도록 한다. 만약 3단계 이상 들어가야 할 경우에는, 네스팅 하지 않고 차라리 클래스로 꺼내두는게 낫다.\n\n```scss\n// Bad case\ndiv#main {\n  #sidebar {\n    #navbar {\n      width: 80%;\n      height: 23px;\n\n      aside {\n        div {\n          ul {\n            list-style-type: none;\n\n            li {\n              float: left;\n\n              a {\n                font-weight: bold;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n부모요소의 참조가 필요한 경우 `&`를 사용한다. 예를 들어 `:hover` 또는 `:before` 등의 가상 클래스 선택자(Pseudo-Class Selector)를 지정하는 경우 부모요소의 참조가 필요하다.\n\n```scss\na.myAnchor {\n  color: blue;\n  &:hover {\n    text-decoration: underline;\n  }\n  &:visited {\n    color: purple;\n  }\n}\n```\n\nNesting은 프로퍼티에도 사용할 수 있다.\n\n```scss\n.funky {\n  font: {\n    family: fantasy;\n    size: 30em;\n    weight: bold;\n  }\n}\n```\n\n위 코드의 컴파일 결과는 아래와 같다.\n\n```css\n.funky {\n  font-family: fantasy;\n  font-size: 30em;\n  font-weight: bold;\n}\n```\n\n<br>\n\n## 2. @-Rules and Directives\n\n### 1) @import\n\n1개의 CSS파일에 모든 스타일을 기술하는 것은 가독성을 나쁘게 한다. 또한 기능에따라 CSS파일을 분리하면 재사용 및 유지보수 측면에서 유리하다. 따라서 룰을 정하여 파일을 분리하여 개발하는 것은 효과적인 방법이다.\n\nSass는 @import directive를 사용하여 분리된 stylesheet 파일을 import할 수 있다. 기존의 CSS @import보다 편리한 기능을 제공한다.\n\n```scss\n@import \"foo.scss\";\n\n//확장자는 생략 가능하다.\n@import \"foo\";\n\n//import multiple files\n@import \"rounded-corners\", \"text-shadow\";\n\n$family: unquote(\"Droid+Sans\");\n@import url(\"https://fonts.googleapis.com/css?family=#{$family}\")\n```\n\n여러개의 파일로 분할하는 것 또는 분할된 파일을 **partial**이라 하며 partial된 Sass 파일명의 선두에는 underscore(_)를 붙인다. (_reset.scss, _module.scss, _print.scss)\n\n예를 들어 \"_foo.scss\"라는 partial된 Sass 파일이 있고 이 파일을 import 하는 경우 아래와 같이 기술한다. 파일명 선두의 _와 확장자는 생략할 수 있다.\n\n```sass\n@import \"foo\";\n```\n\npartial된 Sass 파일명 선두에 붙인 _의 의미는 import는 수행하되 CSS로의 컴파일은 수행하지 말라는 의미를 갖는다. 따라서 partial은 import시에는 CSS파일로 컴파일되지 않기 때문에 최종적으로 CSS로 컴파일을 수행할 Sass 파일에서 import한다. \n\n![partial](http://poiemaweb.com/img/partial.png)  \n\n@import는 top-level에서 사용하는 것이 일반적이지만 CSS rule 또는 @media rule 내에 포함시키는 것도 가능하다.\n\n```scss\n//_example.scss\n.example {\n  color: red;\n}\n```\n\n```scss\n#main {\n  @import \"example\";\n}\n```\n\n위 코드는 컴파일 결과는 아래와 같다.\n\n```css\n#main .example {\n  color: red;\n}\n```\n\n<br>\n\n### 2) @extend\n\n기존 스타일을 상속하고자 경우 @extend를 사용한다.\n\n```html\n<div class=\"error seriousError\">\n  Oh no! You've been hacked!\n</div>\n```\n\n기존에 선언되어 있는 error class를 사용하면서 일부 rule set에 대해서는 다른 선언이 필요한 경우 자주 사용하는 방법이다.\n\n이러한 경우 사용할 수 있는 방법이 상속이다. 상속되는 rule set을 그대로 상속받아 다른 부분만 별도 선언하면 된다.\n\n```scss\n.error {\n  border: 1px #f00;\n}\n\n.seriousError {\n  @extend .error;\n\n  border-width: 3px;\n  border-color: darkblue;\n}\n```\n\n위 코드의 컴파일 결과는 아래와 같다. `.error`과 `.seriousError`가 공통으로 사용하는 프로퍼티를 묶어 *나름 합리적인* 룰셋을 생성한다.\n\n```css\n.error, .serousError {\n  border: 1px #f00;\n  background-color: blue;\n}\n\n.seriousError {\n  border-width: 3px;\n  border-color: darkblue;\n}\n```\n\n이제 하나의 클래스만 적용시키면 된다.\n\n```html\n<div calss=\"seriousError\">\n  Oh no! You've been hacked!\n</div>\n```\n\n@extend를 @media블록과 같이 사용하는 경우, 제대로 작동하지 않는다. 다시말해 @media 안에서 외부 선택자를 @extend할 수 없다.\n\n```scss\n.foo {\n  color: red;\n}\n\n@media print {\n  .bar {\n    //ERROR\n    @extend .foo;\n  }\n}\n```\n\n> 컴파일 후 자신의 셀렉터가 어디에 첨부될 것인지 **예상하기 어렵고, 예상치 못했던 부작용이 발생할 수 있다.** 따라서 @Extend의 사용은 **가급적 자제**하고 Mixin을 사용하는 것을 추천한다.  \n\n[@extend의 부작용](https://sass-guidelin.es/ko/#extend)\n\n<br>\n\n### 3) Placeholder Selectors\n\nPlaceholder Selector는 Sass3.2부터 제공되는 기능으로 재이용 가능한 Rule set을 %키워드로 지정하는 **@extend 전용 Selector**이다. (그러니, extend를 사용하지 않는다면 별로 기억하지 않아도 된다.)\n\nPlaceholder Selector는 상속만을 위한 rule set으로 자신은 컴파일되지 않는다.\n\n```scss\n%input-style {\n  font-size: 14px;\n}\n\n.input-black {\n  @extend %input-style;\n\n  colr: black;\n}\n\n.input-red {\n  @extend %input-style;\n\n  color: red;\n}\n```\n\n컴파일 결과는 아래와 같다.\n\n```css\n.input-black, .input-red {\n  font-size: 14px;\n}\n\n.input-black {\n  color: black;\n}\n\n.input-red {\n  color: red;\n}\n```\n\n<br>\n\n## 3. 조건과 반복\n\nSass는 Javascript 같은 프로그래밍 언어와 같이 제어문(Control flow statement)을 사용할 수 있는 기능을 제공한다.\n\n<br>\n\n### 1) if()\n\nbuilt-in if()함수는 주어진 조건읊 판단하여 결과를 리턴한다. Javascript의 삼항 연산자와 유사하게 동작한다.\n\n```scss\nif(condition, if_true, if_false)\n```\n\ncondition이 true이면 if_true를, false이면 if_false를 반환한다.\n\n```scss\n$type: ocean;\n\np {\n  color: if($type == ocean, blue, black); // color: blue;\n}\n```\n\n<br>\n\n### 2) @if\n\n@if를 사용하면 조건분기가 가능하다.\n\n```scss\n$type: monster;\n\np {\n  @if $type == ocean {\n    color: blue;\n  } @else if $type == matador {\n    color: red;\n  } @else if $type == monster {\n    color: green;\n  } @else {\n    color: black;\n  }\n}\n```\n\n컴파일 결과는 아래와 같다.\n\n```css\np {\n  color: green;\n}\n```\n\n<br>\n\n### 3) @for\n\n@for으로 반복문을 사용할 수 있다.\n\n```scss\n@for $i from 1 though 3 {\n  .item-#{$1} { width: 2em * $i; }\n}\n```\n\n컴파일 결과는 아래와 같다.\n\n```css\n.item-1 {\n  width: 2em;\n}\n.item-2 {\n  width: 4em;\n}\n.item-3 {\n  width: 6em;\n}\n```\n\n<br>\n\n### 4) @each\n\n@each와 list 또는 map의 요소에 대해 반복을 실시한다.\n\n```scss\n//List\n@each $animal in puma, sea-slug, egret, salamander {\n\n  .#{$animal}-icon {\n    background-image: url('/image/#{$animal}.png');\n  }\n}\n\n// Map\n// $header; h1, $size: 2em\n// $header; h2, $size: 1.5em\n// $header; h3, $size: 1.2em\n@each $header, $size in (h1: 2em, h2: 1.5em, h3: 1.2em) {\n  #{$header} {\n    font-size: $size;\n  }\n}\n```\n\n컴파일 결과는 아래와 같다.\n\n```css\n.puma-icon {\n  background-image: url(\"/image/puma.png\");\n}\n\n.sea-slug-icon {\n  background-image: url(\"/images/sea-slug.png\");\n}\n\n.salamander-icon {\n  background-image: url(\"/image/salamander.png\");\n}\n\nh1 {\n  font-size: 2em;\n}\n\nh2 {\n  font-size: 1.5em;\n}\n\nh3 {\n  font-size: 1.2em;\n}\n```\n\n<br>\n\n### 5) @while\n\n@while로 반복문을 사용할 수 있다.\n\n```scss\n$i: 6;\n@while $i > 0 {\n  .item-#{$i} { width: 2em * $i; }\n  $i: $i - 2;\n}\n\n컴파일 결과는 아래와 같다.\n\n```css\n\n.item-6{\n  width: 12em;\n}\n\n.item-4 {\n  width: 8em;\n}\n\n.item-2 {\n  width: 4em;\n}\n```\n\n<br>\n\n## 4. Mixin\n\nMixin은 Sass의 매우 유용한 기능으로 중복 기술을 방직하기 위해 사용 빈도가 높은 마크업을 사전에 정의하여 필요할 때 불러 사용하는 방법이다.\n\n@extend와 유사하나 프로그래밍 언어의 함수와 같이 argument를 받을 수 있다. 사용법은 매우 간단하다. `@mixin` 선언하고 `@include`로 불러들인다.\n\n```scss\n//지름이 50px인 원\n@mixin circle {\n  width: 50px;\n  height: 50px;\n  border-radius: 50%;\n}\n\n//지름이 50px인 원을 위한 mixin을 include한 후, 배경을 추가 지정\n.box {\n  @include circle;\n\n  background: #f00;\n}\n```\n\n컴파일 결과는 아래와 같다. 배경이 red이고 지름이 50px인 원을 표시한다.\n\n```css\n.box {\n  width: 50px;\n  height: 50px;\n  border-radius: 50%;\n  background: #f00;\n}\n```\n\n@extend와 차이가 없어 보이나 Mixin은 함수처럼 argument를 사용할 수 있다.\n\n```scss\n@mixin circle($size) {\n  width: $size;\n  height: $size;\n  border-radius: 50%;\n}\n\n.box {\n  @include circle(100px);\n\n  background: #f00;\n}\n```\n\n컴파일 결과는 아래와 같다.\n\n```css\n.box{\n  width: 100px;\n  height: 100px;\n  border-radius: 50%;\n  background: #f00;\n}\n```\n\n","slug":"SCSS/02.extensions","published":1,"updated":"2017-09-21T06:22:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjai8h184000mvb9qz7u1q1it","content":"<p><img src=\"http://www.unixstickers.com/image/data/stickers/sass/sass.sh.png\" alt=\"\"></p><h1 id=\"Extensions\"><a href=\"#Extensions\" class=\"headerlink\" title=\"Extensions\"></a>Extensions</h1><h2 id=\"1-Nesting\"><a href=\"#1-Nesting\" class=\"headerlink\" title=\"1. Nesting\"></a>1. Nesting</h2><p>Sass의 유용한 확장 기능으로 중첩(Nesting)이 있다. CSS는 후손 셀렉터의 경우 부모요소를 기술하여야 한다.</p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#navbar</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">80%</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">23px</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-id\">#navbar</span> <span class=\"selector-tag\">ul</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">list-style-type</span>: none;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-id\">#navbar</span> <span class=\"selector-tag\">li</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">float</span>: left;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-id\">#navbar</span> <span class=\"selector-tag\">li</span> <span class=\"selector-tag\">a</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">font-weight</span>: bold;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>Sass의 Nesting은 후손 셀렉터를 간단히 기술이 가능하다. <strong><em>또한 HTML의 구조를 반영한 CSS를 기술할 수 있다.</em></strong></p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#navbar</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">80%</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">23px</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"selector-tag\">ul</span> &#123; <span class=\"attribute\">list-style-type</span>: none; &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"selector-tag\">li</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">float</span>: left;</div><div class=\"line\">    <span class=\"selector-tag\">a</span> &#123; <span class=\"attribute\">font-weight</span>: bold; &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>너무 깊은 Nesting은 가독성을 나쁘게 하고 셀렉터를 복잡하게 만든다. 따라서 Nesting은 3단계 이상 들어가지 않도록 한다. 만약 3단계 이상 들어가야 할 경우에는, 네스팅 하지 않고 차라리 클래스로 꺼내두는게 낫다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Bad case</span></div><div class=\"line\"><span class=\"selector-tag\">div</span><span class=\"selector-id\">#main</span> &#123;</div><div class=\"line\">  <span class=\"selector-id\">#sidebar</span> &#123;</div><div class=\"line\">    <span class=\"selector-id\">#navbar</span> &#123;</div><div class=\"line\">      <span class=\"attribute\">width</span>: <span class=\"number\">80%</span>;</div><div class=\"line\">      <span class=\"attribute\">height</span>: <span class=\"number\">23px</span>;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"selector-tag\">aside</span> &#123;</div><div class=\"line\">        <span class=\"selector-tag\">div</span> &#123;</div><div class=\"line\">          <span class=\"selector-tag\">ul</span> &#123;</div><div class=\"line\">            <span class=\"attribute\">list-style-type</span>: none;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"selector-tag\">li</span> &#123;</div><div class=\"line\">              <span class=\"attribute\">float</span>: left;</div><div class=\"line\"></div><div class=\"line\">              <span class=\"selector-tag\">a</span> &#123;</div><div class=\"line\">                <span class=\"attribute\">font-weight</span>: bold;</div><div class=\"line\">              &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>부모요소의 참조가 필요한 경우 <code>&amp;</code>를 사용한다. 예를 들어 <code>:hover</code> 또는 <code>:before</code> 등의 가상 클래스 선택자(Pseudo-Class Selector)를 지정하는 경우 부모요소의 참조가 필요하다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-class\">.myAnchor</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: blue;</div><div class=\"line\">  &amp;:hover &#123;</div><div class=\"line\">    <span class=\"attribute\">text-decoration</span>: underline;</div><div class=\"line\">  &#125;</div><div class=\"line\">  &amp;:visited &#123;</div><div class=\"line\">    <span class=\"attribute\">color</span>: purple;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>Nesting은 프로퍼티에도 사용할 수 있다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.funky</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">font</span>: &#123;</div><div class=\"line\">    family: fantasy;</div><div class=\"line\">    size: <span class=\"number\">30em</span>;</div><div class=\"line\">    weight: bold;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>위 코드의 컴파일 결과는 아래와 같다.</p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.funky</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">font-family</span>: fantasy;</div><div class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">30em</span>;</div><div class=\"line\">  <span class=\"attribute\">font-weight</span>: bold;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p><br></p><h2 id=\"2-Rules-and-Directives\"><a href=\"#2-Rules-and-Directives\" class=\"headerlink\" title=\"2. @-Rules and Directives\"></a>2. @-Rules and Directives</h2><h3 id=\"1-import\"><a href=\"#1-import\" class=\"headerlink\" title=\"1) @import\"></a>1) @import</h3><p>1개의 CSS파일에 모든 스타일을 기술하는 것은 가독성을 나쁘게 한다. 또한 기능에따라 CSS파일을 분리하면 재사용 및 유지보수 측면에서 유리하다. 따라서 룰을 정하여 파일을 분리하여 개발하는 것은 효과적인 방법이다.</p><p>Sass는 @import directive를 사용하여 분리된 stylesheet 파일을 import할 수 있다. 기존의 CSS @import보다 편리한 기능을 제공한다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">@<span class=\"keyword\">import</span> <span class=\"string\">\"foo.scss\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//확장자는 생략 가능하다.</span></div><div class=\"line\">@<span class=\"keyword\">import</span> <span class=\"string\">\"foo\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//import multiple files</span></div><div class=\"line\">@<span class=\"keyword\">import</span> <span class=\"string\">\"rounded-corners\"</span>, <span class=\"string\">\"text-shadow\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"variable\">$family</span>: unquote(<span class=\"string\">\"Droid+Sans\"</span>);</div><div class=\"line\">@<span class=\"keyword\">import</span> url(<span class=\"string\">\"https://fonts.googleapis.com/css?family=#&#123;$family&#125;\"</span>)</div></pre></td></tr></table></figure><p>여러개의 파일로 분할하는 것 또는 분할된 파일을 <strong>partial</strong>이라 하며 partial된 Sass 파일명의 선두에는 underscore(_)를 붙인다. (_reset.scss, _module.scss, _print.scss)</p><p>예를 들어 “<em>foo.scss”라는 partial된 Sass 파일이 있고 이 파일을 import 하는 경우 아래와 같이 기술한다. 파일명 선두의 </em>와 확장자는 생략할 수 있다.</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">@import &quot;foo&quot;;</div></pre></td></tr></table></figure><p>partial된 Sass 파일명 선두에 붙인 _의 의미는 import는 수행하되 CSS로의 컴파일은 수행하지 말라는 의미를 갖는다. 따라서 partial은 import시에는 CSS파일로 컴파일되지 않기 때문에 최종적으로 CSS로 컴파일을 수행할 Sass 파일에서 import한다.</p><p><img src=\"http://poiemaweb.com/img/partial.png\" alt=\"partial\"></p><p>@import는 top-level에서 사용하는 것이 일반적이지만 CSS rule 또는 @media rule 내에 포함시키는 것도 가능하다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//_example.scss</span></div><div class=\"line\"><span class=\"selector-class\">.example</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: red;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#main</span> &#123;</div><div class=\"line\">  @<span class=\"keyword\">import</span> <span class=\"string\">\"example\"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>위 코드는 컴파일 결과는 아래와 같다.</p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#main</span> <span class=\"selector-class\">.example</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: red;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p><br></p><h3 id=\"2-extend\"><a href=\"#2-extend\" class=\"headerlink\" title=\"2) @extend\"></a>2) @extend</h3><p>기존 스타일을 상속하고자 경우 @extend를 사용한다.</p><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"error seriousError\"</span>&gt;</span></div><div class=\"line\">  Oh no! You've been hacked!</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure><p>기존에 선언되어 있는 error class를 사용하면서 일부 rule set에 대해서는 다른 선언이 필요한 경우 자주 사용하는 방법이다.</p><p>이러한 경우 사용할 수 있는 방법이 상속이다. 상속되는 rule set을 그대로 상속받아 다른 부분만 별도 선언하면 된다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.error</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> <span class=\"number\">#f00</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.seriousError</span> &#123;</div><div class=\"line\">  @<span class=\"keyword\">extend</span> .error;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"attribute\">border-width</span>: <span class=\"number\">3px</span>;</div><div class=\"line\">  <span class=\"attribute\">border-color</span>: darkblue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>위 코드의 컴파일 결과는 아래와 같다. <code>.error</code>과 <code>.seriousError</code>가 공통으로 사용하는 프로퍼티를 묶어 <em>나름 합리적인</em> 룰셋을 생성한다.</p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.error</span>, <span class=\"selector-class\">.serousError</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> <span class=\"number\">#f00</span>;</div><div class=\"line\">  <span class=\"attribute\">background-color</span>: blue;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.seriousError</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">border-width</span>: <span class=\"number\">3px</span>;</div><div class=\"line\">  <span class=\"attribute\">border-color</span>: darkblue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>이제 하나의 클래스만 적용시키면 된다.</p><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">calss</span>=<span class=\"string\">\"seriousError\"</span>&gt;</span></div><div class=\"line\">  Oh no! You've been hacked!</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure><p>@extend를 @media블록과 같이 사용하는 경우, 제대로 작동하지 않는다. 다시말해 @media 안에서 외부 선택자를 @extend할 수 없다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.foo</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: red;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@<span class=\"keyword\">media</span> print &#123;</div><div class=\"line\">  <span class=\"selector-class\">.bar</span> &#123;</div><div class=\"line\">    <span class=\"comment\">//ERROR</span></div><div class=\"line\">    @<span class=\"keyword\">extend</span> .foo;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><blockquote><p>컴파일 후 자신의 셀렉터가 어디에 첨부될 것인지 <strong>예상하기 어렵고, 예상치 못했던 부작용이 발생할 수 있다.</strong> 따라서 @Extend의 사용은 <strong>가급적 자제</strong>하고 Mixin을 사용하는 것을 추천한다.</p></blockquote><p><a href=\"https://sass-guidelin.es/ko/#extend\" target=\"_blank\" rel=\"external\">@extend의 부작용</a></p><p><br></p><h3 id=\"3-Placeholder-Selectors\"><a href=\"#3-Placeholder-Selectors\" class=\"headerlink\" title=\"3) Placeholder Selectors\"></a>3) Placeholder Selectors</h3><p>Placeholder Selector는 Sass3.2부터 제공되는 기능으로 재이용 가능한 Rule set을 %키워드로 지정하는 <strong>@extend 전용 Selector</strong>이다. (그러니, extend를 사용하지 않는다면 별로 기억하지 않아도 된다.)</p><p>Placeholder Selector는 상속만을 위한 rule set으로 자신은 컴파일되지 않는다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">%<span class=\"selector-tag\">input</span>-<span class=\"selector-tag\">style</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">14px</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.input-black</span> &#123;</div><div class=\"line\">  @<span class=\"keyword\">extend</span> %input-style;</div><div class=\"line\"></div><div class=\"line\">  colr: black;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.input-red</span> &#123;</div><div class=\"line\">  @<span class=\"keyword\">extend</span> %input-style;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"attribute\">color</span>: red;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>컴파일 결과는 아래와 같다.</p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.input-black</span>, <span class=\"selector-class\">.input-red</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">14px</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.input-black</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: black;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.input-red</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: red;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p><br></p><h2 id=\"3-조건과-반복\"><a href=\"#3-조건과-반복\" class=\"headerlink\" title=\"3. 조건과 반복\"></a>3. 조건과 반복</h2><p>Sass는 Javascript 같은 프로그래밍 언어와 같이 제어문(Control flow statement)을 사용할 수 있는 기능을 제공한다.</p><p><br></p><h3 id=\"1-if\"><a href=\"#1-if\" class=\"headerlink\" title=\"1) if()\"></a>1) if()</h3><p>built-in if()함수는 주어진 조건읊 판단하여 결과를 리턴한다. Javascript의 삼항 연산자와 유사하게 동작한다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">if(condition, if_true, if_false)</div></pre></td></tr></table></figure><p>condition이 true이면 if_true를, false이면 if_false를 반환한다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$type</span>: ocean;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">p</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: if(<span class=\"variable\">$type</span> == ocean, blue, black); <span class=\"comment\">// color: blue;</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p><br></p><h3 id=\"2-if\"><a href=\"#2-if\" class=\"headerlink\" title=\"2) @if\"></a>2) @if</h3><p>@if를 사용하면 조건분기가 가능하다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$type</span>: monster;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">p</span> &#123;</div><div class=\"line\">  @<span class=\"keyword\">if</span> <span class=\"variable\">$type</span> == ocean &#123;</div><div class=\"line\">    <span class=\"attribute\">color</span>: blue;</div><div class=\"line\">  &#125; @<span class=\"keyword\">else</span> if <span class=\"variable\">$type</span> == matador &#123;</div><div class=\"line\">    <span class=\"attribute\">color</span>: red;</div><div class=\"line\">  &#125; @<span class=\"keyword\">else</span> if <span class=\"variable\">$type</span> == monster &#123;</div><div class=\"line\">    <span class=\"attribute\">color</span>: green;</div><div class=\"line\">  &#125; @<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">color</span>: black;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>컴파일 결과는 아래와 같다.</p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">p</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: green;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p><br></p><h3 id=\"3-for\"><a href=\"#3-for\" class=\"headerlink\" title=\"3) @for\"></a>3) @for</h3><p>@for으로 반복문을 사용할 수 있다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">@<span class=\"keyword\">for</span> <span class=\"variable\">$i</span> from 1 though 3 &#123;</div><div class=\"line\">  <span class=\"selector-class\">.item-</span>#&#123;$1&#125; &#123; <span class=\"attribute\">width</span>: <span class=\"number\">2em</span> * <span class=\"variable\">$i</span>; &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>컴파일 결과는 아래와 같다.</p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.item-1</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">2em</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.item-2</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">4em</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.item-3</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">6em</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p><br></p><h3 id=\"4-each\"><a href=\"#4-each\" class=\"headerlink\" title=\"4) @each\"></a>4) @each</h3><p>@each와 list 또는 map의 요소에 대해 반복을 실시한다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//List</span></div><div class=\"line\">@<span class=\"keyword\">each</span> <span class=\"variable\">$animal</span> in puma, sea-slug, egret, salamander &#123;</div><div class=\"line\"></div><div class=\"line\">  .#&#123;<span class=\"variable\">$animal</span>&#125;-<span class=\"attribute\">icon</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">background-image</span>: url(<span class=\"string\">'/image/#&#123;$animal&#125;.png'</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Map</span></div><div class=\"line\"><span class=\"comment\">// $header; h1, $size: 2em</span></div><div class=\"line\"><span class=\"comment\">// $header; h2, $size: 1.5em</span></div><div class=\"line\"><span class=\"comment\">// $header; h3, $size: 1.2em</span></div><div class=\"line\">@<span class=\"keyword\">each</span> <span class=\"variable\">$header</span>, <span class=\"variable\">$size</span> in (h1: 2em, h2: 1.5em, h3: 1.2em) &#123;</div><div class=\"line\">  #&#123;<span class=\"variable\">$header</span>&#125; &#123;</div><div class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"variable\">$size</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>컴파일 결과는 아래와 같다.</p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.puma-icon</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(<span class=\"string\">\"/image/puma.png\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.sea-slug-icon</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(<span class=\"string\">\"/images/sea-slug.png\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.salamander-icon</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(<span class=\"string\">\"/image/salamander.png\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">h1</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">2em</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">h2</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5em</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">h3</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.2em</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p><br></p><h3 id=\"5-while\"><a href=\"#5-while\" class=\"headerlink\" title=\"5) @while\"></a>5) @while</h3><p>@while로 반복문을 사용할 수 있다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$i</span>: <span class=\"number\">6</span>;</div><div class=\"line\">@<span class=\"keyword\">while</span> <span class=\"variable\">$i</span> &gt; 0 &#123;</div><div class=\"line\">  <span class=\"selector-class\">.item-</span>#&#123;<span class=\"variable\">$i</span>&#125; &#123; <span class=\"attribute\">width</span>: <span class=\"number\">2em</span> * <span class=\"variable\">$i</span>; &#125;</div><div class=\"line\">  <span class=\"variable\">$i</span>: <span class=\"variable\">$i</span> - <span class=\"number\">2</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">컴파일 결과는 아래와 같다.</div><div class=\"line\"></div><div class=\"line\">```css</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.item-6</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">12em</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.item-4</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">8em</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.item-2</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">4em</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p><br></p><h2 id=\"4-Mixin\"><a href=\"#4-Mixin\" class=\"headerlink\" title=\"4. Mixin\"></a>4. Mixin</h2><p>Mixin은 Sass의 매우 유용한 기능으로 중복 기술을 방직하기 위해 사용 빈도가 높은 마크업을 사전에 정의하여 필요할 때 불러 사용하는 방법이다.</p><p>@extend와 유사하나 프로그래밍 언어의 함수와 같이 argument를 받을 수 있다. 사용법은 매우 간단하다. <code>@mixin</code> 선언하고 <code>@include</code>로 불러들인다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//지름이 50px인 원</span></div><div class=\"line\">@<span class=\"keyword\">mixin</span> circle &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">50px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">50px</span>;</div><div class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">50%</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//지름이 50px인 원을 위한 mixin을 include한 후, 배경을 추가 지정</span></div><div class=\"line\"><span class=\"selector-class\">.box</span> &#123;</div><div class=\"line\">  @<span class=\"keyword\">include</span> circle;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#f00</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>컴파일 결과는 아래와 같다. 배경이 red이고 지름이 50px인 원을 표시한다.</p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.box</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">50px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">50px</span>;</div><div class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">50%</span>;</div><div class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#f00</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>@extend와 차이가 없어 보이나 Mixin은 함수처럼 argument를 사용할 수 있다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">@<span class=\"keyword\">mixin</span> circle(<span class=\"variable\">$size</span>) &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"variable\">$size</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"variable\">$size</span>;</div><div class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">50%</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.box</span> &#123;</div><div class=\"line\">  @<span class=\"keyword\">include</span> circle(<span class=\"number\">100px</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#f00</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>컴파일 결과는 아래와 같다.</p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.box</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">50%</span>;</div><div class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#f00</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://www.unixstickers.com/image/data/stickers/sass/sass.sh.png\" alt=\"\"></p><h1 id=\"Extensions\"><a href=\"#Extensions\" class=\"headerlink\" title=\"Extensions\"></a>Extensions</h1><h2 id=\"1-Nesting\"><a href=\"#1-Nesting\" class=\"headerlink\" title=\"1. Nesting\"></a>1. Nesting</h2><p>Sass의 유용한 확장 기능으로 중첩(Nesting)이 있다. CSS는 후손 셀렉터의 경우 부모요소를 기술하여야 한다.</p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#navbar</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">80%</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">23px</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-id\">#navbar</span> <span class=\"selector-tag\">ul</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">list-style-type</span>: none;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-id\">#navbar</span> <span class=\"selector-tag\">li</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">float</span>: left;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-id\">#navbar</span> <span class=\"selector-tag\">li</span> <span class=\"selector-tag\">a</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">font-weight</span>: bold;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>Sass의 Nesting은 후손 셀렉터를 간단히 기술이 가능하다. <strong><em>또한 HTML의 구조를 반영한 CSS를 기술할 수 있다.</em></strong></p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#navbar</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">80%</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">23px</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"selector-tag\">ul</span> &#123; <span class=\"attribute\">list-style-type</span>: none; &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"selector-tag\">li</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">float</span>: left;</div><div class=\"line\">    <span class=\"selector-tag\">a</span> &#123; <span class=\"attribute\">font-weight</span>: bold; &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>너무 깊은 Nesting은 가독성을 나쁘게 하고 셀렉터를 복잡하게 만든다. 따라서 Nesting은 3단계 이상 들어가지 않도록 한다. 만약 3단계 이상 들어가야 할 경우에는, 네스팅 하지 않고 차라리 클래스로 꺼내두는게 낫다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Bad case</span></div><div class=\"line\"><span class=\"selector-tag\">div</span><span class=\"selector-id\">#main</span> &#123;</div><div class=\"line\">  <span class=\"selector-id\">#sidebar</span> &#123;</div><div class=\"line\">    <span class=\"selector-id\">#navbar</span> &#123;</div><div class=\"line\">      <span class=\"attribute\">width</span>: <span class=\"number\">80%</span>;</div><div class=\"line\">      <span class=\"attribute\">height</span>: <span class=\"number\">23px</span>;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"selector-tag\">aside</span> &#123;</div><div class=\"line\">        <span class=\"selector-tag\">div</span> &#123;</div><div class=\"line\">          <span class=\"selector-tag\">ul</span> &#123;</div><div class=\"line\">            <span class=\"attribute\">list-style-type</span>: none;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"selector-tag\">li</span> &#123;</div><div class=\"line\">              <span class=\"attribute\">float</span>: left;</div><div class=\"line\"></div><div class=\"line\">              <span class=\"selector-tag\">a</span> &#123;</div><div class=\"line\">                <span class=\"attribute\">font-weight</span>: bold;</div><div class=\"line\">              &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>부모요소의 참조가 필요한 경우 <code>&amp;</code>를 사용한다. 예를 들어 <code>:hover</code> 또는 <code>:before</code> 등의 가상 클래스 선택자(Pseudo-Class Selector)를 지정하는 경우 부모요소의 참조가 필요하다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-class\">.myAnchor</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: blue;</div><div class=\"line\">  &amp;:hover &#123;</div><div class=\"line\">    <span class=\"attribute\">text-decoration</span>: underline;</div><div class=\"line\">  &#125;</div><div class=\"line\">  &amp;:visited &#123;</div><div class=\"line\">    <span class=\"attribute\">color</span>: purple;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>Nesting은 프로퍼티에도 사용할 수 있다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.funky</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">font</span>: &#123;</div><div class=\"line\">    family: fantasy;</div><div class=\"line\">    size: <span class=\"number\">30em</span>;</div><div class=\"line\">    weight: bold;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>위 코드의 컴파일 결과는 아래와 같다.</p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.funky</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">font-family</span>: fantasy;</div><div class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">30em</span>;</div><div class=\"line\">  <span class=\"attribute\">font-weight</span>: bold;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p><br></p><h2 id=\"2-Rules-and-Directives\"><a href=\"#2-Rules-and-Directives\" class=\"headerlink\" title=\"2. @-Rules and Directives\"></a>2. @-Rules and Directives</h2><h3 id=\"1-import\"><a href=\"#1-import\" class=\"headerlink\" title=\"1) @import\"></a>1) @import</h3><p>1개의 CSS파일에 모든 스타일을 기술하는 것은 가독성을 나쁘게 한다. 또한 기능에따라 CSS파일을 분리하면 재사용 및 유지보수 측면에서 유리하다. 따라서 룰을 정하여 파일을 분리하여 개발하는 것은 효과적인 방법이다.</p><p>Sass는 @import directive를 사용하여 분리된 stylesheet 파일을 import할 수 있다. 기존의 CSS @import보다 편리한 기능을 제공한다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">@<span class=\"keyword\">import</span> <span class=\"string\">\"foo.scss\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//확장자는 생략 가능하다.</span></div><div class=\"line\">@<span class=\"keyword\">import</span> <span class=\"string\">\"foo\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//import multiple files</span></div><div class=\"line\">@<span class=\"keyword\">import</span> <span class=\"string\">\"rounded-corners\"</span>, <span class=\"string\">\"text-shadow\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"variable\">$family</span>: unquote(<span class=\"string\">\"Droid+Sans\"</span>);</div><div class=\"line\">@<span class=\"keyword\">import</span> url(<span class=\"string\">\"https://fonts.googleapis.com/css?family=#&#123;$family&#125;\"</span>)</div></pre></td></tr></table></figure><p>여러개의 파일로 분할하는 것 또는 분할된 파일을 <strong>partial</strong>이라 하며 partial된 Sass 파일명의 선두에는 underscore(_)를 붙인다. (_reset.scss, _module.scss, _print.scss)</p><p>예를 들어 “<em>foo.scss”라는 partial된 Sass 파일이 있고 이 파일을 import 하는 경우 아래와 같이 기술한다. 파일명 선두의 </em>와 확장자는 생략할 수 있다.</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">@import &quot;foo&quot;;</div></pre></td></tr></table></figure><p>partial된 Sass 파일명 선두에 붙인 _의 의미는 import는 수행하되 CSS로의 컴파일은 수행하지 말라는 의미를 갖는다. 따라서 partial은 import시에는 CSS파일로 컴파일되지 않기 때문에 최종적으로 CSS로 컴파일을 수행할 Sass 파일에서 import한다.</p><p><img src=\"http://poiemaweb.com/img/partial.png\" alt=\"partial\"></p><p>@import는 top-level에서 사용하는 것이 일반적이지만 CSS rule 또는 @media rule 내에 포함시키는 것도 가능하다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//_example.scss</span></div><div class=\"line\"><span class=\"selector-class\">.example</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: red;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#main</span> &#123;</div><div class=\"line\">  @<span class=\"keyword\">import</span> <span class=\"string\">\"example\"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>위 코드는 컴파일 결과는 아래와 같다.</p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#main</span> <span class=\"selector-class\">.example</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: red;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p><br></p><h3 id=\"2-extend\"><a href=\"#2-extend\" class=\"headerlink\" title=\"2) @extend\"></a>2) @extend</h3><p>기존 스타일을 상속하고자 경우 @extend를 사용한다.</p><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"error seriousError\"</span>&gt;</span></div><div class=\"line\">  Oh no! You've been hacked!</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure><p>기존에 선언되어 있는 error class를 사용하면서 일부 rule set에 대해서는 다른 선언이 필요한 경우 자주 사용하는 방법이다.</p><p>이러한 경우 사용할 수 있는 방법이 상속이다. 상속되는 rule set을 그대로 상속받아 다른 부분만 별도 선언하면 된다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.error</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> <span class=\"number\">#f00</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.seriousError</span> &#123;</div><div class=\"line\">  @<span class=\"keyword\">extend</span> .error;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"attribute\">border-width</span>: <span class=\"number\">3px</span>;</div><div class=\"line\">  <span class=\"attribute\">border-color</span>: darkblue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>위 코드의 컴파일 결과는 아래와 같다. <code>.error</code>과 <code>.seriousError</code>가 공통으로 사용하는 프로퍼티를 묶어 <em>나름 합리적인</em> 룰셋을 생성한다.</p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.error</span>, <span class=\"selector-class\">.serousError</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> <span class=\"number\">#f00</span>;</div><div class=\"line\">  <span class=\"attribute\">background-color</span>: blue;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.seriousError</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">border-width</span>: <span class=\"number\">3px</span>;</div><div class=\"line\">  <span class=\"attribute\">border-color</span>: darkblue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>이제 하나의 클래스만 적용시키면 된다.</p><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">calss</span>=<span class=\"string\">\"seriousError\"</span>&gt;</span></div><div class=\"line\">  Oh no! You've been hacked!</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure><p>@extend를 @media블록과 같이 사용하는 경우, 제대로 작동하지 않는다. 다시말해 @media 안에서 외부 선택자를 @extend할 수 없다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.foo</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: red;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@<span class=\"keyword\">media</span> print &#123;</div><div class=\"line\">  <span class=\"selector-class\">.bar</span> &#123;</div><div class=\"line\">    <span class=\"comment\">//ERROR</span></div><div class=\"line\">    @<span class=\"keyword\">extend</span> .foo;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><blockquote><p>컴파일 후 자신의 셀렉터가 어디에 첨부될 것인지 <strong>예상하기 어렵고, 예상치 못했던 부작용이 발생할 수 있다.</strong> 따라서 @Extend의 사용은 <strong>가급적 자제</strong>하고 Mixin을 사용하는 것을 추천한다.</p></blockquote><p><a href=\"https://sass-guidelin.es/ko/#extend\" target=\"_blank\" rel=\"external\">@extend의 부작용</a></p><p><br></p><h3 id=\"3-Placeholder-Selectors\"><a href=\"#3-Placeholder-Selectors\" class=\"headerlink\" title=\"3) Placeholder Selectors\"></a>3) Placeholder Selectors</h3><p>Placeholder Selector는 Sass3.2부터 제공되는 기능으로 재이용 가능한 Rule set을 %키워드로 지정하는 <strong>@extend 전용 Selector</strong>이다. (그러니, extend를 사용하지 않는다면 별로 기억하지 않아도 된다.)</p><p>Placeholder Selector는 상속만을 위한 rule set으로 자신은 컴파일되지 않는다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">%<span class=\"selector-tag\">input</span>-<span class=\"selector-tag\">style</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">14px</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.input-black</span> &#123;</div><div class=\"line\">  @<span class=\"keyword\">extend</span> %input-style;</div><div class=\"line\"></div><div class=\"line\">  colr: black;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.input-red</span> &#123;</div><div class=\"line\">  @<span class=\"keyword\">extend</span> %input-style;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"attribute\">color</span>: red;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>컴파일 결과는 아래와 같다.</p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.input-black</span>, <span class=\"selector-class\">.input-red</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">14px</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.input-black</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: black;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.input-red</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: red;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p><br></p><h2 id=\"3-조건과-반복\"><a href=\"#3-조건과-반복\" class=\"headerlink\" title=\"3. 조건과 반복\"></a>3. 조건과 반복</h2><p>Sass는 Javascript 같은 프로그래밍 언어와 같이 제어문(Control flow statement)을 사용할 수 있는 기능을 제공한다.</p><p><br></p><h3 id=\"1-if\"><a href=\"#1-if\" class=\"headerlink\" title=\"1) if()\"></a>1) if()</h3><p>built-in if()함수는 주어진 조건읊 판단하여 결과를 리턴한다. Javascript의 삼항 연산자와 유사하게 동작한다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">if(condition, if_true, if_false)</div></pre></td></tr></table></figure><p>condition이 true이면 if_true를, false이면 if_false를 반환한다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$type</span>: ocean;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">p</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: if(<span class=\"variable\">$type</span> == ocean, blue, black); <span class=\"comment\">// color: blue;</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p><br></p><h3 id=\"2-if\"><a href=\"#2-if\" class=\"headerlink\" title=\"2) @if\"></a>2) @if</h3><p>@if를 사용하면 조건분기가 가능하다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$type</span>: monster;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">p</span> &#123;</div><div class=\"line\">  @<span class=\"keyword\">if</span> <span class=\"variable\">$type</span> == ocean &#123;</div><div class=\"line\">    <span class=\"attribute\">color</span>: blue;</div><div class=\"line\">  &#125; @<span class=\"keyword\">else</span> if <span class=\"variable\">$type</span> == matador &#123;</div><div class=\"line\">    <span class=\"attribute\">color</span>: red;</div><div class=\"line\">  &#125; @<span class=\"keyword\">else</span> if <span class=\"variable\">$type</span> == monster &#123;</div><div class=\"line\">    <span class=\"attribute\">color</span>: green;</div><div class=\"line\">  &#125; @<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">color</span>: black;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>컴파일 결과는 아래와 같다.</p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">p</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: green;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p><br></p><h3 id=\"3-for\"><a href=\"#3-for\" class=\"headerlink\" title=\"3) @for\"></a>3) @for</h3><p>@for으로 반복문을 사용할 수 있다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">@<span class=\"keyword\">for</span> <span class=\"variable\">$i</span> from 1 though 3 &#123;</div><div class=\"line\">  <span class=\"selector-class\">.item-</span>#&#123;$1&#125; &#123; <span class=\"attribute\">width</span>: <span class=\"number\">2em</span> * <span class=\"variable\">$i</span>; &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>컴파일 결과는 아래와 같다.</p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.item-1</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">2em</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.item-2</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">4em</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.item-3</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">6em</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p><br></p><h3 id=\"4-each\"><a href=\"#4-each\" class=\"headerlink\" title=\"4) @each\"></a>4) @each</h3><p>@each와 list 또는 map의 요소에 대해 반복을 실시한다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//List</span></div><div class=\"line\">@<span class=\"keyword\">each</span> <span class=\"variable\">$animal</span> in puma, sea-slug, egret, salamander &#123;</div><div class=\"line\"></div><div class=\"line\">  .#&#123;<span class=\"variable\">$animal</span>&#125;-<span class=\"attribute\">icon</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">background-image</span>: url(<span class=\"string\">'/image/#&#123;$animal&#125;.png'</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Map</span></div><div class=\"line\"><span class=\"comment\">// $header; h1, $size: 2em</span></div><div class=\"line\"><span class=\"comment\">// $header; h2, $size: 1.5em</span></div><div class=\"line\"><span class=\"comment\">// $header; h3, $size: 1.2em</span></div><div class=\"line\">@<span class=\"keyword\">each</span> <span class=\"variable\">$header</span>, <span class=\"variable\">$size</span> in (h1: 2em, h2: 1.5em, h3: 1.2em) &#123;</div><div class=\"line\">  #&#123;<span class=\"variable\">$header</span>&#125; &#123;</div><div class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"variable\">$size</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>컴파일 결과는 아래와 같다.</p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.puma-icon</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(<span class=\"string\">\"/image/puma.png\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.sea-slug-icon</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(<span class=\"string\">\"/images/sea-slug.png\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.salamander-icon</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(<span class=\"string\">\"/image/salamander.png\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">h1</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">2em</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">h2</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5em</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">h3</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.2em</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p><br></p><h3 id=\"5-while\"><a href=\"#5-while\" class=\"headerlink\" title=\"5) @while\"></a>5) @while</h3><p>@while로 반복문을 사용할 수 있다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$i</span>: <span class=\"number\">6</span>;</div><div class=\"line\">@<span class=\"keyword\">while</span> <span class=\"variable\">$i</span> &gt; 0 &#123;</div><div class=\"line\">  <span class=\"selector-class\">.item-</span>#&#123;<span class=\"variable\">$i</span>&#125; &#123; <span class=\"attribute\">width</span>: <span class=\"number\">2em</span> * <span class=\"variable\">$i</span>; &#125;</div><div class=\"line\">  <span class=\"variable\">$i</span>: <span class=\"variable\">$i</span> - <span class=\"number\">2</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">컴파일 결과는 아래와 같다.</div><div class=\"line\"></div><div class=\"line\">```css</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.item-6</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">12em</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.item-4</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">8em</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.item-2</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">4em</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p><br></p><h2 id=\"4-Mixin\"><a href=\"#4-Mixin\" class=\"headerlink\" title=\"4. Mixin\"></a>4. Mixin</h2><p>Mixin은 Sass의 매우 유용한 기능으로 중복 기술을 방직하기 위해 사용 빈도가 높은 마크업을 사전에 정의하여 필요할 때 불러 사용하는 방법이다.</p><p>@extend와 유사하나 프로그래밍 언어의 함수와 같이 argument를 받을 수 있다. 사용법은 매우 간단하다. <code>@mixin</code> 선언하고 <code>@include</code>로 불러들인다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//지름이 50px인 원</span></div><div class=\"line\">@<span class=\"keyword\">mixin</span> circle &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">50px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">50px</span>;</div><div class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">50%</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//지름이 50px인 원을 위한 mixin을 include한 후, 배경을 추가 지정</span></div><div class=\"line\"><span class=\"selector-class\">.box</span> &#123;</div><div class=\"line\">  @<span class=\"keyword\">include</span> circle;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#f00</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>컴파일 결과는 아래와 같다. 배경이 red이고 지름이 50px인 원을 표시한다.</p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.box</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">50px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">50px</span>;</div><div class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">50%</span>;</div><div class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#f00</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>@extend와 차이가 없어 보이나 Mixin은 함수처럼 argument를 사용할 수 있다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">@<span class=\"keyword\">mixin</span> circle(<span class=\"variable\">$size</span>) &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"variable\">$size</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"variable\">$size</span>;</div><div class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">50%</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.box</span> &#123;</div><div class=\"line\">  @<span class=\"keyword\">include</span> circle(<span class=\"number\">100px</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#f00</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>컴파일 결과는 아래와 같다.</p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.box</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">50%</span>;</div><div class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#f00</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"[SASS] Sass Script","date":"2017-08-06T07:56:57.000Z","_content":"\n![](http://www.unixstickers.com/image/data/stickers/sass/sass.sh.png)\n\n# Sass Script\n\n## 1. Data Type\n프로퍼티값으로 사용할 수 있는 값에는 각각의 자료형(Data Type)이 존재한다. SassScript가 제공하는 자료형은 7가지가 있다.\n\n* **숫자형**  \n  e.g) 1.2, 13, 10px\n\n* **문자열**  \n  CSS는 2종류의 문자열을 사용할 수 있다. 따옴표를 사용하는 경우(“Lucida Grande”, ‘http://sass-lang.com’)와 사용하지 않는 경우(bold, sans-serif)가 있다. Sass는 2종류의 문자열 모두를 인식할 수 있으며 컴파일 후의 CSS에는 Sass에서 사용한 문자열이 그대로 출력된다.  \n  e.g. “Lucida Grande”, ‘http://sass-lang.com’, sans-serif\n\n* **컬러**  \n  e.g. blue, #04a3f9, rgba(255, 0, 0, 0.5)\n\n* **boolean**  \n  e.g. true, false  \n\n* **null**\n\n* **list**  \n  margin과 padding 프로퍼티값 지정에 사용되는 0 auto와 font-family 프로퍼티값 지정에 사용되는 Helvetica, Arial, sans-serif 등은 공백 또는 콤마 구분된 값의 list이다.  \n  e.g. 1.5em 1em 0 2em, Helvetica, Arial, sans-serif\n\n* **map**  \n  JSON과 유사한 방식으로 map-get 함수를 사용하여 원하는 값은 추출할 수 있다.  \n  e.g. (key1: value1, key2: value2)\n\n```scss\n// map\n$foundation-palette: (\n  primary: #E44347,\n  mars: #D7525C,\n  saturn: #E4B884,\n  neptune: #5147D7\n);\n\n.mars {\n  color: map-get($foundation-palette, mars); \n}\n\n// => .mars { color: #D7525C; }\n```\n\n## 2. 변수\n\nSass에서는 변수를 사용할 수 있다. 문자열, 숫자, 컬러(`#aa443f`) 등을 사전에 변수에 저장하고 필요할 때 불러 사용할 수 있다.\n\n변수명은 `$`로 시작한다.\n\n\n```scss\n$width: 960px;\n\nheader {\n  width: $width;\n  margin: 0 auto;\n}\n\n#main {\n  width: $width;\n  margin: 20px auto;\n}\n\nfooter {\n  width: $width;\n  margin: 0 auto;\n}\n```\n\n어떤 것을 변수명으로 설정할지에 대한 설계가 필요하다. 변수명은 대체로 파일의 앞 쪽에 몰아서 선언해둔다.\n\n## 3. 변수의 스코프\n\n```scss\n$width: 960px; // global variable\n\nheader {\n  width: $width;\n  margin: 0 auto;\n}\n\n#main {\n  $color: #333; // local variable\n  width: $width;\n  margin: 20px auto;\n  section {\n    p {\n      color: $color;\n\n      a:link {\n        color: $color;\n      }\n    }\n  }\n}\n\nfooter {\n  width: $width;\n  margin: 0 auto;\n  color: $color;\n}\n```\n위 코드를 컴파일하면 `Undefined variable: “$color”`라는 에러가 발생한다. 이는 `#main`에서 선언한 `$color`는 `#main` 내에서만 유효한 지역변수이기 때문이다.\n\n코드블럭 내에서 선언한 지역변수를 전역변수화하는 방법은 아래와 같다.\n\n```scss\n#main {\n  $color: #333 !global; // global variable\n  width: $width;\n  ...\n```\n\n## 4. 연산자(Operation)\n\n### 1) 숫자 연산자\n\n|Operator|Description|\n|--------|-----------|\n|+|덧셈|\n|-|뺄셈\n|*|곱셈|\n|/|나눗셈|\n|%|나머지|\n|==|동등|\n|!=|부등|\n\n```scss\n$width: 100px;\n\n#foo {\n  width: $width + 10; //110px\n}\n\n#bar {\n  width: $width + 10in; //1060px\n}\n```\n\n변수 $width의 값 100px에 10 또는 10em과 같이 다른 단위의 값을 연산하여도 에러없이 연산이 수행된다. 이때 연산자의 왼쪽 값을 기준으로 단위가 설정된다.\n\n$width에 10em을 더하면 어떻게 될까?\n\n```scss\n$width: 100px;\n\n#foo {\n  width: $width + 10em; //NG: 100px + 10em\n}\n```\n\n컴파일 결과 Incompatible units: 'em' and 'px'.이라는 에러를 출력한다. Scss 연산은 대상을 변환하여 연산할 수 없는 경우, 에러를 출력한다.\n\n%,em,rem,vh,vw,vmin,vmax와 같이 상대적인 값을 Sass는 알지 못한다. 상대적인 값의 결과값은 브라우저만이 알 수 있기 때문이다. (sass는 단지 css로 변환하기만 할 뿐, em 등등의 값은 알 수 없다.) 따라서 **상대적 값을 갖는 단위의 연산은 동일한 단위를 갖는 값과의 연산만이 유효하다.**\n\n> %는 부모를 기준으로, rem은 html을 기준으로 (기본적으로 16px), vw는 뷰포트를 기준으로, 1vw = viewport를 기준으로 1/100. \n\nCSS3의 calc함수(IE9 이상에서만 사용할 수 있다.)는 이런 문제를 해결할 수 있다. (calc는 브라우저에서 수행하기 때문에 상대값과 절댓값 사이 계산이 가능한 것이다.)\n\n```scss\n#foo {\n  width: calc(25% - 5px);\n}\n```\n\nCSS에서의 `/`는 나눗셈이 아니라 값을 분리하는 의미를 갖는다. 따라서 Sass의 `/` 연산자를 사용하기 위해서는 몇가지 조건이 필요하다. 이외의 조건에서는 나눗셈을 하지 않는다.\n\n* 변수에 대해 사용\n* 괄호 내에서 사용\n* 다른 연산의 일부로서 사용\n\n\n```scss\np {\n  // font와 border-radius의 '/'는 CSS문법에 맞는 표현이므로 연산되지 않는다.\n  font: italic bold 12px/30px Georgia, serif;\n  // 타원형 둥근 모서리\n  border-radius: 10px 20px / 20px;\n\n  $width: 1000px;\n  width: $width / 2;            // 변수에 대해 사용 →　width: 500px;\n  height: (500px / 2);          // 괄호 내에서 사용 →　height: 250px;\n  margin-left: 5px + 8px / 2px; // 다른 연산의 일부로서 사용 →　margin-left: 9px;\n}\n```\n\n변수를 CSS의 /와 함께 사용하고자 하는 경우 `#{}`(Interpolation)를 사용한다.\n`#{}`를 사용하면 변수를 문자열로 인식하게 한다. 따라서 연산을 하지 않는다.\n\n```scss\np{\n  $font-size: 12px;\n  $line-height: 30px;\n  font: #{$font-size} / #{$line-height}; // 12px/30px\n}\n```\n\n`#{}`를 좌항에만 사용해주어도 같은 효과가 난다. (좌항을 기준으로 하며, 둘 다 변수일 때만 연산을 하기 때문이다.)\n하지만 양 쪽 모두 `#{}`를 사용해주는 것이 더 좋다.\n\n### 2) 컬러 연산자\n\n컬러 값에도 모든 산술 연산자를 적용할 수 있다. 컬러 값은 R은 R끼리, G는 G끼리, B는 B끼리 연산한다.\n(#RRBBGG 표기법의 숫자는 16진수로 표기한다. 16진수에서는 10부터 A로 시작하는 알파벳이다. 05 + 05 = A)\n\n```scss\np {\n  color: #010203 + #040506;\n  // R: 01 + 04 = 05\n  // G: 02 + 05 = 07\n  // B: 03 + 06 = 09\n  // => #050709\n}\n\np {\n  color: #010203 * 2;\n  // R: 01 * 2 = 02\n  // G: 02 * 2 = 04\n  // B: x03 * 2 = 06\n  // => #020406\n}\n\np {\n  color: rgba(255, 0, 0, 0.75) + rgba(0, 255, 0, 0.75);\n  /* alpha 값은 연산되지 않는다\n  / color: rgba(255, 255, 0, 0.75);\n  / alpha 값이 서로 다르면, e.g. rgba(0, 0, 0, 0.7) + rgba(100, 120, 255, 0.5);\n  이 경우 error가 발생한다.\n  */\n}\n```\n\nalpha값은 연산되지 않는다. 서로 다른 alpha값을 연산하려 하는 경우 error가 발생한다. 서로 같은 alpha값을 연산하려 하는 경우, error는 발생하지 않지만 연산을 하지 않고 값을 그대로 반환한다. 위 예제에서도 연산 결과로 0.75를 그대로 반환하였다.  \n\nalpha 값을 연산하려면 [opacify 함수 또는 transparentize 함수](http://poiemaweb.com/sass-built-in-function#65-alpha-연산)를 사용해야 한다.\n\n* opacify(불투명화) 함수: `+` 연산, 첫번째 argument의 alpha값에 두번째 argument를 더해 **불투명도를 증가**시킨다.\n* transparentize(투명화) 함수: `-` 연산, 첫번째 argument의 alpha값에 두번째 argument의 alpha값을 빼서 **불투명도를 감소**시킨다.\n\n```scss\n$translucent-red: rgba(255, 0, 0, 0.5);\np {\n  color: opacify($translucent-red, 0.3);\n  // => color: rgba(255, 0, 0, 0.8)\n  background-color: transparentize($translucent-red, 0.25);\n  // =>  color: rgba(255, 0, 0, 0.25);\n}\n```\n\n### 3) 문자열 연산자\n\n`+` 연산자는 자바스크립트와 같이 문자열을 연결할 수 있다.\n\n```scss\np {\n  cursor: e + -resize; // e-resize\n}\n```\n\n따옴표가 있는 문자열과 없는 문자열을 함께 사용하는 경우, 좌향의 문자열을 기준으로 따옴표를 처리한다. 하이픈(`-`) 기호가 사용될 경우, 하이픈 기호를 포함해서 붙인다.\n\n```scss\np:before {\n  content: \"Foo \" + Bar; //Foo Bar\n  font-family: sans- + \"serif\"; //sans-serif;\n}\n\n.btn {\n  cursor: p + inter;\n  font-family: sans- + 'serif';\n  &:after {\n    content: \"Hello \" + world;\n  }\n  $value: 100;\n  &:before {\n    content: \"I'm #{$value} years old!\";\n  }\n}\n```\n\n```css\n/* compiled */\n\np:before{\n  content: \"Foo Bar\";\n  font-family: sans-serif;\n}\n\n.btn {\n  cursor: pinter;\n  font-family: sans-serif;\n}\n.btn:after { content: \"Hello world\"; }\n.btn:before { content: \"I'm 100 years old!\"; }\n```\n\n### 4) boolean 연산자\n\n* **&&** (and)\n* **||** (or)\n* **!** (not)\n\n### 5) list 연산자\n\n리스트를 위한 별도의 연산자는 제공되지 않지만, [리스트 함수](http://poiemaweb.com/sass-built-in-function#4-list-functions)를 사용하여 필요한 처리를 수행할 수 있다.\n\n## 5. 함수(Function)\n\n[Built-in Function](http://poiemaweb.com/sass-built-in-function)\n\n## 6. Interpolation: `#{}`\n\n인터폴레이션은 변수의 값을 문자열 그대로 삽입한다. 인터폴레이션에 의해 삽입된 문자열은 연산 대상으로 취급되지 않는다. 변수는 프로퍼티값으로만 사용할 수 있으나 `#{}`을 사용하면 **셀렉터와 프로퍼티명에도** 사용할 수 있다.\n\n```scss\n$name: foo;\n$attr: border;\n\np.#{$name} { //p.foo\n  #{$attr}-color: blue; //border-color: blue;\n}\n\n\n.someclass {\n  $font-size: 12px;\n  $line-height: 30px;\n  //연산의 대상으로 취급되지 않게 한다.\n  font: #{$font-size} / #{$line-height};\n  // 12px / 30px\n}\n\n```\n\n## 7. Ampersand(&)\n\n`&`는 부모요소를 참조하는 셀렉터이다.\n`&`는 Sass와 Less에서 아주 유용한 기능으로  주로 중첩(nesting)시에 사용된다. 사용법만 알면, css로 동일한 코드를 작성할 때보다 훨씬 많은 시간을 절약할 수 있다.\n\n![Ampersand in SASS](https://cdn.css-tricks.com/wp-content/uploads/2016/01/scss-to-css.gif)\n\n---\n\n### **Nesting**\n\n```scss\n//scss\n.parent {\n  .child {}\n}\n```\n\n```css\n/* compiles to css */\n.parent .child {}\n```\n\n원하는 만큼 깊게 중첩시킬 수 있지만 지나치게 특수한 셀렉터(덜 유용하고 재정의하기 어려운)가 되는 것을 막기 위해 1 ~ 2단계의 중첩만 유지하는 게 좋다.\n\n### **Adding another class**\n\n`&`는 이러한 중첩(네스팅, nesting)에 편리하다. 다음과 같이 둘 이상의 클래스를 사용해서 특수한(구체적인) 선택자(selector)를 만들고자 할 때 특히 그렇다.\n\n```css\n/* css */\n.some-class.anoter-class {}\n```\n\n위와 같은 css코드는 sass로는 아래처럼 작성할 수 있다.\n\n```scss\n//scss\n.some-class {\n  &.anoter-class{}\n}\n```\n\n`&`는 네스팅시 항상 상위 선택자를 탐조한다. `&`를 제거하고 부모 선택자로 대체한 것으로 생각할 수 있다.  \n\n위에서 예시로 들었던 코드를 다시 살펴보면,\n\n```scss\n//scss\n.parent {\n  .child {}\n}\n```\n\n이 코드는 사실 `&`로 네스팅하는 것의 short-hand이다.\n\n```scss\n//scss\n.parent {\n  & .child{\n\n  }\n}\n```\n\n따라서 이 두 예시는 모두 아래처럼 동일하게 컴파일된다.\n\n```css\n/* compiles to css */\n.parent .child {}\n```\n\n`&`는 자식 선택자에 필요할 때마다 부모 선택자를 배치할 수 있게 하는 매커니즘 정도로 생각할 수 있다. 그러면 `&`를 어떻게 더 다양하게 활용할 수 있을지 예제를 통해 알아보자.\n\n### **Using the `&` with pseudo classes**\n\n`&`를 이용하면 가상클래스(pseudo class)를 작성할 때 코드의 반복을 현저하게 줄일 수 있다.\n\n```scss\n.button {\n  &:visited {}\n  &:hover {}\n  &:active{}\n}\n```\n\n```css\n/*compiles to css*/\n.button:visited {}\n.buttom:hover {}\n.button:active {}\n```\n\n이 경우 `&`를 사용함으로써 `.button`을 반복적으로 작성하지 않고도 가상클래스 바로 옆에 `.button`를 배치할 수 있다. 만약 이때 `&`를 생략하면, 기본 중첩(nesting)은 다음과 같이 둘 사이에 공백을 넣는다.\n\n```scss\n//scss\n.button {\n  :visited {}\n  :hover {}\n  :active {}\n}\n```\n\n```css\n/*css*/\n.button :hover\n```\n\n주의하자. 공백이 있는 것과 없는 것은 절대 같지 않다.\n\n### *Using the `&` with `>`, `+`, and `~`*\n`&`를 부모-자식 관계를 나타내는 combinator인 `>`, 인접 형제 관계임을 나타내는 combinator인 `+`, 그리고 일반적인 형제 관계임을 나타내는 combinator인 `~`와 함께 사용하면 아주 용이하다.  \n\n코드를 작성할 때, `&`를 함께 작성해야한다 생각하겠지만, 사실 그렇지 않다.\n\n```scss\n.button {\n  & > span {}\n  & + span {}\n  & ~ span {}\n}\n```\n\n선택자에서 `&`를 떼어내서 아래처럼 작성할 수도 있는데, 두 코드는 동일하게 컴파일 된다.\n\n```scss\n// 이렇게 작성해도 똑같다.\n.button {\n  > span {}\n  + span {}\n  ~ span {} \n}\n```\n\n```css\n/*compiles to css*/\n.button > span {}\n.button + span {}\n.button ~ span{}\n```\n\n### **Qualifying based on context**\n\n네스팅된 셀렉터에 `&`가 반드시 앞에 붙을 필요는 없다. 끝에 `&`를 붙이면 선택자를 한정할 수 있다.\n\n```scss\n//scss\n.button {\n  body.page-about & {}\n}\n```\n\n`&` 자리는 본래 부모 선택자의 자리이다. 만약 필요한 부모 선택자가 있다면 그 자리에 부모 선택자를 기재한다. `&`는 마지막에 붙인다. 이 방식은 다른 부모를 기반으로 셀렉터를 한정하는데 아주 유용하다. 이 코드는 아래와 같이 컴파일 된다.\n\n```css\nbody.page-about .button{}\n```\n\n해석해보자면, `page-about`이 **`body`클래스의 자식클래스로 있을 때에만** (다르게 말하면, 다른 클래스의 자식클래스로 있을 때는 적용하지 않는다.) `button` 클래스에 {내용}의 css를 정의한다\n\n\n[그 외 더 많은 예시](https://css-tricks.com/the-sass-ampersand/#article-header-id-9)\n\n---\n\n## 8. `!default`\n\n`!default` flag는 할당되지 않은 변수의 초기값을 설정한다.\n\n```scss\n$content: null; //값이 할당되지 않았다.\n$content: \"Non-null content\" !default;\n\n#main {\n  content: $content; //\"Non-null content\"\n}\n\n```\n\n이미 값이 할당되어 있는 변수에 `!default` flag를 사용하면 적용되지 않는다.\n\n```scss\n$content: \"First content\";\n$content: \"Second content?\" !default;\n$new_content: \"First time reference\" !default;\n\n#main {\n  content: $content; //\"First content\"\n  new_content: $new_content; //\"First time reference\"\n}\n```\n\n이러한 특성은 [partial](http://sass-lang.com/documentation/file.SASS_REFERENCE.html#Partials__partials)에 매우 유용하다.\n2개의 font.scss와 main.scss파일을 생성해보자.  \n\n```scss\n//font.scss\n$font-size: 16px !default;\n$line-height: 1.5 !default;\n$font-family: \"Helvetica Neue\", \"Helverica\", \"Arial\", sans-serif !default;\n\nbody {\n  font: #{$font-size}/$line-height $font-family;\n}\n```\n\nmain.scss는 내부에서 font.scss를 import한다.\n\n```scss\n//main.scss\n$font-family: \"Lucida Grande\", \"Lucida Sans Unicode\", sans-serif;\n\n@import \"font\";\n```\n\n위 코드의 컴파일 결과는 아래와 같다. \n\n```css\nbody {\n  font: 16px/1.5 \"Lucida Grande\", \"Lucida Sans Unicode\", sans-serif;\n}\n```\n\n`!default`는 **변수에 값이 할당되지 않았을 때** 사용할 기본 값을 지정할 때 사용한다. 위 예제의 경우 `main.scss`에서 **변수에 값을 할당하였기 때문에** `!default`와 같이 사용한 변수값은 무력화된다.  \n\n만일 `font.scss`의 `$font-family` 변수에 `!default`설정이 없었다면 후위에 선언된 `font.scss`의 `$font-family` 변수값이 적용되어 아래와 같은 결과가 생성되었을 것이다.\n\n```css\nbody {\n  font: 16px/1.5 \"Helvetica Neue\", \"Helvetica\", \"Arial\", sans-serif;\n}\n```\n","source":"_posts/SCSS/03.sassScript.md","raw":"---\ntitle: '[SASS] Sass Script'\ndate: 2017-08-06 16:56:57\ncategory: Sass\ntags: sass syntax\n---\n\n![](http://www.unixstickers.com/image/data/stickers/sass/sass.sh.png)\n\n# Sass Script\n\n## 1. Data Type\n프로퍼티값으로 사용할 수 있는 값에는 각각의 자료형(Data Type)이 존재한다. SassScript가 제공하는 자료형은 7가지가 있다.\n\n* **숫자형**  \n  e.g) 1.2, 13, 10px\n\n* **문자열**  \n  CSS는 2종류의 문자열을 사용할 수 있다. 따옴표를 사용하는 경우(“Lucida Grande”, ‘http://sass-lang.com’)와 사용하지 않는 경우(bold, sans-serif)가 있다. Sass는 2종류의 문자열 모두를 인식할 수 있으며 컴파일 후의 CSS에는 Sass에서 사용한 문자열이 그대로 출력된다.  \n  e.g. “Lucida Grande”, ‘http://sass-lang.com’, sans-serif\n\n* **컬러**  \n  e.g. blue, #04a3f9, rgba(255, 0, 0, 0.5)\n\n* **boolean**  \n  e.g. true, false  \n\n* **null**\n\n* **list**  \n  margin과 padding 프로퍼티값 지정에 사용되는 0 auto와 font-family 프로퍼티값 지정에 사용되는 Helvetica, Arial, sans-serif 등은 공백 또는 콤마 구분된 값의 list이다.  \n  e.g. 1.5em 1em 0 2em, Helvetica, Arial, sans-serif\n\n* **map**  \n  JSON과 유사한 방식으로 map-get 함수를 사용하여 원하는 값은 추출할 수 있다.  \n  e.g. (key1: value1, key2: value2)\n\n```scss\n// map\n$foundation-palette: (\n  primary: #E44347,\n  mars: #D7525C,\n  saturn: #E4B884,\n  neptune: #5147D7\n);\n\n.mars {\n  color: map-get($foundation-palette, mars); \n}\n\n// => .mars { color: #D7525C; }\n```\n\n## 2. 변수\n\nSass에서는 변수를 사용할 수 있다. 문자열, 숫자, 컬러(`#aa443f`) 등을 사전에 변수에 저장하고 필요할 때 불러 사용할 수 있다.\n\n변수명은 `$`로 시작한다.\n\n\n```scss\n$width: 960px;\n\nheader {\n  width: $width;\n  margin: 0 auto;\n}\n\n#main {\n  width: $width;\n  margin: 20px auto;\n}\n\nfooter {\n  width: $width;\n  margin: 0 auto;\n}\n```\n\n어떤 것을 변수명으로 설정할지에 대한 설계가 필요하다. 변수명은 대체로 파일의 앞 쪽에 몰아서 선언해둔다.\n\n## 3. 변수의 스코프\n\n```scss\n$width: 960px; // global variable\n\nheader {\n  width: $width;\n  margin: 0 auto;\n}\n\n#main {\n  $color: #333; // local variable\n  width: $width;\n  margin: 20px auto;\n  section {\n    p {\n      color: $color;\n\n      a:link {\n        color: $color;\n      }\n    }\n  }\n}\n\nfooter {\n  width: $width;\n  margin: 0 auto;\n  color: $color;\n}\n```\n위 코드를 컴파일하면 `Undefined variable: “$color”`라는 에러가 발생한다. 이는 `#main`에서 선언한 `$color`는 `#main` 내에서만 유효한 지역변수이기 때문이다.\n\n코드블럭 내에서 선언한 지역변수를 전역변수화하는 방법은 아래와 같다.\n\n```scss\n#main {\n  $color: #333 !global; // global variable\n  width: $width;\n  ...\n```\n\n## 4. 연산자(Operation)\n\n### 1) 숫자 연산자\n\n|Operator|Description|\n|--------|-----------|\n|+|덧셈|\n|-|뺄셈\n|*|곱셈|\n|/|나눗셈|\n|%|나머지|\n|==|동등|\n|!=|부등|\n\n```scss\n$width: 100px;\n\n#foo {\n  width: $width + 10; //110px\n}\n\n#bar {\n  width: $width + 10in; //1060px\n}\n```\n\n변수 $width의 값 100px에 10 또는 10em과 같이 다른 단위의 값을 연산하여도 에러없이 연산이 수행된다. 이때 연산자의 왼쪽 값을 기준으로 단위가 설정된다.\n\n$width에 10em을 더하면 어떻게 될까?\n\n```scss\n$width: 100px;\n\n#foo {\n  width: $width + 10em; //NG: 100px + 10em\n}\n```\n\n컴파일 결과 Incompatible units: 'em' and 'px'.이라는 에러를 출력한다. Scss 연산은 대상을 변환하여 연산할 수 없는 경우, 에러를 출력한다.\n\n%,em,rem,vh,vw,vmin,vmax와 같이 상대적인 값을 Sass는 알지 못한다. 상대적인 값의 결과값은 브라우저만이 알 수 있기 때문이다. (sass는 단지 css로 변환하기만 할 뿐, em 등등의 값은 알 수 없다.) 따라서 **상대적 값을 갖는 단위의 연산은 동일한 단위를 갖는 값과의 연산만이 유효하다.**\n\n> %는 부모를 기준으로, rem은 html을 기준으로 (기본적으로 16px), vw는 뷰포트를 기준으로, 1vw = viewport를 기준으로 1/100. \n\nCSS3의 calc함수(IE9 이상에서만 사용할 수 있다.)는 이런 문제를 해결할 수 있다. (calc는 브라우저에서 수행하기 때문에 상대값과 절댓값 사이 계산이 가능한 것이다.)\n\n```scss\n#foo {\n  width: calc(25% - 5px);\n}\n```\n\nCSS에서의 `/`는 나눗셈이 아니라 값을 분리하는 의미를 갖는다. 따라서 Sass의 `/` 연산자를 사용하기 위해서는 몇가지 조건이 필요하다. 이외의 조건에서는 나눗셈을 하지 않는다.\n\n* 변수에 대해 사용\n* 괄호 내에서 사용\n* 다른 연산의 일부로서 사용\n\n\n```scss\np {\n  // font와 border-radius의 '/'는 CSS문법에 맞는 표현이므로 연산되지 않는다.\n  font: italic bold 12px/30px Georgia, serif;\n  // 타원형 둥근 모서리\n  border-radius: 10px 20px / 20px;\n\n  $width: 1000px;\n  width: $width / 2;            // 변수에 대해 사용 →　width: 500px;\n  height: (500px / 2);          // 괄호 내에서 사용 →　height: 250px;\n  margin-left: 5px + 8px / 2px; // 다른 연산의 일부로서 사용 →　margin-left: 9px;\n}\n```\n\n변수를 CSS의 /와 함께 사용하고자 하는 경우 `#{}`(Interpolation)를 사용한다.\n`#{}`를 사용하면 변수를 문자열로 인식하게 한다. 따라서 연산을 하지 않는다.\n\n```scss\np{\n  $font-size: 12px;\n  $line-height: 30px;\n  font: #{$font-size} / #{$line-height}; // 12px/30px\n}\n```\n\n`#{}`를 좌항에만 사용해주어도 같은 효과가 난다. (좌항을 기준으로 하며, 둘 다 변수일 때만 연산을 하기 때문이다.)\n하지만 양 쪽 모두 `#{}`를 사용해주는 것이 더 좋다.\n\n### 2) 컬러 연산자\n\n컬러 값에도 모든 산술 연산자를 적용할 수 있다. 컬러 값은 R은 R끼리, G는 G끼리, B는 B끼리 연산한다.\n(#RRBBGG 표기법의 숫자는 16진수로 표기한다. 16진수에서는 10부터 A로 시작하는 알파벳이다. 05 + 05 = A)\n\n```scss\np {\n  color: #010203 + #040506;\n  // R: 01 + 04 = 05\n  // G: 02 + 05 = 07\n  // B: 03 + 06 = 09\n  // => #050709\n}\n\np {\n  color: #010203 * 2;\n  // R: 01 * 2 = 02\n  // G: 02 * 2 = 04\n  // B: x03 * 2 = 06\n  // => #020406\n}\n\np {\n  color: rgba(255, 0, 0, 0.75) + rgba(0, 255, 0, 0.75);\n  /* alpha 값은 연산되지 않는다\n  / color: rgba(255, 255, 0, 0.75);\n  / alpha 값이 서로 다르면, e.g. rgba(0, 0, 0, 0.7) + rgba(100, 120, 255, 0.5);\n  이 경우 error가 발생한다.\n  */\n}\n```\n\nalpha값은 연산되지 않는다. 서로 다른 alpha값을 연산하려 하는 경우 error가 발생한다. 서로 같은 alpha값을 연산하려 하는 경우, error는 발생하지 않지만 연산을 하지 않고 값을 그대로 반환한다. 위 예제에서도 연산 결과로 0.75를 그대로 반환하였다.  \n\nalpha 값을 연산하려면 [opacify 함수 또는 transparentize 함수](http://poiemaweb.com/sass-built-in-function#65-alpha-연산)를 사용해야 한다.\n\n* opacify(불투명화) 함수: `+` 연산, 첫번째 argument의 alpha값에 두번째 argument를 더해 **불투명도를 증가**시킨다.\n* transparentize(투명화) 함수: `-` 연산, 첫번째 argument의 alpha값에 두번째 argument의 alpha값을 빼서 **불투명도를 감소**시킨다.\n\n```scss\n$translucent-red: rgba(255, 0, 0, 0.5);\np {\n  color: opacify($translucent-red, 0.3);\n  // => color: rgba(255, 0, 0, 0.8)\n  background-color: transparentize($translucent-red, 0.25);\n  // =>  color: rgba(255, 0, 0, 0.25);\n}\n```\n\n### 3) 문자열 연산자\n\n`+` 연산자는 자바스크립트와 같이 문자열을 연결할 수 있다.\n\n```scss\np {\n  cursor: e + -resize; // e-resize\n}\n```\n\n따옴표가 있는 문자열과 없는 문자열을 함께 사용하는 경우, 좌향의 문자열을 기준으로 따옴표를 처리한다. 하이픈(`-`) 기호가 사용될 경우, 하이픈 기호를 포함해서 붙인다.\n\n```scss\np:before {\n  content: \"Foo \" + Bar; //Foo Bar\n  font-family: sans- + \"serif\"; //sans-serif;\n}\n\n.btn {\n  cursor: p + inter;\n  font-family: sans- + 'serif';\n  &:after {\n    content: \"Hello \" + world;\n  }\n  $value: 100;\n  &:before {\n    content: \"I'm #{$value} years old!\";\n  }\n}\n```\n\n```css\n/* compiled */\n\np:before{\n  content: \"Foo Bar\";\n  font-family: sans-serif;\n}\n\n.btn {\n  cursor: pinter;\n  font-family: sans-serif;\n}\n.btn:after { content: \"Hello world\"; }\n.btn:before { content: \"I'm 100 years old!\"; }\n```\n\n### 4) boolean 연산자\n\n* **&&** (and)\n* **||** (or)\n* **!** (not)\n\n### 5) list 연산자\n\n리스트를 위한 별도의 연산자는 제공되지 않지만, [리스트 함수](http://poiemaweb.com/sass-built-in-function#4-list-functions)를 사용하여 필요한 처리를 수행할 수 있다.\n\n## 5. 함수(Function)\n\n[Built-in Function](http://poiemaweb.com/sass-built-in-function)\n\n## 6. Interpolation: `#{}`\n\n인터폴레이션은 변수의 값을 문자열 그대로 삽입한다. 인터폴레이션에 의해 삽입된 문자열은 연산 대상으로 취급되지 않는다. 변수는 프로퍼티값으로만 사용할 수 있으나 `#{}`을 사용하면 **셀렉터와 프로퍼티명에도** 사용할 수 있다.\n\n```scss\n$name: foo;\n$attr: border;\n\np.#{$name} { //p.foo\n  #{$attr}-color: blue; //border-color: blue;\n}\n\n\n.someclass {\n  $font-size: 12px;\n  $line-height: 30px;\n  //연산의 대상으로 취급되지 않게 한다.\n  font: #{$font-size} / #{$line-height};\n  // 12px / 30px\n}\n\n```\n\n## 7. Ampersand(&)\n\n`&`는 부모요소를 참조하는 셀렉터이다.\n`&`는 Sass와 Less에서 아주 유용한 기능으로  주로 중첩(nesting)시에 사용된다. 사용법만 알면, css로 동일한 코드를 작성할 때보다 훨씬 많은 시간을 절약할 수 있다.\n\n![Ampersand in SASS](https://cdn.css-tricks.com/wp-content/uploads/2016/01/scss-to-css.gif)\n\n---\n\n### **Nesting**\n\n```scss\n//scss\n.parent {\n  .child {}\n}\n```\n\n```css\n/* compiles to css */\n.parent .child {}\n```\n\n원하는 만큼 깊게 중첩시킬 수 있지만 지나치게 특수한 셀렉터(덜 유용하고 재정의하기 어려운)가 되는 것을 막기 위해 1 ~ 2단계의 중첩만 유지하는 게 좋다.\n\n### **Adding another class**\n\n`&`는 이러한 중첩(네스팅, nesting)에 편리하다. 다음과 같이 둘 이상의 클래스를 사용해서 특수한(구체적인) 선택자(selector)를 만들고자 할 때 특히 그렇다.\n\n```css\n/* css */\n.some-class.anoter-class {}\n```\n\n위와 같은 css코드는 sass로는 아래처럼 작성할 수 있다.\n\n```scss\n//scss\n.some-class {\n  &.anoter-class{}\n}\n```\n\n`&`는 네스팅시 항상 상위 선택자를 탐조한다. `&`를 제거하고 부모 선택자로 대체한 것으로 생각할 수 있다.  \n\n위에서 예시로 들었던 코드를 다시 살펴보면,\n\n```scss\n//scss\n.parent {\n  .child {}\n}\n```\n\n이 코드는 사실 `&`로 네스팅하는 것의 short-hand이다.\n\n```scss\n//scss\n.parent {\n  & .child{\n\n  }\n}\n```\n\n따라서 이 두 예시는 모두 아래처럼 동일하게 컴파일된다.\n\n```css\n/* compiles to css */\n.parent .child {}\n```\n\n`&`는 자식 선택자에 필요할 때마다 부모 선택자를 배치할 수 있게 하는 매커니즘 정도로 생각할 수 있다. 그러면 `&`를 어떻게 더 다양하게 활용할 수 있을지 예제를 통해 알아보자.\n\n### **Using the `&` with pseudo classes**\n\n`&`를 이용하면 가상클래스(pseudo class)를 작성할 때 코드의 반복을 현저하게 줄일 수 있다.\n\n```scss\n.button {\n  &:visited {}\n  &:hover {}\n  &:active{}\n}\n```\n\n```css\n/*compiles to css*/\n.button:visited {}\n.buttom:hover {}\n.button:active {}\n```\n\n이 경우 `&`를 사용함으로써 `.button`을 반복적으로 작성하지 않고도 가상클래스 바로 옆에 `.button`를 배치할 수 있다. 만약 이때 `&`를 생략하면, 기본 중첩(nesting)은 다음과 같이 둘 사이에 공백을 넣는다.\n\n```scss\n//scss\n.button {\n  :visited {}\n  :hover {}\n  :active {}\n}\n```\n\n```css\n/*css*/\n.button :hover\n```\n\n주의하자. 공백이 있는 것과 없는 것은 절대 같지 않다.\n\n### *Using the `&` with `>`, `+`, and `~`*\n`&`를 부모-자식 관계를 나타내는 combinator인 `>`, 인접 형제 관계임을 나타내는 combinator인 `+`, 그리고 일반적인 형제 관계임을 나타내는 combinator인 `~`와 함께 사용하면 아주 용이하다.  \n\n코드를 작성할 때, `&`를 함께 작성해야한다 생각하겠지만, 사실 그렇지 않다.\n\n```scss\n.button {\n  & > span {}\n  & + span {}\n  & ~ span {}\n}\n```\n\n선택자에서 `&`를 떼어내서 아래처럼 작성할 수도 있는데, 두 코드는 동일하게 컴파일 된다.\n\n```scss\n// 이렇게 작성해도 똑같다.\n.button {\n  > span {}\n  + span {}\n  ~ span {} \n}\n```\n\n```css\n/*compiles to css*/\n.button > span {}\n.button + span {}\n.button ~ span{}\n```\n\n### **Qualifying based on context**\n\n네스팅된 셀렉터에 `&`가 반드시 앞에 붙을 필요는 없다. 끝에 `&`를 붙이면 선택자를 한정할 수 있다.\n\n```scss\n//scss\n.button {\n  body.page-about & {}\n}\n```\n\n`&` 자리는 본래 부모 선택자의 자리이다. 만약 필요한 부모 선택자가 있다면 그 자리에 부모 선택자를 기재한다. `&`는 마지막에 붙인다. 이 방식은 다른 부모를 기반으로 셀렉터를 한정하는데 아주 유용하다. 이 코드는 아래와 같이 컴파일 된다.\n\n```css\nbody.page-about .button{}\n```\n\n해석해보자면, `page-about`이 **`body`클래스의 자식클래스로 있을 때에만** (다르게 말하면, 다른 클래스의 자식클래스로 있을 때는 적용하지 않는다.) `button` 클래스에 {내용}의 css를 정의한다\n\n\n[그 외 더 많은 예시](https://css-tricks.com/the-sass-ampersand/#article-header-id-9)\n\n---\n\n## 8. `!default`\n\n`!default` flag는 할당되지 않은 변수의 초기값을 설정한다.\n\n```scss\n$content: null; //값이 할당되지 않았다.\n$content: \"Non-null content\" !default;\n\n#main {\n  content: $content; //\"Non-null content\"\n}\n\n```\n\n이미 값이 할당되어 있는 변수에 `!default` flag를 사용하면 적용되지 않는다.\n\n```scss\n$content: \"First content\";\n$content: \"Second content?\" !default;\n$new_content: \"First time reference\" !default;\n\n#main {\n  content: $content; //\"First content\"\n  new_content: $new_content; //\"First time reference\"\n}\n```\n\n이러한 특성은 [partial](http://sass-lang.com/documentation/file.SASS_REFERENCE.html#Partials__partials)에 매우 유용하다.\n2개의 font.scss와 main.scss파일을 생성해보자.  \n\n```scss\n//font.scss\n$font-size: 16px !default;\n$line-height: 1.5 !default;\n$font-family: \"Helvetica Neue\", \"Helverica\", \"Arial\", sans-serif !default;\n\nbody {\n  font: #{$font-size}/$line-height $font-family;\n}\n```\n\nmain.scss는 내부에서 font.scss를 import한다.\n\n```scss\n//main.scss\n$font-family: \"Lucida Grande\", \"Lucida Sans Unicode\", sans-serif;\n\n@import \"font\";\n```\n\n위 코드의 컴파일 결과는 아래와 같다. \n\n```css\nbody {\n  font: 16px/1.5 \"Lucida Grande\", \"Lucida Sans Unicode\", sans-serif;\n}\n```\n\n`!default`는 **변수에 값이 할당되지 않았을 때** 사용할 기본 값을 지정할 때 사용한다. 위 예제의 경우 `main.scss`에서 **변수에 값을 할당하였기 때문에** `!default`와 같이 사용한 변수값은 무력화된다.  \n\n만일 `font.scss`의 `$font-family` 변수에 `!default`설정이 없었다면 후위에 선언된 `font.scss`의 `$font-family` 변수값이 적용되어 아래와 같은 결과가 생성되었을 것이다.\n\n```css\nbody {\n  font: 16px/1.5 \"Helvetica Neue\", \"Helvetica\", \"Arial\", sans-serif;\n}\n```\n","slug":"SCSS/03.sassScript","published":1,"updated":"2017-09-21T06:22:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjai8h185000pvb9qv0v5fvlz","content":"<p><img src=\"http://www.unixstickers.com/image/data/stickers/sass/sass.sh.png\" alt=\"\"></p><h1 id=\"Sass-Script\"><a href=\"#Sass-Script\" class=\"headerlink\" title=\"Sass Script\"></a>Sass Script</h1><h2 id=\"1-Data-Type\"><a href=\"#1-Data-Type\" class=\"headerlink\" title=\"1. Data Type\"></a>1. Data Type</h2><p>프로퍼티값으로 사용할 수 있는 값에는 각각의 자료형(Data Type)이 존재한다. SassScript가 제공하는 자료형은 7가지가 있다.</p><ul><li><p><strong>숫자형</strong><br>e.g) 1.2, 13, 10px</p></li><li><p><strong>문자열</strong><br>CSS는 2종류의 문자열을 사용할 수 있다. 따옴표를 사용하는 경우(“Lucida Grande”, ‘<a href=\"http://sass-lang.com’)와\" target=\"_blank\" rel=\"external\">http://sass-lang.com’)와</a> 사용하지 않는 경우(bold, sans-serif)가 있다. Sass는 2종류의 문자열 모두를 인식할 수 있으며 컴파일 후의 CSS에는 Sass에서 사용한 문자열이 그대로 출력된다.<br>e.g. “Lucida Grande”, ‘<a href=\"http://sass-lang.com’\" target=\"_blank\" rel=\"external\">http://sass-lang.com’</a>, sans-serif</p></li><li><p><strong>컬러</strong><br>e.g. blue, #04a3f9, rgba(255, 0, 0, 0.5)</p></li><li><p><strong>boolean</strong><br>e.g. true, false</p></li><li><p><strong>null</strong></p></li><li><p><strong>list</strong><br>margin과 padding 프로퍼티값 지정에 사용되는 0 auto와 font-family 프로퍼티값 지정에 사용되는 Helvetica, Arial, sans-serif 등은 공백 또는 콤마 구분된 값의 list이다.<br>e.g. 1.5em 1em 0 2em, Helvetica, Arial, sans-serif</p></li><li><p><strong>map</strong><br>JSON과 유사한 방식으로 map-get 함수를 사용하여 원하는 값은 추출할 수 있다.<br>e.g. (key1: value1, key2: value2)</p></li></ul><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// map</span></div><div class=\"line\"><span class=\"variable\">$foundation-palette</span>: (</div><div class=\"line\">  primary: <span class=\"number\">#E44347</span>,</div><div class=\"line\">  mars: <span class=\"number\">#D7525C</span>,</div><div class=\"line\">  saturn: <span class=\"number\">#E4B884</span>,</div><div class=\"line\">  neptune: <span class=\"number\">#5147D7</span></div><div class=\"line\">);</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.mars</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: map-get(<span class=\"variable\">$foundation-palette</span>, mars); </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// =&gt; .mars &#123; color: #D7525C; &#125;</span></div></pre></td></tr></table></figure><h2 id=\"2-변수\"><a href=\"#2-변수\" class=\"headerlink\" title=\"2. 변수\"></a>2. 변수</h2><p>Sass에서는 변수를 사용할 수 있다. 문자열, 숫자, 컬러(<code>#aa443f</code>) 등을 사전에 변수에 저장하고 필요할 때 불러 사용할 수 있다.</p><p>변수명은 <code>$</code>로 시작한다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$width</span>: <span class=\"number\">960px</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">header</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"variable\">$width</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> auto;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-id\">#main</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"variable\">$width</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">20px</span> auto;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">footer</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"variable\">$width</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> auto;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>어떤 것을 변수명으로 설정할지에 대한 설계가 필요하다. 변수명은 대체로 파일의 앞 쪽에 몰아서 선언해둔다.</p><h2 id=\"3-변수의-스코프\"><a href=\"#3-변수의-스코프\" class=\"headerlink\" title=\"3. 변수의 스코프\"></a>3. 변수의 스코프</h2><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$width</span>: <span class=\"number\">960px</span>; <span class=\"comment\">// global variable</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">header</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"variable\">$width</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> auto;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-id\">#main</span> &#123;</div><div class=\"line\">  <span class=\"variable\">$color</span>: <span class=\"number\">#333</span>; <span class=\"comment\">// local variable</span></div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"variable\">$width</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">20px</span> auto;</div><div class=\"line\">  <span class=\"selector-tag\">section</span> &#123;</div><div class=\"line\">    <span class=\"selector-tag\">p</span> &#123;</div><div class=\"line\">      <span class=\"attribute\">color</span>: <span class=\"variable\">$color</span>;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"selector-tag\">a</span>:link &#123;</div><div class=\"line\">        <span class=\"attribute\">color</span>: <span class=\"variable\">$color</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">footer</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"variable\">$width</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> auto;</div><div class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"variable\">$color</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>위 코드를 컴파일하면 <code>Undefined variable: “$color”</code>라는 에러가 발생한다. 이는 <code>#main</code>에서 선언한 <code>$color</code>는 <code>#main</code> 내에서만 유효한 지역변수이기 때문이다.</p><p>코드블럭 내에서 선언한 지역변수를 전역변수화하는 방법은 아래와 같다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#main</span> &#123;</div><div class=\"line\">  <span class=\"variable\">$color</span>: <span class=\"number\">#333</span> !global; <span class=\"comment\">// global variable</span></div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"variable\">$width</span>;</div><div class=\"line\">  ...</div></pre></td></tr></table></figure><h2 id=\"4-연산자-Operation\"><a href=\"#4-연산자-Operation\" class=\"headerlink\" title=\"4. 연산자(Operation)\"></a>4. 연산자(Operation)</h2><h3 id=\"1-숫자-연산자\"><a href=\"#1-숫자-연산자\" class=\"headerlink\" title=\"1) 숫자 연산자\"></a>1) 숫자 연산자</h3><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td>+</td><td>덧셈</td></tr><tr><td>-</td><td>뺄셈</td></tr><tr><td>*</td><td>곱셈</td></tr><tr><td>/</td><td>나눗셈</td></tr><tr><td>%</td><td>나머지</td></tr><tr><td>==</td><td>동등</td></tr><tr><td>!=</td><td>부등</td></tr></tbody></table><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-id\">#foo</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"variable\">$width</span> + <span class=\"number\">10</span>; <span class=\"comment\">//110px</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-id\">#bar</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"variable\">$width</span> + <span class=\"number\">10in</span>; <span class=\"comment\">//1060px</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>변수 $width의 값 100px에 10 또는 10em과 같이 다른 단위의 값을 연산하여도 에러없이 연산이 수행된다. 이때 연산자의 왼쪽 값을 기준으로 단위가 설정된다.</p><p>$width에 10em을 더하면 어떻게 될까?</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-id\">#foo</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"variable\">$width</span> + <span class=\"number\">10em</span>; <span class=\"comment\">//NG: 100px + 10em</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>컴파일 결과 Incompatible units: ‘em’ and ‘px’.이라는 에러를 출력한다. Scss 연산은 대상을 변환하여 연산할 수 없는 경우, 에러를 출력한다.</p><p>%,em,rem,vh,vw,vmin,vmax와 같이 상대적인 값을 Sass는 알지 못한다. 상대적인 값의 결과값은 브라우저만이 알 수 있기 때문이다. (sass는 단지 css로 변환하기만 할 뿐, em 등등의 값은 알 수 없다.) 따라서 <strong>상대적 값을 갖는 단위의 연산은 동일한 단위를 갖는 값과의 연산만이 유효하다.</strong></p><blockquote><p>%는 부모를 기준으로, rem은 html을 기준으로 (기본적으로 16px), vw는 뷰포트를 기준으로, 1vw = viewport를 기준으로 1/100.</p></blockquote><p>CSS3의 calc함수(IE9 이상에서만 사용할 수 있다.)는 이런 문제를 해결할 수 있다. (calc는 브라우저에서 수행하기 때문에 상대값과 절댓값 사이 계산이 가능한 것이다.)</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#foo</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: calc(<span class=\"number\">25%</span> - <span class=\"number\">5px</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>CSS에서의 <code>/</code>는 나눗셈이 아니라 값을 분리하는 의미를 갖는다. 따라서 Sass의 <code>/</code> 연산자를 사용하기 위해서는 몇가지 조건이 필요하다. 이외의 조건에서는 나눗셈을 하지 않는다.</p><ul><li>변수에 대해 사용</li><li>괄호 내에서 사용</li><li>다른 연산의 일부로서 사용</li></ul><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">p</span> &#123;</div><div class=\"line\">  <span class=\"comment\">// font와 border-radius의 '/'는 CSS문법에 맞는 표현이므로 연산되지 않는다.</span></div><div class=\"line\">  <span class=\"attribute\">font</span>: italic bold <span class=\"number\">12px</span>/<span class=\"number\">30px</span> Georgia, serif;</div><div class=\"line\">  <span class=\"comment\">// 타원형 둥근 모서리</span></div><div class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">10px</span> <span class=\"number\">20px</span> / <span class=\"number\">20px</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"variable\">$width</span>: <span class=\"number\">1000px</span>;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"variable\">$width</span> / <span class=\"number\">2</span>;            <span class=\"comment\">// 변수에 대해 사용 →　width: 500px;</span></div><div class=\"line\">  <span class=\"attribute\">height</span>: (<span class=\"number\">500px</span> / <span class=\"number\">2</span>);          <span class=\"comment\">// 괄호 내에서 사용 →　height: 250px;</span></div><div class=\"line\">  <span class=\"attribute\">margin-left</span>: <span class=\"number\">5px</span> + <span class=\"number\">8px</span> / <span class=\"number\">2px</span>; <span class=\"comment\">// 다른 연산의 일부로서 사용 →　margin-left: 9px;</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>변수를 CSS의 /와 함께 사용하고자 하는 경우 <code>#{}</code>(Interpolation)를 사용한다.<br><code>#{}</code>를 사용하면 변수를 문자열로 인식하게 한다. 따라서 연산을 하지 않는다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">p</span>&#123;</div><div class=\"line\">  <span class=\"variable\">$font-size</span>: <span class=\"number\">12px</span>;</div><div class=\"line\">  <span class=\"variable\">$line-height</span>: <span class=\"number\">30px</span>;</div><div class=\"line\">  <span class=\"attribute\">font</span>: #&#123;<span class=\"variable\">$font-size</span>&#125; / #&#123;<span class=\"variable\">$line-height</span>&#125;; <span class=\"comment\">// 12px/30px</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p><code>#{}</code>를 좌항에만 사용해주어도 같은 효과가 난다. (좌항을 기준으로 하며, 둘 다 변수일 때만 연산을 하기 때문이다.)<br>하지만 양 쪽 모두 <code>#{}</code>를 사용해주는 것이 더 좋다.</p><h3 id=\"2-컬러-연산자\"><a href=\"#2-컬러-연산자\" class=\"headerlink\" title=\"2) 컬러 연산자\"></a>2) 컬러 연산자</h3><p>컬러 값에도 모든 산술 연산자를 적용할 수 있다. 컬러 값은 R은 R끼리, G는 G끼리, B는 B끼리 연산한다.<br>(#RRBBGG 표기법의 숫자는 16진수로 표기한다. 16진수에서는 10부터 A로 시작하는 알파벳이다. 05 + 05 = A)</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">p</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#010203</span> + <span class=\"number\">#040506</span>;</div><div class=\"line\">  <span class=\"comment\">// R: 01 + 04 = 05</span></div><div class=\"line\">  <span class=\"comment\">// G: 02 + 05 = 07</span></div><div class=\"line\">  <span class=\"comment\">// B: 03 + 06 = 09</span></div><div class=\"line\">  <span class=\"comment\">// =&gt; #050709</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">p</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#010203</span> * <span class=\"number\">2</span>;</div><div class=\"line\">  <span class=\"comment\">// R: 01 * 2 = 02</span></div><div class=\"line\">  <span class=\"comment\">// G: 02 * 2 = 04</span></div><div class=\"line\">  <span class=\"comment\">// B: x03 * 2 = 06</span></div><div class=\"line\">  <span class=\"comment\">// =&gt; #020406</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">p</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: rgba(<span class=\"number\">255</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0.75</span>) + rgba(<span class=\"number\">0</span>, <span class=\"number\">255</span>, <span class=\"number\">0</span>, <span class=\"number\">0.75</span>);</div><div class=\"line\">  <span class=\"comment\">/* alpha 값은 연산되지 않는다</span></div><div class=\"line\"><span class=\"comment\">  / color: rgba(255, 255, 0, 0.75);</span></div><div class=\"line\"><span class=\"comment\">  / alpha 값이 서로 다르면, e.g. rgba(0, 0, 0, 0.7) + rgba(100, 120, 255, 0.5);</span></div><div class=\"line\"><span class=\"comment\">  이 경우 error가 발생한다.</span></div><div class=\"line\"><span class=\"comment\">  */</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>alpha값은 연산되지 않는다. 서로 다른 alpha값을 연산하려 하는 경우 error가 발생한다. 서로 같은 alpha값을 연산하려 하는 경우, error는 발생하지 않지만 연산을 하지 않고 값을 그대로 반환한다. 위 예제에서도 연산 결과로 0.75를 그대로 반환하였다.</p><p>alpha 값을 연산하려면 <a href=\"http://poiemaweb.com/sass-built-in-function#65-alpha-연산\" target=\"_blank\" rel=\"external\">opacify 함수 또는 transparentize 함수</a>를 사용해야 한다.</p><ul><li>opacify(불투명화) 함수: <code>+</code> 연산, 첫번째 argument의 alpha값에 두번째 argument를 더해 <strong>불투명도를 증가</strong>시킨다.</li><li>transparentize(투명화) 함수: <code>-</code> 연산, 첫번째 argument의 alpha값에 두번째 argument의 alpha값을 빼서 <strong>불투명도를 감소</strong>시킨다.</li></ul><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$translucent-red</span>: rgba(<span class=\"number\">255</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0.5</span>);</div><div class=\"line\"><span class=\"selector-tag\">p</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: opacify(<span class=\"variable\">$translucent-red</span>, <span class=\"number\">0.3</span>);</div><div class=\"line\">  <span class=\"comment\">// =&gt; color: rgba(255, 0, 0, 0.8)</span></div><div class=\"line\">  <span class=\"attribute\">background-color</span>: transparentize(<span class=\"variable\">$translucent-red</span>, <span class=\"number\">0.25</span>);</div><div class=\"line\">  <span class=\"comment\">// =&gt;  color: rgba(255, 0, 0, 0.25);</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><h3 id=\"3-문자열-연산자\"><a href=\"#3-문자열-연산자\" class=\"headerlink\" title=\"3) 문자열 연산자\"></a>3) 문자열 연산자</h3><p><code>+</code> 연산자는 자바스크립트와 같이 문자열을 연결할 수 있다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">p</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">cursor</span>: e + -resize; <span class=\"comment\">// e-resize</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>따옴표가 있는 문자열과 없는 문자열을 함께 사용하는 경우, 좌향의 문자열을 기준으로 따옴표를 처리한다. 하이픈(<code>-</code>) 기호가 사용될 경우, 하이픈 기호를 포함해서 붙인다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">p</span>:before &#123;</div><div class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">\"Foo \"</span> + Bar; <span class=\"comment\">//Foo Bar</span></div><div class=\"line\">  <span class=\"attribute\">font-family</span>: sans- + <span class=\"string\">\"serif\"</span>; <span class=\"comment\">//sans-serif;</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.btn</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">cursor</span>: p + inter;</div><div class=\"line\">  <span class=\"attribute\">font-family</span>: sans- + <span class=\"string\">'serif'</span>;</div><div class=\"line\">  &amp;:after &#123;</div><div class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">\"Hello \"</span> + world;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"variable\">$value</span>: <span class=\"number\">100</span>;</div><div class=\"line\">  &amp;:before &#123;</div><div class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">\"I'm #&#123;$value&#125; years old!\"</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* compiled */</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">p</span><span class=\"selector-pseudo\">:before</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">\"Foo Bar\"</span>;</div><div class=\"line\">  <span class=\"attribute\">font-family</span>: sans-serif;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.btn</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">cursor</span>: pinter;</div><div class=\"line\">  <span class=\"attribute\">font-family</span>: sans-serif;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.btn</span><span class=\"selector-pseudo\">:after</span> &#123; <span class=\"attribute\">content</span>: <span class=\"string\">\"Hello world\"</span>; &#125;</div><div class=\"line\"><span class=\"selector-class\">.btn</span><span class=\"selector-pseudo\">:before</span> &#123; <span class=\"attribute\">content</span>: <span class=\"string\">\"I'm 100 years old!\"</span>; &#125;</div></pre></td></tr></table></figure><h3 id=\"4-boolean-연산자\"><a href=\"#4-boolean-연산자\" class=\"headerlink\" title=\"4) boolean 연산자\"></a>4) boolean 연산자</h3><ul><li><strong>&amp;&amp;</strong> (and)</li><li><strong>||</strong> (or)</li><li><strong>!</strong> (not)</li></ul><h3 id=\"5-list-연산자\"><a href=\"#5-list-연산자\" class=\"headerlink\" title=\"5) list 연산자\"></a>5) list 연산자</h3><p>리스트를 위한 별도의 연산자는 제공되지 않지만, <a href=\"http://poiemaweb.com/sass-built-in-function#4-list-functions\" target=\"_blank\" rel=\"external\">리스트 함수</a>를 사용하여 필요한 처리를 수행할 수 있다.</p><h2 id=\"5-함수-Function\"><a href=\"#5-함수-Function\" class=\"headerlink\" title=\"5. 함수(Function)\"></a>5. 함수(Function)</h2><p><a href=\"http://poiemaweb.com/sass-built-in-function\" target=\"_blank\" rel=\"external\">Built-in Function</a></p><h2 id=\"6-Interpolation\"><a href=\"#6-Interpolation\" class=\"headerlink\" title=\"6. Interpolation: #{}\"></a>6. Interpolation: <code>#{}</code></h2><p>인터폴레이션은 변수의 값을 문자열 그대로 삽입한다. 인터폴레이션에 의해 삽입된 문자열은 연산 대상으로 취급되지 않는다. 변수는 프로퍼티값으로만 사용할 수 있으나 <code>#{}</code>을 사용하면 <strong>셀렉터와 프로퍼티명에도</strong> 사용할 수 있다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$name</span>: foo;</div><div class=\"line\"><span class=\"variable\">$attr</span>: border;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">p</span>.#&#123;<span class=\"variable\">$name</span>&#125; &#123; <span class=\"comment\">//p.foo</span></div><div class=\"line\">  #&#123;<span class=\"variable\">$attr</span>&#125;-<span class=\"attribute\">color</span>: blue; <span class=\"comment\">//border-color: blue;</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.someclass</span> &#123;</div><div class=\"line\">  <span class=\"variable\">$font-size</span>: <span class=\"number\">12px</span>;</div><div class=\"line\">  <span class=\"variable\">$line-height</span>: <span class=\"number\">30px</span>;</div><div class=\"line\">  <span class=\"comment\">//연산의 대상으로 취급되지 않게 한다.</span></div><div class=\"line\">  <span class=\"attribute\">font</span>: #&#123;<span class=\"variable\">$font-size</span>&#125; / #&#123;<span class=\"variable\">$line-height</span>&#125;;</div><div class=\"line\">  <span class=\"comment\">// 12px / 30px</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><h2 id=\"7-Ampersand-amp\"><a href=\"#7-Ampersand-amp\" class=\"headerlink\" title=\"7. Ampersand(&amp;)\"></a>7. Ampersand(&amp;)</h2><p><code>&amp;</code>는 부모요소를 참조하는 셀렉터이다.<br><code>&amp;</code>는 Sass와 Less에서 아주 유용한 기능으로 주로 중첩(nesting)시에 사용된다. 사용법만 알면, css로 동일한 코드를 작성할 때보다 훨씬 많은 시간을 절약할 수 있다.</p><p><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2016/01/scss-to-css.gif\" alt=\"Ampersand in SASS\"></p><hr><h3 id=\"Nesting\"><a href=\"#Nesting\" class=\"headerlink\" title=\"Nesting\"></a><strong>Nesting</strong></h3><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//scss</span></div><div class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</div><div class=\"line\">  <span class=\"selector-class\">.child</span> &#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* compiles to css */</span></div><div class=\"line\"><span class=\"selector-class\">.parent</span> <span class=\"selector-class\">.child</span> &#123;&#125;</div></pre></td></tr></table></figure><p>원하는 만큼 깊게 중첩시킬 수 있지만 지나치게 특수한 셀렉터(덜 유용하고 재정의하기 어려운)가 되는 것을 막기 위해 1 ~ 2단계의 중첩만 유지하는 게 좋다.</p><h3 id=\"Adding-another-class\"><a href=\"#Adding-another-class\" class=\"headerlink\" title=\"Adding another class\"></a><strong>Adding another class</strong></h3><p><code>&amp;</code>는 이러한 중첩(네스팅, nesting)에 편리하다. 다음과 같이 둘 이상의 클래스를 사용해서 특수한(구체적인) 선택자(selector)를 만들고자 할 때 특히 그렇다.</p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* css */</span></div><div class=\"line\"><span class=\"selector-class\">.some-class</span><span class=\"selector-class\">.anoter-class</span> &#123;&#125;</div></pre></td></tr></table></figure><p>위와 같은 css코드는 sass로는 아래처럼 작성할 수 있다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//scss</span></div><div class=\"line\"><span class=\"selector-class\">.some-class</span> &#123;</div><div class=\"line\">  &amp;<span class=\"selector-class\">.anoter-class</span>&#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p><code>&amp;</code>는 네스팅시 항상 상위 선택자를 탐조한다. <code>&amp;</code>를 제거하고 부모 선택자로 대체한 것으로 생각할 수 있다.</p><p>위에서 예시로 들었던 코드를 다시 살펴보면,</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//scss</span></div><div class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</div><div class=\"line\">  <span class=\"selector-class\">.child</span> &#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>이 코드는 사실 <code>&amp;</code>로 네스팅하는 것의 short-hand이다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//scss</span></div><div class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</div><div class=\"line\">  &amp; <span class=\"selector-class\">.child</span>&#123;</div><div class=\"line\"></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>따라서 이 두 예시는 모두 아래처럼 동일하게 컴파일된다.</p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* compiles to css */</span></div><div class=\"line\"><span class=\"selector-class\">.parent</span> <span class=\"selector-class\">.child</span> &#123;&#125;</div></pre></td></tr></table></figure><p><code>&amp;</code>는 자식 선택자에 필요할 때마다 부모 선택자를 배치할 수 있게 하는 매커니즘 정도로 생각할 수 있다. 그러면 <code>&amp;</code>를 어떻게 더 다양하게 활용할 수 있을지 예제를 통해 알아보자.</p><h3 id=\"Using-the-amp-with-pseudo-classes\"><a href=\"#Using-the-amp-with-pseudo-classes\" class=\"headerlink\" title=\"Using the &amp; with pseudo classes\"></a><strong>Using the <code>&amp;</code> with pseudo classes</strong></h3><p><code>&amp;</code>를 이용하면 가상클래스(pseudo class)를 작성할 때 코드의 반복을 현저하게 줄일 수 있다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.button</span> &#123;</div><div class=\"line\">  &amp;:visited &#123;&#125;</div><div class=\"line\">  &amp;:hover &#123;&#125;</div><div class=\"line\">  &amp;:active&#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*compiles to css*/</span></div><div class=\"line\"><span class=\"selector-class\">.button</span><span class=\"selector-pseudo\">:visited</span> &#123;&#125;</div><div class=\"line\"><span class=\"selector-class\">.buttom</span><span class=\"selector-pseudo\">:hover</span> &#123;&#125;</div><div class=\"line\"><span class=\"selector-class\">.button</span><span class=\"selector-pseudo\">:active</span> &#123;&#125;</div></pre></td></tr></table></figure><p>이 경우 <code>&amp;</code>를 사용함으로써 <code>.button</code>을 반복적으로 작성하지 않고도 가상클래스 바로 옆에 <code>.button</code>를 배치할 수 있다. 만약 이때 <code>&amp;</code>를 생략하면, 기본 중첩(nesting)은 다음과 같이 둘 사이에 공백을 넣는다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//scss</span></div><div class=\"line\"><span class=\"selector-class\">.button</span> &#123;</div><div class=\"line\">  :visited &#123;&#125;</div><div class=\"line\">  :hover &#123;&#125;</div><div class=\"line\">  :active &#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*css*/</span></div><div class=\"line\"><span class=\"selector-class\">.button</span> <span class=\"selector-pseudo\">:hover</span></div></pre></td></tr></table></figure><p>주의하자. 공백이 있는 것과 없는 것은 절대 같지 않다.</p><h3 id=\"Using-the-amp-with-gt-and\"><a href=\"#Using-the-amp-with-gt-and\" class=\"headerlink\" title=\"Using the &amp; with &gt;, +, and ~\"></a><em>Using the <code>&amp;</code> with <code>&gt;</code>, <code>+</code>, and <code>~</code></em></h3><p><code>&amp;</code>를 부모-자식 관계를 나타내는 combinator인 <code>&gt;</code>, 인접 형제 관계임을 나타내는 combinator인 <code>+</code>, 그리고 일반적인 형제 관계임을 나타내는 combinator인 <code>~</code>와 함께 사용하면 아주 용이하다.</p><p>코드를 작성할 때, <code>&amp;</code>를 함께 작성해야한다 생각하겠지만, 사실 그렇지 않다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.button</span> &#123;</div><div class=\"line\">  &amp; &gt; <span class=\"selector-tag\">span</span> &#123;&#125;</div><div class=\"line\">  &amp; + <span class=\"selector-tag\">span</span> &#123;&#125;</div><div class=\"line\">  &amp; ~ <span class=\"selector-tag\">span</span> &#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>선택자에서 <code>&amp;</code>를 떼어내서 아래처럼 작성할 수도 있는데, 두 코드는 동일하게 컴파일 된다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 이렇게 작성해도 똑같다.</span></div><div class=\"line\"><span class=\"selector-class\">.button</span> &#123;</div><div class=\"line\">  &gt; <span class=\"selector-tag\">span</span> &#123;&#125;</div><div class=\"line\">  + <span class=\"selector-tag\">span</span> &#123;&#125;</div><div class=\"line\">  ~ <span class=\"selector-tag\">span</span> &#123;&#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*compiles to css*/</span></div><div class=\"line\"><span class=\"selector-class\">.button</span> &gt; <span class=\"selector-tag\">span</span> &#123;&#125;</div><div class=\"line\"><span class=\"selector-class\">.button</span> + <span class=\"selector-tag\">span</span> &#123;&#125;</div><div class=\"line\"><span class=\"selector-class\">.button</span> ~ <span class=\"selector-tag\">span</span>&#123;&#125;</div></pre></td></tr></table></figure><h3 id=\"Qualifying-based-on-context\"><a href=\"#Qualifying-based-on-context\" class=\"headerlink\" title=\"Qualifying based on context\"></a><strong>Qualifying based on context</strong></h3><p>네스팅된 셀렉터에 <code>&amp;</code>가 반드시 앞에 붙을 필요는 없다. 끝에 <code>&amp;</code>를 붙이면 선택자를 한정할 수 있다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//scss</span></div><div class=\"line\"><span class=\"selector-class\">.button</span> &#123;</div><div class=\"line\">  <span class=\"selector-tag\">body</span><span class=\"selector-class\">.page-about</span> &amp; &#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p><code>&amp;</code> 자리는 본래 부모 선택자의 자리이다. 만약 필요한 부모 선택자가 있다면 그 자리에 부모 선택자를 기재한다. <code>&amp;</code>는 마지막에 붙인다. 이 방식은 다른 부모를 기반으로 셀렉터를 한정하는데 아주 유용하다. 이 코드는 아래와 같이 컴파일 된다.</p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">body</span><span class=\"selector-class\">.page-about</span> <span class=\"selector-class\">.button</span>&#123;&#125;</div></pre></td></tr></table></figure><p>해석해보자면, <code>page-about</code>이 <strong><code>body</code>클래스의 자식클래스로 있을 때에만</strong> (다르게 말하면, 다른 클래스의 자식클래스로 있을 때는 적용하지 않는다.) <code>button</code> 클래스에 {내용}의 css를 정의한다</p><p><a href=\"https://css-tricks.com/the-sass-ampersand/#article-header-id-9\" target=\"_blank\" rel=\"external\">그 외 더 많은 예시</a></p><hr><h2 id=\"8-default\"><a href=\"#8-default\" class=\"headerlink\" title=\"8. !default\"></a>8. <code>!default</code></h2><p><code>!default</code> flag는 할당되지 않은 변수의 초기값을 설정한다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$content</span>: null; <span class=\"comment\">//값이 할당되지 않았다.</span></div><div class=\"line\"><span class=\"variable\">$content</span>: <span class=\"string\">\"Non-null content\"</span> !default;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-id\">#main</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"variable\">$content</span>; <span class=\"comment\">//\"Non-null content\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>이미 값이 할당되어 있는 변수에 <code>!default</code> flag를 사용하면 적용되지 않는다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$content</span>: <span class=\"string\">\"First content\"</span>;</div><div class=\"line\"><span class=\"variable\">$content</span>: <span class=\"string\">\"Second content?\"</span> !default;</div><div class=\"line\"><span class=\"variable\">$new_content</span>: <span class=\"string\">\"First time reference\"</span> !default;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-id\">#main</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"variable\">$content</span>; <span class=\"comment\">//\"First content\"</span></div><div class=\"line\">  new_content: <span class=\"variable\">$new_content</span>; <span class=\"comment\">//\"First time reference\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>이러한 특성은 <a href=\"http://sass-lang.com/documentation/file.SASS_REFERENCE.html#Partials__partials\" target=\"_blank\" rel=\"external\">partial</a>에 매우 유용하다.<br>2개의 font.scss와 main.scss파일을 생성해보자.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//font.scss</span></div><div class=\"line\"><span class=\"variable\">$font-size</span>: <span class=\"number\">16px</span> !default;</div><div class=\"line\"><span class=\"variable\">$line-height</span>: <span class=\"number\">1.5</span> !default;</div><div class=\"line\"><span class=\"variable\">$font-family</span>: <span class=\"string\">\"Helvetica Neue\"</span>, <span class=\"string\">\"Helverica\"</span>, <span class=\"string\">\"Arial\"</span>, sans-serif !default;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">body</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">font</span>: #&#123;<span class=\"variable\">$font-size</span>&#125;/<span class=\"variable\">$line-height</span> <span class=\"variable\">$font-family</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>main.scss는 내부에서 font.scss를 import한다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//main.scss</span></div><div class=\"line\"><span class=\"variable\">$font-family</span>: <span class=\"string\">\"Lucida Grande\"</span>, <span class=\"string\">\"Lucida Sans Unicode\"</span>, sans-serif;</div><div class=\"line\"></div><div class=\"line\">@<span class=\"keyword\">import</span> <span class=\"string\">\"font\"</span>;</div></pre></td></tr></table></figure><p>위 코드의 컴파일 결과는 아래와 같다.</p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">body</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">font</span>: <span class=\"number\">16px</span>/<span class=\"number\">1.5</span> <span class=\"string\">\"Lucida Grande\"</span>, <span class=\"string\">\"Lucida Sans Unicode\"</span>, sans-serif;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p><code>!default</code>는 <strong>변수에 값이 할당되지 않았을 때</strong> 사용할 기본 값을 지정할 때 사용한다. 위 예제의 경우 <code>main.scss</code>에서 <strong>변수에 값을 할당하였기 때문에</strong> <code>!default</code>와 같이 사용한 변수값은 무력화된다.</p><p>만일 <code>font.scss</code>의 <code>$font-family</code> 변수에 <code>!default</code>설정이 없었다면 후위에 선언된 <code>font.scss</code>의 <code>$font-family</code> 변수값이 적용되어 아래와 같은 결과가 생성되었을 것이다.</p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">body</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">font</span>: <span class=\"number\">16px</span>/<span class=\"number\">1.5</span> <span class=\"string\">\"Helvetica Neue\"</span>, <span class=\"string\">\"Helvetica\"</span>, <span class=\"string\">\"Arial\"</span>, sans-serif;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://www.unixstickers.com/image/data/stickers/sass/sass.sh.png\" alt=\"\"></p><h1 id=\"Sass-Script\"><a href=\"#Sass-Script\" class=\"headerlink\" title=\"Sass Script\"></a>Sass Script</h1><h2 id=\"1-Data-Type\"><a href=\"#1-Data-Type\" class=\"headerlink\" title=\"1. Data Type\"></a>1. Data Type</h2><p>프로퍼티값으로 사용할 수 있는 값에는 각각의 자료형(Data Type)이 존재한다. SassScript가 제공하는 자료형은 7가지가 있다.</p><ul><li><p><strong>숫자형</strong><br>e.g) 1.2, 13, 10px</p></li><li><p><strong>문자열</strong><br>CSS는 2종류의 문자열을 사용할 수 있다. 따옴표를 사용하는 경우(“Lucida Grande”, ‘<a href=\"http://sass-lang.com’)와\" target=\"_blank\" rel=\"external\">http://sass-lang.com’)와</a> 사용하지 않는 경우(bold, sans-serif)가 있다. Sass는 2종류의 문자열 모두를 인식할 수 있으며 컴파일 후의 CSS에는 Sass에서 사용한 문자열이 그대로 출력된다.<br>e.g. “Lucida Grande”, ‘<a href=\"http://sass-lang.com’\" target=\"_blank\" rel=\"external\">http://sass-lang.com’</a>, sans-serif</p></li><li><p><strong>컬러</strong><br>e.g. blue, #04a3f9, rgba(255, 0, 0, 0.5)</p></li><li><p><strong>boolean</strong><br>e.g. true, false</p></li><li><p><strong>null</strong></p></li><li><p><strong>list</strong><br>margin과 padding 프로퍼티값 지정에 사용되는 0 auto와 font-family 프로퍼티값 지정에 사용되는 Helvetica, Arial, sans-serif 등은 공백 또는 콤마 구분된 값의 list이다.<br>e.g. 1.5em 1em 0 2em, Helvetica, Arial, sans-serif</p></li><li><p><strong>map</strong><br>JSON과 유사한 방식으로 map-get 함수를 사용하여 원하는 값은 추출할 수 있다.<br>e.g. (key1: value1, key2: value2)</p></li></ul><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// map</span></div><div class=\"line\"><span class=\"variable\">$foundation-palette</span>: (</div><div class=\"line\">  primary: <span class=\"number\">#E44347</span>,</div><div class=\"line\">  mars: <span class=\"number\">#D7525C</span>,</div><div class=\"line\">  saturn: <span class=\"number\">#E4B884</span>,</div><div class=\"line\">  neptune: <span class=\"number\">#5147D7</span></div><div class=\"line\">);</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.mars</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: map-get(<span class=\"variable\">$foundation-palette</span>, mars); </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// =&gt; .mars &#123; color: #D7525C; &#125;</span></div></pre></td></tr></table></figure><h2 id=\"2-변수\"><a href=\"#2-변수\" class=\"headerlink\" title=\"2. 변수\"></a>2. 변수</h2><p>Sass에서는 변수를 사용할 수 있다. 문자열, 숫자, 컬러(<code>#aa443f</code>) 등을 사전에 변수에 저장하고 필요할 때 불러 사용할 수 있다.</p><p>변수명은 <code>$</code>로 시작한다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$width</span>: <span class=\"number\">960px</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">header</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"variable\">$width</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> auto;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-id\">#main</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"variable\">$width</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">20px</span> auto;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">footer</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"variable\">$width</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> auto;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>어떤 것을 변수명으로 설정할지에 대한 설계가 필요하다. 변수명은 대체로 파일의 앞 쪽에 몰아서 선언해둔다.</p><h2 id=\"3-변수의-스코프\"><a href=\"#3-변수의-스코프\" class=\"headerlink\" title=\"3. 변수의 스코프\"></a>3. 변수의 스코프</h2><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$width</span>: <span class=\"number\">960px</span>; <span class=\"comment\">// global variable</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">header</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"variable\">$width</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> auto;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-id\">#main</span> &#123;</div><div class=\"line\">  <span class=\"variable\">$color</span>: <span class=\"number\">#333</span>; <span class=\"comment\">// local variable</span></div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"variable\">$width</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">20px</span> auto;</div><div class=\"line\">  <span class=\"selector-tag\">section</span> &#123;</div><div class=\"line\">    <span class=\"selector-tag\">p</span> &#123;</div><div class=\"line\">      <span class=\"attribute\">color</span>: <span class=\"variable\">$color</span>;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"selector-tag\">a</span>:link &#123;</div><div class=\"line\">        <span class=\"attribute\">color</span>: <span class=\"variable\">$color</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">footer</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"variable\">$width</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> auto;</div><div class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"variable\">$color</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>위 코드를 컴파일하면 <code>Undefined variable: “$color”</code>라는 에러가 발생한다. 이는 <code>#main</code>에서 선언한 <code>$color</code>는 <code>#main</code> 내에서만 유효한 지역변수이기 때문이다.</p><p>코드블럭 내에서 선언한 지역변수를 전역변수화하는 방법은 아래와 같다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#main</span> &#123;</div><div class=\"line\">  <span class=\"variable\">$color</span>: <span class=\"number\">#333</span> !global; <span class=\"comment\">// global variable</span></div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"variable\">$width</span>;</div><div class=\"line\">  ...</div></pre></td></tr></table></figure><h2 id=\"4-연산자-Operation\"><a href=\"#4-연산자-Operation\" class=\"headerlink\" title=\"4. 연산자(Operation)\"></a>4. 연산자(Operation)</h2><h3 id=\"1-숫자-연산자\"><a href=\"#1-숫자-연산자\" class=\"headerlink\" title=\"1) 숫자 연산자\"></a>1) 숫자 연산자</h3><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td>+</td><td>덧셈</td></tr><tr><td>-</td><td>뺄셈</td></tr><tr><td>*</td><td>곱셈</td></tr><tr><td>/</td><td>나눗셈</td></tr><tr><td>%</td><td>나머지</td></tr><tr><td>==</td><td>동등</td></tr><tr><td>!=</td><td>부등</td></tr></tbody></table><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-id\">#foo</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"variable\">$width</span> + <span class=\"number\">10</span>; <span class=\"comment\">//110px</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-id\">#bar</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"variable\">$width</span> + <span class=\"number\">10in</span>; <span class=\"comment\">//1060px</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>변수 $width의 값 100px에 10 또는 10em과 같이 다른 단위의 값을 연산하여도 에러없이 연산이 수행된다. 이때 연산자의 왼쪽 값을 기준으로 단위가 설정된다.</p><p>$width에 10em을 더하면 어떻게 될까?</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-id\">#foo</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"variable\">$width</span> + <span class=\"number\">10em</span>; <span class=\"comment\">//NG: 100px + 10em</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>컴파일 결과 Incompatible units: ‘em’ and ‘px’.이라는 에러를 출력한다. Scss 연산은 대상을 변환하여 연산할 수 없는 경우, 에러를 출력한다.</p><p>%,em,rem,vh,vw,vmin,vmax와 같이 상대적인 값을 Sass는 알지 못한다. 상대적인 값의 결과값은 브라우저만이 알 수 있기 때문이다. (sass는 단지 css로 변환하기만 할 뿐, em 등등의 값은 알 수 없다.) 따라서 <strong>상대적 값을 갖는 단위의 연산은 동일한 단위를 갖는 값과의 연산만이 유효하다.</strong></p><blockquote><p>%는 부모를 기준으로, rem은 html을 기준으로 (기본적으로 16px), vw는 뷰포트를 기준으로, 1vw = viewport를 기준으로 1/100.</p></blockquote><p>CSS3의 calc함수(IE9 이상에서만 사용할 수 있다.)는 이런 문제를 해결할 수 있다. (calc는 브라우저에서 수행하기 때문에 상대값과 절댓값 사이 계산이 가능한 것이다.)</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#foo</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: calc(<span class=\"number\">25%</span> - <span class=\"number\">5px</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>CSS에서의 <code>/</code>는 나눗셈이 아니라 값을 분리하는 의미를 갖는다. 따라서 Sass의 <code>/</code> 연산자를 사용하기 위해서는 몇가지 조건이 필요하다. 이외의 조건에서는 나눗셈을 하지 않는다.</p><ul><li>변수에 대해 사용</li><li>괄호 내에서 사용</li><li>다른 연산의 일부로서 사용</li></ul><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">p</span> &#123;</div><div class=\"line\">  <span class=\"comment\">// font와 border-radius의 '/'는 CSS문법에 맞는 표현이므로 연산되지 않는다.</span></div><div class=\"line\">  <span class=\"attribute\">font</span>: italic bold <span class=\"number\">12px</span>/<span class=\"number\">30px</span> Georgia, serif;</div><div class=\"line\">  <span class=\"comment\">// 타원형 둥근 모서리</span></div><div class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">10px</span> <span class=\"number\">20px</span> / <span class=\"number\">20px</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"variable\">$width</span>: <span class=\"number\">1000px</span>;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"variable\">$width</span> / <span class=\"number\">2</span>;            <span class=\"comment\">// 변수에 대해 사용 →　width: 500px;</span></div><div class=\"line\">  <span class=\"attribute\">height</span>: (<span class=\"number\">500px</span> / <span class=\"number\">2</span>);          <span class=\"comment\">// 괄호 내에서 사용 →　height: 250px;</span></div><div class=\"line\">  <span class=\"attribute\">margin-left</span>: <span class=\"number\">5px</span> + <span class=\"number\">8px</span> / <span class=\"number\">2px</span>; <span class=\"comment\">// 다른 연산의 일부로서 사용 →　margin-left: 9px;</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>변수를 CSS의 /와 함께 사용하고자 하는 경우 <code>#{}</code>(Interpolation)를 사용한다.<br><code>#{}</code>를 사용하면 변수를 문자열로 인식하게 한다. 따라서 연산을 하지 않는다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">p</span>&#123;</div><div class=\"line\">  <span class=\"variable\">$font-size</span>: <span class=\"number\">12px</span>;</div><div class=\"line\">  <span class=\"variable\">$line-height</span>: <span class=\"number\">30px</span>;</div><div class=\"line\">  <span class=\"attribute\">font</span>: #&#123;<span class=\"variable\">$font-size</span>&#125; / #&#123;<span class=\"variable\">$line-height</span>&#125;; <span class=\"comment\">// 12px/30px</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p><code>#{}</code>를 좌항에만 사용해주어도 같은 효과가 난다. (좌항을 기준으로 하며, 둘 다 변수일 때만 연산을 하기 때문이다.)<br>하지만 양 쪽 모두 <code>#{}</code>를 사용해주는 것이 더 좋다.</p><h3 id=\"2-컬러-연산자\"><a href=\"#2-컬러-연산자\" class=\"headerlink\" title=\"2) 컬러 연산자\"></a>2) 컬러 연산자</h3><p>컬러 값에도 모든 산술 연산자를 적용할 수 있다. 컬러 값은 R은 R끼리, G는 G끼리, B는 B끼리 연산한다.<br>(#RRBBGG 표기법의 숫자는 16진수로 표기한다. 16진수에서는 10부터 A로 시작하는 알파벳이다. 05 + 05 = A)</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">p</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#010203</span> + <span class=\"number\">#040506</span>;</div><div class=\"line\">  <span class=\"comment\">// R: 01 + 04 = 05</span></div><div class=\"line\">  <span class=\"comment\">// G: 02 + 05 = 07</span></div><div class=\"line\">  <span class=\"comment\">// B: 03 + 06 = 09</span></div><div class=\"line\">  <span class=\"comment\">// =&gt; #050709</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">p</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#010203</span> * <span class=\"number\">2</span>;</div><div class=\"line\">  <span class=\"comment\">// R: 01 * 2 = 02</span></div><div class=\"line\">  <span class=\"comment\">// G: 02 * 2 = 04</span></div><div class=\"line\">  <span class=\"comment\">// B: x03 * 2 = 06</span></div><div class=\"line\">  <span class=\"comment\">// =&gt; #020406</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">p</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: rgba(<span class=\"number\">255</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0.75</span>) + rgba(<span class=\"number\">0</span>, <span class=\"number\">255</span>, <span class=\"number\">0</span>, <span class=\"number\">0.75</span>);</div><div class=\"line\">  <span class=\"comment\">/* alpha 값은 연산되지 않는다</span></div><div class=\"line\"><span class=\"comment\">  / color: rgba(255, 255, 0, 0.75);</span></div><div class=\"line\"><span class=\"comment\">  / alpha 값이 서로 다르면, e.g. rgba(0, 0, 0, 0.7) + rgba(100, 120, 255, 0.5);</span></div><div class=\"line\"><span class=\"comment\">  이 경우 error가 발생한다.</span></div><div class=\"line\"><span class=\"comment\">  */</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>alpha값은 연산되지 않는다. 서로 다른 alpha값을 연산하려 하는 경우 error가 발생한다. 서로 같은 alpha값을 연산하려 하는 경우, error는 발생하지 않지만 연산을 하지 않고 값을 그대로 반환한다. 위 예제에서도 연산 결과로 0.75를 그대로 반환하였다.</p><p>alpha 값을 연산하려면 <a href=\"http://poiemaweb.com/sass-built-in-function#65-alpha-연산\" target=\"_blank\" rel=\"external\">opacify 함수 또는 transparentize 함수</a>를 사용해야 한다.</p><ul><li>opacify(불투명화) 함수: <code>+</code> 연산, 첫번째 argument의 alpha값에 두번째 argument를 더해 <strong>불투명도를 증가</strong>시킨다.</li><li>transparentize(투명화) 함수: <code>-</code> 연산, 첫번째 argument의 alpha값에 두번째 argument의 alpha값을 빼서 <strong>불투명도를 감소</strong>시킨다.</li></ul><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$translucent-red</span>: rgba(<span class=\"number\">255</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0.5</span>);</div><div class=\"line\"><span class=\"selector-tag\">p</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: opacify(<span class=\"variable\">$translucent-red</span>, <span class=\"number\">0.3</span>);</div><div class=\"line\">  <span class=\"comment\">// =&gt; color: rgba(255, 0, 0, 0.8)</span></div><div class=\"line\">  <span class=\"attribute\">background-color</span>: transparentize(<span class=\"variable\">$translucent-red</span>, <span class=\"number\">0.25</span>);</div><div class=\"line\">  <span class=\"comment\">// =&gt;  color: rgba(255, 0, 0, 0.25);</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><h3 id=\"3-문자열-연산자\"><a href=\"#3-문자열-연산자\" class=\"headerlink\" title=\"3) 문자열 연산자\"></a>3) 문자열 연산자</h3><p><code>+</code> 연산자는 자바스크립트와 같이 문자열을 연결할 수 있다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">p</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">cursor</span>: e + -resize; <span class=\"comment\">// e-resize</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>따옴표가 있는 문자열과 없는 문자열을 함께 사용하는 경우, 좌향의 문자열을 기준으로 따옴표를 처리한다. 하이픈(<code>-</code>) 기호가 사용될 경우, 하이픈 기호를 포함해서 붙인다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">p</span>:before &#123;</div><div class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">\"Foo \"</span> + Bar; <span class=\"comment\">//Foo Bar</span></div><div class=\"line\">  <span class=\"attribute\">font-family</span>: sans- + <span class=\"string\">\"serif\"</span>; <span class=\"comment\">//sans-serif;</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.btn</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">cursor</span>: p + inter;</div><div class=\"line\">  <span class=\"attribute\">font-family</span>: sans- + <span class=\"string\">'serif'</span>;</div><div class=\"line\">  &amp;:after &#123;</div><div class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">\"Hello \"</span> + world;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"variable\">$value</span>: <span class=\"number\">100</span>;</div><div class=\"line\">  &amp;:before &#123;</div><div class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">\"I'm #&#123;$value&#125; years old!\"</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* compiled */</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">p</span><span class=\"selector-pseudo\">:before</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">\"Foo Bar\"</span>;</div><div class=\"line\">  <span class=\"attribute\">font-family</span>: sans-serif;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.btn</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">cursor</span>: pinter;</div><div class=\"line\">  <span class=\"attribute\">font-family</span>: sans-serif;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.btn</span><span class=\"selector-pseudo\">:after</span> &#123; <span class=\"attribute\">content</span>: <span class=\"string\">\"Hello world\"</span>; &#125;</div><div class=\"line\"><span class=\"selector-class\">.btn</span><span class=\"selector-pseudo\">:before</span> &#123; <span class=\"attribute\">content</span>: <span class=\"string\">\"I'm 100 years old!\"</span>; &#125;</div></pre></td></tr></table></figure><h3 id=\"4-boolean-연산자\"><a href=\"#4-boolean-연산자\" class=\"headerlink\" title=\"4) boolean 연산자\"></a>4) boolean 연산자</h3><ul><li><strong>&amp;&amp;</strong> (and)</li><li><strong>||</strong> (or)</li><li><strong>!</strong> (not)</li></ul><h3 id=\"5-list-연산자\"><a href=\"#5-list-연산자\" class=\"headerlink\" title=\"5) list 연산자\"></a>5) list 연산자</h3><p>리스트를 위한 별도의 연산자는 제공되지 않지만, <a href=\"http://poiemaweb.com/sass-built-in-function#4-list-functions\" target=\"_blank\" rel=\"external\">리스트 함수</a>를 사용하여 필요한 처리를 수행할 수 있다.</p><h2 id=\"5-함수-Function\"><a href=\"#5-함수-Function\" class=\"headerlink\" title=\"5. 함수(Function)\"></a>5. 함수(Function)</h2><p><a href=\"http://poiemaweb.com/sass-built-in-function\" target=\"_blank\" rel=\"external\">Built-in Function</a></p><h2 id=\"6-Interpolation\"><a href=\"#6-Interpolation\" class=\"headerlink\" title=\"6. Interpolation: #{}\"></a>6. Interpolation: <code>#{}</code></h2><p>인터폴레이션은 변수의 값을 문자열 그대로 삽입한다. 인터폴레이션에 의해 삽입된 문자열은 연산 대상으로 취급되지 않는다. 변수는 프로퍼티값으로만 사용할 수 있으나 <code>#{}</code>을 사용하면 <strong>셀렉터와 프로퍼티명에도</strong> 사용할 수 있다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$name</span>: foo;</div><div class=\"line\"><span class=\"variable\">$attr</span>: border;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">p</span>.#&#123;<span class=\"variable\">$name</span>&#125; &#123; <span class=\"comment\">//p.foo</span></div><div class=\"line\">  #&#123;<span class=\"variable\">$attr</span>&#125;-<span class=\"attribute\">color</span>: blue; <span class=\"comment\">//border-color: blue;</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.someclass</span> &#123;</div><div class=\"line\">  <span class=\"variable\">$font-size</span>: <span class=\"number\">12px</span>;</div><div class=\"line\">  <span class=\"variable\">$line-height</span>: <span class=\"number\">30px</span>;</div><div class=\"line\">  <span class=\"comment\">//연산의 대상으로 취급되지 않게 한다.</span></div><div class=\"line\">  <span class=\"attribute\">font</span>: #&#123;<span class=\"variable\">$font-size</span>&#125; / #&#123;<span class=\"variable\">$line-height</span>&#125;;</div><div class=\"line\">  <span class=\"comment\">// 12px / 30px</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><h2 id=\"7-Ampersand-amp\"><a href=\"#7-Ampersand-amp\" class=\"headerlink\" title=\"7. Ampersand(&amp;)\"></a>7. Ampersand(&amp;)</h2><p><code>&amp;</code>는 부모요소를 참조하는 셀렉터이다.<br><code>&amp;</code>는 Sass와 Less에서 아주 유용한 기능으로 주로 중첩(nesting)시에 사용된다. 사용법만 알면, css로 동일한 코드를 작성할 때보다 훨씬 많은 시간을 절약할 수 있다.</p><p><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2016/01/scss-to-css.gif\" alt=\"Ampersand in SASS\"></p><hr><h3 id=\"Nesting\"><a href=\"#Nesting\" class=\"headerlink\" title=\"Nesting\"></a><strong>Nesting</strong></h3><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//scss</span></div><div class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</div><div class=\"line\">  <span class=\"selector-class\">.child</span> &#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* compiles to css */</span></div><div class=\"line\"><span class=\"selector-class\">.parent</span> <span class=\"selector-class\">.child</span> &#123;&#125;</div></pre></td></tr></table></figure><p>원하는 만큼 깊게 중첩시킬 수 있지만 지나치게 특수한 셀렉터(덜 유용하고 재정의하기 어려운)가 되는 것을 막기 위해 1 ~ 2단계의 중첩만 유지하는 게 좋다.</p><h3 id=\"Adding-another-class\"><a href=\"#Adding-another-class\" class=\"headerlink\" title=\"Adding another class\"></a><strong>Adding another class</strong></h3><p><code>&amp;</code>는 이러한 중첩(네스팅, nesting)에 편리하다. 다음과 같이 둘 이상의 클래스를 사용해서 특수한(구체적인) 선택자(selector)를 만들고자 할 때 특히 그렇다.</p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* css */</span></div><div class=\"line\"><span class=\"selector-class\">.some-class</span><span class=\"selector-class\">.anoter-class</span> &#123;&#125;</div></pre></td></tr></table></figure><p>위와 같은 css코드는 sass로는 아래처럼 작성할 수 있다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//scss</span></div><div class=\"line\"><span class=\"selector-class\">.some-class</span> &#123;</div><div class=\"line\">  &amp;<span class=\"selector-class\">.anoter-class</span>&#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p><code>&amp;</code>는 네스팅시 항상 상위 선택자를 탐조한다. <code>&amp;</code>를 제거하고 부모 선택자로 대체한 것으로 생각할 수 있다.</p><p>위에서 예시로 들었던 코드를 다시 살펴보면,</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//scss</span></div><div class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</div><div class=\"line\">  <span class=\"selector-class\">.child</span> &#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>이 코드는 사실 <code>&amp;</code>로 네스팅하는 것의 short-hand이다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//scss</span></div><div class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</div><div class=\"line\">  &amp; <span class=\"selector-class\">.child</span>&#123;</div><div class=\"line\"></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>따라서 이 두 예시는 모두 아래처럼 동일하게 컴파일된다.</p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* compiles to css */</span></div><div class=\"line\"><span class=\"selector-class\">.parent</span> <span class=\"selector-class\">.child</span> &#123;&#125;</div></pre></td></tr></table></figure><p><code>&amp;</code>는 자식 선택자에 필요할 때마다 부모 선택자를 배치할 수 있게 하는 매커니즘 정도로 생각할 수 있다. 그러면 <code>&amp;</code>를 어떻게 더 다양하게 활용할 수 있을지 예제를 통해 알아보자.</p><h3 id=\"Using-the-amp-with-pseudo-classes\"><a href=\"#Using-the-amp-with-pseudo-classes\" class=\"headerlink\" title=\"Using the &amp; with pseudo classes\"></a><strong>Using the <code>&amp;</code> with pseudo classes</strong></h3><p><code>&amp;</code>를 이용하면 가상클래스(pseudo class)를 작성할 때 코드의 반복을 현저하게 줄일 수 있다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.button</span> &#123;</div><div class=\"line\">  &amp;:visited &#123;&#125;</div><div class=\"line\">  &amp;:hover &#123;&#125;</div><div class=\"line\">  &amp;:active&#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*compiles to css*/</span></div><div class=\"line\"><span class=\"selector-class\">.button</span><span class=\"selector-pseudo\">:visited</span> &#123;&#125;</div><div class=\"line\"><span class=\"selector-class\">.buttom</span><span class=\"selector-pseudo\">:hover</span> &#123;&#125;</div><div class=\"line\"><span class=\"selector-class\">.button</span><span class=\"selector-pseudo\">:active</span> &#123;&#125;</div></pre></td></tr></table></figure><p>이 경우 <code>&amp;</code>를 사용함으로써 <code>.button</code>을 반복적으로 작성하지 않고도 가상클래스 바로 옆에 <code>.button</code>를 배치할 수 있다. 만약 이때 <code>&amp;</code>를 생략하면, 기본 중첩(nesting)은 다음과 같이 둘 사이에 공백을 넣는다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//scss</span></div><div class=\"line\"><span class=\"selector-class\">.button</span> &#123;</div><div class=\"line\">  :visited &#123;&#125;</div><div class=\"line\">  :hover &#123;&#125;</div><div class=\"line\">  :active &#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*css*/</span></div><div class=\"line\"><span class=\"selector-class\">.button</span> <span class=\"selector-pseudo\">:hover</span></div></pre></td></tr></table></figure><p>주의하자. 공백이 있는 것과 없는 것은 절대 같지 않다.</p><h3 id=\"Using-the-amp-with-gt-and\"><a href=\"#Using-the-amp-with-gt-and\" class=\"headerlink\" title=\"Using the &amp; with &gt;, +, and ~\"></a><em>Using the <code>&amp;</code> with <code>&gt;</code>, <code>+</code>, and <code>~</code></em></h3><p><code>&amp;</code>를 부모-자식 관계를 나타내는 combinator인 <code>&gt;</code>, 인접 형제 관계임을 나타내는 combinator인 <code>+</code>, 그리고 일반적인 형제 관계임을 나타내는 combinator인 <code>~</code>와 함께 사용하면 아주 용이하다.</p><p>코드를 작성할 때, <code>&amp;</code>를 함께 작성해야한다 생각하겠지만, 사실 그렇지 않다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.button</span> &#123;</div><div class=\"line\">  &amp; &gt; <span class=\"selector-tag\">span</span> &#123;&#125;</div><div class=\"line\">  &amp; + <span class=\"selector-tag\">span</span> &#123;&#125;</div><div class=\"line\">  &amp; ~ <span class=\"selector-tag\">span</span> &#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>선택자에서 <code>&amp;</code>를 떼어내서 아래처럼 작성할 수도 있는데, 두 코드는 동일하게 컴파일 된다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 이렇게 작성해도 똑같다.</span></div><div class=\"line\"><span class=\"selector-class\">.button</span> &#123;</div><div class=\"line\">  &gt; <span class=\"selector-tag\">span</span> &#123;&#125;</div><div class=\"line\">  + <span class=\"selector-tag\">span</span> &#123;&#125;</div><div class=\"line\">  ~ <span class=\"selector-tag\">span</span> &#123;&#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*compiles to css*/</span></div><div class=\"line\"><span class=\"selector-class\">.button</span> &gt; <span class=\"selector-tag\">span</span> &#123;&#125;</div><div class=\"line\"><span class=\"selector-class\">.button</span> + <span class=\"selector-tag\">span</span> &#123;&#125;</div><div class=\"line\"><span class=\"selector-class\">.button</span> ~ <span class=\"selector-tag\">span</span>&#123;&#125;</div></pre></td></tr></table></figure><h3 id=\"Qualifying-based-on-context\"><a href=\"#Qualifying-based-on-context\" class=\"headerlink\" title=\"Qualifying based on context\"></a><strong>Qualifying based on context</strong></h3><p>네스팅된 셀렉터에 <code>&amp;</code>가 반드시 앞에 붙을 필요는 없다. 끝에 <code>&amp;</code>를 붙이면 선택자를 한정할 수 있다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//scss</span></div><div class=\"line\"><span class=\"selector-class\">.button</span> &#123;</div><div class=\"line\">  <span class=\"selector-tag\">body</span><span class=\"selector-class\">.page-about</span> &amp; &#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p><code>&amp;</code> 자리는 본래 부모 선택자의 자리이다. 만약 필요한 부모 선택자가 있다면 그 자리에 부모 선택자를 기재한다. <code>&amp;</code>는 마지막에 붙인다. 이 방식은 다른 부모를 기반으로 셀렉터를 한정하는데 아주 유용하다. 이 코드는 아래와 같이 컴파일 된다.</p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">body</span><span class=\"selector-class\">.page-about</span> <span class=\"selector-class\">.button</span>&#123;&#125;</div></pre></td></tr></table></figure><p>해석해보자면, <code>page-about</code>이 <strong><code>body</code>클래스의 자식클래스로 있을 때에만</strong> (다르게 말하면, 다른 클래스의 자식클래스로 있을 때는 적용하지 않는다.) <code>button</code> 클래스에 {내용}의 css를 정의한다</p><p><a href=\"https://css-tricks.com/the-sass-ampersand/#article-header-id-9\" target=\"_blank\" rel=\"external\">그 외 더 많은 예시</a></p><hr><h2 id=\"8-default\"><a href=\"#8-default\" class=\"headerlink\" title=\"8. !default\"></a>8. <code>!default</code></h2><p><code>!default</code> flag는 할당되지 않은 변수의 초기값을 설정한다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$content</span>: null; <span class=\"comment\">//값이 할당되지 않았다.</span></div><div class=\"line\"><span class=\"variable\">$content</span>: <span class=\"string\">\"Non-null content\"</span> !default;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-id\">#main</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"variable\">$content</span>; <span class=\"comment\">//\"Non-null content\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>이미 값이 할당되어 있는 변수에 <code>!default</code> flag를 사용하면 적용되지 않는다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$content</span>: <span class=\"string\">\"First content\"</span>;</div><div class=\"line\"><span class=\"variable\">$content</span>: <span class=\"string\">\"Second content?\"</span> !default;</div><div class=\"line\"><span class=\"variable\">$new_content</span>: <span class=\"string\">\"First time reference\"</span> !default;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-id\">#main</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"variable\">$content</span>; <span class=\"comment\">//\"First content\"</span></div><div class=\"line\">  new_content: <span class=\"variable\">$new_content</span>; <span class=\"comment\">//\"First time reference\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>이러한 특성은 <a href=\"http://sass-lang.com/documentation/file.SASS_REFERENCE.html#Partials__partials\" target=\"_blank\" rel=\"external\">partial</a>에 매우 유용하다.<br>2개의 font.scss와 main.scss파일을 생성해보자.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//font.scss</span></div><div class=\"line\"><span class=\"variable\">$font-size</span>: <span class=\"number\">16px</span> !default;</div><div class=\"line\"><span class=\"variable\">$line-height</span>: <span class=\"number\">1.5</span> !default;</div><div class=\"line\"><span class=\"variable\">$font-family</span>: <span class=\"string\">\"Helvetica Neue\"</span>, <span class=\"string\">\"Helverica\"</span>, <span class=\"string\">\"Arial\"</span>, sans-serif !default;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">body</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">font</span>: #&#123;<span class=\"variable\">$font-size</span>&#125;/<span class=\"variable\">$line-height</span> <span class=\"variable\">$font-family</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>main.scss는 내부에서 font.scss를 import한다.</p><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//main.scss</span></div><div class=\"line\"><span class=\"variable\">$font-family</span>: <span class=\"string\">\"Lucida Grande\"</span>, <span class=\"string\">\"Lucida Sans Unicode\"</span>, sans-serif;</div><div class=\"line\"></div><div class=\"line\">@<span class=\"keyword\">import</span> <span class=\"string\">\"font\"</span>;</div></pre></td></tr></table></figure><p>위 코드의 컴파일 결과는 아래와 같다.</p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">body</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">font</span>: <span class=\"number\">16px</span>/<span class=\"number\">1.5</span> <span class=\"string\">\"Lucida Grande\"</span>, <span class=\"string\">\"Lucida Sans Unicode\"</span>, sans-serif;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p><code>!default</code>는 <strong>변수에 값이 할당되지 않았을 때</strong> 사용할 기본 값을 지정할 때 사용한다. 위 예제의 경우 <code>main.scss</code>에서 <strong>변수에 값을 할당하였기 때문에</strong> <code>!default</code>와 같이 사용한 변수값은 무력화된다.</p><p>만일 <code>font.scss</code>의 <code>$font-family</code> 변수에 <code>!default</code>설정이 없었다면 후위에 선언된 <code>font.scss</code>의 <code>$font-family</code> 변수값이 적용되어 아래와 같은 결과가 생성되었을 것이다.</p><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">body</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">font</span>: <span class=\"number\">16px</span>/<span class=\"number\">1.5</span> <span class=\"string\">\"Helvetica Neue\"</span>, <span class=\"string\">\"Helvetica\"</span>, <span class=\"string\">\"Arial\"</span>, sans-serif;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"[node]  REST API: POST VS PUT","date":"2017-09-09T09:42:28.000Z","_content":"\n![](http://allvectorlogo.com/img/2016/05/node-js-logo.png)\n\n# REST API: POST VS PUT\n\nPOST와 PUT은 CRUD로직중 Create와 Update의 속성을 가진 http 메소드이다.\n\n정의만 보면 둘은 동일한 작업을 하는 것 같다. 둘은 어떤 차이가 있는가?\n\n## Idempotent\n\n첫번째 차이는 [멱등성(Idempotent)](https://ko.wikipedia.org/wiki/%EB%A9%B1%EB%93%B1%EB%B2%95%EC%B9%99)이다. 멱등성이란 단항연산 ƒ에 대해 결과 값이 항상 자기 자신을 향하는 성질이다. 이러한 성질을 수식으로 표현하면 아래와 같다.  \n\n### *ƒ(ƒ(x)) = ƒ(x)*  \n\n한마디로, 같은 연산을 무한정 반복해도 결과는 **항상 동일한 값을 갖는다**는 말이다.  \n\nRESTful 서비스 관점에서, 연산(서비스 호출)이 idempotent하려면, 클라이언트가 (의도했거나 말거나) 동일한 요청을 반복적으로 보내도 한번 요청했을 때와 같은 결과를 산출할 수 있어야 한다. 결론부터 말하면, PUT은 멱등성을 가지고 있지만 POST는 그렇지 못하다.\n\n## 리소스 결정권\n\n두번째 차이는 리소스 결정권을 누가 가지고 있는가이다. URI에 대한 결정권이 POST는 서버측에 있으며 PUT은 클라이언트 측에 있다.\n\n<br>\n\n\n### POST\n\nPOST는 새로운 리소스(자원)를 생성(create)할 때 주로 사용된다. 특히 하위 리소스를 만드는 데 주로 사용된다. 즉, POST로 생성하는 리소스는 상위 리소스에 종속된다. 부모(상위) 리소스에 POST를 보내면 **서비스가 부모와 새로 생성할 리소스를 연결하고 ID(새 리소스의 URI)를 할당하는 등의 작업을 처리한다.** 클라이언트는 저장해야할 리소스의 위치를 모르기 때문에 지정해줄 수 없다. 즉, 리소스의 URI 결정권이 전적으로 서버측에 있다.  \n\n```json\nPOST /customers HTTP/1.1\n{ \"name\": \"Bob\", \"age\": 17  }\n\nHTTP/1.1 201 Created\n```\n\n위 예제에서 `{ \"name\": \"Bob\", \"age\": 17  }`는 POST요청으로 새롭게 생성될 리소스(하위 리소스)이며 부모(싱위 리소스)인 customers 아래에 생성된다. POST로 생성되는 리소스는 요청마다 다른 위치에 배정된다. 위 리소스의 위치는 `/customers/2`로 지정되며 만약 동일한 리소스에 대한 POST 요청을 한번 더 보내면 위치만 다르게(`/customers/3`) 같은 리소스가 생성될 것이다.  \n\n이처럼 POST는 not idempotent하다. POST 요청은 보내는 족족 서버는 새로운 위치에 새로운 리소스를 만든다.\n\n<br>\n\n### PUT\n\nPUT은 **클라이언트가 지정한 위치에** 리소스를 생성하거나 업데이트(update/replace)한다. 클라이언트가 리소스를 저장할 위치를 알고 있으며, URI에 대한 결정권은 전적으로 클라이언트측에 있다.  \n\nPUT은 리소스의 생성보다는 **수정/업데이트** 기능에 가장 많이 사용된다.  \n\n```json\nPUT /customers/3 HTTP/1.1\n{ \"name\": \"Ash\", \"age\": 28  }\n```\n\nPUT은 지정된 특정 위치의 리소스에 대해 제어하므로 동일 요청을 여러번으로 보내도 한번 보낸 것과 동일한 효과를 낸다. 즉, idempotent하다.\n\n---\n\n**Reference**\n\n[멱등성](https://ko.wikipedia.org/wiki/%EB%A9%B1%EB%93%B1%EB%B2%95%EC%B9%99)  \n\n[REST API: POST VS PUT](https://1ambda.github.io/javascripts/rest-api-put-vs-post/)   \n\n[What Is Idempotence?](http://www.restapitutorial.com/lessons/idempotency.html)  \n\n[When should we use PUT and when should we use POST?](http://restcookbook.com/HTTP%20Methods/put-vs-post/)  \n\n[POST vs PUT](http://blog.embian.com/66)  \n","source":"_posts/nodejs/00.POST VS PUT.md","raw":"---\ntitle: '[node]  REST API: POST VS PUT'\ndate: 2017-09-09 18:42:28\ncategory: Nodejs\ntags: idempotent\n---\n\n![](http://allvectorlogo.com/img/2016/05/node-js-logo.png)\n\n# REST API: POST VS PUT\n\nPOST와 PUT은 CRUD로직중 Create와 Update의 속성을 가진 http 메소드이다.\n\n정의만 보면 둘은 동일한 작업을 하는 것 같다. 둘은 어떤 차이가 있는가?\n\n## Idempotent\n\n첫번째 차이는 [멱등성(Idempotent)](https://ko.wikipedia.org/wiki/%EB%A9%B1%EB%93%B1%EB%B2%95%EC%B9%99)이다. 멱등성이란 단항연산 ƒ에 대해 결과 값이 항상 자기 자신을 향하는 성질이다. 이러한 성질을 수식으로 표현하면 아래와 같다.  \n\n### *ƒ(ƒ(x)) = ƒ(x)*  \n\n한마디로, 같은 연산을 무한정 반복해도 결과는 **항상 동일한 값을 갖는다**는 말이다.  \n\nRESTful 서비스 관점에서, 연산(서비스 호출)이 idempotent하려면, 클라이언트가 (의도했거나 말거나) 동일한 요청을 반복적으로 보내도 한번 요청했을 때와 같은 결과를 산출할 수 있어야 한다. 결론부터 말하면, PUT은 멱등성을 가지고 있지만 POST는 그렇지 못하다.\n\n## 리소스 결정권\n\n두번째 차이는 리소스 결정권을 누가 가지고 있는가이다. URI에 대한 결정권이 POST는 서버측에 있으며 PUT은 클라이언트 측에 있다.\n\n<br>\n\n\n### POST\n\nPOST는 새로운 리소스(자원)를 생성(create)할 때 주로 사용된다. 특히 하위 리소스를 만드는 데 주로 사용된다. 즉, POST로 생성하는 리소스는 상위 리소스에 종속된다. 부모(상위) 리소스에 POST를 보내면 **서비스가 부모와 새로 생성할 리소스를 연결하고 ID(새 리소스의 URI)를 할당하는 등의 작업을 처리한다.** 클라이언트는 저장해야할 리소스의 위치를 모르기 때문에 지정해줄 수 없다. 즉, 리소스의 URI 결정권이 전적으로 서버측에 있다.  \n\n```json\nPOST /customers HTTP/1.1\n{ \"name\": \"Bob\", \"age\": 17  }\n\nHTTP/1.1 201 Created\n```\n\n위 예제에서 `{ \"name\": \"Bob\", \"age\": 17  }`는 POST요청으로 새롭게 생성될 리소스(하위 리소스)이며 부모(싱위 리소스)인 customers 아래에 생성된다. POST로 생성되는 리소스는 요청마다 다른 위치에 배정된다. 위 리소스의 위치는 `/customers/2`로 지정되며 만약 동일한 리소스에 대한 POST 요청을 한번 더 보내면 위치만 다르게(`/customers/3`) 같은 리소스가 생성될 것이다.  \n\n이처럼 POST는 not idempotent하다. POST 요청은 보내는 족족 서버는 새로운 위치에 새로운 리소스를 만든다.\n\n<br>\n\n### PUT\n\nPUT은 **클라이언트가 지정한 위치에** 리소스를 생성하거나 업데이트(update/replace)한다. 클라이언트가 리소스를 저장할 위치를 알고 있으며, URI에 대한 결정권은 전적으로 클라이언트측에 있다.  \n\nPUT은 리소스의 생성보다는 **수정/업데이트** 기능에 가장 많이 사용된다.  \n\n```json\nPUT /customers/3 HTTP/1.1\n{ \"name\": \"Ash\", \"age\": 28  }\n```\n\nPUT은 지정된 특정 위치의 리소스에 대해 제어하므로 동일 요청을 여러번으로 보내도 한번 보낸 것과 동일한 효과를 낸다. 즉, idempotent하다.\n\n---\n\n**Reference**\n\n[멱등성](https://ko.wikipedia.org/wiki/%EB%A9%B1%EB%93%B1%EB%B2%95%EC%B9%99)  \n\n[REST API: POST VS PUT](https://1ambda.github.io/javascripts/rest-api-put-vs-post/)   \n\n[What Is Idempotence?](http://www.restapitutorial.com/lessons/idempotency.html)  \n\n[When should we use PUT and when should we use POST?](http://restcookbook.com/HTTP%20Methods/put-vs-post/)  \n\n[POST vs PUT](http://blog.embian.com/66)  \n","slug":"nodejs/00.POST VS PUT","published":1,"updated":"2017-09-21T06:06:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjai8h187000tvb9qmy3la3ls","content":"<p><img src=\"http://allvectorlogo.com/img/2016/05/node-js-logo.png\" alt=\"\"></p><h1 id=\"REST-API-POST-VS-PUT\"><a href=\"#REST-API-POST-VS-PUT\" class=\"headerlink\" title=\"REST API: POST VS PUT\"></a>REST API: POST VS PUT</h1><p>POST와 PUT은 CRUD로직중 Create와 Update의 속성을 가진 http 메소드이다.</p><p>정의만 보면 둘은 동일한 작업을 하는 것 같다. 둘은 어떤 차이가 있는가?</p><h2 id=\"Idempotent\"><a href=\"#Idempotent\" class=\"headerlink\" title=\"Idempotent\"></a>Idempotent</h2><p>첫번째 차이는 <a href=\"https://ko.wikipedia.org/wiki/%EB%A9%B1%EB%93%B1%EB%B2%95%EC%B9%99\" target=\"_blank\" rel=\"external\">멱등성(Idempotent)</a>이다. 멱등성이란 단항연산 ƒ에 대해 결과 값이 항상 자기 자신을 향하는 성질이다. 이러한 성질을 수식으로 표현하면 아래와 같다.</p><h3 id=\"f-f-x-f-x\"><a href=\"#f-f-x-f-x\" class=\"headerlink\" title=\"ƒ(ƒ(x)) = ƒ(x)\"></a><em>ƒ(ƒ(x)) = ƒ(x)</em></h3><p>한마디로, 같은 연산을 무한정 반복해도 결과는 <strong>항상 동일한 값을 갖는다</strong>는 말이다.</p><p>RESTful 서비스 관점에서, 연산(서비스 호출)이 idempotent하려면, 클라이언트가 (의도했거나 말거나) 동일한 요청을 반복적으로 보내도 한번 요청했을 때와 같은 결과를 산출할 수 있어야 한다. 결론부터 말하면, PUT은 멱등성을 가지고 있지만 POST는 그렇지 못하다.</p><h2 id=\"리소스-결정권\"><a href=\"#리소스-결정권\" class=\"headerlink\" title=\"리소스 결정권\"></a>리소스 결정권</h2><p>두번째 차이는 리소스 결정권을 누가 가지고 있는가이다. URI에 대한 결정권이 POST는 서버측에 있으며 PUT은 클라이언트 측에 있다.</p><p><br></p><h3 id=\"POST\"><a href=\"#POST\" class=\"headerlink\" title=\"POST\"></a>POST</h3><p>POST는 새로운 리소스(자원)를 생성(create)할 때 주로 사용된다. 특히 하위 리소스를 만드는 데 주로 사용된다. 즉, POST로 생성하는 리소스는 상위 리소스에 종속된다. 부모(상위) 리소스에 POST를 보내면 <strong>서비스가 부모와 새로 생성할 리소스를 연결하고 ID(새 리소스의 URI)를 할당하는 등의 작업을 처리한다.</strong> 클라이언트는 저장해야할 리소스의 위치를 모르기 때문에 지정해줄 수 없다. 즉, 리소스의 URI 결정권이 전적으로 서버측에 있다.</p><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">POST /customers HTTP/1.1</div><div class=\"line\">&#123; <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Bob\"</span>, <span class=\"attr\">\"age\"</span>: <span class=\"number\">17</span>  &#125;</div><div class=\"line\"></div><div class=\"line\">HTTP/1.1 201 Created</div></pre></td></tr></table></figure><p>위 예제에서 <code>{ &quot;name&quot;: &quot;Bob&quot;, &quot;age&quot;: 17 }</code>는 POST요청으로 새롭게 생성될 리소스(하위 리소스)이며 부모(싱위 리소스)인 customers 아래에 생성된다. POST로 생성되는 리소스는 요청마다 다른 위치에 배정된다. 위 리소스의 위치는 <code>/customers/2</code>로 지정되며 만약 동일한 리소스에 대한 POST 요청을 한번 더 보내면 위치만 다르게(<code>/customers/3</code>) 같은 리소스가 생성될 것이다.</p><p>이처럼 POST는 not idempotent하다. POST 요청은 보내는 족족 서버는 새로운 위치에 새로운 리소스를 만든다.</p><p><br></p><h3 id=\"PUT\"><a href=\"#PUT\" class=\"headerlink\" title=\"PUT\"></a>PUT</h3><p>PUT은 <strong>클라이언트가 지정한 위치에</strong> 리소스를 생성하거나 업데이트(update/replace)한다. 클라이언트가 리소스를 저장할 위치를 알고 있으며, URI에 대한 결정권은 전적으로 클라이언트측에 있다.</p><p>PUT은 리소스의 생성보다는 <strong>수정/업데이트</strong> 기능에 가장 많이 사용된다.</p><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">PUT /customers/3 HTTP/1.1</div><div class=\"line\">&#123; <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Ash\"</span>, <span class=\"attr\">\"age\"</span>: <span class=\"number\">28</span>  &#125;</div></pre></td></tr></table></figure><p>PUT은 지정된 특정 위치의 리소스에 대해 제어하므로 동일 요청을 여러번으로 보내도 한번 보낸 것과 동일한 효과를 낸다. 즉, idempotent하다.</p><hr><p><strong>Reference</strong></p><p><a href=\"https://ko.wikipedia.org/wiki/%EB%A9%B1%EB%93%B1%EB%B2%95%EC%B9%99\" target=\"_blank\" rel=\"external\">멱등성</a></p><p><a href=\"https://1ambda.github.io/javascripts/rest-api-put-vs-post/\" target=\"_blank\" rel=\"external\">REST API: POST VS PUT</a></p><p><a href=\"http://www.restapitutorial.com/lessons/idempotency.html\" target=\"_blank\" rel=\"external\">What Is Idempotence?</a></p><p><a href=\"http://restcookbook.com/HTTP%20Methods/put-vs-post/\" target=\"_blank\" rel=\"external\">When should we use PUT and when should we use POST?</a></p><p><a href=\"http://blog.embian.com/66\" target=\"_blank\" rel=\"external\">POST vs PUT</a></p>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://allvectorlogo.com/img/2016/05/node-js-logo.png\" alt=\"\"></p><h1 id=\"REST-API-POST-VS-PUT\"><a href=\"#REST-API-POST-VS-PUT\" class=\"headerlink\" title=\"REST API: POST VS PUT\"></a>REST API: POST VS PUT</h1><p>POST와 PUT은 CRUD로직중 Create와 Update의 속성을 가진 http 메소드이다.</p><p>정의만 보면 둘은 동일한 작업을 하는 것 같다. 둘은 어떤 차이가 있는가?</p><h2 id=\"Idempotent\"><a href=\"#Idempotent\" class=\"headerlink\" title=\"Idempotent\"></a>Idempotent</h2><p>첫번째 차이는 <a href=\"https://ko.wikipedia.org/wiki/%EB%A9%B1%EB%93%B1%EB%B2%95%EC%B9%99\" target=\"_blank\" rel=\"external\">멱등성(Idempotent)</a>이다. 멱등성이란 단항연산 ƒ에 대해 결과 값이 항상 자기 자신을 향하는 성질이다. 이러한 성질을 수식으로 표현하면 아래와 같다.</p><h3 id=\"f-f-x-f-x\"><a href=\"#f-f-x-f-x\" class=\"headerlink\" title=\"ƒ(ƒ(x)) = ƒ(x)\"></a><em>ƒ(ƒ(x)) = ƒ(x)</em></h3><p>한마디로, 같은 연산을 무한정 반복해도 결과는 <strong>항상 동일한 값을 갖는다</strong>는 말이다.</p><p>RESTful 서비스 관점에서, 연산(서비스 호출)이 idempotent하려면, 클라이언트가 (의도했거나 말거나) 동일한 요청을 반복적으로 보내도 한번 요청했을 때와 같은 결과를 산출할 수 있어야 한다. 결론부터 말하면, PUT은 멱등성을 가지고 있지만 POST는 그렇지 못하다.</p><h2 id=\"리소스-결정권\"><a href=\"#리소스-결정권\" class=\"headerlink\" title=\"리소스 결정권\"></a>리소스 결정권</h2><p>두번째 차이는 리소스 결정권을 누가 가지고 있는가이다. URI에 대한 결정권이 POST는 서버측에 있으며 PUT은 클라이언트 측에 있다.</p><p><br></p><h3 id=\"POST\"><a href=\"#POST\" class=\"headerlink\" title=\"POST\"></a>POST</h3><p>POST는 새로운 리소스(자원)를 생성(create)할 때 주로 사용된다. 특히 하위 리소스를 만드는 데 주로 사용된다. 즉, POST로 생성하는 리소스는 상위 리소스에 종속된다. 부모(상위) 리소스에 POST를 보내면 <strong>서비스가 부모와 새로 생성할 리소스를 연결하고 ID(새 리소스의 URI)를 할당하는 등의 작업을 처리한다.</strong> 클라이언트는 저장해야할 리소스의 위치를 모르기 때문에 지정해줄 수 없다. 즉, 리소스의 URI 결정권이 전적으로 서버측에 있다.</p><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">POST /customers HTTP/1.1</div><div class=\"line\">&#123; <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Bob\"</span>, <span class=\"attr\">\"age\"</span>: <span class=\"number\">17</span>  &#125;</div><div class=\"line\"></div><div class=\"line\">HTTP/1.1 201 Created</div></pre></td></tr></table></figure><p>위 예제에서 <code>{ &quot;name&quot;: &quot;Bob&quot;, &quot;age&quot;: 17 }</code>는 POST요청으로 새롭게 생성될 리소스(하위 리소스)이며 부모(싱위 리소스)인 customers 아래에 생성된다. POST로 생성되는 리소스는 요청마다 다른 위치에 배정된다. 위 리소스의 위치는 <code>/customers/2</code>로 지정되며 만약 동일한 리소스에 대한 POST 요청을 한번 더 보내면 위치만 다르게(<code>/customers/3</code>) 같은 리소스가 생성될 것이다.</p><p>이처럼 POST는 not idempotent하다. POST 요청은 보내는 족족 서버는 새로운 위치에 새로운 리소스를 만든다.</p><p><br></p><h3 id=\"PUT\"><a href=\"#PUT\" class=\"headerlink\" title=\"PUT\"></a>PUT</h3><p>PUT은 <strong>클라이언트가 지정한 위치에</strong> 리소스를 생성하거나 업데이트(update/replace)한다. 클라이언트가 리소스를 저장할 위치를 알고 있으며, URI에 대한 결정권은 전적으로 클라이언트측에 있다.</p><p>PUT은 리소스의 생성보다는 <strong>수정/업데이트</strong> 기능에 가장 많이 사용된다.</p><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">PUT /customers/3 HTTP/1.1</div><div class=\"line\">&#123; <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Ash\"</span>, <span class=\"attr\">\"age\"</span>: <span class=\"number\">28</span>  &#125;</div></pre></td></tr></table></figure><p>PUT은 지정된 특정 위치의 리소스에 대해 제어하므로 동일 요청을 여러번으로 보내도 한번 보낸 것과 동일한 효과를 낸다. 즉, idempotent하다.</p><hr><p><strong>Reference</strong></p><p><a href=\"https://ko.wikipedia.org/wiki/%EB%A9%B1%EB%93%B1%EB%B2%95%EC%B9%99\" target=\"_blank\" rel=\"external\">멱등성</a></p><p><a href=\"https://1ambda.github.io/javascripts/rest-api-put-vs-post/\" target=\"_blank\" rel=\"external\">REST API: POST VS PUT</a></p><p><a href=\"http://www.restapitutorial.com/lessons/idempotency.html\" target=\"_blank\" rel=\"external\">What Is Idempotence?</a></p><p><a href=\"http://restcookbook.com/HTTP%20Methods/put-vs-post/\" target=\"_blank\" rel=\"external\">When should we use PUT and when should we use POST?</a></p><p><a href=\"http://blog.embian.com/66\" target=\"_blank\" rel=\"external\">POST vs PUT</a></p>"},{"title":"[node] HTTP","date":"2017-08-29T15:40:30.000Z","_content":"\n![](http://allvectorlogo.com/img/2016/05/node-js-logo.png)\n\n# HTTP\n\n## 네트워크 확인하기\n\n### 1) wireshark\n\n![WIRESHARK](/images/WIRESHARK.png)\n\n![WIRESHARK](/images/WIRESHARK2.png)\n\n### 2) 크롬 개발자도구\n\n![크롬 개발자도구](/images/chromeDevTools.png)\n\n<br>\n\n## HTTP\n\n![](/images/http.png)\n\n* 웹 브라우저와 웹 서버 간의 통신을 위해 개발된 통신규약\n* 최근에는 REST API의 부상와 함께 다른 용도로도 널리 사용된다.\n  * 모바일 앱 - 서버 간 통신\n  * 서버 - 서버 간 통신\n* 80번 포트를 기본으로 사용\n* 클라이언트의 요청(request)과 서버의 응답(response)으로 이루어진다.\n\n### 1) http의 역사\n**1991**  \nHTTP 초기버전 발표. 텍스트만 전송할 수 있는 극도로 단순한 프로토콜. 1990년대 초 인터넷 붐을 일으킴\n\n**1996**  \n여러 인터넷 서비스 업체들이 자체적으로 사용하던 HTTP 구현들을 모아 HTTP 1.0 발표\n\n**1999**  \n1.0의 문제를 해결하고 여러가지 기능을 추가한 HTTP 1.1을 발표. 지금까지 사용되고 있는 버전\n\n<br>\n\n### 2) HTTPS\n\n![](/images/https.png)\n\n* HTTP over SSL\n* HTTP 통신을 암호화해 주고 받는 내용을 중간에서 가로챌 수 없도록 한다.\n* 443번 포트를 기본으로 사용한다.\n\n\n### 3) HTTP/2\n* 구글의 [SPDY](http://d2.naver.com/helloworld/140351) 프로토콜을 기반으로 2015년에 확정된 새로운 HTTP 표준\n* 0,1만으로 통신하는 프로토콜로 더이상 텍스트 기반이 아님\n* 오로지 **속도 개선**에 중점을 두고 개발됨\n* 반드시 HTTPS를 사용해야 함\n* [현재 전체 웹사이트 중 16% 이상이 사용중](https://w3techs.com/technologies/details/ce-http2/all/all)\n\n## HTTP 작동방식 \n\n### 1) Request & Response\n* 요청 Request: 웹 브라우저(또는 다른 클라이언트)는 웹 서버에 요청(request)를 보냄\n* 응답 Response: 그에 따라 서버는 클라이언트에 응답(response)를 보냄\n* 웹 브라우저의 경우, HTML 문서 형태의 응답이 오면 해당 문서를 분석한 후, 문서에 포함된 모든 자원에 대한 요청을 각각 추가로 보냄 (이미지, 동영상, 오디오, CSS, JS, 폰트, ...)\n\n### 2) Request Methods\n\n* [HTTP 명세](https://developer.mozilla.org/ko/docs/Web/HTTP/Methods)에는 8 종류가 등록되어 있고, 각각의 역할과 충족해야 하는 성질이 명시되어 있음\n* 웹 브라우저는 **특정 상황에서 특정 메소드로 요청을 보내도록** 만들어져 있음\n* Ajax와 같이 **요청을 보내는 코드를 직접 짤 때**는 요청 메소드를 선택할 수 있음\n* **자료의 본문을 요청하는 GET 메소드**와, 새로운 **자료를 등록하는 POST 메소드**가 가장 많이 쓰임\n\n웹 브라우저는 순수 HTML만으로는 GET과 POST 메소드만 사용할 수 있도록 강제하고 있다. AJAX등으로 코드를 직접 작성할 때에는 메소드를 자유롭게 선택하여 사용할 수 있다.\n\n### 서버가 충족시켜야하는 메소드의 성질\n\n* Safe  \n\n요청이 서버의 상태에 영향을 미치지 않아야 함. 즉, **읽기 전용**이어야 함이 표준에 명시되어 있다.\n\n* Idempotent  \n\n여러 번 같은 요청을 해도 한 번 요청한 것과 같은 효과여야 함. **네트워크가 불안정해도 안전하게 요청을 보낼 수 있음**\n\n> DELETE, GET은 Idempotent을 만족해야 한다. 게시글의 삭제 요청을 여러번 보내도 한 번의 삭제 작업이 이루어져야 한다. GET도 마찬가지로, 여러번 요청이 가도 한 번만 GET 작업을 해야한다.\n\n> POST는 데이터를 서버로 보내는 방법이다. 자료를 새로 만들 때 사용된다. 게시물을 만드는 요청을 서버에 보내다가 네트워크가 끊어진 상황을 가정했을 때, 서버에는 이미 해당 데이터가 만들어졌으므로 이후 같은 요청을 보내면 에러가 나야 한다. 따라서 POST는 Idempotent를 만족시켜서는 안 된다.\n\n* Cacheable  \n\n(특정 조건을 만족하면) 응답을 클라이언트에 저장해두었다가 다음 번 요청 때 **다시 쓸 수 있음**  \n\n<br>\n\n### 3) URL\n\n![URL](https://cascadingmedia.com/assets/images/insites/2015/02/url-anatomy/url-anatomy-55598c24.png)\n\n---\n\n<서버의 위치>\n\n1. 스키마\n\n2. 서브 도메인\n\n3. 도메인\n\n4. 탑레벨 도메인\n\n5. 포트\n\n---\n\n<서버에서 얻고자 하는 자원의 위치>\n\n6. 경로(path)\n\n7. 쿼리 스트링 \n\n8. 해시 (fragment identifier)\n\n### 4) Percent Encoding\n\n* URL은 ASCII 문자(128개의 영문자+특수문자+제어문자)밖에 사용하지 못하기 때문에, non-ASCII 문자를 위한 표현방법이 필요함 #\n\n* Percent encoding은 non-ASCII 문자를 위한 웹 표준 인코딩 방법으로, JavaScript에 관련 기능이 포함되어 있음\n\n```\n> encodeURIComponent(\"한글\")\n\"%ED%95%9C%EA%B8%80\"\n> decodeURIComponent(\"%ED%95%9C%EA%B8%80\")\n\"한글\"\n```\n\n![퍼센트인코딩](/images/퍼센트인코딩.png)\n\n\n### 5) Request Target\n\n일반적인 경우 아래와 같은 구조가 사용됨  \n\n`absolute path + query string + fragment id`\n\n절대 경로 + 쿼리스트링 + 해시  \n\n`GET /path/to/resource?foo=bar&spam=hoge#fragid HTTP/1.1`\n\n\n### 6) Response Status\n\n응답의 성공, 실패 여부와 종류를 나타내며, [상태 코드](https://httpstatuses.com/) + 상태 메시지의 형태로 응답에 포함됨\n\n`HTTP/1.1 200 OK`\n\n### [Status Category]\n\n**2xx** 성공\n\n  * 200 OK - 성공\n  * 201 Created - 자료가 성공적으로 생성되었다.\n\n**3xx** 추가 작업이 필요하다.\n\n  * 301 Moved Permanently (Redirection) - 자료가 완전히 다른 곳으로 이동했다.\n  * 302 Found (Redirection) - 자료가 일시적으로 다른 곳에 있다.\n  * 304 Not Modified (Cache) - 클라이언트가 이미 가지고 있던 자료가 수정되지 않았다. (그대로 사용하면 된다.) CSS나 Javascript에 대한 응답인 경우가 많다.\n\n**4xx** 실패 - 클라이언트 책임\n\n  * 400 Bad Request - 요청의 형태가 잘못되어 응답할 수 없다.\n  * 403 Forbidden - 요청한 자료에 접근할 권한이 없다.\n  * 404 Not Found - 요청한 자료가 없다.\n\n**5xx** 실패 - 서버 책임\n\n  * 500 Internal Server Error - 요청을 처리하던 중에 예상치 못한 요류가 발생했다.\n  * 503 Service Unavailable - 서버가 일시적으로 응답을 할 수 없다.\n\n### 7) Header\n\n  * 요청과 응답에 대한 추가 정보를 표현하는 데 사용\n  * 인증, 캐싱, 쿠키, 보안, 내용협상, 프록시 등 웹 표준에 정의된 많은 기능을 제어하는 데 사용됨\n\n  * **Authorization**  \n    요청의 인증 정보\n  * **User-Agent**  \n    요청 중인 클라이언트의 정보\n  * **Location**  \n    301, 302 응답에서 자료의 위치\n  * **Accept**  \n    요청이 어떤 형태의 자료를 원하는지 나타냄\n  * **Content-Type**  \n    요청 혹은 응답이 어떤 형태의 자료인지 나타냄\n\n### 8) Content Negotiation\n\n요청의 Accept, Accept-Language 등의 헤더를 보고 서버가 그에 맞는 형태의 자료를 응답하는 절차를 content negotiation(내용 협상)이라고 함\n\n![](https://www.codeproject.com/KB/aspnet/1163143/Fig01-ContentNegotiation.png)\n\n클라이언트가 JSON이 필요하다는 요청을 보내면, 서버가 JSON포맷의 데이터를 보내준다. 만약 없다면 XML 또는 기타 다른 포맷의 데이터를 대신 보내주는데, 이 과정을 content negotiation: 내용 협상이라고 한다.\n","source":"_posts/nodejs/02.http.md","raw":"---\ntitle: '[node] HTTP'\ndate: 2017-08-30 00:40:30\ncategory: Nodejs\ntags: http\n---\n\n![](http://allvectorlogo.com/img/2016/05/node-js-logo.png)\n\n# HTTP\n\n## 네트워크 확인하기\n\n### 1) wireshark\n\n![WIRESHARK](/images/WIRESHARK.png)\n\n![WIRESHARK](/images/WIRESHARK2.png)\n\n### 2) 크롬 개발자도구\n\n![크롬 개발자도구](/images/chromeDevTools.png)\n\n<br>\n\n## HTTP\n\n![](/images/http.png)\n\n* 웹 브라우저와 웹 서버 간의 통신을 위해 개발된 통신규약\n* 최근에는 REST API의 부상와 함께 다른 용도로도 널리 사용된다.\n  * 모바일 앱 - 서버 간 통신\n  * 서버 - 서버 간 통신\n* 80번 포트를 기본으로 사용\n* 클라이언트의 요청(request)과 서버의 응답(response)으로 이루어진다.\n\n### 1) http의 역사\n**1991**  \nHTTP 초기버전 발표. 텍스트만 전송할 수 있는 극도로 단순한 프로토콜. 1990년대 초 인터넷 붐을 일으킴\n\n**1996**  \n여러 인터넷 서비스 업체들이 자체적으로 사용하던 HTTP 구현들을 모아 HTTP 1.0 발표\n\n**1999**  \n1.0의 문제를 해결하고 여러가지 기능을 추가한 HTTP 1.1을 발표. 지금까지 사용되고 있는 버전\n\n<br>\n\n### 2) HTTPS\n\n![](/images/https.png)\n\n* HTTP over SSL\n* HTTP 통신을 암호화해 주고 받는 내용을 중간에서 가로챌 수 없도록 한다.\n* 443번 포트를 기본으로 사용한다.\n\n\n### 3) HTTP/2\n* 구글의 [SPDY](http://d2.naver.com/helloworld/140351) 프로토콜을 기반으로 2015년에 확정된 새로운 HTTP 표준\n* 0,1만으로 통신하는 프로토콜로 더이상 텍스트 기반이 아님\n* 오로지 **속도 개선**에 중점을 두고 개발됨\n* 반드시 HTTPS를 사용해야 함\n* [현재 전체 웹사이트 중 16% 이상이 사용중](https://w3techs.com/technologies/details/ce-http2/all/all)\n\n## HTTP 작동방식 \n\n### 1) Request & Response\n* 요청 Request: 웹 브라우저(또는 다른 클라이언트)는 웹 서버에 요청(request)를 보냄\n* 응답 Response: 그에 따라 서버는 클라이언트에 응답(response)를 보냄\n* 웹 브라우저의 경우, HTML 문서 형태의 응답이 오면 해당 문서를 분석한 후, 문서에 포함된 모든 자원에 대한 요청을 각각 추가로 보냄 (이미지, 동영상, 오디오, CSS, JS, 폰트, ...)\n\n### 2) Request Methods\n\n* [HTTP 명세](https://developer.mozilla.org/ko/docs/Web/HTTP/Methods)에는 8 종류가 등록되어 있고, 각각의 역할과 충족해야 하는 성질이 명시되어 있음\n* 웹 브라우저는 **특정 상황에서 특정 메소드로 요청을 보내도록** 만들어져 있음\n* Ajax와 같이 **요청을 보내는 코드를 직접 짤 때**는 요청 메소드를 선택할 수 있음\n* **자료의 본문을 요청하는 GET 메소드**와, 새로운 **자료를 등록하는 POST 메소드**가 가장 많이 쓰임\n\n웹 브라우저는 순수 HTML만으로는 GET과 POST 메소드만 사용할 수 있도록 강제하고 있다. AJAX등으로 코드를 직접 작성할 때에는 메소드를 자유롭게 선택하여 사용할 수 있다.\n\n### 서버가 충족시켜야하는 메소드의 성질\n\n* Safe  \n\n요청이 서버의 상태에 영향을 미치지 않아야 함. 즉, **읽기 전용**이어야 함이 표준에 명시되어 있다.\n\n* Idempotent  \n\n여러 번 같은 요청을 해도 한 번 요청한 것과 같은 효과여야 함. **네트워크가 불안정해도 안전하게 요청을 보낼 수 있음**\n\n> DELETE, GET은 Idempotent을 만족해야 한다. 게시글의 삭제 요청을 여러번 보내도 한 번의 삭제 작업이 이루어져야 한다. GET도 마찬가지로, 여러번 요청이 가도 한 번만 GET 작업을 해야한다.\n\n> POST는 데이터를 서버로 보내는 방법이다. 자료를 새로 만들 때 사용된다. 게시물을 만드는 요청을 서버에 보내다가 네트워크가 끊어진 상황을 가정했을 때, 서버에는 이미 해당 데이터가 만들어졌으므로 이후 같은 요청을 보내면 에러가 나야 한다. 따라서 POST는 Idempotent를 만족시켜서는 안 된다.\n\n* Cacheable  \n\n(특정 조건을 만족하면) 응답을 클라이언트에 저장해두었다가 다음 번 요청 때 **다시 쓸 수 있음**  \n\n<br>\n\n### 3) URL\n\n![URL](https://cascadingmedia.com/assets/images/insites/2015/02/url-anatomy/url-anatomy-55598c24.png)\n\n---\n\n<서버의 위치>\n\n1. 스키마\n\n2. 서브 도메인\n\n3. 도메인\n\n4. 탑레벨 도메인\n\n5. 포트\n\n---\n\n<서버에서 얻고자 하는 자원의 위치>\n\n6. 경로(path)\n\n7. 쿼리 스트링 \n\n8. 해시 (fragment identifier)\n\n### 4) Percent Encoding\n\n* URL은 ASCII 문자(128개의 영문자+특수문자+제어문자)밖에 사용하지 못하기 때문에, non-ASCII 문자를 위한 표현방법이 필요함 #\n\n* Percent encoding은 non-ASCII 문자를 위한 웹 표준 인코딩 방법으로, JavaScript에 관련 기능이 포함되어 있음\n\n```\n> encodeURIComponent(\"한글\")\n\"%ED%95%9C%EA%B8%80\"\n> decodeURIComponent(\"%ED%95%9C%EA%B8%80\")\n\"한글\"\n```\n\n![퍼센트인코딩](/images/퍼센트인코딩.png)\n\n\n### 5) Request Target\n\n일반적인 경우 아래와 같은 구조가 사용됨  \n\n`absolute path + query string + fragment id`\n\n절대 경로 + 쿼리스트링 + 해시  \n\n`GET /path/to/resource?foo=bar&spam=hoge#fragid HTTP/1.1`\n\n\n### 6) Response Status\n\n응답의 성공, 실패 여부와 종류를 나타내며, [상태 코드](https://httpstatuses.com/) + 상태 메시지의 형태로 응답에 포함됨\n\n`HTTP/1.1 200 OK`\n\n### [Status Category]\n\n**2xx** 성공\n\n  * 200 OK - 성공\n  * 201 Created - 자료가 성공적으로 생성되었다.\n\n**3xx** 추가 작업이 필요하다.\n\n  * 301 Moved Permanently (Redirection) - 자료가 완전히 다른 곳으로 이동했다.\n  * 302 Found (Redirection) - 자료가 일시적으로 다른 곳에 있다.\n  * 304 Not Modified (Cache) - 클라이언트가 이미 가지고 있던 자료가 수정되지 않았다. (그대로 사용하면 된다.) CSS나 Javascript에 대한 응답인 경우가 많다.\n\n**4xx** 실패 - 클라이언트 책임\n\n  * 400 Bad Request - 요청의 형태가 잘못되어 응답할 수 없다.\n  * 403 Forbidden - 요청한 자료에 접근할 권한이 없다.\n  * 404 Not Found - 요청한 자료가 없다.\n\n**5xx** 실패 - 서버 책임\n\n  * 500 Internal Server Error - 요청을 처리하던 중에 예상치 못한 요류가 발생했다.\n  * 503 Service Unavailable - 서버가 일시적으로 응답을 할 수 없다.\n\n### 7) Header\n\n  * 요청과 응답에 대한 추가 정보를 표현하는 데 사용\n  * 인증, 캐싱, 쿠키, 보안, 내용협상, 프록시 등 웹 표준에 정의된 많은 기능을 제어하는 데 사용됨\n\n  * **Authorization**  \n    요청의 인증 정보\n  * **User-Agent**  \n    요청 중인 클라이언트의 정보\n  * **Location**  \n    301, 302 응답에서 자료의 위치\n  * **Accept**  \n    요청이 어떤 형태의 자료를 원하는지 나타냄\n  * **Content-Type**  \n    요청 혹은 응답이 어떤 형태의 자료인지 나타냄\n\n### 8) Content Negotiation\n\n요청의 Accept, Accept-Language 등의 헤더를 보고 서버가 그에 맞는 형태의 자료를 응답하는 절차를 content negotiation(내용 협상)이라고 함\n\n![](https://www.codeproject.com/KB/aspnet/1163143/Fig01-ContentNegotiation.png)\n\n클라이언트가 JSON이 필요하다는 요청을 보내면, 서버가 JSON포맷의 데이터를 보내준다. 만약 없다면 XML 또는 기타 다른 포맷의 데이터를 대신 보내주는데, 이 과정을 content negotiation: 내용 협상이라고 한다.\n","slug":"nodejs/02.http","published":1,"updated":"2017-09-21T06:07:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjai8h189000vvb9qwknochl1","content":"<p><img src=\"http://allvectorlogo.com/img/2016/05/node-js-logo.png\" alt=\"\"></p><h1 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h1><h2 id=\"네트워크-확인하기\"><a href=\"#네트워크-확인하기\" class=\"headerlink\" title=\"네트워크 확인하기\"></a>네트워크 확인하기</h2><h3 id=\"1-wireshark\"><a href=\"#1-wireshark\" class=\"headerlink\" title=\"1) wireshark\"></a>1) wireshark</h3><p><img src=\"/images/WIRESHARK.png\" alt=\"WIRESHARK\"></p><p><img src=\"/images/WIRESHARK2.png\" alt=\"WIRESHARK\"></p><h3 id=\"2-크롬-개발자도구\"><a href=\"#2-크롬-개발자도구\" class=\"headerlink\" title=\"2) 크롬 개발자도구\"></a>2) 크롬 개발자도구</h3><p><img src=\"/images/chromeDevTools.png\" alt=\"크롬 개발자도구\"></p><p><br></p><h2 id=\"HTTP-1\"><a href=\"#HTTP-1\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h2><p><img src=\"/images/http.png\" alt=\"\"></p><ul><li>웹 브라우저와 웹 서버 간의 통신을 위해 개발된 통신규약</li><li>최근에는 REST API의 부상와 함께 다른 용도로도 널리 사용된다.<ul><li>모바일 앱 - 서버 간 통신</li><li>서버 - 서버 간 통신</li></ul></li><li>80번 포트를 기본으로 사용</li><li>클라이언트의 요청(request)과 서버의 응답(response)으로 이루어진다.</li></ul><h3 id=\"1-http의-역사\"><a href=\"#1-http의-역사\" class=\"headerlink\" title=\"1) http의 역사\"></a>1) http의 역사</h3><p><strong>1991</strong><br>HTTP 초기버전 발표. 텍스트만 전송할 수 있는 극도로 단순한 프로토콜. 1990년대 초 인터넷 붐을 일으킴</p><p><strong>1996</strong><br>여러 인터넷 서비스 업체들이 자체적으로 사용하던 HTTP 구현들을 모아 HTTP 1.0 발표</p><p><strong>1999</strong><br>1.0의 문제를 해결하고 여러가지 기능을 추가한 HTTP 1.1을 발표. 지금까지 사용되고 있는 버전</p><p><br></p><h3 id=\"2-HTTPS\"><a href=\"#2-HTTPS\" class=\"headerlink\" title=\"2) HTTPS\"></a>2) HTTPS</h3><p><img src=\"/images/https.png\" alt=\"\"></p><ul><li>HTTP over SSL</li><li>HTTP 통신을 암호화해 주고 받는 내용을 중간에서 가로챌 수 없도록 한다.</li><li>443번 포트를 기본으로 사용한다.</li></ul><h3 id=\"3-HTTP-2\"><a href=\"#3-HTTP-2\" class=\"headerlink\" title=\"3) HTTP/2\"></a>3) HTTP/2</h3><ul><li>구글의 <a href=\"http://d2.naver.com/helloworld/140351\" target=\"_blank\" rel=\"external\">SPDY</a> 프로토콜을 기반으로 2015년에 확정된 새로운 HTTP 표준</li><li>0,1만으로 통신하는 프로토콜로 더이상 텍스트 기반이 아님</li><li>오로지 <strong>속도 개선</strong>에 중점을 두고 개발됨</li><li>반드시 HTTPS를 사용해야 함</li><li><a href=\"https://w3techs.com/technologies/details/ce-http2/all/all\" target=\"_blank\" rel=\"external\">현재 전체 웹사이트 중 16% 이상이 사용중</a></li></ul><h2 id=\"HTTP-작동방식\"><a href=\"#HTTP-작동방식\" class=\"headerlink\" title=\"HTTP 작동방식\"></a>HTTP 작동방식</h2><h3 id=\"1-Request-amp-Response\"><a href=\"#1-Request-amp-Response\" class=\"headerlink\" title=\"1) Request &amp; Response\"></a>1) Request &amp; Response</h3><ul><li>요청 Request: 웹 브라우저(또는 다른 클라이언트)는 웹 서버에 요청(request)를 보냄</li><li>응답 Response: 그에 따라 서버는 클라이언트에 응답(response)를 보냄</li><li>웹 브라우저의 경우, HTML 문서 형태의 응답이 오면 해당 문서를 분석한 후, 문서에 포함된 모든 자원에 대한 요청을 각각 추가로 보냄 (이미지, 동영상, 오디오, CSS, JS, 폰트, …)</li></ul><h3 id=\"2-Request-Methods\"><a href=\"#2-Request-Methods\" class=\"headerlink\" title=\"2) Request Methods\"></a>2) Request Methods</h3><ul><li><a href=\"https://developer.mozilla.org/ko/docs/Web/HTTP/Methods\" target=\"_blank\" rel=\"external\">HTTP 명세</a>에는 8 종류가 등록되어 있고, 각각의 역할과 충족해야 하는 성질이 명시되어 있음</li><li>웹 브라우저는 <strong>특정 상황에서 특정 메소드로 요청을 보내도록</strong> 만들어져 있음</li><li>Ajax와 같이 <strong>요청을 보내는 코드를 직접 짤 때</strong>는 요청 메소드를 선택할 수 있음</li><li><strong>자료의 본문을 요청하는 GET 메소드</strong>와, 새로운 <strong>자료를 등록하는 POST 메소드</strong>가 가장 많이 쓰임</li></ul><p>웹 브라우저는 순수 HTML만으로는 GET과 POST 메소드만 사용할 수 있도록 강제하고 있다. AJAX등으로 코드를 직접 작성할 때에는 메소드를 자유롭게 선택하여 사용할 수 있다.</p><h3 id=\"서버가-충족시켜야하는-메소드의-성질\"><a href=\"#서버가-충족시켜야하는-메소드의-성질\" class=\"headerlink\" title=\"서버가 충족시켜야하는 메소드의 성질\"></a>서버가 충족시켜야하는 메소드의 성질</h3><ul><li>Safe</li></ul><p>요청이 서버의 상태에 영향을 미치지 않아야 함. 즉, <strong>읽기 전용</strong>이어야 함이 표준에 명시되어 있다.</p><ul><li>Idempotent</li></ul><p>여러 번 같은 요청을 해도 한 번 요청한 것과 같은 효과여야 함. <strong>네트워크가 불안정해도 안전하게 요청을 보낼 수 있음</strong></p><blockquote><p>DELETE, GET은 Idempotent을 만족해야 한다. 게시글의 삭제 요청을 여러번 보내도 한 번의 삭제 작업이 이루어져야 한다. GET도 마찬가지로, 여러번 요청이 가도 한 번만 GET 작업을 해야한다.</p><p>POST는 데이터를 서버로 보내는 방법이다. 자료를 새로 만들 때 사용된다. 게시물을 만드는 요청을 서버에 보내다가 네트워크가 끊어진 상황을 가정했을 때, 서버에는 이미 해당 데이터가 만들어졌으므로 이후 같은 요청을 보내면 에러가 나야 한다. 따라서 POST는 Idempotent를 만족시켜서는 안 된다.</p></blockquote><ul><li>Cacheable</li></ul><p>(특정 조건을 만족하면) 응답을 클라이언트에 저장해두었다가 다음 번 요청 때 <strong>다시 쓸 수 있음</strong></p><p><br></p><h3 id=\"3-URL\"><a href=\"#3-URL\" class=\"headerlink\" title=\"3) URL\"></a>3) URL</h3><p><img src=\"https://cascadingmedia.com/assets/images/insites/2015/02/url-anatomy/url-anatomy-55598c24.png\" alt=\"URL\"></p><hr><p>&lt;서버의 위치&gt;</p><ol><li><p>스키마</p></li><li><p>서브 도메인</p></li><li><p>도메인</p></li><li><p>탑레벨 도메인</p></li><li><p>포트</p></li></ol><hr><p>&lt;서버에서 얻고자 하는 자원의 위치&gt;</p><ol><li><p>경로(path)</p></li><li><p>쿼리 스트링</p></li><li><p>해시 (fragment identifier)</p></li></ol><h3 id=\"4-Percent-Encoding\"><a href=\"#4-Percent-Encoding\" class=\"headerlink\" title=\"4) Percent Encoding\"></a>4) Percent Encoding</h3><ul><li><p>URL은 ASCII 문자(128개의 영문자+특수문자+제어문자)밖에 사용하지 못하기 때문에, non-ASCII 문자를 위한 표현방법이 필요함 #</p></li><li><p>Percent encoding은 non-ASCII 문자를 위한 웹 표준 인코딩 방법으로, JavaScript에 관련 기능이 포함되어 있음</p></li></ul><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; encodeURIComponent(&quot;한글&quot;)</div><div class=\"line\">&quot;%ED%95%9C%EA%B8%80&quot;</div><div class=\"line\">&gt; decodeURIComponent(&quot;%ED%95%9C%EA%B8%80&quot;)</div><div class=\"line\">&quot;한글&quot;</div></pre></td></tr></table></figure><p><img src=\"/images/퍼센트인코딩.png\" alt=\"퍼센트인코딩\"></p><h3 id=\"5-Request-Target\"><a href=\"#5-Request-Target\" class=\"headerlink\" title=\"5) Request Target\"></a>5) Request Target</h3><p>일반적인 경우 아래와 같은 구조가 사용됨</p><p><code>absolute path + query string + fragment id</code></p><p>절대 경로 + 쿼리스트링 + 해시</p><p><code>GET /path/to/resource?foo=bar&amp;spam=hoge#fragid HTTP/1.1</code></p><h3 id=\"6-Response-Status\"><a href=\"#6-Response-Status\" class=\"headerlink\" title=\"6) Response Status\"></a>6) Response Status</h3><p>응답의 성공, 실패 여부와 종류를 나타내며, <a href=\"https://httpstatuses.com/\" target=\"_blank\" rel=\"external\">상태 코드</a> + 상태 메시지의 형태로 응답에 포함됨</p><p><code>HTTP/1.1 200 OK</code></p><h3 id=\"Status-Category\"><a href=\"#Status-Category\" class=\"headerlink\" title=\"[Status Category]\"></a>[Status Category]</h3><p><strong>2xx</strong> 성공</p><ul><li>200 OK - 성공</li><li>201 Created - 자료가 성공적으로 생성되었다.</li></ul><p><strong>3xx</strong> 추가 작업이 필요하다.</p><ul><li>301 Moved Permanently (Redirection) - 자료가 완전히 다른 곳으로 이동했다.</li><li>302 Found (Redirection) - 자료가 일시적으로 다른 곳에 있다.</li><li>304 Not Modified (Cache) - 클라이언트가 이미 가지고 있던 자료가 수정되지 않았다. (그대로 사용하면 된다.) CSS나 Javascript에 대한 응답인 경우가 많다.</li></ul><p><strong>4xx</strong> 실패 - 클라이언트 책임</p><ul><li>400 Bad Request - 요청의 형태가 잘못되어 응답할 수 없다.</li><li>403 Forbidden - 요청한 자료에 접근할 권한이 없다.</li><li>404 Not Found - 요청한 자료가 없다.</li></ul><p><strong>5xx</strong> 실패 - 서버 책임</p><ul><li>500 Internal Server Error - 요청을 처리하던 중에 예상치 못한 요류가 발생했다.</li><li>503 Service Unavailable - 서버가 일시적으로 응답을 할 수 없다.</li></ul><h3 id=\"7-Header\"><a href=\"#7-Header\" class=\"headerlink\" title=\"7) Header\"></a>7) Header</h3><ul><li>요청과 응답에 대한 추가 정보를 표현하는 데 사용</li><li><p>인증, 캐싱, 쿠키, 보안, 내용협상, 프록시 등 웹 표준에 정의된 많은 기능을 제어하는 데 사용됨</p></li><li><p><strong>Authorization</strong><br>요청의 인증 정보</p></li><li><strong>User-Agent</strong><br>요청 중인 클라이언트의 정보</li><li><strong>Location</strong><br>301, 302 응답에서 자료의 위치</li><li><strong>Accept</strong><br>요청이 어떤 형태의 자료를 원하는지 나타냄</li><li><strong>Content-Type</strong><br>요청 혹은 응답이 어떤 형태의 자료인지 나타냄</li></ul><h3 id=\"8-Content-Negotiation\"><a href=\"#8-Content-Negotiation\" class=\"headerlink\" title=\"8) Content Negotiation\"></a>8) Content Negotiation</h3><p>요청의 Accept, Accept-Language 등의 헤더를 보고 서버가 그에 맞는 형태의 자료를 응답하는 절차를 content negotiation(내용 협상)이라고 함</p><p><img src=\"https://www.codeproject.com/KB/aspnet/1163143/Fig01-ContentNegotiation.png\" alt=\"\"></p><p>클라이언트가 JSON이 필요하다는 요청을 보내면, 서버가 JSON포맷의 데이터를 보내준다. 만약 없다면 XML 또는 기타 다른 포맷의 데이터를 대신 보내주는데, 이 과정을 content negotiation: 내용 협상이라고 한다.</p>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://allvectorlogo.com/img/2016/05/node-js-logo.png\" alt=\"\"></p><h1 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h1><h2 id=\"네트워크-확인하기\"><a href=\"#네트워크-확인하기\" class=\"headerlink\" title=\"네트워크 확인하기\"></a>네트워크 확인하기</h2><h3 id=\"1-wireshark\"><a href=\"#1-wireshark\" class=\"headerlink\" title=\"1) wireshark\"></a>1) wireshark</h3><p><img src=\"/images/WIRESHARK.png\" alt=\"WIRESHARK\"></p><p><img src=\"/images/WIRESHARK2.png\" alt=\"WIRESHARK\"></p><h3 id=\"2-크롬-개발자도구\"><a href=\"#2-크롬-개발자도구\" class=\"headerlink\" title=\"2) 크롬 개발자도구\"></a>2) 크롬 개발자도구</h3><p><img src=\"/images/chromeDevTools.png\" alt=\"크롬 개발자도구\"></p><p><br></p><h2 id=\"HTTP-1\"><a href=\"#HTTP-1\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h2><p><img src=\"/images/http.png\" alt=\"\"></p><ul><li>웹 브라우저와 웹 서버 간의 통신을 위해 개발된 통신규약</li><li>최근에는 REST API의 부상와 함께 다른 용도로도 널리 사용된다.<ul><li>모바일 앱 - 서버 간 통신</li><li>서버 - 서버 간 통신</li></ul></li><li>80번 포트를 기본으로 사용</li><li>클라이언트의 요청(request)과 서버의 응답(response)으로 이루어진다.</li></ul><h3 id=\"1-http의-역사\"><a href=\"#1-http의-역사\" class=\"headerlink\" title=\"1) http의 역사\"></a>1) http의 역사</h3><p><strong>1991</strong><br>HTTP 초기버전 발표. 텍스트만 전송할 수 있는 극도로 단순한 프로토콜. 1990년대 초 인터넷 붐을 일으킴</p><p><strong>1996</strong><br>여러 인터넷 서비스 업체들이 자체적으로 사용하던 HTTP 구현들을 모아 HTTP 1.0 발표</p><p><strong>1999</strong><br>1.0의 문제를 해결하고 여러가지 기능을 추가한 HTTP 1.1을 발표. 지금까지 사용되고 있는 버전</p><p><br></p><h3 id=\"2-HTTPS\"><a href=\"#2-HTTPS\" class=\"headerlink\" title=\"2) HTTPS\"></a>2) HTTPS</h3><p><img src=\"/images/https.png\" alt=\"\"></p><ul><li>HTTP over SSL</li><li>HTTP 통신을 암호화해 주고 받는 내용을 중간에서 가로챌 수 없도록 한다.</li><li>443번 포트를 기본으로 사용한다.</li></ul><h3 id=\"3-HTTP-2\"><a href=\"#3-HTTP-2\" class=\"headerlink\" title=\"3) HTTP/2\"></a>3) HTTP/2</h3><ul><li>구글의 <a href=\"http://d2.naver.com/helloworld/140351\" target=\"_blank\" rel=\"external\">SPDY</a> 프로토콜을 기반으로 2015년에 확정된 새로운 HTTP 표준</li><li>0,1만으로 통신하는 프로토콜로 더이상 텍스트 기반이 아님</li><li>오로지 <strong>속도 개선</strong>에 중점을 두고 개발됨</li><li>반드시 HTTPS를 사용해야 함</li><li><a href=\"https://w3techs.com/technologies/details/ce-http2/all/all\" target=\"_blank\" rel=\"external\">현재 전체 웹사이트 중 16% 이상이 사용중</a></li></ul><h2 id=\"HTTP-작동방식\"><a href=\"#HTTP-작동방식\" class=\"headerlink\" title=\"HTTP 작동방식\"></a>HTTP 작동방식</h2><h3 id=\"1-Request-amp-Response\"><a href=\"#1-Request-amp-Response\" class=\"headerlink\" title=\"1) Request &amp; Response\"></a>1) Request &amp; Response</h3><ul><li>요청 Request: 웹 브라우저(또는 다른 클라이언트)는 웹 서버에 요청(request)를 보냄</li><li>응답 Response: 그에 따라 서버는 클라이언트에 응답(response)를 보냄</li><li>웹 브라우저의 경우, HTML 문서 형태의 응답이 오면 해당 문서를 분석한 후, 문서에 포함된 모든 자원에 대한 요청을 각각 추가로 보냄 (이미지, 동영상, 오디오, CSS, JS, 폰트, …)</li></ul><h3 id=\"2-Request-Methods\"><a href=\"#2-Request-Methods\" class=\"headerlink\" title=\"2) Request Methods\"></a>2) Request Methods</h3><ul><li><a href=\"https://developer.mozilla.org/ko/docs/Web/HTTP/Methods\" target=\"_blank\" rel=\"external\">HTTP 명세</a>에는 8 종류가 등록되어 있고, 각각의 역할과 충족해야 하는 성질이 명시되어 있음</li><li>웹 브라우저는 <strong>특정 상황에서 특정 메소드로 요청을 보내도록</strong> 만들어져 있음</li><li>Ajax와 같이 <strong>요청을 보내는 코드를 직접 짤 때</strong>는 요청 메소드를 선택할 수 있음</li><li><strong>자료의 본문을 요청하는 GET 메소드</strong>와, 새로운 <strong>자료를 등록하는 POST 메소드</strong>가 가장 많이 쓰임</li></ul><p>웹 브라우저는 순수 HTML만으로는 GET과 POST 메소드만 사용할 수 있도록 강제하고 있다. AJAX등으로 코드를 직접 작성할 때에는 메소드를 자유롭게 선택하여 사용할 수 있다.</p><h3 id=\"서버가-충족시켜야하는-메소드의-성질\"><a href=\"#서버가-충족시켜야하는-메소드의-성질\" class=\"headerlink\" title=\"서버가 충족시켜야하는 메소드의 성질\"></a>서버가 충족시켜야하는 메소드의 성질</h3><ul><li>Safe</li></ul><p>요청이 서버의 상태에 영향을 미치지 않아야 함. 즉, <strong>읽기 전용</strong>이어야 함이 표준에 명시되어 있다.</p><ul><li>Idempotent</li></ul><p>여러 번 같은 요청을 해도 한 번 요청한 것과 같은 효과여야 함. <strong>네트워크가 불안정해도 안전하게 요청을 보낼 수 있음</strong></p><blockquote><p>DELETE, GET은 Idempotent을 만족해야 한다. 게시글의 삭제 요청을 여러번 보내도 한 번의 삭제 작업이 이루어져야 한다. GET도 마찬가지로, 여러번 요청이 가도 한 번만 GET 작업을 해야한다.</p><p>POST는 데이터를 서버로 보내는 방법이다. 자료를 새로 만들 때 사용된다. 게시물을 만드는 요청을 서버에 보내다가 네트워크가 끊어진 상황을 가정했을 때, 서버에는 이미 해당 데이터가 만들어졌으므로 이후 같은 요청을 보내면 에러가 나야 한다. 따라서 POST는 Idempotent를 만족시켜서는 안 된다.</p></blockquote><ul><li>Cacheable</li></ul><p>(특정 조건을 만족하면) 응답을 클라이언트에 저장해두었다가 다음 번 요청 때 <strong>다시 쓸 수 있음</strong></p><p><br></p><h3 id=\"3-URL\"><a href=\"#3-URL\" class=\"headerlink\" title=\"3) URL\"></a>3) URL</h3><p><img src=\"https://cascadingmedia.com/assets/images/insites/2015/02/url-anatomy/url-anatomy-55598c24.png\" alt=\"URL\"></p><hr><p>&lt;서버의 위치&gt;</p><ol><li><p>스키마</p></li><li><p>서브 도메인</p></li><li><p>도메인</p></li><li><p>탑레벨 도메인</p></li><li><p>포트</p></li></ol><hr><p>&lt;서버에서 얻고자 하는 자원의 위치&gt;</p><ol><li><p>경로(path)</p></li><li><p>쿼리 스트링</p></li><li><p>해시 (fragment identifier)</p></li></ol><h3 id=\"4-Percent-Encoding\"><a href=\"#4-Percent-Encoding\" class=\"headerlink\" title=\"4) Percent Encoding\"></a>4) Percent Encoding</h3><ul><li><p>URL은 ASCII 문자(128개의 영문자+특수문자+제어문자)밖에 사용하지 못하기 때문에, non-ASCII 문자를 위한 표현방법이 필요함 #</p></li><li><p>Percent encoding은 non-ASCII 문자를 위한 웹 표준 인코딩 방법으로, JavaScript에 관련 기능이 포함되어 있음</p></li></ul><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; encodeURIComponent(&quot;한글&quot;)</div><div class=\"line\">&quot;%ED%95%9C%EA%B8%80&quot;</div><div class=\"line\">&gt; decodeURIComponent(&quot;%ED%95%9C%EA%B8%80&quot;)</div><div class=\"line\">&quot;한글&quot;</div></pre></td></tr></table></figure><p><img src=\"/images/퍼센트인코딩.png\" alt=\"퍼센트인코딩\"></p><h3 id=\"5-Request-Target\"><a href=\"#5-Request-Target\" class=\"headerlink\" title=\"5) Request Target\"></a>5) Request Target</h3><p>일반적인 경우 아래와 같은 구조가 사용됨</p><p><code>absolute path + query string + fragment id</code></p><p>절대 경로 + 쿼리스트링 + 해시</p><p><code>GET /path/to/resource?foo=bar&amp;spam=hoge#fragid HTTP/1.1</code></p><h3 id=\"6-Response-Status\"><a href=\"#6-Response-Status\" class=\"headerlink\" title=\"6) Response Status\"></a>6) Response Status</h3><p>응답의 성공, 실패 여부와 종류를 나타내며, <a href=\"https://httpstatuses.com/\" target=\"_blank\" rel=\"external\">상태 코드</a> + 상태 메시지의 형태로 응답에 포함됨</p><p><code>HTTP/1.1 200 OK</code></p><h3 id=\"Status-Category\"><a href=\"#Status-Category\" class=\"headerlink\" title=\"[Status Category]\"></a>[Status Category]</h3><p><strong>2xx</strong> 성공</p><ul><li>200 OK - 성공</li><li>201 Created - 자료가 성공적으로 생성되었다.</li></ul><p><strong>3xx</strong> 추가 작업이 필요하다.</p><ul><li>301 Moved Permanently (Redirection) - 자료가 완전히 다른 곳으로 이동했다.</li><li>302 Found (Redirection) - 자료가 일시적으로 다른 곳에 있다.</li><li>304 Not Modified (Cache) - 클라이언트가 이미 가지고 있던 자료가 수정되지 않았다. (그대로 사용하면 된다.) CSS나 Javascript에 대한 응답인 경우가 많다.</li></ul><p><strong>4xx</strong> 실패 - 클라이언트 책임</p><ul><li>400 Bad Request - 요청의 형태가 잘못되어 응답할 수 없다.</li><li>403 Forbidden - 요청한 자료에 접근할 권한이 없다.</li><li>404 Not Found - 요청한 자료가 없다.</li></ul><p><strong>5xx</strong> 실패 - 서버 책임</p><ul><li>500 Internal Server Error - 요청을 처리하던 중에 예상치 못한 요류가 발생했다.</li><li>503 Service Unavailable - 서버가 일시적으로 응답을 할 수 없다.</li></ul><h3 id=\"7-Header\"><a href=\"#7-Header\" class=\"headerlink\" title=\"7) Header\"></a>7) Header</h3><ul><li>요청과 응답에 대한 추가 정보를 표현하는 데 사용</li><li><p>인증, 캐싱, 쿠키, 보안, 내용협상, 프록시 등 웹 표준에 정의된 많은 기능을 제어하는 데 사용됨</p></li><li><p><strong>Authorization</strong><br>요청의 인증 정보</p></li><li><strong>User-Agent</strong><br>요청 중인 클라이언트의 정보</li><li><strong>Location</strong><br>301, 302 응답에서 자료의 위치</li><li><strong>Accept</strong><br>요청이 어떤 형태의 자료를 원하는지 나타냄</li><li><strong>Content-Type</strong><br>요청 혹은 응답이 어떤 형태의 자료인지 나타냄</li></ul><h3 id=\"8-Content-Negotiation\"><a href=\"#8-Content-Negotiation\" class=\"headerlink\" title=\"8) Content Negotiation\"></a>8) Content Negotiation</h3><p>요청의 Accept, Accept-Language 등의 헤더를 보고 서버가 그에 맞는 형태의 자료를 응답하는 절차를 content negotiation(내용 협상)이라고 함</p><p><img src=\"https://www.codeproject.com/KB/aspnet/1163143/Fig01-ContentNegotiation.png\" alt=\"\"></p><p>클라이언트가 JSON이 필요하다는 요청을 보내면, 서버가 JSON포맷의 데이터를 보내준다. 만약 없다면 XML 또는 기타 다른 포맷의 데이터를 대신 보내주는데, 이 과정을 content negotiation: 내용 협상이라고 한다.</p>"},{"title":"[node] node 시작하기","date":"2017-08-29T15:40:12.000Z","_content":"\n![](http://allvectorlogo.com/img/2016/05/node-js-logo.png)\n\n# nvm(node version manager)\n\n```bash\n# 주석: `#`으로 시작하는 명령은 bash에서 무시됩니다.\n# 아래 명령을 한 줄씩 차례대로 입력하세요\n$ nvm install 8.4\n$ nvm use 8.4\n$ nvm alias default 8.4 # nvm-windows는 필요없음\n```\n\n# Node.js REPL\n\nREPL(Read Eval Print Loop): 윈도우 커맨드, 혹은 UNIX/LINUX Shell처럼 사용자가 커맨드를 입력하면 시스템이 값을 반환하는 환경을 일컫는다. \n\nNode.js는 REPL 환경과 함께 제공되며 다음과 같은 기능을 수행할 수 있다.\n\n* Read: 유저의 값을 입력 받아 Javascript 데이터 구조로 메모리에 저장한다.\n* Eval: 데이터를 처리(Evaluate)한다.\n* Print: 결과값을 출력한다.\n* Loop: Read, Eval, Print를 유저가 Ctrl+C를 두 번 눌러 종료할 때까지 반복한다.\n\nNode.js 의 REPL 환경은 자바스크립트 코드의 테스팅 및 디버깅할 때 유용하게 사용된다.\n\n```bash\n// REPL 시작하기\n$ node\n\n// 한 줄 짜리 코드 입력하기\n> 'hello node'\n'hello node'\n\n// 위쪽 화살표 키를 입력해서 이전 명령 불러오기\n> 'hello node'\n'hello node'\n\n// Underscore(_) 변수\n밑줄 _변수는 최근 결과값을 지칭한다.\n> var x = 10;\nundefined\n> var y = 5;\nundefined\n> x+y;\n15\n> var sum = _\nundefined\n>console.log(sum)\n15\nundefined\n\n// 변수 사용하기\n> const factorial = n => n < 1 ? 1 : n * factorial(n-1)\nundefined\n\n> factorial(3)\n6\n\n// 여러 줄에 나눠서 입력하기\n> function factorial2(n) {\n... return n < 1 ? 1 : n * factorial(n-1)\n... }\nundefined\n\n> factorial2(4)\n24\n\n// `.exit`를 입력하거나 `Ctrl+C`를 두 번 입력해서 나가기\n> .exit\n\n// Node.js module 사용하기\n> const os = require('os') // 급할땐 `os = ...`\nundefined\n\n> os.platform()\n'linux'\n\n> os.freemem()\n658300928\n```\n\n# node.js로 파일 실행시키기\n\n```bash\n$ node (파일 경로)\n```\n\n# node.js\n\nNode.js®은 chrome의 v8 자바스크립트 엔진에 기반한 자바스크립트 런타임이다.\n\nNode.js는 가볍고 효율적인 event-driven, non-blocking I/O model을 사용한다. \n\nNode.js의 패키지 에코 시스템인 npm은 전 세계 오픈 소스 라이브러리 중 가장 큰 생태계(ecosystem)이다.\n\n## 1) JavaScript Runtime이란?\n\n* JavaScript는 언어\n* JavaScript 런타임(runtime)은 JS를 구동하기 위해 필요한 실행 환경\n* 프로그래머는 런타임이 제공하는 도구를 응용해서 프로그램을 개발\n* 웹 브라우저나 Node.js도 JavaScript 런타임의 일종\n\n## 2) JavaScript Runtime 종류\n* Chrome이 제공하는 웹 브라우저용 런타임\n* Node.js가 제공하는 서버용 런타임\n* MongoDB가 제공하는 데이터 처리용 런타임\n* Photoshop이 제공하는 전용 런타임\n...\n\n# V8 JavaScript Engine\nJIT(Just-In-Time) compilation\nCode Optimization\nUsed in\nGoogle Chrome\nNode.js\nMongoDB\n...\n\n\n## V8 엔진의 작동 방식?\n\n### 1) Event-driven Programming\n프로그램의 흐름이 외부 요인에 의해 일어나는 사건에 의해 결정되는 프로그래밍 양식  \n약속된 방식으로 이벤트 핸들러를 작성함으로써 외부 이벤트가 일어났을 때 코드를 실행  \n\n* 마우스 입력\n* 키보드 입력\n* 다른 프로그램/컴퓨터로부터의 통신\n\n```js\n // DOM 이벤트 핸들러 등록 (웹 브라우저)\ndomElement.addEventListener('click', function(e) {\n  e.stopPropagation()\n  alert('hello')\n})\n\n// 서버도 똑같이 합니다.\n// (단, 프레임워크를 쓸 때는 직접 이벤트를 다룰 일이 별로 없음)\n// HTTP 응답 이벤트 핸들러 등록 (Node.js)\nhttpResponse.on('data', data => {\n  console.log(data)\n})\n```\n\n### 2) Non-blocking I/O\n\nBlocking I/O는 스레드가 입력/출력이 완료될 때까지 기다렸다가 다음 코드를 실행  \n\nNon-blocking I/O는 스레드가 입력/출력을 기다리지 않고 코드를 계속 실행  \n\n순차적으로 실행되다가 기다려야 할 상황이 오면 코드 실행을 멈추고 그 상황이 완료된 이후에 코드를 실행하지만, 어떤 프로그래밍 언어나 기술들은 코드가 기다려야 하는 상황이 왔을 때, 그에 대한 신호만 주고 다음 코드를 계속 실행한다. 이전 코드가 완료되기를 기다렸다가 실행하는 것이 blocking I/O라고 하며 기다리지 않고 계속 실행하는 것을 non-blocking I/O라고 한다.\n\nnon-blocking의 단점은 코드가 복잡해질 수 있다는 점이다. (이러한 복잡함을 해결해주는 도구가 promise이다.)\n\n**I/O 성능 향상 & 복잡한 코드**  \n\n# Node.js Module\n\n```js\n// name.js\n\n// `module.exports`에 저장한 값은 다른 모듈에서 불러올 수 있음\nmodule.exports = {\n  familyName: '김',\n  givenName: '승하',\n  fullName: function() {\n    return this.familyName + this.givenName\n  }\n}\n// calc.js\n\n// `exports`로도 참조 가능\nexports.add = (x, y) => x + y\nexports.sub = (x, y) => x - y\n```\n\n# REPL에서 불러오기\n\n```\n// Node.js 내장 모듈과는 다르게 경로를 지정해야 함\n> const name = require('./name')\nundefined\n> name\n{ familyName: '김',\n  givenName: '승하',\n  fullName: [Function: fullName] }\n> name.familyName\n'김'\n> name.fullName()\n'김승하'\n> require('./calc').add(1, 2)\n3\n```\n\n**브라우저에서는 전역변수를 쓰면 위험하다**\nscript1.js 파일에 var evil = 1; 이라는 전역 변수를 선언하면 script2.js 파일에서도 evil을 참조할 수 있게 된다.\n하지만 nodejs는 조금 다르다. nodejs 모듈은 각각의 스코프(scope)가 따로 존재한다. 따라서 module1.js에서 var evil = 1;이라고 선언하더라도 전역에 선언되는 것이 아닌, module1이라는 모듈 내의 스코프에서만 존재하기 때문에 다른 모듈에서 접근할 수 없다. 따라서 export하지 않으면 다른 모듈에서 해당 변수에 접근할 수 없다.\n\n\n# NPM\n\nNode.js 패키지 관리 도구 + 클라우드 패키지 저장소\n\n* 의존 패키지 관리\n* 스크립트 실행\n* 패키지 설정\n* NPM에 패키지 배포\n* Node.js 종합 작업 도구\n\n```bash\n$ mkdir hello-npm\n$ cd hello-npm\n$ npm init -y\n$ code .\n// package.json\n{\n  \"name\": \"hello-npm\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\"\n}\n```\n\n# package.json\n\n패키지 정보를 담고 있는 파일\n\n**dependencies**  \n`npm install --save` 명령으로 설치한 패키지가 기록됨  \n\n**scripts**  \n원래 목적은 패키지 생명주기마다 자동으로 실행되는 명령을 등록하기 위함이나, 개발자 편의를 위해 자주 사용되는 명령을 등록하는 용도로 더 많이 사용됨  \n\n```bash\n$ npm install --save randomstring # node_modules에 저장됨\n```\n\n```js\n// index.js\nconst randomstring = require('randomstring')\nconsole.log(randomstring.generate())\n```\n\n```json\n// package.json\n...\n  \"scripts\": {\n    \"start\": \"node index.js\"\n  }\n...\n```\n\n```bash\n$ npm start\n```\n\n\n# Concurrency Model(동시성 모델)\n\n프로그램이 생애 주기가 겹치는 여러 실행 과정을 통해 실행된다 하더라도 프로그램의 결과에는 영향을 미치지 않는 성질\n\n생애 주기가 겹치는 여러 실행 과정이 자원을 공유할 때 어떻게 충돌이 생기지 않도록 할 것인가?\n\n## Resources\n\n* CPU\n* 메모리\n* 네트워크\n* ...\n\n# Thread\n\n코드 실행의 가장 작은 단위\n\n프로그램은 하나 이상의 스레드로 이루어짐\n\nCPU 코어 하나는 한 번에 하나의 스레드를 실행\n\n```bash\n$ sysctl -n hw.ncpu # OSX\n$ nproc # linux\n$ mmc devmgmt.msc # Windows\n$ top -H # Shows the total number of threads\n```\n\n# 동시성을 위한 도구\n\n자원의 공유를 위해 프로그래밍 언어는 언어들만이 가지고 있는 동시성을 위한 도구를 가지고 있는 경우가 많다.\n\n## 1) 운영체제 차원의 도구\n\n* Process\n* Thread\n* Mutex (Mutual Exclusion)\n\n## 2) 언어 차원의 도구\n\n* Python - asyncio\n* Go - goroutine\n* Erlang - actor\n* JavaScript - ...?\n\n<br>\n\n# 자바스크립트의 동시성\n\n## Single-Threaded Event Loop\n\n**자바스크립트를 실행시키는 스레드가 하나 뿐이다.**\n실행 과정(보통 콜백 연쇄)의 생애 주기가 겹칠 수는 있지만 어떤 경우에도 두 자바스크립트 실행과정이 동시에 실행되는 경우는 없음. 내부적으로 메시지 큐를 활용하고 있으나, 모든 처리가 자동으로 이루어짐\n\n!MDN[https://developer.mozilla.org/ko/docs/Web/JavaScript/EventLoop]\n\n## 1) 장점\n\n* 프로그래머가 동시성에 대해 신경쓸 필요가 없어짐\n* 프로그램 작성이 쉬워짐\n\n## 2) 단점\n\n* CPU를 많이 쓰는 작업에 부적절\n* 오래 걸리는 자바스크립트 코드가 실행되면 전체 프로그램에 영향을 미침\n\n## 3) 전략\n\n브라우저는 API가 있다면 API에 위임, 노드js는 c/c++로 만들어진 모듈을 가져와서 사용할 수 있는 방법이 있다.\n\n* 오래 걸리는 일은 외부에 위임하고 넘어간 뒤, 나중에 결과를 받아 처리하기\n  * Database\n  * Node.js - External libraries\n  * Web browser - WebAssembly\n* 긴 실행과정을 **여러 개의 함수로 쪼개서** 한 번의 함수 실행이 금방 끝나게 만들기\n\n<br>\n\n# Asynchronous JavaScript\nnon-blocking과 asynchronous는 비슷한 맥락이다. 다만, non-blocking은 코드의 실행 순서에 대한 개념이고, asynchronous는 코드 작성 방식에 대한 개념이다.\n\n* 함수를 호출할 때, 콜백까지 같이 인자에 넣어서 호출하는 비동기 프로그래밍 양식\n* 콜백에서 에러 인자를 받는 방식으로 에러 처리를 함\n* Node.js 내장 모듈 전체가 이 방식을 사용하도록 만들어져 있음\n* 주의! 모든 콜백이 비동기인 것은 아님\n\n---\n\n# 비동기식 코드의 에러처리: 관습\n\ntry-catch는 동기식 에러처리 시에만 사용한다. 비동기식 에러 처리는 관습적으로 아래 방식을 사용한다.\n\n```js\n//readFile.js\nconst fs = require('fs'); // Node.js 내장 모듈\nfs.readFile('./calc.js', 'utf8', (err, data) => {\n  // 에러처리\n  if(err) { //error가 있으면\n    console.error(err);\n  }else { //errro가 없으면 \n    console.data(data);\n  }\n});\nconsole.log('done!');\n```\n\n# 동기식 코드의 에러 처리: 일반적인 방식으로 처리\n\n```js\n//readFileSync.js\nconst fs = require('fs'); // Node.js 내장 모듈\ntry {\n  const data = fs.readFileSync('./calc.js', 'utf8');\n  console.log(data);\n} catch (err) {\n  console.log(err);\n}\nconsole.log('done!');\n```\n\n---\n위 예제에서 readFile.js는 비동기 방식이며 readFileSync는 동기 방식으로 동작하는 코드이다. 코드를 실행 한 후 결과를 보면, \n\n* readFile.js\n\n```bash\ndone!\n{ Error: ENOENT: no such file or directory, open './calc.js' errno: -2, code: 'ENOENT', syscall: 'open', path: './calc.js' }\n```\n\n비동기 방식에서는 마지막 줄의 `console.log('done!')`코드가 이전 코드의 실행이 완료될 때까지 기다리지 않고 먼저 실행된다.\n\n* readFileSync.js\n\n```bash\n{ Error: ENOENT: no such file or directory, open './calc.js'\n    at Object.fs.openSync (fs.js:652:18)\n    at Object.fs.readFileSync (fs.js:553:33)\n    at Object.<anonymous> (/Users/ihyeseung/projectfolder/fastcam/frontstudy/nodejs/practice/readFileSync.js:4:19)\n    at Module._compile (module.js:573:30)\n    at Object.Module._extensions..js (module.js:584:10)\n    at Module.load (module.js:507:32)\n    at tryModuleLoad (module.js:470:12)\n    at Function.Module._load (module.js:462:3)\n    at Function.Module.runMain (module.js:609:10)\n    at startup (bootstrap_node.js:158:16) errno: -2, code: 'ENOENT', syscall: 'open', path: './calc.js' }\ndone!\n```\n\n동기 방식에서는 `console.log('done!')`이 이전 코드의 실행이 완료될때까지 기다린 후 실행되었다.\n\n<br>\n\n# Github REST API 호출\n\n```js\n//request.js\n\n// 유저 이름, 저장소, 할당된 이슈 갯수 출력하기\nconst request = require('request')\nconst apiUrl = 'https://api.github.com'\nconst option = {\n  json: true,\n  auth: {\n    'user': 'username', // github 유저네임\n    'pass': 'password', // github 비밀번호\n  },\n  headers: {\n    'User-Agent': 'request'\n  }\n}\nrequest.get(`${apiUrl}/user`, option, function (error, response, body) {\n  const name = body.name\n  if (error) console.error(error)\n  // 콜백 안에 콜백\n  request.get(`${apiUrl}/user/repos`, option, function (error, response, body) {\n    if (error) console.error(error)\n    const repoNames = body.map(item => item.name)\n    // 콜백 안에 콜백 안에 콜백\n    request.get(`${apiUrl}/issues`, option, function (error, response, body) {\n      if (error) console.error(error)\n      const issueNum = body.length\n      console.log(`name: ${name}`)\n      console.log('repos:')\n      repoNames.forEach(name => {\n        console.log(name)\n      })\n      console.log(`num of assigned issues: ${issueNum}`)\n    })\n  })\n})\n```\n\n```bash\n$ node request.js\n```\n\n## Callback Hell\n\n![callback hell](https://image.slidesharecdn.com/promisesandchaininginangularjs-141027044455-conversion-gate02/95/promises-and-chaining-in-angularjs-into-callback-hell-and-back-again-17-638.jpg?cb=1414385382)\n\n<br>\n\n# Promise\n\n비동기 작업의 결과를 담는 객체  \n정확히 언제가 될지 모르지만, 결국 성공 또는 실패의 상태를 갖게 되며 이 상태가 되었을 때 비로소 콜백을 실행하라는 명령을 갖게 된다.\n\n```js\n// tenSec.js\n\n// 10초 뒤에 콜백(promise 객체를 새로 만들어서 리턴)을 실행하는 함수\nmodule.exports = function tenSec(value) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(value)\n    }, 10000)\n  })\n}\n```\n\n```\n> const tenSec = require('./tenSec')\n> const p = tenSec(1) // p에 Promise 저장\n> p // 만든지 10초가 지나기 전\nPromise {\n  [pending], //pending: 아직 결과가 나오지 않음.\n  ...\n> p // 만든지 10초가 지난 후\nPromise {\n  1,\n  ...\n```\n\n## 1) promise의 상태(state)\n\n* pending\n아직 수행 중인 상태 (fulfilled 혹은 rejected 되기 전)\n\n* fulfilled\npromise가 지켜진(수행된) 상태\n\n* rejected\npromise가 지켜지지 못한(거부된) 상태\n\n* settled\nfulfilled이든 rejected이든 결론이 난 상태\n\n## 2) .then\n\npromise 객체의 메서드\n\n\n```\n> tenSec('hello promise').then(value => {\n... console.log(value)\n... })\nPromise { // `then`은 Promise를 반환\n  [pending],\n  ...\n> // 10초 후\n'hello promise'\n```\n\nnew Promise ()의 결과는 promise이다.\n.then 메소드에서 반환된 값도 promise이다.\n따라서 .then 메소드를 계속 사용할 수 있다.\n.then 메소드를 쓰면 들여쓰기를 하지 않아도 된다.\n따라서 Callback Hell을 피할 수 있다.\n\nreturn은 바로 실행되는 동기식 작업이다. \n\n비동기 작업을 하려면 콜백을 통해서 해야 했다.\n\n```js\nnew Promise()\n.then(value => {\n  request.get( function(){\n\n  })\nreturn // 콜백은 함수 밖에서 리턴이 불가하다\n})\n```\n\npromise는 함수 밖에서 리턴해야 하는데 위와 같은 콜백 방식에서는 함수 밖에서 리턴이 불가하다.\n\n\n```js\nnew Promise()\n.then(value => {\n  \n})\n.then(value => {\n\n})\n```\n\n\n## 3) Promise chaining\n\n```js\n// chaining.js\nconst tenSec = require('./tenSec')\ntenSec('hello promise')\n  .then(value => {\n    console.log(value)\n    return 1 // 위 `.then`은 값이 1인 Promise를 반환함\n  })\n  .then(value => {\n    console.log(value) // value = 1\n    return tenSec('new promise') // Promise도 반환할 수 있음\n  }) // 안에 들어 있는 값이 value(=1)인 Promise 생성\n  .then(value => { // tenSec이 실행되고 10초 후 실행됨\n    console.log(value)\n  })\n  .then(() => { //promise 안에서 에러가 나면\n    throw new Error('error in promise')\n  })\n  .catch(err => { // 에러가 나면 catch 내부 코드 실행, 안나면 통과\n    console.error(err)\n  })\n  .then(() => { // 에러 처리 이후에도 코드 실행 가능\n    console.log('done')\n  })\n```\n\n---\n### 기타 메소드\n\n* Promise.all(Arr): 모든 프라미스가 성공해야 성공하는 promise\n\n```js\npa = Promise.all([p1, p2])\n// pa는 p1, p2가 모두 성공해야 성공하는 Promise이다.\n```\n\n* Promise.race(Arr): 가장 빨리 성공하는 promise를 반환\n\n```js\npr = Promise.race([p1, pw])\n```\n\n* promisify 함수\n\n```js\n// readfilePromise.js\nconst {promisify} = require('util') // Node.js 8.0.0부터 추가됨\nconst fs = require('fs')\nconst readFile = promisify(fs.readFile)\nreadFile('./calc.js', 'utf8')\n  .then(data => {\n    console.log(data)\n  })\n  .catch(err => {\n    console.error(err)\n  })\n```\n\n```\n{ Error: ENOENT: no such file or directory, open './calc.js' errno: -2, code: 'ENOENT', syscall: 'open', path: './calc.js' }\n```\n\n---\n\n## 4) Promise의 특징\n\n1) 이미 resolve 된 Promise에도 콜백을 실행할 수 있음\n\n```js\n> const resolved = Promise.resolve(1)\n> resolved.then(v => console.log(v))\n```\n\n2) `.then`에 넘겨진 콜백은 (비동기가 아니라 바로 성공하도록 만들어진 동기식 promise라 하더라도)무조건 다음 루프에 실행됨\n\n```js\n> (function() {\n... Promise.resolve(1).then(v => console.log(v))\n... console.log('done!')\n... })()\n/* 출력:\ndone! -> 먼저 출력된다.\n1\n*/\n```\n\n## Promise.all\n\n```js\n// npm install --save request-promise\nconst rp = require('request-promise')\nconst apiUrl = 'https://api.github.com'\nconst option = {\n  json: true,\n  auth: {\n    'user': 'username',\n    'pass': 'password',\n  },\n  headers: {\n    'User-Agent': 'request'\n  }\n}\n\nconst userPromise = rp.get(`${apiUrl}/user`, option)\nconst reposPromise = rp.get(`${apiUrl}/user/repos`, option)\nconst issuesPromise = rp.get(`${apiUrl}/issues`, option)\n\n// 배열 내의 모든 Promise 객체가 완료되었을 때\n// resolve 되는 Promise를 만든다.\nPromise.all([userPromise, reposPromise, issuesPromise])\n  .then(([user, repos, issues]) => {\n    console.log(`name: ${user.name}`)\n    console.log('repos:')\n    repos.forEach(repo => {\n      console.log(repo.name)\n    })\n    console.log(`num of assigned issues: ${issues.length}`)\n  })\n```\n\n비동기 코드와 동일한 일을 promise로 할 수 있으며 promise를 이용하면 좀 더 깔끔하게 코드를 짤 수 있다.\n\n> * [Fetch API](http://hacks.mozilla.or.kr/2015/05/this-api-is-so-fetching/)\n>  * window.fetch polyfill: Fetch API를 IE에서도 사용할 수 있게 해준다.\n\n<br>\n\n# Async/Await\n\n* ES2017에서 도입되어, 비동기식 코드를 동기식 코드처럼 쓸 수 있는 문법 제공\n* Chrome 55, Node.js 8.0.0 부터 사용가능\n(아주 최근에 나온 문법이므로, 아직까지는 비동기식 코드에 promise가 더 널리 쓰인다.)\n* async function 안에서 반환된 값은 최종적으로 Promise 객체로 변환되어 반환된다.\n* async function 안에서 쓸 수 있는 await 키워드는 현재 함수를 중단시키고 Promise 객체가 충족될 때까지 기다리지만, 스레드를 block 하지 않는다.\n* 에러 처리는 동기식 코드처럼 try, catch 블록을 통해서 한다.\n\n```js\nconst tenSec = require('./tenSec')\n\n//await는 async 함수 안에서만 사용할 수 있다.\nasync function resolveAfterTenSec() {\n  await tenSec()\n  return 1\n}\n\nresolveAfterTenSec().then(value => {\n  console.log(value)\n})\n```\n\n## 1) readFile - async/await\n\n```js\n// readfileAsync.js\nconst {promisify} = require('util') // Node.js 8.0.0부터 추가됨\nconst fs = require('fs')\nconst readFile = promisify(fs.readFile)\n\nasync function readFileAsync() {\n  try {\n    const data = await readFile('./calc.js', 'utf8')\n    console.log(data)\n  } catch (e) {\n    console.error(e)\n  }\n}\n\nreadFileAsync()\n```\n\n```\n{ Error: ENOENT: no such file or directory, open './calc.js' errno: -2, code: 'ENOENT', syscall: 'open', path: './calc.js' }\n```\n\n---\n","source":"_posts/nodejs/01.basic.md","raw":"---\ntitle: '[node] node 시작하기'\ndate: 2017-08-30 00:40:12\ncategory: Nodejs\ntags: nvm\n---\n\n![](http://allvectorlogo.com/img/2016/05/node-js-logo.png)\n\n# nvm(node version manager)\n\n```bash\n# 주석: `#`으로 시작하는 명령은 bash에서 무시됩니다.\n# 아래 명령을 한 줄씩 차례대로 입력하세요\n$ nvm install 8.4\n$ nvm use 8.4\n$ nvm alias default 8.4 # nvm-windows는 필요없음\n```\n\n# Node.js REPL\n\nREPL(Read Eval Print Loop): 윈도우 커맨드, 혹은 UNIX/LINUX Shell처럼 사용자가 커맨드를 입력하면 시스템이 값을 반환하는 환경을 일컫는다. \n\nNode.js는 REPL 환경과 함께 제공되며 다음과 같은 기능을 수행할 수 있다.\n\n* Read: 유저의 값을 입력 받아 Javascript 데이터 구조로 메모리에 저장한다.\n* Eval: 데이터를 처리(Evaluate)한다.\n* Print: 결과값을 출력한다.\n* Loop: Read, Eval, Print를 유저가 Ctrl+C를 두 번 눌러 종료할 때까지 반복한다.\n\nNode.js 의 REPL 환경은 자바스크립트 코드의 테스팅 및 디버깅할 때 유용하게 사용된다.\n\n```bash\n// REPL 시작하기\n$ node\n\n// 한 줄 짜리 코드 입력하기\n> 'hello node'\n'hello node'\n\n// 위쪽 화살표 키를 입력해서 이전 명령 불러오기\n> 'hello node'\n'hello node'\n\n// Underscore(_) 변수\n밑줄 _변수는 최근 결과값을 지칭한다.\n> var x = 10;\nundefined\n> var y = 5;\nundefined\n> x+y;\n15\n> var sum = _\nundefined\n>console.log(sum)\n15\nundefined\n\n// 변수 사용하기\n> const factorial = n => n < 1 ? 1 : n * factorial(n-1)\nundefined\n\n> factorial(3)\n6\n\n// 여러 줄에 나눠서 입력하기\n> function factorial2(n) {\n... return n < 1 ? 1 : n * factorial(n-1)\n... }\nundefined\n\n> factorial2(4)\n24\n\n// `.exit`를 입력하거나 `Ctrl+C`를 두 번 입력해서 나가기\n> .exit\n\n// Node.js module 사용하기\n> const os = require('os') // 급할땐 `os = ...`\nundefined\n\n> os.platform()\n'linux'\n\n> os.freemem()\n658300928\n```\n\n# node.js로 파일 실행시키기\n\n```bash\n$ node (파일 경로)\n```\n\n# node.js\n\nNode.js®은 chrome의 v8 자바스크립트 엔진에 기반한 자바스크립트 런타임이다.\n\nNode.js는 가볍고 효율적인 event-driven, non-blocking I/O model을 사용한다. \n\nNode.js의 패키지 에코 시스템인 npm은 전 세계 오픈 소스 라이브러리 중 가장 큰 생태계(ecosystem)이다.\n\n## 1) JavaScript Runtime이란?\n\n* JavaScript는 언어\n* JavaScript 런타임(runtime)은 JS를 구동하기 위해 필요한 실행 환경\n* 프로그래머는 런타임이 제공하는 도구를 응용해서 프로그램을 개발\n* 웹 브라우저나 Node.js도 JavaScript 런타임의 일종\n\n## 2) JavaScript Runtime 종류\n* Chrome이 제공하는 웹 브라우저용 런타임\n* Node.js가 제공하는 서버용 런타임\n* MongoDB가 제공하는 데이터 처리용 런타임\n* Photoshop이 제공하는 전용 런타임\n...\n\n# V8 JavaScript Engine\nJIT(Just-In-Time) compilation\nCode Optimization\nUsed in\nGoogle Chrome\nNode.js\nMongoDB\n...\n\n\n## V8 엔진의 작동 방식?\n\n### 1) Event-driven Programming\n프로그램의 흐름이 외부 요인에 의해 일어나는 사건에 의해 결정되는 프로그래밍 양식  \n약속된 방식으로 이벤트 핸들러를 작성함으로써 외부 이벤트가 일어났을 때 코드를 실행  \n\n* 마우스 입력\n* 키보드 입력\n* 다른 프로그램/컴퓨터로부터의 통신\n\n```js\n // DOM 이벤트 핸들러 등록 (웹 브라우저)\ndomElement.addEventListener('click', function(e) {\n  e.stopPropagation()\n  alert('hello')\n})\n\n// 서버도 똑같이 합니다.\n// (단, 프레임워크를 쓸 때는 직접 이벤트를 다룰 일이 별로 없음)\n// HTTP 응답 이벤트 핸들러 등록 (Node.js)\nhttpResponse.on('data', data => {\n  console.log(data)\n})\n```\n\n### 2) Non-blocking I/O\n\nBlocking I/O는 스레드가 입력/출력이 완료될 때까지 기다렸다가 다음 코드를 실행  \n\nNon-blocking I/O는 스레드가 입력/출력을 기다리지 않고 코드를 계속 실행  \n\n순차적으로 실행되다가 기다려야 할 상황이 오면 코드 실행을 멈추고 그 상황이 완료된 이후에 코드를 실행하지만, 어떤 프로그래밍 언어나 기술들은 코드가 기다려야 하는 상황이 왔을 때, 그에 대한 신호만 주고 다음 코드를 계속 실행한다. 이전 코드가 완료되기를 기다렸다가 실행하는 것이 blocking I/O라고 하며 기다리지 않고 계속 실행하는 것을 non-blocking I/O라고 한다.\n\nnon-blocking의 단점은 코드가 복잡해질 수 있다는 점이다. (이러한 복잡함을 해결해주는 도구가 promise이다.)\n\n**I/O 성능 향상 & 복잡한 코드**  \n\n# Node.js Module\n\n```js\n// name.js\n\n// `module.exports`에 저장한 값은 다른 모듈에서 불러올 수 있음\nmodule.exports = {\n  familyName: '김',\n  givenName: '승하',\n  fullName: function() {\n    return this.familyName + this.givenName\n  }\n}\n// calc.js\n\n// `exports`로도 참조 가능\nexports.add = (x, y) => x + y\nexports.sub = (x, y) => x - y\n```\n\n# REPL에서 불러오기\n\n```\n// Node.js 내장 모듈과는 다르게 경로를 지정해야 함\n> const name = require('./name')\nundefined\n> name\n{ familyName: '김',\n  givenName: '승하',\n  fullName: [Function: fullName] }\n> name.familyName\n'김'\n> name.fullName()\n'김승하'\n> require('./calc').add(1, 2)\n3\n```\n\n**브라우저에서는 전역변수를 쓰면 위험하다**\nscript1.js 파일에 var evil = 1; 이라는 전역 변수를 선언하면 script2.js 파일에서도 evil을 참조할 수 있게 된다.\n하지만 nodejs는 조금 다르다. nodejs 모듈은 각각의 스코프(scope)가 따로 존재한다. 따라서 module1.js에서 var evil = 1;이라고 선언하더라도 전역에 선언되는 것이 아닌, module1이라는 모듈 내의 스코프에서만 존재하기 때문에 다른 모듈에서 접근할 수 없다. 따라서 export하지 않으면 다른 모듈에서 해당 변수에 접근할 수 없다.\n\n\n# NPM\n\nNode.js 패키지 관리 도구 + 클라우드 패키지 저장소\n\n* 의존 패키지 관리\n* 스크립트 실행\n* 패키지 설정\n* NPM에 패키지 배포\n* Node.js 종합 작업 도구\n\n```bash\n$ mkdir hello-npm\n$ cd hello-npm\n$ npm init -y\n$ code .\n// package.json\n{\n  \"name\": \"hello-npm\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\"\n}\n```\n\n# package.json\n\n패키지 정보를 담고 있는 파일\n\n**dependencies**  \n`npm install --save` 명령으로 설치한 패키지가 기록됨  \n\n**scripts**  \n원래 목적은 패키지 생명주기마다 자동으로 실행되는 명령을 등록하기 위함이나, 개발자 편의를 위해 자주 사용되는 명령을 등록하는 용도로 더 많이 사용됨  \n\n```bash\n$ npm install --save randomstring # node_modules에 저장됨\n```\n\n```js\n// index.js\nconst randomstring = require('randomstring')\nconsole.log(randomstring.generate())\n```\n\n```json\n// package.json\n...\n  \"scripts\": {\n    \"start\": \"node index.js\"\n  }\n...\n```\n\n```bash\n$ npm start\n```\n\n\n# Concurrency Model(동시성 모델)\n\n프로그램이 생애 주기가 겹치는 여러 실행 과정을 통해 실행된다 하더라도 프로그램의 결과에는 영향을 미치지 않는 성질\n\n생애 주기가 겹치는 여러 실행 과정이 자원을 공유할 때 어떻게 충돌이 생기지 않도록 할 것인가?\n\n## Resources\n\n* CPU\n* 메모리\n* 네트워크\n* ...\n\n# Thread\n\n코드 실행의 가장 작은 단위\n\n프로그램은 하나 이상의 스레드로 이루어짐\n\nCPU 코어 하나는 한 번에 하나의 스레드를 실행\n\n```bash\n$ sysctl -n hw.ncpu # OSX\n$ nproc # linux\n$ mmc devmgmt.msc # Windows\n$ top -H # Shows the total number of threads\n```\n\n# 동시성을 위한 도구\n\n자원의 공유를 위해 프로그래밍 언어는 언어들만이 가지고 있는 동시성을 위한 도구를 가지고 있는 경우가 많다.\n\n## 1) 운영체제 차원의 도구\n\n* Process\n* Thread\n* Mutex (Mutual Exclusion)\n\n## 2) 언어 차원의 도구\n\n* Python - asyncio\n* Go - goroutine\n* Erlang - actor\n* JavaScript - ...?\n\n<br>\n\n# 자바스크립트의 동시성\n\n## Single-Threaded Event Loop\n\n**자바스크립트를 실행시키는 스레드가 하나 뿐이다.**\n실행 과정(보통 콜백 연쇄)의 생애 주기가 겹칠 수는 있지만 어떤 경우에도 두 자바스크립트 실행과정이 동시에 실행되는 경우는 없음. 내부적으로 메시지 큐를 활용하고 있으나, 모든 처리가 자동으로 이루어짐\n\n!MDN[https://developer.mozilla.org/ko/docs/Web/JavaScript/EventLoop]\n\n## 1) 장점\n\n* 프로그래머가 동시성에 대해 신경쓸 필요가 없어짐\n* 프로그램 작성이 쉬워짐\n\n## 2) 단점\n\n* CPU를 많이 쓰는 작업에 부적절\n* 오래 걸리는 자바스크립트 코드가 실행되면 전체 프로그램에 영향을 미침\n\n## 3) 전략\n\n브라우저는 API가 있다면 API에 위임, 노드js는 c/c++로 만들어진 모듈을 가져와서 사용할 수 있는 방법이 있다.\n\n* 오래 걸리는 일은 외부에 위임하고 넘어간 뒤, 나중에 결과를 받아 처리하기\n  * Database\n  * Node.js - External libraries\n  * Web browser - WebAssembly\n* 긴 실행과정을 **여러 개의 함수로 쪼개서** 한 번의 함수 실행이 금방 끝나게 만들기\n\n<br>\n\n# Asynchronous JavaScript\nnon-blocking과 asynchronous는 비슷한 맥락이다. 다만, non-blocking은 코드의 실행 순서에 대한 개념이고, asynchronous는 코드 작성 방식에 대한 개념이다.\n\n* 함수를 호출할 때, 콜백까지 같이 인자에 넣어서 호출하는 비동기 프로그래밍 양식\n* 콜백에서 에러 인자를 받는 방식으로 에러 처리를 함\n* Node.js 내장 모듈 전체가 이 방식을 사용하도록 만들어져 있음\n* 주의! 모든 콜백이 비동기인 것은 아님\n\n---\n\n# 비동기식 코드의 에러처리: 관습\n\ntry-catch는 동기식 에러처리 시에만 사용한다. 비동기식 에러 처리는 관습적으로 아래 방식을 사용한다.\n\n```js\n//readFile.js\nconst fs = require('fs'); // Node.js 내장 모듈\nfs.readFile('./calc.js', 'utf8', (err, data) => {\n  // 에러처리\n  if(err) { //error가 있으면\n    console.error(err);\n  }else { //errro가 없으면 \n    console.data(data);\n  }\n});\nconsole.log('done!');\n```\n\n# 동기식 코드의 에러 처리: 일반적인 방식으로 처리\n\n```js\n//readFileSync.js\nconst fs = require('fs'); // Node.js 내장 모듈\ntry {\n  const data = fs.readFileSync('./calc.js', 'utf8');\n  console.log(data);\n} catch (err) {\n  console.log(err);\n}\nconsole.log('done!');\n```\n\n---\n위 예제에서 readFile.js는 비동기 방식이며 readFileSync는 동기 방식으로 동작하는 코드이다. 코드를 실행 한 후 결과를 보면, \n\n* readFile.js\n\n```bash\ndone!\n{ Error: ENOENT: no such file or directory, open './calc.js' errno: -2, code: 'ENOENT', syscall: 'open', path: './calc.js' }\n```\n\n비동기 방식에서는 마지막 줄의 `console.log('done!')`코드가 이전 코드의 실행이 완료될 때까지 기다리지 않고 먼저 실행된다.\n\n* readFileSync.js\n\n```bash\n{ Error: ENOENT: no such file or directory, open './calc.js'\n    at Object.fs.openSync (fs.js:652:18)\n    at Object.fs.readFileSync (fs.js:553:33)\n    at Object.<anonymous> (/Users/ihyeseung/projectfolder/fastcam/frontstudy/nodejs/practice/readFileSync.js:4:19)\n    at Module._compile (module.js:573:30)\n    at Object.Module._extensions..js (module.js:584:10)\n    at Module.load (module.js:507:32)\n    at tryModuleLoad (module.js:470:12)\n    at Function.Module._load (module.js:462:3)\n    at Function.Module.runMain (module.js:609:10)\n    at startup (bootstrap_node.js:158:16) errno: -2, code: 'ENOENT', syscall: 'open', path: './calc.js' }\ndone!\n```\n\n동기 방식에서는 `console.log('done!')`이 이전 코드의 실행이 완료될때까지 기다린 후 실행되었다.\n\n<br>\n\n# Github REST API 호출\n\n```js\n//request.js\n\n// 유저 이름, 저장소, 할당된 이슈 갯수 출력하기\nconst request = require('request')\nconst apiUrl = 'https://api.github.com'\nconst option = {\n  json: true,\n  auth: {\n    'user': 'username', // github 유저네임\n    'pass': 'password', // github 비밀번호\n  },\n  headers: {\n    'User-Agent': 'request'\n  }\n}\nrequest.get(`${apiUrl}/user`, option, function (error, response, body) {\n  const name = body.name\n  if (error) console.error(error)\n  // 콜백 안에 콜백\n  request.get(`${apiUrl}/user/repos`, option, function (error, response, body) {\n    if (error) console.error(error)\n    const repoNames = body.map(item => item.name)\n    // 콜백 안에 콜백 안에 콜백\n    request.get(`${apiUrl}/issues`, option, function (error, response, body) {\n      if (error) console.error(error)\n      const issueNum = body.length\n      console.log(`name: ${name}`)\n      console.log('repos:')\n      repoNames.forEach(name => {\n        console.log(name)\n      })\n      console.log(`num of assigned issues: ${issueNum}`)\n    })\n  })\n})\n```\n\n```bash\n$ node request.js\n```\n\n## Callback Hell\n\n![callback hell](https://image.slidesharecdn.com/promisesandchaininginangularjs-141027044455-conversion-gate02/95/promises-and-chaining-in-angularjs-into-callback-hell-and-back-again-17-638.jpg?cb=1414385382)\n\n<br>\n\n# Promise\n\n비동기 작업의 결과를 담는 객체  \n정확히 언제가 될지 모르지만, 결국 성공 또는 실패의 상태를 갖게 되며 이 상태가 되었을 때 비로소 콜백을 실행하라는 명령을 갖게 된다.\n\n```js\n// tenSec.js\n\n// 10초 뒤에 콜백(promise 객체를 새로 만들어서 리턴)을 실행하는 함수\nmodule.exports = function tenSec(value) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(value)\n    }, 10000)\n  })\n}\n```\n\n```\n> const tenSec = require('./tenSec')\n> const p = tenSec(1) // p에 Promise 저장\n> p // 만든지 10초가 지나기 전\nPromise {\n  [pending], //pending: 아직 결과가 나오지 않음.\n  ...\n> p // 만든지 10초가 지난 후\nPromise {\n  1,\n  ...\n```\n\n## 1) promise의 상태(state)\n\n* pending\n아직 수행 중인 상태 (fulfilled 혹은 rejected 되기 전)\n\n* fulfilled\npromise가 지켜진(수행된) 상태\n\n* rejected\npromise가 지켜지지 못한(거부된) 상태\n\n* settled\nfulfilled이든 rejected이든 결론이 난 상태\n\n## 2) .then\n\npromise 객체의 메서드\n\n\n```\n> tenSec('hello promise').then(value => {\n... console.log(value)\n... })\nPromise { // `then`은 Promise를 반환\n  [pending],\n  ...\n> // 10초 후\n'hello promise'\n```\n\nnew Promise ()의 결과는 promise이다.\n.then 메소드에서 반환된 값도 promise이다.\n따라서 .then 메소드를 계속 사용할 수 있다.\n.then 메소드를 쓰면 들여쓰기를 하지 않아도 된다.\n따라서 Callback Hell을 피할 수 있다.\n\nreturn은 바로 실행되는 동기식 작업이다. \n\n비동기 작업을 하려면 콜백을 통해서 해야 했다.\n\n```js\nnew Promise()\n.then(value => {\n  request.get( function(){\n\n  })\nreturn // 콜백은 함수 밖에서 리턴이 불가하다\n})\n```\n\npromise는 함수 밖에서 리턴해야 하는데 위와 같은 콜백 방식에서는 함수 밖에서 리턴이 불가하다.\n\n\n```js\nnew Promise()\n.then(value => {\n  \n})\n.then(value => {\n\n})\n```\n\n\n## 3) Promise chaining\n\n```js\n// chaining.js\nconst tenSec = require('./tenSec')\ntenSec('hello promise')\n  .then(value => {\n    console.log(value)\n    return 1 // 위 `.then`은 값이 1인 Promise를 반환함\n  })\n  .then(value => {\n    console.log(value) // value = 1\n    return tenSec('new promise') // Promise도 반환할 수 있음\n  }) // 안에 들어 있는 값이 value(=1)인 Promise 생성\n  .then(value => { // tenSec이 실행되고 10초 후 실행됨\n    console.log(value)\n  })\n  .then(() => { //promise 안에서 에러가 나면\n    throw new Error('error in promise')\n  })\n  .catch(err => { // 에러가 나면 catch 내부 코드 실행, 안나면 통과\n    console.error(err)\n  })\n  .then(() => { // 에러 처리 이후에도 코드 실행 가능\n    console.log('done')\n  })\n```\n\n---\n### 기타 메소드\n\n* Promise.all(Arr): 모든 프라미스가 성공해야 성공하는 promise\n\n```js\npa = Promise.all([p1, p2])\n// pa는 p1, p2가 모두 성공해야 성공하는 Promise이다.\n```\n\n* Promise.race(Arr): 가장 빨리 성공하는 promise를 반환\n\n```js\npr = Promise.race([p1, pw])\n```\n\n* promisify 함수\n\n```js\n// readfilePromise.js\nconst {promisify} = require('util') // Node.js 8.0.0부터 추가됨\nconst fs = require('fs')\nconst readFile = promisify(fs.readFile)\nreadFile('./calc.js', 'utf8')\n  .then(data => {\n    console.log(data)\n  })\n  .catch(err => {\n    console.error(err)\n  })\n```\n\n```\n{ Error: ENOENT: no such file or directory, open './calc.js' errno: -2, code: 'ENOENT', syscall: 'open', path: './calc.js' }\n```\n\n---\n\n## 4) Promise의 특징\n\n1) 이미 resolve 된 Promise에도 콜백을 실행할 수 있음\n\n```js\n> const resolved = Promise.resolve(1)\n> resolved.then(v => console.log(v))\n```\n\n2) `.then`에 넘겨진 콜백은 (비동기가 아니라 바로 성공하도록 만들어진 동기식 promise라 하더라도)무조건 다음 루프에 실행됨\n\n```js\n> (function() {\n... Promise.resolve(1).then(v => console.log(v))\n... console.log('done!')\n... })()\n/* 출력:\ndone! -> 먼저 출력된다.\n1\n*/\n```\n\n## Promise.all\n\n```js\n// npm install --save request-promise\nconst rp = require('request-promise')\nconst apiUrl = 'https://api.github.com'\nconst option = {\n  json: true,\n  auth: {\n    'user': 'username',\n    'pass': 'password',\n  },\n  headers: {\n    'User-Agent': 'request'\n  }\n}\n\nconst userPromise = rp.get(`${apiUrl}/user`, option)\nconst reposPromise = rp.get(`${apiUrl}/user/repos`, option)\nconst issuesPromise = rp.get(`${apiUrl}/issues`, option)\n\n// 배열 내의 모든 Promise 객체가 완료되었을 때\n// resolve 되는 Promise를 만든다.\nPromise.all([userPromise, reposPromise, issuesPromise])\n  .then(([user, repos, issues]) => {\n    console.log(`name: ${user.name}`)\n    console.log('repos:')\n    repos.forEach(repo => {\n      console.log(repo.name)\n    })\n    console.log(`num of assigned issues: ${issues.length}`)\n  })\n```\n\n비동기 코드와 동일한 일을 promise로 할 수 있으며 promise를 이용하면 좀 더 깔끔하게 코드를 짤 수 있다.\n\n> * [Fetch API](http://hacks.mozilla.or.kr/2015/05/this-api-is-so-fetching/)\n>  * window.fetch polyfill: Fetch API를 IE에서도 사용할 수 있게 해준다.\n\n<br>\n\n# Async/Await\n\n* ES2017에서 도입되어, 비동기식 코드를 동기식 코드처럼 쓸 수 있는 문법 제공\n* Chrome 55, Node.js 8.0.0 부터 사용가능\n(아주 최근에 나온 문법이므로, 아직까지는 비동기식 코드에 promise가 더 널리 쓰인다.)\n* async function 안에서 반환된 값은 최종적으로 Promise 객체로 변환되어 반환된다.\n* async function 안에서 쓸 수 있는 await 키워드는 현재 함수를 중단시키고 Promise 객체가 충족될 때까지 기다리지만, 스레드를 block 하지 않는다.\n* 에러 처리는 동기식 코드처럼 try, catch 블록을 통해서 한다.\n\n```js\nconst tenSec = require('./tenSec')\n\n//await는 async 함수 안에서만 사용할 수 있다.\nasync function resolveAfterTenSec() {\n  await tenSec()\n  return 1\n}\n\nresolveAfterTenSec().then(value => {\n  console.log(value)\n})\n```\n\n## 1) readFile - async/await\n\n```js\n// readfileAsync.js\nconst {promisify} = require('util') // Node.js 8.0.0부터 추가됨\nconst fs = require('fs')\nconst readFile = promisify(fs.readFile)\n\nasync function readFileAsync() {\n  try {\n    const data = await readFile('./calc.js', 'utf8')\n    console.log(data)\n  } catch (e) {\n    console.error(e)\n  }\n}\n\nreadFileAsync()\n```\n\n```\n{ Error: ENOENT: no such file or directory, open './calc.js' errno: -2, code: 'ENOENT', syscall: 'open', path: './calc.js' }\n```\n\n---\n","slug":"nodejs/01.basic","published":1,"updated":"2017-09-21T06:07:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjai8h18b0010vb9q08cpfgmg","content":"<p><img src=\"http://allvectorlogo.com/img/2016/05/node-js-logo.png\" alt=\"\"></p><h1 id=\"nvm-node-version-manager\"><a href=\"#nvm-node-version-manager\" class=\"headerlink\" title=\"nvm(node version manager)\"></a>nvm(node version manager)</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 주석: `#`으로 시작하는 명령은 bash에서 무시됩니다.</span></div><div class=\"line\"><span class=\"comment\"># 아래 명령을 한 줄씩 차례대로 입력하세요</span></div><div class=\"line\">$ nvm install 8.4</div><div class=\"line\">$ nvm use 8.4</div><div class=\"line\">$ nvm <span class=\"built_in\">alias</span> default 8.4 <span class=\"comment\"># nvm-windows는 필요없음</span></div></pre></td></tr></table></figure><h1 id=\"Node-js-REPL\"><a href=\"#Node-js-REPL\" class=\"headerlink\" title=\"Node.js REPL\"></a>Node.js REPL</h1><p>REPL(Read Eval Print Loop): 윈도우 커맨드, 혹은 UNIX/LINUX Shell처럼 사용자가 커맨드를 입력하면 시스템이 값을 반환하는 환경을 일컫는다.</p><p>Node.js는 REPL 환경과 함께 제공되며 다음과 같은 기능을 수행할 수 있다.</p><ul><li>Read: 유저의 값을 입력 받아 Javascript 데이터 구조로 메모리에 저장한다.</li><li>Eval: 데이터를 처리(Evaluate)한다.</li><li>Print: 결과값을 출력한다.</li><li>Loop: Read, Eval, Print를 유저가 Ctrl+C를 두 번 눌러 종료할 때까지 반복한다.</li></ul><p>Node.js 의 REPL 환경은 자바스크립트 코드의 테스팅 및 디버깅할 때 유용하게 사용된다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">// REPL 시작하기</div><div class=\"line\">$ node</div><div class=\"line\"></div><div class=\"line\">// 한 줄 짜리 코드 입력하기</div><div class=\"line\">&gt; <span class=\"string\">'hello node'</span></div><div class=\"line\"><span class=\"string\">'hello node'</span></div><div class=\"line\"></div><div class=\"line\">// 위쪽 화살표 키를 입력해서 이전 명령 불러오기</div><div class=\"line\">&gt; <span class=\"string\">'hello node'</span></div><div class=\"line\"><span class=\"string\">'hello node'</span></div><div class=\"line\"></div><div class=\"line\">// Underscore(_) 변수</div><div class=\"line\">밑줄 _변수는 최근 결과값을 지칭한다.</div><div class=\"line\">&gt; var x = 10;</div><div class=\"line\">undefined</div><div class=\"line\">&gt; var y = 5;</div><div class=\"line\">undefined</div><div class=\"line\">&gt; x+y;</div><div class=\"line\">15</div><div class=\"line\">&gt; var sum = _</div><div class=\"line\">undefined</div><div class=\"line\">&gt;console.log(sum)</div><div class=\"line\">15</div><div class=\"line\">undefined</div><div class=\"line\"></div><div class=\"line\">// 변수 사용하기</div><div class=\"line\">&gt; const factorial = n =&gt; n &lt; 1 ? 1 : n * factorial(n-1)</div><div class=\"line\">undefined</div><div class=\"line\"></div><div class=\"line\">&gt; factorial(3)</div><div class=\"line\">6</div><div class=\"line\"></div><div class=\"line\">// 여러 줄에 나눠서 입력하기</div><div class=\"line\">&gt; <span class=\"keyword\">function</span> factorial2(n) &#123;</div><div class=\"line\">... <span class=\"built_in\">return</span> n &lt; 1 ? 1 : n * factorial(n-1)</div><div class=\"line\">... &#125;</div><div class=\"line\">undefined</div><div class=\"line\"></div><div class=\"line\">&gt; factorial2(4)</div><div class=\"line\">24</div><div class=\"line\"></div><div class=\"line\">// `.<span class=\"built_in\">exit</span>`를 입력하거나 `Ctrl+C`를 두 번 입력해서 나가기</div><div class=\"line\">&gt; .<span class=\"built_in\">exit</span></div><div class=\"line\"></div><div class=\"line\">// Node.js module 사용하기</div><div class=\"line\">&gt; const os = require(<span class=\"string\">'os'</span>) // 급할땐 `os = ...`</div><div class=\"line\">undefined</div><div class=\"line\"></div><div class=\"line\">&gt; os.platform()</div><div class=\"line\"><span class=\"string\">'linux'</span></div><div class=\"line\"></div><div class=\"line\">&gt; os.freemem()</div><div class=\"line\">658300928</div></pre></td></tr></table></figure><h1 id=\"node-js로-파일-실행시키기\"><a href=\"#node-js로-파일-실행시키기\" class=\"headerlink\" title=\"node.js로 파일 실행시키기\"></a>node.js로 파일 실행시키기</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ node (파일 경로)</div></pre></td></tr></table></figure><h1 id=\"node-js\"><a href=\"#node-js\" class=\"headerlink\" title=\"node.js\"></a>node.js</h1><p>Node.js®은 chrome의 v8 자바스크립트 엔진에 기반한 자바스크립트 런타임이다.</p><p>Node.js는 가볍고 효율적인 event-driven, non-blocking I/O model을 사용한다.</p><p>Node.js의 패키지 에코 시스템인 npm은 전 세계 오픈 소스 라이브러리 중 가장 큰 생태계(ecosystem)이다.</p><h2 id=\"1-JavaScript-Runtime이란\"><a href=\"#1-JavaScript-Runtime이란\" class=\"headerlink\" title=\"1) JavaScript Runtime이란?\"></a>1) JavaScript Runtime이란?</h2><ul><li>JavaScript는 언어</li><li>JavaScript 런타임(runtime)은 JS를 구동하기 위해 필요한 실행 환경</li><li>프로그래머는 런타임이 제공하는 도구를 응용해서 프로그램을 개발</li><li>웹 브라우저나 Node.js도 JavaScript 런타임의 일종</li></ul><h2 id=\"2-JavaScript-Runtime-종류\"><a href=\"#2-JavaScript-Runtime-종류\" class=\"headerlink\" title=\"2) JavaScript Runtime 종류\"></a>2) JavaScript Runtime 종류</h2><ul><li>Chrome이 제공하는 웹 브라우저용 런타임</li><li>Node.js가 제공하는 서버용 런타임</li><li>MongoDB가 제공하는 데이터 처리용 런타임</li><li>Photoshop이 제공하는 전용 런타임<br>…</li></ul><h1 id=\"V8-JavaScript-Engine\"><a href=\"#V8-JavaScript-Engine\" class=\"headerlink\" title=\"V8 JavaScript Engine\"></a>V8 JavaScript Engine</h1><p>JIT(Just-In-Time) compilation<br>Code Optimization<br>Used in<br>Google Chrome<br>Node.js<br>MongoDB<br>…</p><h2 id=\"V8-엔진의-작동-방식\"><a href=\"#V8-엔진의-작동-방식\" class=\"headerlink\" title=\"V8 엔진의 작동 방식?\"></a>V8 엔진의 작동 방식?</h2><h3 id=\"1-Event-driven-Programming\"><a href=\"#1-Event-driven-Programming\" class=\"headerlink\" title=\"1) Event-driven Programming\"></a>1) Event-driven Programming</h3><p>프로그램의 흐름이 외부 요인에 의해 일어나는 사건에 의해 결정되는 프로그래밍 양식<br>약속된 방식으로 이벤트 핸들러를 작성함으로써 외부 이벤트가 일어났을 때 코드를 실행</p><ul><li>마우스 입력</li><li>키보드 입력</li><li>다른 프로그램/컴퓨터로부터의 통신</li></ul><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"comment\">// DOM 이벤트 핸들러 등록 (웹 브라우저)</span></div><div class=\"line\">domElement.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">  e.stopPropagation()</div><div class=\"line\">  alert(<span class=\"string\">'hello'</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 서버도 똑같이 합니다.</span></div><div class=\"line\"><span class=\"comment\">// (단, 프레임워크를 쓸 때는 직접 이벤트를 다룰 일이 별로 없음)</span></div><div class=\"line\"><span class=\"comment\">// HTTP 응답 이벤트 핸들러 등록 (Node.js)</span></div><div class=\"line\">httpResponse.on(<span class=\"string\">'data'</span>, data =&gt; &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(data)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><h3 id=\"2-Non-blocking-I-O\"><a href=\"#2-Non-blocking-I-O\" class=\"headerlink\" title=\"2) Non-blocking I/O\"></a>2) Non-blocking I/O</h3><p>Blocking I/O는 스레드가 입력/출력이 완료될 때까지 기다렸다가 다음 코드를 실행</p><p>Non-blocking I/O는 스레드가 입력/출력을 기다리지 않고 코드를 계속 실행</p><p>순차적으로 실행되다가 기다려야 할 상황이 오면 코드 실행을 멈추고 그 상황이 완료된 이후에 코드를 실행하지만, 어떤 프로그래밍 언어나 기술들은 코드가 기다려야 하는 상황이 왔을 때, 그에 대한 신호만 주고 다음 코드를 계속 실행한다. 이전 코드가 완료되기를 기다렸다가 실행하는 것이 blocking I/O라고 하며 기다리지 않고 계속 실행하는 것을 non-blocking I/O라고 한다.</p><p>non-blocking의 단점은 코드가 복잡해질 수 있다는 점이다. (이러한 복잡함을 해결해주는 도구가 promise이다.)</p><p><strong>I/O 성능 향상 &amp; 복잡한 코드</strong></p><h1 id=\"Node-js-Module\"><a href=\"#Node-js-Module\" class=\"headerlink\" title=\"Node.js Module\"></a>Node.js Module</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// name.js</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// `module.exports`에 저장한 값은 다른 모듈에서 불러올 수 있음</span></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">  familyName: <span class=\"string\">'김'</span>,</div><div class=\"line\">  givenName: <span class=\"string\">'승하'</span>,</div><div class=\"line\">  fullName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.familyName + <span class=\"keyword\">this</span>.givenName</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// calc.js</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// `exports`로도 참조 가능</span></div><div class=\"line\">exports.add = <span class=\"function\">(<span class=\"params\">x, y</span>) =&gt;</span> x + y</div><div class=\"line\">exports.sub = <span class=\"function\">(<span class=\"params\">x, y</span>) =&gt;</span> x - y</div></pre></td></tr></table></figure><h1 id=\"REPL에서-불러오기\"><a href=\"#REPL에서-불러오기\" class=\"headerlink\" title=\"REPL에서 불러오기\"></a>REPL에서 불러오기</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Node.js 내장 모듈과는 다르게 경로를 지정해야 함</div><div class=\"line\">&gt; const name = require(&apos;./name&apos;)</div><div class=\"line\">undefined</div><div class=\"line\">&gt; name</div><div class=\"line\">&#123; familyName: &apos;김&apos;,</div><div class=\"line\">  givenName: &apos;승하&apos;,</div><div class=\"line\">  fullName: [Function: fullName] &#125;</div><div class=\"line\">&gt; name.familyName</div><div class=\"line\">&apos;김&apos;</div><div class=\"line\">&gt; name.fullName()</div><div class=\"line\">&apos;김승하&apos;</div><div class=\"line\">&gt; require(&apos;./calc&apos;).add(1, 2)</div><div class=\"line\">3</div></pre></td></tr></table></figure><p><strong>브라우저에서는 전역변수를 쓰면 위험하다</strong><br>script1.js 파일에 var evil = 1; 이라는 전역 변수를 선언하면 script2.js 파일에서도 evil을 참조할 수 있게 된다.<br>하지만 nodejs는 조금 다르다. nodejs 모듈은 각각의 스코프(scope)가 따로 존재한다. 따라서 module1.js에서 var evil = 1;이라고 선언하더라도 전역에 선언되는 것이 아닌, module1이라는 모듈 내의 스코프에서만 존재하기 때문에 다른 모듈에서 접근할 수 없다. 따라서 export하지 않으면 다른 모듈에서 해당 변수에 접근할 수 없다.</p><h1 id=\"NPM\"><a href=\"#NPM\" class=\"headerlink\" title=\"NPM\"></a>NPM</h1><p>Node.js 패키지 관리 도구 + 클라우드 패키지 저장소</p><ul><li>의존 패키지 관리</li><li>스크립트 실행</li><li>패키지 설정</li><li>NPM에 패키지 배포</li><li>Node.js 종합 작업 도구</li></ul><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ mkdir hello-npm</div><div class=\"line\">$ <span class=\"built_in\">cd</span> hello-npm</div><div class=\"line\">$ npm init -y</div><div class=\"line\">$ code .</div><div class=\"line\">// package.json</div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"name\"</span>: <span class=\"string\">\"hello-npm\"</span>,</div><div class=\"line\">  <span class=\"string\">\"version\"</span>: <span class=\"string\">\"1.0.0\"</span>,</div><div class=\"line\">  <span class=\"string\">\"description\"</span>: <span class=\"string\">\"\"</span>,</div><div class=\"line\">  <span class=\"string\">\"main\"</span>: <span class=\"string\">\"index.js\"</span>,</div><div class=\"line\">  <span class=\"string\">\"scripts\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"test\"</span>: <span class=\"string\">\"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"string\">\"keywords\"</span>: [],</div><div class=\"line\">  <span class=\"string\">\"author\"</span>: <span class=\"string\">\"\"</span>,</div><div class=\"line\">  <span class=\"string\">\"license\"</span>: <span class=\"string\">\"ISC\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><h1 id=\"package-json\"><a href=\"#package-json\" class=\"headerlink\" title=\"package.json\"></a>package.json</h1><p>패키지 정보를 담고 있는 파일</p><p><strong>dependencies</strong><br><code>npm install --save</code> 명령으로 설치한 패키지가 기록됨</p><p><strong>scripts</strong><br>원래 목적은 패키지 생명주기마다 자동으로 실행되는 명령을 등록하기 위함이나, 개발자 편의를 위해 자주 사용되는 명령을 등록하는 용도로 더 많이 사용됨</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install --save randomstring <span class=\"comment\"># node_modules에 저장됨</span></div></pre></td></tr></table></figure><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// index.js</span></div><div class=\"line\"><span class=\"keyword\">const</span> randomstring = <span class=\"built_in\">require</span>(<span class=\"string\">'randomstring'</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(randomstring.generate())</div></pre></td></tr></table></figure><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// package.json</div><div class=\"line\">...</div><div class=\"line\">  \"scripts\": &#123;</div><div class=\"line\">    \"start\": \"node index.js\"</div><div class=\"line\">  &#125;</div><div class=\"line\">...</div></pre></td></tr></table></figure><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm start</div></pre></td></tr></table></figure><h1 id=\"Concurrency-Model-동시성-모델\"><a href=\"#Concurrency-Model-동시성-모델\" class=\"headerlink\" title=\"Concurrency Model(동시성 모델)\"></a>Concurrency Model(동시성 모델)</h1><p>프로그램이 생애 주기가 겹치는 여러 실행 과정을 통해 실행된다 하더라도 프로그램의 결과에는 영향을 미치지 않는 성질</p><p>생애 주기가 겹치는 여러 실행 과정이 자원을 공유할 때 어떻게 충돌이 생기지 않도록 할 것인가?</p><h2 id=\"Resources\"><a href=\"#Resources\" class=\"headerlink\" title=\"Resources\"></a>Resources</h2><ul><li>CPU</li><li>메모리</li><li>네트워크</li><li>…</li></ul><h1 id=\"Thread\"><a href=\"#Thread\" class=\"headerlink\" title=\"Thread\"></a>Thread</h1><p>코드 실행의 가장 작은 단위</p><p>프로그램은 하나 이상의 스레드로 이루어짐</p><p>CPU 코어 하나는 한 번에 하나의 스레드를 실행</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sysctl -n hw.ncpu <span class=\"comment\"># OSX</span></div><div class=\"line\">$ nproc <span class=\"comment\"># linux</span></div><div class=\"line\">$ mmc devmgmt.msc <span class=\"comment\"># Windows</span></div><div class=\"line\">$ top -H <span class=\"comment\"># Shows the total number of threads</span></div></pre></td></tr></table></figure><h1 id=\"동시성을-위한-도구\"><a href=\"#동시성을-위한-도구\" class=\"headerlink\" title=\"동시성을 위한 도구\"></a>동시성을 위한 도구</h1><p>자원의 공유를 위해 프로그래밍 언어는 언어들만이 가지고 있는 동시성을 위한 도구를 가지고 있는 경우가 많다.</p><h2 id=\"1-운영체제-차원의-도구\"><a href=\"#1-운영체제-차원의-도구\" class=\"headerlink\" title=\"1) 운영체제 차원의 도구\"></a>1) 운영체제 차원의 도구</h2><ul><li>Process</li><li>Thread</li><li>Mutex (Mutual Exclusion)</li></ul><h2 id=\"2-언어-차원의-도구\"><a href=\"#2-언어-차원의-도구\" class=\"headerlink\" title=\"2) 언어 차원의 도구\"></a>2) 언어 차원의 도구</h2><ul><li>Python - asyncio</li><li>Go - goroutine</li><li>Erlang - actor</li><li>JavaScript - …?</li></ul><p><br></p><h1 id=\"자바스크립트의-동시성\"><a href=\"#자바스크립트의-동시성\" class=\"headerlink\" title=\"자바스크립트의 동시성\"></a>자바스크립트의 동시성</h1><h2 id=\"Single-Threaded-Event-Loop\"><a href=\"#Single-Threaded-Event-Loop\" class=\"headerlink\" title=\"Single-Threaded Event Loop\"></a>Single-Threaded Event Loop</h2><p><strong>자바스크립트를 실행시키는 스레드가 하나 뿐이다.</strong><br>실행 과정(보통 콜백 연쇄)의 생애 주기가 겹칠 수는 있지만 어떤 경우에도 두 자바스크립트 실행과정이 동시에 실행되는 경우는 없음. 내부적으로 메시지 큐를 활용하고 있으나, 모든 처리가 자동으로 이루어짐</p><p>!MDN[<a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/EventLoop\" target=\"_blank\" rel=\"external\">https://developer.mozilla.org/ko/docs/Web/JavaScript/EventLoop</a>]</p><h2 id=\"1-장점\"><a href=\"#1-장점\" class=\"headerlink\" title=\"1) 장점\"></a>1) 장점</h2><ul><li>프로그래머가 동시성에 대해 신경쓸 필요가 없어짐</li><li>프로그램 작성이 쉬워짐</li></ul><h2 id=\"2-단점\"><a href=\"#2-단점\" class=\"headerlink\" title=\"2) 단점\"></a>2) 단점</h2><ul><li>CPU를 많이 쓰는 작업에 부적절</li><li>오래 걸리는 자바스크립트 코드가 실행되면 전체 프로그램에 영향을 미침</li></ul><h2 id=\"3-전략\"><a href=\"#3-전략\" class=\"headerlink\" title=\"3) 전략\"></a>3) 전략</h2><p>브라우저는 API가 있다면 API에 위임, 노드js는 c/c++로 만들어진 모듈을 가져와서 사용할 수 있는 방법이 있다.</p><ul><li>오래 걸리는 일은 외부에 위임하고 넘어간 뒤, 나중에 결과를 받아 처리하기<ul><li>Database</li><li>Node.js - External libraries</li><li>Web browser - WebAssembly</li></ul></li><li>긴 실행과정을 <strong>여러 개의 함수로 쪼개서</strong> 한 번의 함수 실행이 금방 끝나게 만들기</li></ul><p><br></p><h1 id=\"Asynchronous-JavaScript\"><a href=\"#Asynchronous-JavaScript\" class=\"headerlink\" title=\"Asynchronous JavaScript\"></a>Asynchronous JavaScript</h1><p>non-blocking과 asynchronous는 비슷한 맥락이다. 다만, non-blocking은 코드의 실행 순서에 대한 개념이고, asynchronous는 코드 작성 방식에 대한 개념이다.</p><ul><li>함수를 호출할 때, 콜백까지 같이 인자에 넣어서 호출하는 비동기 프로그래밍 양식</li><li>콜백에서 에러 인자를 받는 방식으로 에러 처리를 함</li><li>Node.js 내장 모듈 전체가 이 방식을 사용하도록 만들어져 있음</li><li>주의! 모든 콜백이 비동기인 것은 아님</li></ul><hr><h1 id=\"비동기식-코드의-에러처리-관습\"><a href=\"#비동기식-코드의-에러처리-관습\" class=\"headerlink\" title=\"비동기식 코드의 에러처리: 관습\"></a>비동기식 코드의 에러처리: 관습</h1><p>try-catch는 동기식 에러처리 시에만 사용한다. 비동기식 에러 처리는 관습적으로 아래 방식을 사용한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//readFile.js</span></div><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>); <span class=\"comment\">// Node.js 내장 모듈</span></div><div class=\"line\">fs.readFile(<span class=\"string\">'./calc.js'</span>, <span class=\"string\">'utf8'</span>, (err, data) =&gt; &#123;</div><div class=\"line\">  <span class=\"comment\">// 에러처리</span></div><div class=\"line\">  <span class=\"keyword\">if</span>(err) &#123; <span class=\"comment\">//error가 있으면</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.error(err);</div><div class=\"line\">  &#125;<span class=\"keyword\">else</span> &#123; <span class=\"comment\">//errro가 없으면 </span></div><div class=\"line\">    <span class=\"built_in\">console</span>.data(data);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'done!'</span>);</div></pre></td></tr></table></figure><h1 id=\"동기식-코드의-에러-처리-일반적인-방식으로-처리\"><a href=\"#동기식-코드의-에러-처리-일반적인-방식으로-처리\" class=\"headerlink\" title=\"동기식 코드의 에러 처리: 일반적인 방식으로 처리\"></a>동기식 코드의 에러 처리: 일반적인 방식으로 처리</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//readFileSync.js</span></div><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>); <span class=\"comment\">// Node.js 내장 모듈</span></div><div class=\"line\"><span class=\"keyword\">try</span> &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> data = fs.readFileSync(<span class=\"string\">'./calc.js'</span>, <span class=\"string\">'utf8'</span>);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> (err) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'done!'</span>);</div></pre></td></tr></table></figure><hr><p>위 예제에서 readFile.js는 비동기 방식이며 readFileSync는 동기 방식으로 동작하는 코드이다. 코드를 실행 한 후 결과를 보면,</p><ul><li>readFile.js</li></ul><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">done</span>!</div><div class=\"line\">&#123; Error: ENOENT: no such file or directory, open <span class=\"string\">'./calc.js'</span> errno: -2, code: <span class=\"string\">'ENOENT'</span>, syscall: <span class=\"string\">'open'</span>, path: <span class=\"string\">'./calc.js'</span> &#125;</div></pre></td></tr></table></figure><p>비동기 방식에서는 마지막 줄의 <code>console.log(&#39;done!&#39;)</code>코드가 이전 코드의 실행이 완료될 때까지 기다리지 않고 먼저 실행된다.</p><ul><li>readFileSync.js</li></ul><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123; Error: ENOENT: no such file or directory, open <span class=\"string\">'./calc.js'</span></div><div class=\"line\">    at Object.fs.openSync (fs.js:652:18)</div><div class=\"line\">    at Object.fs.readFileSync (fs.js:553:33)</div><div class=\"line\">    at Object.&lt;anonymous&gt; (/Users/ihyeseung/projectfolder/fastcam/frontstudy/nodejs/practice/readFileSync.js:4:19)</div><div class=\"line\">    at Module._compile (module.js:573:30)</div><div class=\"line\">    at Object.Module._extensions..js (module.js:584:10)</div><div class=\"line\">    at Module.load (module.js:507:32)</div><div class=\"line\">    at tryModuleLoad (module.js:470:12)</div><div class=\"line\">    at Function.Module._load (module.js:462:3)</div><div class=\"line\">    at Function.Module.runMain (module.js:609:10)</div><div class=\"line\">    at startup (bootstrap_node.js:158:16) errno: -2, code: <span class=\"string\">'ENOENT'</span>, syscall: <span class=\"string\">'open'</span>, path: <span class=\"string\">'./calc.js'</span> &#125;</div><div class=\"line\"><span class=\"keyword\">done</span>!</div></pre></td></tr></table></figure><p>동기 방식에서는 <code>console.log(&#39;done!&#39;)</code>이 이전 코드의 실행이 완료될때까지 기다린 후 실행되었다.</p><p><br></p><h1 id=\"Github-REST-API-호출\"><a href=\"#Github-REST-API-호출\" class=\"headerlink\" title=\"Github REST API 호출\"></a>Github REST API 호출</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//request.js</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 유저 이름, 저장소, 할당된 이슈 갯수 출력하기</span></div><div class=\"line\"><span class=\"keyword\">const</span> request = <span class=\"built_in\">require</span>(<span class=\"string\">'request'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> apiUrl = <span class=\"string\">'https://api.github.com'</span></div><div class=\"line\"><span class=\"keyword\">const</span> option = &#123;</div><div class=\"line\">  json: <span class=\"literal\">true</span>,</div><div class=\"line\">  auth: &#123;</div><div class=\"line\">    <span class=\"string\">'user'</span>: <span class=\"string\">'username'</span>, <span class=\"comment\">// github 유저네임</span></div><div class=\"line\">    <span class=\"string\">'pass'</span>: <span class=\"string\">'password'</span>, <span class=\"comment\">// github 비밀번호</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  headers: &#123;</div><div class=\"line\">    <span class=\"string\">'User-Agent'</span>: <span class=\"string\">'request'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">request.get(<span class=\"string\">`<span class=\"subst\">$&#123;apiUrl&#125;</span>/user`</span>, option, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error, response, body</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> name = body.name</div><div class=\"line\">  <span class=\"keyword\">if</span> (error) <span class=\"built_in\">console</span>.error(error)</div><div class=\"line\">  <span class=\"comment\">// 콜백 안에 콜백</span></div><div class=\"line\">  request.get(<span class=\"string\">`<span class=\"subst\">$&#123;apiUrl&#125;</span>/user/repos`</span>, option, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error, response, body</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (error) <span class=\"built_in\">console</span>.error(error)</div><div class=\"line\">    <span class=\"keyword\">const</span> repoNames = body.map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item.name)</div><div class=\"line\">    <span class=\"comment\">// 콜백 안에 콜백 안에 콜백</span></div><div class=\"line\">    request.get(<span class=\"string\">`<span class=\"subst\">$&#123;apiUrl&#125;</span>/issues`</span>, option, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error, response, body</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (error) <span class=\"built_in\">console</span>.error(error)</div><div class=\"line\">      <span class=\"keyword\">const</span> issueNum = body.length</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`name: <span class=\"subst\">$&#123;name&#125;</span>`</span>)</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'repos:'</span>)</div><div class=\"line\">      repoNames.forEach(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(name)</div><div class=\"line\">      &#125;)</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`num of assigned issues: <span class=\"subst\">$&#123;issueNum&#125;</span>`</span>)</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ node request.js</div></pre></td></tr></table></figure><h2 id=\"Callback-Hell\"><a href=\"#Callback-Hell\" class=\"headerlink\" title=\"Callback Hell\"></a>Callback Hell</h2><p><img src=\"https://image.slidesharecdn.com/promisesandchaininginangularjs-141027044455-conversion-gate02/95/promises-and-chaining-in-angularjs-into-callback-hell-and-back-again-17-638.jpg?cb=1414385382\" alt=\"callback hell\"></p><p><br></p><h1 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h1><p>비동기 작업의 결과를 담는 객체<br>정확히 언제가 될지 모르지만, 결국 성공 또는 실패의 상태를 갖게 되며 이 상태가 되었을 때 비로소 콜백을 실행하라는 명령을 갖게 된다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// tenSec.js</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 10초 뒤에 콜백(promise 객체를 새로 만들어서 리턴)을 실행하는 함수</span></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tenSec</span>(<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</div><div class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">      resolve(value)</div><div class=\"line\">    &#125;, <span class=\"number\">10000</span>)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; const tenSec = require(&apos;./tenSec&apos;)</div><div class=\"line\">&gt; const p = tenSec(1) // p에 Promise 저장</div><div class=\"line\">&gt; p // 만든지 10초가 지나기 전</div><div class=\"line\">Promise &#123;</div><div class=\"line\">  [pending], //pending: 아직 결과가 나오지 않음.</div><div class=\"line\">  ...</div><div class=\"line\">&gt; p // 만든지 10초가 지난 후</div><div class=\"line\">Promise &#123;</div><div class=\"line\">  1,</div><div class=\"line\">  ...</div></pre></td></tr></table></figure><h2 id=\"1-promise의-상태-state\"><a href=\"#1-promise의-상태-state\" class=\"headerlink\" title=\"1) promise의 상태(state)\"></a>1) promise의 상태(state)</h2><ul><li><p>pending<br>아직 수행 중인 상태 (fulfilled 혹은 rejected 되기 전)</p></li><li><p>fulfilled<br>promise가 지켜진(수행된) 상태</p></li><li><p>rejected<br>promise가 지켜지지 못한(거부된) 상태</p></li><li><p>settled<br>fulfilled이든 rejected이든 결론이 난 상태</p></li></ul><h2 id=\"2-then\"><a href=\"#2-then\" class=\"headerlink\" title=\"2) .then\"></a>2) .then</h2><p>promise 객체의 메서드</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; tenSec(&apos;hello promise&apos;).then(value =&gt; &#123;</div><div class=\"line\">... console.log(value)</div><div class=\"line\">... &#125;)</div><div class=\"line\">Promise &#123; // `then`은 Promise를 반환</div><div class=\"line\">  [pending],</div><div class=\"line\">  ...</div><div class=\"line\">&gt; // 10초 후</div><div class=\"line\">&apos;hello promise&apos;</div></pre></td></tr></table></figure><p>new Promise ()의 결과는 promise이다.<br>.then 메소드에서 반환된 값도 promise이다.<br>따라서 .then 메소드를 계속 사용할 수 있다.<br>.then 메소드를 쓰면 들여쓰기를 하지 않아도 된다.<br>따라서 Callback Hell을 피할 수 있다.</p><p>return은 바로 실행되는 동기식 작업이다.</p><p>비동기 작업을 하려면 콜백을 통해서 해야 했다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>()</div><div class=\"line\">.then(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</div><div class=\"line\">  request.get( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">  &#125;)</div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"comment\">// 콜백은 함수 밖에서 리턴이 불가하다</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p>promise는 함수 밖에서 리턴해야 하는데 위와 같은 콜백 방식에서는 함수 밖에서 리턴이 불가하다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>()</div><div class=\"line\">.then(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</div><div class=\"line\">  </div><div class=\"line\">&#125;)</div><div class=\"line\">.then(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</div><div class=\"line\"></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><h2 id=\"3-Promise-chaining\"><a href=\"#3-Promise-chaining\" class=\"headerlink\" title=\"3) Promise chaining\"></a>3) Promise chaining</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// chaining.js</span></div><div class=\"line\"><span class=\"keyword\">const</span> tenSec = <span class=\"built_in\">require</span>(<span class=\"string\">'./tenSec'</span>)</div><div class=\"line\">tenSec(<span class=\"string\">'hello promise'</span>)</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(value)</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span> <span class=\"comment\">// 위 `.then`은 값이 1인 Promise를 반환함</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(value) <span class=\"comment\">// value = 1</span></div><div class=\"line\">    <span class=\"keyword\">return</span> tenSec(<span class=\"string\">'new promise'</span>) <span class=\"comment\">// Promise도 반환할 수 있음</span></div><div class=\"line\">  &#125;) <span class=\"comment\">// 안에 들어 있는 값이 value(=1)인 Promise 생성</span></div><div class=\"line\">  .then(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123; <span class=\"comment\">// tenSec이 실행되고 10초 후 실행됨</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(value)</div><div class=\"line\">  &#125;)</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"comment\">//promise 안에서 에러가 나면</span></div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'error in promise'</span>)</div><div class=\"line\">  &#125;)</div><div class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123; <span class=\"comment\">// 에러가 나면 catch 내부 코드 실행, 안나면 통과</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.error(err)</div><div class=\"line\">  &#125;)</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"comment\">// 에러 처리 이후에도 코드 실행 가능</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'done'</span>)</div><div class=\"line\">  &#125;)</div></pre></td></tr></table></figure><hr><h3 id=\"기타-메소드\"><a href=\"#기타-메소드\" class=\"headerlink\" title=\"기타 메소드\"></a>기타 메소드</h3><ul><li>Promise.all(Arr): 모든 프라미스가 성공해야 성공하는 promise</li></ul><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">pa = <span class=\"built_in\">Promise</span>.all([p1, p2])</div><div class=\"line\"><span class=\"comment\">// pa는 p1, p2가 모두 성공해야 성공하는 Promise이다.</span></div></pre></td></tr></table></figure><ul><li>Promise.race(Arr): 가장 빨리 성공하는 promise를 반환</li></ul><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pr = <span class=\"built_in\">Promise</span>.race([p1, pw])</div></pre></td></tr></table></figure><ul><li>promisify 함수</li></ul><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// readfilePromise.js</span></div><div class=\"line\"><span class=\"keyword\">const</span> &#123;promisify&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>) <span class=\"comment\">// Node.js 8.0.0부터 추가됨</span></div><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> readFile = promisify(fs.readFile)</div><div class=\"line\">readFile(<span class=\"string\">'./calc.js'</span>, <span class=\"string\">'utf8'</span>)</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(data)</div><div class=\"line\">  &#125;)</div><div class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.error(err)</div><div class=\"line\">  &#125;)</div></pre></td></tr></table></figure><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123; Error: ENOENT: no such file or directory, open &apos;./calc.js&apos; errno: -2, code: &apos;ENOENT&apos;, syscall: &apos;open&apos;, path: &apos;./calc.js&apos; &#125;</div></pre></td></tr></table></figure><hr><h2 id=\"4-Promise의-특징\"><a href=\"#4-Promise의-특징\" class=\"headerlink\" title=\"4) Promise의 특징\"></a>4) Promise의 특징</h2><p>1) 이미 resolve 된 Promise에도 콜백을 실행할 수 있음</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; <span class=\"keyword\">const</span> resolved = <span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">1</span>)</div><div class=\"line\">&gt; resolved.then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</div></pre></td></tr></table></figure><p>2) <code>.then</code>에 넘겨진 콜백은 (비동기가 아니라 바로 성공하도록 만들어진 동기식 promise라 하더라도)무조건 다음 루프에 실행됨</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">... Promise.resolve(<span class=\"number\">1</span>).then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</div><div class=\"line\">... console.log(<span class=\"string\">'done!'</span>)</div><div class=\"line\">... &#125;)()</div><div class=\"line\"><span class=\"comment\">/* 출력:</span></div><div class=\"line\"><span class=\"comment\">done! -&gt; 먼저 출력된다.</span></div><div class=\"line\"><span class=\"comment\">1</span></div><div class=\"line\"><span class=\"comment\">*/</span></div></pre></td></tr></table></figure><h2 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all\"></a>Promise.all</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// npm install --save request-promise</span></div><div class=\"line\"><span class=\"keyword\">const</span> rp = <span class=\"built_in\">require</span>(<span class=\"string\">'request-promise'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> apiUrl = <span class=\"string\">'https://api.github.com'</span></div><div class=\"line\"><span class=\"keyword\">const</span> option = &#123;</div><div class=\"line\">  json: <span class=\"literal\">true</span>,</div><div class=\"line\">  auth: &#123;</div><div class=\"line\">    <span class=\"string\">'user'</span>: <span class=\"string\">'username'</span>,</div><div class=\"line\">    <span class=\"string\">'pass'</span>: <span class=\"string\">'password'</span>,</div><div class=\"line\">  &#125;,</div><div class=\"line\">  headers: &#123;</div><div class=\"line\">    <span class=\"string\">'User-Agent'</span>: <span class=\"string\">'request'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> userPromise = rp.get(<span class=\"string\">`<span class=\"subst\">$&#123;apiUrl&#125;</span>/user`</span>, option)</div><div class=\"line\"><span class=\"keyword\">const</span> reposPromise = rp.get(<span class=\"string\">`<span class=\"subst\">$&#123;apiUrl&#125;</span>/user/repos`</span>, option)</div><div class=\"line\"><span class=\"keyword\">const</span> issuesPromise = rp.get(<span class=\"string\">`<span class=\"subst\">$&#123;apiUrl&#125;</span>/issues`</span>, option)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 배열 내의 모든 Promise 객체가 완료되었을 때</span></div><div class=\"line\"><span class=\"comment\">// resolve 되는 Promise를 만든다.</span></div><div class=\"line\"><span class=\"built_in\">Promise</span>.all([userPromise, reposPromise, issuesPromise])</div><div class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">[user, repos, issues]</span>) =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`name: <span class=\"subst\">$&#123;user.name&#125;</span>`</span>)</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'repos:'</span>)</div><div class=\"line\">    repos.forEach(<span class=\"function\"><span class=\"params\">repo</span> =&gt;</span> &#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(repo.name)</div><div class=\"line\">    &#125;)</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`num of assigned issues: <span class=\"subst\">$&#123;issues.length&#125;</span>`</span>)</div><div class=\"line\">  &#125;)</div></pre></td></tr></table></figure><p>비동기 코드와 동일한 일을 promise로 할 수 있으며 promise를 이용하면 좀 더 깔끔하게 코드를 짤 수 있다.</p><blockquote><ul><li><a href=\"http://hacks.mozilla.or.kr/2015/05/this-api-is-so-fetching/\" target=\"_blank\" rel=\"external\">Fetch API</a><ul><li>window.fetch polyfill: Fetch API를 IE에서도 사용할 수 있게 해준다.</li></ul></li></ul></blockquote><p><br></p><h1 id=\"Async-Await\"><a href=\"#Async-Await\" class=\"headerlink\" title=\"Async/Await\"></a>Async/Await</h1><ul><li>ES2017에서 도입되어, 비동기식 코드를 동기식 코드처럼 쓸 수 있는 문법 제공</li><li>Chrome 55, Node.js 8.0.0 부터 사용가능<br>(아주 최근에 나온 문법이므로, 아직까지는 비동기식 코드에 promise가 더 널리 쓰인다.)</li><li>async function 안에서 반환된 값은 최종적으로 Promise 객체로 변환되어 반환된다.</li><li>async function 안에서 쓸 수 있는 await 키워드는 현재 함수를 중단시키고 Promise 객체가 충족될 때까지 기다리지만, 스레드를 block 하지 않는다.</li><li>에러 처리는 동기식 코드처럼 try, catch 블록을 통해서 한다.</li></ul><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> tenSec = <span class=\"built_in\">require</span>(<span class=\"string\">'./tenSec'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//await는 async 함수 안에서만 사용할 수 있다.</span></div><div class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolveAfterTenSec</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">await</span> tenSec()</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">resolveAfterTenSec().then(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(value)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><h2 id=\"1-readFile-async-await\"><a href=\"#1-readFile-async-await\" class=\"headerlink\" title=\"1) readFile - async/await\"></a>1) readFile - async/await</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// readfileAsync.js</span></div><div class=\"line\"><span class=\"keyword\">const</span> &#123;promisify&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>) <span class=\"comment\">// Node.js 8.0.0부터 추가됨</span></div><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> readFile = promisify(fs.readFile)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">readFileAsync</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> readFile(<span class=\"string\">'./calc.js'</span>, <span class=\"string\">'utf8'</span>)</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(data)</div><div class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.error(e)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">readFileAsync()</div></pre></td></tr></table></figure><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123; Error: ENOENT: no such file or directory, open &apos;./calc.js&apos; errno: -2, code: &apos;ENOENT&apos;, syscall: &apos;open&apos;, path: &apos;./calc.js&apos; &#125;</div></pre></td></tr></table></figure><hr>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://allvectorlogo.com/img/2016/05/node-js-logo.png\" alt=\"\"></p><h1 id=\"nvm-node-version-manager\"><a href=\"#nvm-node-version-manager\" class=\"headerlink\" title=\"nvm(node version manager)\"></a>nvm(node version manager)</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 주석: `#`으로 시작하는 명령은 bash에서 무시됩니다.</span></div><div class=\"line\"><span class=\"comment\"># 아래 명령을 한 줄씩 차례대로 입력하세요</span></div><div class=\"line\">$ nvm install 8.4</div><div class=\"line\">$ nvm use 8.4</div><div class=\"line\">$ nvm <span class=\"built_in\">alias</span> default 8.4 <span class=\"comment\"># nvm-windows는 필요없음</span></div></pre></td></tr></table></figure><h1 id=\"Node-js-REPL\"><a href=\"#Node-js-REPL\" class=\"headerlink\" title=\"Node.js REPL\"></a>Node.js REPL</h1><p>REPL(Read Eval Print Loop): 윈도우 커맨드, 혹은 UNIX/LINUX Shell처럼 사용자가 커맨드를 입력하면 시스템이 값을 반환하는 환경을 일컫는다.</p><p>Node.js는 REPL 환경과 함께 제공되며 다음과 같은 기능을 수행할 수 있다.</p><ul><li>Read: 유저의 값을 입력 받아 Javascript 데이터 구조로 메모리에 저장한다.</li><li>Eval: 데이터를 처리(Evaluate)한다.</li><li>Print: 결과값을 출력한다.</li><li>Loop: Read, Eval, Print를 유저가 Ctrl+C를 두 번 눌러 종료할 때까지 반복한다.</li></ul><p>Node.js 의 REPL 환경은 자바스크립트 코드의 테스팅 및 디버깅할 때 유용하게 사용된다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">// REPL 시작하기</div><div class=\"line\">$ node</div><div class=\"line\"></div><div class=\"line\">// 한 줄 짜리 코드 입력하기</div><div class=\"line\">&gt; <span class=\"string\">'hello node'</span></div><div class=\"line\"><span class=\"string\">'hello node'</span></div><div class=\"line\"></div><div class=\"line\">// 위쪽 화살표 키를 입력해서 이전 명령 불러오기</div><div class=\"line\">&gt; <span class=\"string\">'hello node'</span></div><div class=\"line\"><span class=\"string\">'hello node'</span></div><div class=\"line\"></div><div class=\"line\">// Underscore(_) 변수</div><div class=\"line\">밑줄 _변수는 최근 결과값을 지칭한다.</div><div class=\"line\">&gt; var x = 10;</div><div class=\"line\">undefined</div><div class=\"line\">&gt; var y = 5;</div><div class=\"line\">undefined</div><div class=\"line\">&gt; x+y;</div><div class=\"line\">15</div><div class=\"line\">&gt; var sum = _</div><div class=\"line\">undefined</div><div class=\"line\">&gt;console.log(sum)</div><div class=\"line\">15</div><div class=\"line\">undefined</div><div class=\"line\"></div><div class=\"line\">// 변수 사용하기</div><div class=\"line\">&gt; const factorial = n =&gt; n &lt; 1 ? 1 : n * factorial(n-1)</div><div class=\"line\">undefined</div><div class=\"line\"></div><div class=\"line\">&gt; factorial(3)</div><div class=\"line\">6</div><div class=\"line\"></div><div class=\"line\">// 여러 줄에 나눠서 입력하기</div><div class=\"line\">&gt; <span class=\"keyword\">function</span> factorial2(n) &#123;</div><div class=\"line\">... <span class=\"built_in\">return</span> n &lt; 1 ? 1 : n * factorial(n-1)</div><div class=\"line\">... &#125;</div><div class=\"line\">undefined</div><div class=\"line\"></div><div class=\"line\">&gt; factorial2(4)</div><div class=\"line\">24</div><div class=\"line\"></div><div class=\"line\">// `.<span class=\"built_in\">exit</span>`를 입력하거나 `Ctrl+C`를 두 번 입력해서 나가기</div><div class=\"line\">&gt; .<span class=\"built_in\">exit</span></div><div class=\"line\"></div><div class=\"line\">// Node.js module 사용하기</div><div class=\"line\">&gt; const os = require(<span class=\"string\">'os'</span>) // 급할땐 `os = ...`</div><div class=\"line\">undefined</div><div class=\"line\"></div><div class=\"line\">&gt; os.platform()</div><div class=\"line\"><span class=\"string\">'linux'</span></div><div class=\"line\"></div><div class=\"line\">&gt; os.freemem()</div><div class=\"line\">658300928</div></pre></td></tr></table></figure><h1 id=\"node-js로-파일-실행시키기\"><a href=\"#node-js로-파일-실행시키기\" class=\"headerlink\" title=\"node.js로 파일 실행시키기\"></a>node.js로 파일 실행시키기</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ node (파일 경로)</div></pre></td></tr></table></figure><h1 id=\"node-js\"><a href=\"#node-js\" class=\"headerlink\" title=\"node.js\"></a>node.js</h1><p>Node.js®은 chrome의 v8 자바스크립트 엔진에 기반한 자바스크립트 런타임이다.</p><p>Node.js는 가볍고 효율적인 event-driven, non-blocking I/O model을 사용한다.</p><p>Node.js의 패키지 에코 시스템인 npm은 전 세계 오픈 소스 라이브러리 중 가장 큰 생태계(ecosystem)이다.</p><h2 id=\"1-JavaScript-Runtime이란\"><a href=\"#1-JavaScript-Runtime이란\" class=\"headerlink\" title=\"1) JavaScript Runtime이란?\"></a>1) JavaScript Runtime이란?</h2><ul><li>JavaScript는 언어</li><li>JavaScript 런타임(runtime)은 JS를 구동하기 위해 필요한 실행 환경</li><li>프로그래머는 런타임이 제공하는 도구를 응용해서 프로그램을 개발</li><li>웹 브라우저나 Node.js도 JavaScript 런타임의 일종</li></ul><h2 id=\"2-JavaScript-Runtime-종류\"><a href=\"#2-JavaScript-Runtime-종류\" class=\"headerlink\" title=\"2) JavaScript Runtime 종류\"></a>2) JavaScript Runtime 종류</h2><ul><li>Chrome이 제공하는 웹 브라우저용 런타임</li><li>Node.js가 제공하는 서버용 런타임</li><li>MongoDB가 제공하는 데이터 처리용 런타임</li><li>Photoshop이 제공하는 전용 런타임<br>…</li></ul><h1 id=\"V8-JavaScript-Engine\"><a href=\"#V8-JavaScript-Engine\" class=\"headerlink\" title=\"V8 JavaScript Engine\"></a>V8 JavaScript Engine</h1><p>JIT(Just-In-Time) compilation<br>Code Optimization<br>Used in<br>Google Chrome<br>Node.js<br>MongoDB<br>…</p><h2 id=\"V8-엔진의-작동-방식\"><a href=\"#V8-엔진의-작동-방식\" class=\"headerlink\" title=\"V8 엔진의 작동 방식?\"></a>V8 엔진의 작동 방식?</h2><h3 id=\"1-Event-driven-Programming\"><a href=\"#1-Event-driven-Programming\" class=\"headerlink\" title=\"1) Event-driven Programming\"></a>1) Event-driven Programming</h3><p>프로그램의 흐름이 외부 요인에 의해 일어나는 사건에 의해 결정되는 프로그래밍 양식<br>약속된 방식으로 이벤트 핸들러를 작성함으로써 외부 이벤트가 일어났을 때 코드를 실행</p><ul><li>마우스 입력</li><li>키보드 입력</li><li>다른 프로그램/컴퓨터로부터의 통신</li></ul><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"comment\">// DOM 이벤트 핸들러 등록 (웹 브라우저)</span></div><div class=\"line\">domElement.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">  e.stopPropagation()</div><div class=\"line\">  alert(<span class=\"string\">'hello'</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 서버도 똑같이 합니다.</span></div><div class=\"line\"><span class=\"comment\">// (단, 프레임워크를 쓸 때는 직접 이벤트를 다룰 일이 별로 없음)</span></div><div class=\"line\"><span class=\"comment\">// HTTP 응답 이벤트 핸들러 등록 (Node.js)</span></div><div class=\"line\">httpResponse.on(<span class=\"string\">'data'</span>, data =&gt; &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(data)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><h3 id=\"2-Non-blocking-I-O\"><a href=\"#2-Non-blocking-I-O\" class=\"headerlink\" title=\"2) Non-blocking I/O\"></a>2) Non-blocking I/O</h3><p>Blocking I/O는 스레드가 입력/출력이 완료될 때까지 기다렸다가 다음 코드를 실행</p><p>Non-blocking I/O는 스레드가 입력/출력을 기다리지 않고 코드를 계속 실행</p><p>순차적으로 실행되다가 기다려야 할 상황이 오면 코드 실행을 멈추고 그 상황이 완료된 이후에 코드를 실행하지만, 어떤 프로그래밍 언어나 기술들은 코드가 기다려야 하는 상황이 왔을 때, 그에 대한 신호만 주고 다음 코드를 계속 실행한다. 이전 코드가 완료되기를 기다렸다가 실행하는 것이 blocking I/O라고 하며 기다리지 않고 계속 실행하는 것을 non-blocking I/O라고 한다.</p><p>non-blocking의 단점은 코드가 복잡해질 수 있다는 점이다. (이러한 복잡함을 해결해주는 도구가 promise이다.)</p><p><strong>I/O 성능 향상 &amp; 복잡한 코드</strong></p><h1 id=\"Node-js-Module\"><a href=\"#Node-js-Module\" class=\"headerlink\" title=\"Node.js Module\"></a>Node.js Module</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// name.js</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// `module.exports`에 저장한 값은 다른 모듈에서 불러올 수 있음</span></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">  familyName: <span class=\"string\">'김'</span>,</div><div class=\"line\">  givenName: <span class=\"string\">'승하'</span>,</div><div class=\"line\">  fullName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.familyName + <span class=\"keyword\">this</span>.givenName</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// calc.js</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// `exports`로도 참조 가능</span></div><div class=\"line\">exports.add = <span class=\"function\">(<span class=\"params\">x, y</span>) =&gt;</span> x + y</div><div class=\"line\">exports.sub = <span class=\"function\">(<span class=\"params\">x, y</span>) =&gt;</span> x - y</div></pre></td></tr></table></figure><h1 id=\"REPL에서-불러오기\"><a href=\"#REPL에서-불러오기\" class=\"headerlink\" title=\"REPL에서 불러오기\"></a>REPL에서 불러오기</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Node.js 내장 모듈과는 다르게 경로를 지정해야 함</div><div class=\"line\">&gt; const name = require(&apos;./name&apos;)</div><div class=\"line\">undefined</div><div class=\"line\">&gt; name</div><div class=\"line\">&#123; familyName: &apos;김&apos;,</div><div class=\"line\">  givenName: &apos;승하&apos;,</div><div class=\"line\">  fullName: [Function: fullName] &#125;</div><div class=\"line\">&gt; name.familyName</div><div class=\"line\">&apos;김&apos;</div><div class=\"line\">&gt; name.fullName()</div><div class=\"line\">&apos;김승하&apos;</div><div class=\"line\">&gt; require(&apos;./calc&apos;).add(1, 2)</div><div class=\"line\">3</div></pre></td></tr></table></figure><p><strong>브라우저에서는 전역변수를 쓰면 위험하다</strong><br>script1.js 파일에 var evil = 1; 이라는 전역 변수를 선언하면 script2.js 파일에서도 evil을 참조할 수 있게 된다.<br>하지만 nodejs는 조금 다르다. nodejs 모듈은 각각의 스코프(scope)가 따로 존재한다. 따라서 module1.js에서 var evil = 1;이라고 선언하더라도 전역에 선언되는 것이 아닌, module1이라는 모듈 내의 스코프에서만 존재하기 때문에 다른 모듈에서 접근할 수 없다. 따라서 export하지 않으면 다른 모듈에서 해당 변수에 접근할 수 없다.</p><h1 id=\"NPM\"><a href=\"#NPM\" class=\"headerlink\" title=\"NPM\"></a>NPM</h1><p>Node.js 패키지 관리 도구 + 클라우드 패키지 저장소</p><ul><li>의존 패키지 관리</li><li>스크립트 실행</li><li>패키지 설정</li><li>NPM에 패키지 배포</li><li>Node.js 종합 작업 도구</li></ul><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ mkdir hello-npm</div><div class=\"line\">$ <span class=\"built_in\">cd</span> hello-npm</div><div class=\"line\">$ npm init -y</div><div class=\"line\">$ code .</div><div class=\"line\">// package.json</div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"name\"</span>: <span class=\"string\">\"hello-npm\"</span>,</div><div class=\"line\">  <span class=\"string\">\"version\"</span>: <span class=\"string\">\"1.0.0\"</span>,</div><div class=\"line\">  <span class=\"string\">\"description\"</span>: <span class=\"string\">\"\"</span>,</div><div class=\"line\">  <span class=\"string\">\"main\"</span>: <span class=\"string\">\"index.js\"</span>,</div><div class=\"line\">  <span class=\"string\">\"scripts\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"test\"</span>: <span class=\"string\">\"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"string\">\"keywords\"</span>: [],</div><div class=\"line\">  <span class=\"string\">\"author\"</span>: <span class=\"string\">\"\"</span>,</div><div class=\"line\">  <span class=\"string\">\"license\"</span>: <span class=\"string\">\"ISC\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><h1 id=\"package-json\"><a href=\"#package-json\" class=\"headerlink\" title=\"package.json\"></a>package.json</h1><p>패키지 정보를 담고 있는 파일</p><p><strong>dependencies</strong><br><code>npm install --save</code> 명령으로 설치한 패키지가 기록됨</p><p><strong>scripts</strong><br>원래 목적은 패키지 생명주기마다 자동으로 실행되는 명령을 등록하기 위함이나, 개발자 편의를 위해 자주 사용되는 명령을 등록하는 용도로 더 많이 사용됨</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install --save randomstring <span class=\"comment\"># node_modules에 저장됨</span></div></pre></td></tr></table></figure><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// index.js</span></div><div class=\"line\"><span class=\"keyword\">const</span> randomstring = <span class=\"built_in\">require</span>(<span class=\"string\">'randomstring'</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(randomstring.generate())</div></pre></td></tr></table></figure><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// package.json</div><div class=\"line\">...</div><div class=\"line\">  \"scripts\": &#123;</div><div class=\"line\">    \"start\": \"node index.js\"</div><div class=\"line\">  &#125;</div><div class=\"line\">...</div></pre></td></tr></table></figure><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm start</div></pre></td></tr></table></figure><h1 id=\"Concurrency-Model-동시성-모델\"><a href=\"#Concurrency-Model-동시성-모델\" class=\"headerlink\" title=\"Concurrency Model(동시성 모델)\"></a>Concurrency Model(동시성 모델)</h1><p>프로그램이 생애 주기가 겹치는 여러 실행 과정을 통해 실행된다 하더라도 프로그램의 결과에는 영향을 미치지 않는 성질</p><p>생애 주기가 겹치는 여러 실행 과정이 자원을 공유할 때 어떻게 충돌이 생기지 않도록 할 것인가?</p><h2 id=\"Resources\"><a href=\"#Resources\" class=\"headerlink\" title=\"Resources\"></a>Resources</h2><ul><li>CPU</li><li>메모리</li><li>네트워크</li><li>…</li></ul><h1 id=\"Thread\"><a href=\"#Thread\" class=\"headerlink\" title=\"Thread\"></a>Thread</h1><p>코드 실행의 가장 작은 단위</p><p>프로그램은 하나 이상의 스레드로 이루어짐</p><p>CPU 코어 하나는 한 번에 하나의 스레드를 실행</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sysctl -n hw.ncpu <span class=\"comment\"># OSX</span></div><div class=\"line\">$ nproc <span class=\"comment\"># linux</span></div><div class=\"line\">$ mmc devmgmt.msc <span class=\"comment\"># Windows</span></div><div class=\"line\">$ top -H <span class=\"comment\"># Shows the total number of threads</span></div></pre></td></tr></table></figure><h1 id=\"동시성을-위한-도구\"><a href=\"#동시성을-위한-도구\" class=\"headerlink\" title=\"동시성을 위한 도구\"></a>동시성을 위한 도구</h1><p>자원의 공유를 위해 프로그래밍 언어는 언어들만이 가지고 있는 동시성을 위한 도구를 가지고 있는 경우가 많다.</p><h2 id=\"1-운영체제-차원의-도구\"><a href=\"#1-운영체제-차원의-도구\" class=\"headerlink\" title=\"1) 운영체제 차원의 도구\"></a>1) 운영체제 차원의 도구</h2><ul><li>Process</li><li>Thread</li><li>Mutex (Mutual Exclusion)</li></ul><h2 id=\"2-언어-차원의-도구\"><a href=\"#2-언어-차원의-도구\" class=\"headerlink\" title=\"2) 언어 차원의 도구\"></a>2) 언어 차원의 도구</h2><ul><li>Python - asyncio</li><li>Go - goroutine</li><li>Erlang - actor</li><li>JavaScript - …?</li></ul><p><br></p><h1 id=\"자바스크립트의-동시성\"><a href=\"#자바스크립트의-동시성\" class=\"headerlink\" title=\"자바스크립트의 동시성\"></a>자바스크립트의 동시성</h1><h2 id=\"Single-Threaded-Event-Loop\"><a href=\"#Single-Threaded-Event-Loop\" class=\"headerlink\" title=\"Single-Threaded Event Loop\"></a>Single-Threaded Event Loop</h2><p><strong>자바스크립트를 실행시키는 스레드가 하나 뿐이다.</strong><br>실행 과정(보통 콜백 연쇄)의 생애 주기가 겹칠 수는 있지만 어떤 경우에도 두 자바스크립트 실행과정이 동시에 실행되는 경우는 없음. 내부적으로 메시지 큐를 활용하고 있으나, 모든 처리가 자동으로 이루어짐</p><p>!MDN[<a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/EventLoop\" target=\"_blank\" rel=\"external\">https://developer.mozilla.org/ko/docs/Web/JavaScript/EventLoop</a>]</p><h2 id=\"1-장점\"><a href=\"#1-장점\" class=\"headerlink\" title=\"1) 장점\"></a>1) 장점</h2><ul><li>프로그래머가 동시성에 대해 신경쓸 필요가 없어짐</li><li>프로그램 작성이 쉬워짐</li></ul><h2 id=\"2-단점\"><a href=\"#2-단점\" class=\"headerlink\" title=\"2) 단점\"></a>2) 단점</h2><ul><li>CPU를 많이 쓰는 작업에 부적절</li><li>오래 걸리는 자바스크립트 코드가 실행되면 전체 프로그램에 영향을 미침</li></ul><h2 id=\"3-전략\"><a href=\"#3-전략\" class=\"headerlink\" title=\"3) 전략\"></a>3) 전략</h2><p>브라우저는 API가 있다면 API에 위임, 노드js는 c/c++로 만들어진 모듈을 가져와서 사용할 수 있는 방법이 있다.</p><ul><li>오래 걸리는 일은 외부에 위임하고 넘어간 뒤, 나중에 결과를 받아 처리하기<ul><li>Database</li><li>Node.js - External libraries</li><li>Web browser - WebAssembly</li></ul></li><li>긴 실행과정을 <strong>여러 개의 함수로 쪼개서</strong> 한 번의 함수 실행이 금방 끝나게 만들기</li></ul><p><br></p><h1 id=\"Asynchronous-JavaScript\"><a href=\"#Asynchronous-JavaScript\" class=\"headerlink\" title=\"Asynchronous JavaScript\"></a>Asynchronous JavaScript</h1><p>non-blocking과 asynchronous는 비슷한 맥락이다. 다만, non-blocking은 코드의 실행 순서에 대한 개념이고, asynchronous는 코드 작성 방식에 대한 개념이다.</p><ul><li>함수를 호출할 때, 콜백까지 같이 인자에 넣어서 호출하는 비동기 프로그래밍 양식</li><li>콜백에서 에러 인자를 받는 방식으로 에러 처리를 함</li><li>Node.js 내장 모듈 전체가 이 방식을 사용하도록 만들어져 있음</li><li>주의! 모든 콜백이 비동기인 것은 아님</li></ul><hr><h1 id=\"비동기식-코드의-에러처리-관습\"><a href=\"#비동기식-코드의-에러처리-관습\" class=\"headerlink\" title=\"비동기식 코드의 에러처리: 관습\"></a>비동기식 코드의 에러처리: 관습</h1><p>try-catch는 동기식 에러처리 시에만 사용한다. 비동기식 에러 처리는 관습적으로 아래 방식을 사용한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//readFile.js</span></div><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>); <span class=\"comment\">// Node.js 내장 모듈</span></div><div class=\"line\">fs.readFile(<span class=\"string\">'./calc.js'</span>, <span class=\"string\">'utf8'</span>, (err, data) =&gt; &#123;</div><div class=\"line\">  <span class=\"comment\">// 에러처리</span></div><div class=\"line\">  <span class=\"keyword\">if</span>(err) &#123; <span class=\"comment\">//error가 있으면</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.error(err);</div><div class=\"line\">  &#125;<span class=\"keyword\">else</span> &#123; <span class=\"comment\">//errro가 없으면 </span></div><div class=\"line\">    <span class=\"built_in\">console</span>.data(data);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'done!'</span>);</div></pre></td></tr></table></figure><h1 id=\"동기식-코드의-에러-처리-일반적인-방식으로-처리\"><a href=\"#동기식-코드의-에러-처리-일반적인-방식으로-처리\" class=\"headerlink\" title=\"동기식 코드의 에러 처리: 일반적인 방식으로 처리\"></a>동기식 코드의 에러 처리: 일반적인 방식으로 처리</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//readFileSync.js</span></div><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>); <span class=\"comment\">// Node.js 내장 모듈</span></div><div class=\"line\"><span class=\"keyword\">try</span> &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> data = fs.readFileSync(<span class=\"string\">'./calc.js'</span>, <span class=\"string\">'utf8'</span>);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> (err) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'done!'</span>);</div></pre></td></tr></table></figure><hr><p>위 예제에서 readFile.js는 비동기 방식이며 readFileSync는 동기 방식으로 동작하는 코드이다. 코드를 실행 한 후 결과를 보면,</p><ul><li>readFile.js</li></ul><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">done</span>!</div><div class=\"line\">&#123; Error: ENOENT: no such file or directory, open <span class=\"string\">'./calc.js'</span> errno: -2, code: <span class=\"string\">'ENOENT'</span>, syscall: <span class=\"string\">'open'</span>, path: <span class=\"string\">'./calc.js'</span> &#125;</div></pre></td></tr></table></figure><p>비동기 방식에서는 마지막 줄의 <code>console.log(&#39;done!&#39;)</code>코드가 이전 코드의 실행이 완료될 때까지 기다리지 않고 먼저 실행된다.</p><ul><li>readFileSync.js</li></ul><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123; Error: ENOENT: no such file or directory, open <span class=\"string\">'./calc.js'</span></div><div class=\"line\">    at Object.fs.openSync (fs.js:652:18)</div><div class=\"line\">    at Object.fs.readFileSync (fs.js:553:33)</div><div class=\"line\">    at Object.&lt;anonymous&gt; (/Users/ihyeseung/projectfolder/fastcam/frontstudy/nodejs/practice/readFileSync.js:4:19)</div><div class=\"line\">    at Module._compile (module.js:573:30)</div><div class=\"line\">    at Object.Module._extensions..js (module.js:584:10)</div><div class=\"line\">    at Module.load (module.js:507:32)</div><div class=\"line\">    at tryModuleLoad (module.js:470:12)</div><div class=\"line\">    at Function.Module._load (module.js:462:3)</div><div class=\"line\">    at Function.Module.runMain (module.js:609:10)</div><div class=\"line\">    at startup (bootstrap_node.js:158:16) errno: -2, code: <span class=\"string\">'ENOENT'</span>, syscall: <span class=\"string\">'open'</span>, path: <span class=\"string\">'./calc.js'</span> &#125;</div><div class=\"line\"><span class=\"keyword\">done</span>!</div></pre></td></tr></table></figure><p>동기 방식에서는 <code>console.log(&#39;done!&#39;)</code>이 이전 코드의 실행이 완료될때까지 기다린 후 실행되었다.</p><p><br></p><h1 id=\"Github-REST-API-호출\"><a href=\"#Github-REST-API-호출\" class=\"headerlink\" title=\"Github REST API 호출\"></a>Github REST API 호출</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//request.js</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 유저 이름, 저장소, 할당된 이슈 갯수 출력하기</span></div><div class=\"line\"><span class=\"keyword\">const</span> request = <span class=\"built_in\">require</span>(<span class=\"string\">'request'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> apiUrl = <span class=\"string\">'https://api.github.com'</span></div><div class=\"line\"><span class=\"keyword\">const</span> option = &#123;</div><div class=\"line\">  json: <span class=\"literal\">true</span>,</div><div class=\"line\">  auth: &#123;</div><div class=\"line\">    <span class=\"string\">'user'</span>: <span class=\"string\">'username'</span>, <span class=\"comment\">// github 유저네임</span></div><div class=\"line\">    <span class=\"string\">'pass'</span>: <span class=\"string\">'password'</span>, <span class=\"comment\">// github 비밀번호</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  headers: &#123;</div><div class=\"line\">    <span class=\"string\">'User-Agent'</span>: <span class=\"string\">'request'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">request.get(<span class=\"string\">`<span class=\"subst\">$&#123;apiUrl&#125;</span>/user`</span>, option, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error, response, body</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> name = body.name</div><div class=\"line\">  <span class=\"keyword\">if</span> (error) <span class=\"built_in\">console</span>.error(error)</div><div class=\"line\">  <span class=\"comment\">// 콜백 안에 콜백</span></div><div class=\"line\">  request.get(<span class=\"string\">`<span class=\"subst\">$&#123;apiUrl&#125;</span>/user/repos`</span>, option, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error, response, body</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (error) <span class=\"built_in\">console</span>.error(error)</div><div class=\"line\">    <span class=\"keyword\">const</span> repoNames = body.map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item.name)</div><div class=\"line\">    <span class=\"comment\">// 콜백 안에 콜백 안에 콜백</span></div><div class=\"line\">    request.get(<span class=\"string\">`<span class=\"subst\">$&#123;apiUrl&#125;</span>/issues`</span>, option, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error, response, body</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (error) <span class=\"built_in\">console</span>.error(error)</div><div class=\"line\">      <span class=\"keyword\">const</span> issueNum = body.length</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`name: <span class=\"subst\">$&#123;name&#125;</span>`</span>)</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'repos:'</span>)</div><div class=\"line\">      repoNames.forEach(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(name)</div><div class=\"line\">      &#125;)</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`num of assigned issues: <span class=\"subst\">$&#123;issueNum&#125;</span>`</span>)</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ node request.js</div></pre></td></tr></table></figure><h2 id=\"Callback-Hell\"><a href=\"#Callback-Hell\" class=\"headerlink\" title=\"Callback Hell\"></a>Callback Hell</h2><p><img src=\"https://image.slidesharecdn.com/promisesandchaininginangularjs-141027044455-conversion-gate02/95/promises-and-chaining-in-angularjs-into-callback-hell-and-back-again-17-638.jpg?cb=1414385382\" alt=\"callback hell\"></p><p><br></p><h1 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h1><p>비동기 작업의 결과를 담는 객체<br>정확히 언제가 될지 모르지만, 결국 성공 또는 실패의 상태를 갖게 되며 이 상태가 되었을 때 비로소 콜백을 실행하라는 명령을 갖게 된다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// tenSec.js</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 10초 뒤에 콜백(promise 객체를 새로 만들어서 리턴)을 실행하는 함수</span></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tenSec</span>(<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</div><div class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">      resolve(value)</div><div class=\"line\">    &#125;, <span class=\"number\">10000</span>)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; const tenSec = require(&apos;./tenSec&apos;)</div><div class=\"line\">&gt; const p = tenSec(1) // p에 Promise 저장</div><div class=\"line\">&gt; p // 만든지 10초가 지나기 전</div><div class=\"line\">Promise &#123;</div><div class=\"line\">  [pending], //pending: 아직 결과가 나오지 않음.</div><div class=\"line\">  ...</div><div class=\"line\">&gt; p // 만든지 10초가 지난 후</div><div class=\"line\">Promise &#123;</div><div class=\"line\">  1,</div><div class=\"line\">  ...</div></pre></td></tr></table></figure><h2 id=\"1-promise의-상태-state\"><a href=\"#1-promise의-상태-state\" class=\"headerlink\" title=\"1) promise의 상태(state)\"></a>1) promise의 상태(state)</h2><ul><li><p>pending<br>아직 수행 중인 상태 (fulfilled 혹은 rejected 되기 전)</p></li><li><p>fulfilled<br>promise가 지켜진(수행된) 상태</p></li><li><p>rejected<br>promise가 지켜지지 못한(거부된) 상태</p></li><li><p>settled<br>fulfilled이든 rejected이든 결론이 난 상태</p></li></ul><h2 id=\"2-then\"><a href=\"#2-then\" class=\"headerlink\" title=\"2) .then\"></a>2) .then</h2><p>promise 객체의 메서드</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; tenSec(&apos;hello promise&apos;).then(value =&gt; &#123;</div><div class=\"line\">... console.log(value)</div><div class=\"line\">... &#125;)</div><div class=\"line\">Promise &#123; // `then`은 Promise를 반환</div><div class=\"line\">  [pending],</div><div class=\"line\">  ...</div><div class=\"line\">&gt; // 10초 후</div><div class=\"line\">&apos;hello promise&apos;</div></pre></td></tr></table></figure><p>new Promise ()의 결과는 promise이다.<br>.then 메소드에서 반환된 값도 promise이다.<br>따라서 .then 메소드를 계속 사용할 수 있다.<br>.then 메소드를 쓰면 들여쓰기를 하지 않아도 된다.<br>따라서 Callback Hell을 피할 수 있다.</p><p>return은 바로 실행되는 동기식 작업이다.</p><p>비동기 작업을 하려면 콜백을 통해서 해야 했다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>()</div><div class=\"line\">.then(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</div><div class=\"line\">  request.get( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">  &#125;)</div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"comment\">// 콜백은 함수 밖에서 리턴이 불가하다</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p>promise는 함수 밖에서 리턴해야 하는데 위와 같은 콜백 방식에서는 함수 밖에서 리턴이 불가하다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>()</div><div class=\"line\">.then(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</div><div class=\"line\">  </div><div class=\"line\">&#125;)</div><div class=\"line\">.then(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</div><div class=\"line\"></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><h2 id=\"3-Promise-chaining\"><a href=\"#3-Promise-chaining\" class=\"headerlink\" title=\"3) Promise chaining\"></a>3) Promise chaining</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// chaining.js</span></div><div class=\"line\"><span class=\"keyword\">const</span> tenSec = <span class=\"built_in\">require</span>(<span class=\"string\">'./tenSec'</span>)</div><div class=\"line\">tenSec(<span class=\"string\">'hello promise'</span>)</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(value)</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span> <span class=\"comment\">// 위 `.then`은 값이 1인 Promise를 반환함</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(value) <span class=\"comment\">// value = 1</span></div><div class=\"line\">    <span class=\"keyword\">return</span> tenSec(<span class=\"string\">'new promise'</span>) <span class=\"comment\">// Promise도 반환할 수 있음</span></div><div class=\"line\">  &#125;) <span class=\"comment\">// 안에 들어 있는 값이 value(=1)인 Promise 생성</span></div><div class=\"line\">  .then(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123; <span class=\"comment\">// tenSec이 실행되고 10초 후 실행됨</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(value)</div><div class=\"line\">  &#125;)</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"comment\">//promise 안에서 에러가 나면</span></div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'error in promise'</span>)</div><div class=\"line\">  &#125;)</div><div class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123; <span class=\"comment\">// 에러가 나면 catch 내부 코드 실행, 안나면 통과</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.error(err)</div><div class=\"line\">  &#125;)</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"comment\">// 에러 처리 이후에도 코드 실행 가능</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'done'</span>)</div><div class=\"line\">  &#125;)</div></pre></td></tr></table></figure><hr><h3 id=\"기타-메소드\"><a href=\"#기타-메소드\" class=\"headerlink\" title=\"기타 메소드\"></a>기타 메소드</h3><ul><li>Promise.all(Arr): 모든 프라미스가 성공해야 성공하는 promise</li></ul><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">pa = <span class=\"built_in\">Promise</span>.all([p1, p2])</div><div class=\"line\"><span class=\"comment\">// pa는 p1, p2가 모두 성공해야 성공하는 Promise이다.</span></div></pre></td></tr></table></figure><ul><li>Promise.race(Arr): 가장 빨리 성공하는 promise를 반환</li></ul><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pr = <span class=\"built_in\">Promise</span>.race([p1, pw])</div></pre></td></tr></table></figure><ul><li>promisify 함수</li></ul><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// readfilePromise.js</span></div><div class=\"line\"><span class=\"keyword\">const</span> &#123;promisify&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>) <span class=\"comment\">// Node.js 8.0.0부터 추가됨</span></div><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> readFile = promisify(fs.readFile)</div><div class=\"line\">readFile(<span class=\"string\">'./calc.js'</span>, <span class=\"string\">'utf8'</span>)</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(data)</div><div class=\"line\">  &#125;)</div><div class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.error(err)</div><div class=\"line\">  &#125;)</div></pre></td></tr></table></figure><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123; Error: ENOENT: no such file or directory, open &apos;./calc.js&apos; errno: -2, code: &apos;ENOENT&apos;, syscall: &apos;open&apos;, path: &apos;./calc.js&apos; &#125;</div></pre></td></tr></table></figure><hr><h2 id=\"4-Promise의-특징\"><a href=\"#4-Promise의-특징\" class=\"headerlink\" title=\"4) Promise의 특징\"></a>4) Promise의 특징</h2><p>1) 이미 resolve 된 Promise에도 콜백을 실행할 수 있음</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; <span class=\"keyword\">const</span> resolved = <span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">1</span>)</div><div class=\"line\">&gt; resolved.then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</div></pre></td></tr></table></figure><p>2) <code>.then</code>에 넘겨진 콜백은 (비동기가 아니라 바로 성공하도록 만들어진 동기식 promise라 하더라도)무조건 다음 루프에 실행됨</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">... Promise.resolve(<span class=\"number\">1</span>).then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</div><div class=\"line\">... console.log(<span class=\"string\">'done!'</span>)</div><div class=\"line\">... &#125;)()</div><div class=\"line\"><span class=\"comment\">/* 출력:</span></div><div class=\"line\"><span class=\"comment\">done! -&gt; 먼저 출력된다.</span></div><div class=\"line\"><span class=\"comment\">1</span></div><div class=\"line\"><span class=\"comment\">*/</span></div></pre></td></tr></table></figure><h2 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all\"></a>Promise.all</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// npm install --save request-promise</span></div><div class=\"line\"><span class=\"keyword\">const</span> rp = <span class=\"built_in\">require</span>(<span class=\"string\">'request-promise'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> apiUrl = <span class=\"string\">'https://api.github.com'</span></div><div class=\"line\"><span class=\"keyword\">const</span> option = &#123;</div><div class=\"line\">  json: <span class=\"literal\">true</span>,</div><div class=\"line\">  auth: &#123;</div><div class=\"line\">    <span class=\"string\">'user'</span>: <span class=\"string\">'username'</span>,</div><div class=\"line\">    <span class=\"string\">'pass'</span>: <span class=\"string\">'password'</span>,</div><div class=\"line\">  &#125;,</div><div class=\"line\">  headers: &#123;</div><div class=\"line\">    <span class=\"string\">'User-Agent'</span>: <span class=\"string\">'request'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> userPromise = rp.get(<span class=\"string\">`<span class=\"subst\">$&#123;apiUrl&#125;</span>/user`</span>, option)</div><div class=\"line\"><span class=\"keyword\">const</span> reposPromise = rp.get(<span class=\"string\">`<span class=\"subst\">$&#123;apiUrl&#125;</span>/user/repos`</span>, option)</div><div class=\"line\"><span class=\"keyword\">const</span> issuesPromise = rp.get(<span class=\"string\">`<span class=\"subst\">$&#123;apiUrl&#125;</span>/issues`</span>, option)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 배열 내의 모든 Promise 객체가 완료되었을 때</span></div><div class=\"line\"><span class=\"comment\">// resolve 되는 Promise를 만든다.</span></div><div class=\"line\"><span class=\"built_in\">Promise</span>.all([userPromise, reposPromise, issuesPromise])</div><div class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">[user, repos, issues]</span>) =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`name: <span class=\"subst\">$&#123;user.name&#125;</span>`</span>)</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'repos:'</span>)</div><div class=\"line\">    repos.forEach(<span class=\"function\"><span class=\"params\">repo</span> =&gt;</span> &#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(repo.name)</div><div class=\"line\">    &#125;)</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`num of assigned issues: <span class=\"subst\">$&#123;issues.length&#125;</span>`</span>)</div><div class=\"line\">  &#125;)</div></pre></td></tr></table></figure><p>비동기 코드와 동일한 일을 promise로 할 수 있으며 promise를 이용하면 좀 더 깔끔하게 코드를 짤 수 있다.</p><blockquote><ul><li><a href=\"http://hacks.mozilla.or.kr/2015/05/this-api-is-so-fetching/\" target=\"_blank\" rel=\"external\">Fetch API</a><ul><li>window.fetch polyfill: Fetch API를 IE에서도 사용할 수 있게 해준다.</li></ul></li></ul></blockquote><p><br></p><h1 id=\"Async-Await\"><a href=\"#Async-Await\" class=\"headerlink\" title=\"Async/Await\"></a>Async/Await</h1><ul><li>ES2017에서 도입되어, 비동기식 코드를 동기식 코드처럼 쓸 수 있는 문법 제공</li><li>Chrome 55, Node.js 8.0.0 부터 사용가능<br>(아주 최근에 나온 문법이므로, 아직까지는 비동기식 코드에 promise가 더 널리 쓰인다.)</li><li>async function 안에서 반환된 값은 최종적으로 Promise 객체로 변환되어 반환된다.</li><li>async function 안에서 쓸 수 있는 await 키워드는 현재 함수를 중단시키고 Promise 객체가 충족될 때까지 기다리지만, 스레드를 block 하지 않는다.</li><li>에러 처리는 동기식 코드처럼 try, catch 블록을 통해서 한다.</li></ul><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> tenSec = <span class=\"built_in\">require</span>(<span class=\"string\">'./tenSec'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//await는 async 함수 안에서만 사용할 수 있다.</span></div><div class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolveAfterTenSec</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">await</span> tenSec()</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">resolveAfterTenSec().then(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(value)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><h2 id=\"1-readFile-async-await\"><a href=\"#1-readFile-async-await\" class=\"headerlink\" title=\"1) readFile - async/await\"></a>1) readFile - async/await</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// readfileAsync.js</span></div><div class=\"line\"><span class=\"keyword\">const</span> &#123;promisify&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>) <span class=\"comment\">// Node.js 8.0.0부터 추가됨</span></div><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> readFile = promisify(fs.readFile)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">readFileAsync</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> readFile(<span class=\"string\">'./calc.js'</span>, <span class=\"string\">'utf8'</span>)</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(data)</div><div class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.error(e)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">readFileAsync()</div></pre></td></tr></table></figure><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123; Error: ENOENT: no such file or directory, open &apos;./calc.js&apos; errno: -2, code: &apos;ENOENT&apos;, syscall: &apos;open&apos;, path: &apos;./calc.js&apos; &#125;</div></pre></td></tr></table></figure><hr>"},{"title":"[node] 템플릿 언어 ejs","date":"2017-08-29T15:42:01.000Z","_content":"\n![](http://allvectorlogo.com/img/2016/05/node-js-logo.png)\n\n# Template Language\n\n## Web Page\n\n### 1) Static Web Page\n\n누가 어떻게 요청하든 미리 저장되어 있던 HTML 파일을 그대로 응답\n\n### 2) Dynamic Web Page\n\n요청한 사람과 요청한 내용에 따라 **각각 다른 내용으로 편집한 HTML을 응답**\n\n## Template Engine\n템플릿과 데이터를 결합해 문서를 생성하는 프로그램, 혹은 라이브러리. 템플릿을 작성할 때 사용하는 언어를 템플릿 언어라고 한다.\n\n## [EJS: Embedded JavaScript Template](http://ejs.co/)\n\n* Node.js 생태계에서 가장 많이 사용되는 템플릿 엔진\n* 문법이 단순하다.\n* JavaScript 코드를 템플릿 안에서 그대로 쓸 수 있음\n* .ejs VSCode Extension\n\n```js\n<%# index.ejs %>\n<html>\n  <head>\n    <title><%= title %></title>\n  </head>\n  <body>\n    <div class=\"message\">\n      <%= message %>\n    </div>\n    <% if (showSecret) { %>\n      <div>my secret</div>\n    <% } %>\n  </body>\n</html>\n```\n\n## Express에서 EJS 사용하기\n\n* ejs 설치\n\n```bash\n$ npm install --save ejs\n```\n\n* template engine 설정\n\n```bash\napp.set('view engine', 'ejs')\n```\n\n* res.render()\n```js\nconst data = {\n  title: 'Template Language',\n  message: 'Hello EJS!',\n  showSecret: true\n}\nres.render('index.ejs', data)\n```\n\n### 템플릿 태그\n\n* `<% ... %>`: 템플릿의 구조를 제어하기 위해 사용하며, 문자열을 내놓지 않는다.\n\n* `<%= ... %>`: 내부의 식을 문자열로 변환해 HTML 문서 안에 삽입한다.\n\n* `<%# ... %>`: EJS 주석입니다. HTML 주석과는 다르게 아예 HTML 문서에 포함되지 않는다. 일반 HTML 주석보다는 EJS 주석을 사용하는 것이 좋다.\n\n### HTML escape\n\n데이터를 HTML에 삽입하는 `<%= ... %>` 템플릿 태그는 <, > 두 문자를 각각 `&lt;`, `&gt;`로 변환하여 HTML에 삽입합니다. 결과적으로 HTML 태그를 직접 템플릿에 삽입하지 못하게 막습니다. 이렇게 하는 이유는 보안 때문으로, XSS(Cross-site Scripting)를 당할 위험을 줄여줍니다. XSS에 대해서는 추후 자세히 배울 것입니다.\n\n`<%- ... %>` 템플릿 태그를 이용하면 HTML escape를 생략할 수 있으나, 아주 특별한 경우가 아니면 `<%= ... %>` 태그를 사용하기를 권장합니다.\n\n[example code](https://glitch.com/edit/#!/married-wing)\n\n### Serving Static Files\n\nstatic 파일 (변하지 않는 파일)은 static 경로를 사용해 주는 것이 좋다. EX. `/static/index.css`\n\n```js\n// `public` 폴더에 있는 파일을 `/static` 경로 아래에서 제공\napp.use('/static', express.static('public'))\n```\n\n```html\n<!-- 템플릿 파일에서 참조할 수 있음 -->\n<link rel=\"stylesheet\" href=\"/static/index.css\">\n<script type=\"text/javascript\" src=\"/static/index.js\"></script>\n```\n\n### 실습\n\n* `:slug` : 긴 영문 제목을 url에서 쓰기 위해 짧게 만든 것.\n\n* Array.find(): 콜백 함수는 foreach나 map과 비슷한 모양을 하고 있다. true인 첫번째 요소 반환  \n\n```js\nconst arr = [1,2,3];\narr.map(item => item*2) // [2, 4, 6]\narr.find(item => item === 2) // 2\n\nconst item = [{value: 1}, {value: 2}, {value: 1, name: 'second'}]\n\n\nitem.find(item => item.value === 2) // {value: 2}\n\nitem.find(item => item.value === 1) // {value: 1}\n\n```\n\n* Array. filter(): true인 것을 모두 반환\n\n```js\nitems.filter(item => item.value === 2) // [{value:2}]\n\nitems.filter(item => item.value === 1) // [{value: 1}, {value: 1, name: \"second\"}]\n```\n\n---\n\n# # Another template Language\n\n## [Pug(=jade)](https://pugjs.org/api/getting-started.html)\n\n* 코드가 ejs보다 깔끔하다.\n\n* pug은 닫는 태그가 없다. 닫는 태그에 의한 에러를 걱정할 필요가 없다.\n","source":"_posts/nodejs/04.Template Language.md","raw":"---\ntitle: '[node] 템플릿 언어 ejs'\ndate: 2017-08-30 00:42:01\ncategory: Nodejs\ntags: ejs\n---\n\n![](http://allvectorlogo.com/img/2016/05/node-js-logo.png)\n\n# Template Language\n\n## Web Page\n\n### 1) Static Web Page\n\n누가 어떻게 요청하든 미리 저장되어 있던 HTML 파일을 그대로 응답\n\n### 2) Dynamic Web Page\n\n요청한 사람과 요청한 내용에 따라 **각각 다른 내용으로 편집한 HTML을 응답**\n\n## Template Engine\n템플릿과 데이터를 결합해 문서를 생성하는 프로그램, 혹은 라이브러리. 템플릿을 작성할 때 사용하는 언어를 템플릿 언어라고 한다.\n\n## [EJS: Embedded JavaScript Template](http://ejs.co/)\n\n* Node.js 생태계에서 가장 많이 사용되는 템플릿 엔진\n* 문법이 단순하다.\n* JavaScript 코드를 템플릿 안에서 그대로 쓸 수 있음\n* .ejs VSCode Extension\n\n```js\n<%# index.ejs %>\n<html>\n  <head>\n    <title><%= title %></title>\n  </head>\n  <body>\n    <div class=\"message\">\n      <%= message %>\n    </div>\n    <% if (showSecret) { %>\n      <div>my secret</div>\n    <% } %>\n  </body>\n</html>\n```\n\n## Express에서 EJS 사용하기\n\n* ejs 설치\n\n```bash\n$ npm install --save ejs\n```\n\n* template engine 설정\n\n```bash\napp.set('view engine', 'ejs')\n```\n\n* res.render()\n```js\nconst data = {\n  title: 'Template Language',\n  message: 'Hello EJS!',\n  showSecret: true\n}\nres.render('index.ejs', data)\n```\n\n### 템플릿 태그\n\n* `<% ... %>`: 템플릿의 구조를 제어하기 위해 사용하며, 문자열을 내놓지 않는다.\n\n* `<%= ... %>`: 내부의 식을 문자열로 변환해 HTML 문서 안에 삽입한다.\n\n* `<%# ... %>`: EJS 주석입니다. HTML 주석과는 다르게 아예 HTML 문서에 포함되지 않는다. 일반 HTML 주석보다는 EJS 주석을 사용하는 것이 좋다.\n\n### HTML escape\n\n데이터를 HTML에 삽입하는 `<%= ... %>` 템플릿 태그는 <, > 두 문자를 각각 `&lt;`, `&gt;`로 변환하여 HTML에 삽입합니다. 결과적으로 HTML 태그를 직접 템플릿에 삽입하지 못하게 막습니다. 이렇게 하는 이유는 보안 때문으로, XSS(Cross-site Scripting)를 당할 위험을 줄여줍니다. XSS에 대해서는 추후 자세히 배울 것입니다.\n\n`<%- ... %>` 템플릿 태그를 이용하면 HTML escape를 생략할 수 있으나, 아주 특별한 경우가 아니면 `<%= ... %>` 태그를 사용하기를 권장합니다.\n\n[example code](https://glitch.com/edit/#!/married-wing)\n\n### Serving Static Files\n\nstatic 파일 (변하지 않는 파일)은 static 경로를 사용해 주는 것이 좋다. EX. `/static/index.css`\n\n```js\n// `public` 폴더에 있는 파일을 `/static` 경로 아래에서 제공\napp.use('/static', express.static('public'))\n```\n\n```html\n<!-- 템플릿 파일에서 참조할 수 있음 -->\n<link rel=\"stylesheet\" href=\"/static/index.css\">\n<script type=\"text/javascript\" src=\"/static/index.js\"></script>\n```\n\n### 실습\n\n* `:slug` : 긴 영문 제목을 url에서 쓰기 위해 짧게 만든 것.\n\n* Array.find(): 콜백 함수는 foreach나 map과 비슷한 모양을 하고 있다. true인 첫번째 요소 반환  \n\n```js\nconst arr = [1,2,3];\narr.map(item => item*2) // [2, 4, 6]\narr.find(item => item === 2) // 2\n\nconst item = [{value: 1}, {value: 2}, {value: 1, name: 'second'}]\n\n\nitem.find(item => item.value === 2) // {value: 2}\n\nitem.find(item => item.value === 1) // {value: 1}\n\n```\n\n* Array. filter(): true인 것을 모두 반환\n\n```js\nitems.filter(item => item.value === 2) // [{value:2}]\n\nitems.filter(item => item.value === 1) // [{value: 1}, {value: 1, name: \"second\"}]\n```\n\n---\n\n# # Another template Language\n\n## [Pug(=jade)](https://pugjs.org/api/getting-started.html)\n\n* 코드가 ejs보다 깔끔하다.\n\n* pug은 닫는 태그가 없다. 닫는 태그에 의한 에러를 걱정할 필요가 없다.\n","slug":"nodejs/04.Template Language","published":1,"updated":"2017-09-21T06:06:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjai8h18e0011vb9qcuescbq6","content":"<p><img src=\"http://allvectorlogo.com/img/2016/05/node-js-logo.png\" alt=\"\"></p><h1 id=\"Template-Language\"><a href=\"#Template-Language\" class=\"headerlink\" title=\"Template Language\"></a>Template Language</h1><h2 id=\"Web-Page\"><a href=\"#Web-Page\" class=\"headerlink\" title=\"Web Page\"></a>Web Page</h2><h3 id=\"1-Static-Web-Page\"><a href=\"#1-Static-Web-Page\" class=\"headerlink\" title=\"1) Static Web Page\"></a>1) Static Web Page</h3><p>누가 어떻게 요청하든 미리 저장되어 있던 HTML 파일을 그대로 응답</p><h3 id=\"2-Dynamic-Web-Page\"><a href=\"#2-Dynamic-Web-Page\" class=\"headerlink\" title=\"2) Dynamic Web Page\"></a>2) Dynamic Web Page</h3><p>요청한 사람과 요청한 내용에 따라 <strong>각각 다른 내용으로 편집한 HTML을 응답</strong></p><h2 id=\"Template-Engine\"><a href=\"#Template-Engine\" class=\"headerlink\" title=\"Template Engine\"></a>Template Engine</h2><p>템플릿과 데이터를 결합해 문서를 생성하는 프로그램, 혹은 라이브러리. 템플릿을 작성할 때 사용하는 언어를 템플릿 언어라고 한다.</p><h2 id=\"EJS-Embedded-JavaScript-Template\"><a href=\"#EJS-Embedded-JavaScript-Template\" class=\"headerlink\" title=\"EJS: Embedded JavaScript Template\"></a><a href=\"http://ejs.co/\" target=\"_blank\" rel=\"external\">EJS: Embedded JavaScript Template</a></h2><ul><li>Node.js 생태계에서 가장 많이 사용되는 템플릿 엔진</li><li>문법이 단순하다.</li><li>JavaScript 코드를 템플릿 안에서 그대로 쓸 수 있음</li><li>.ejs VSCode Extension</li></ul><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;%# index.ejs %&gt;</div><div class=\"line\">&lt;html&gt;</div><div class=\"line\">  &lt;head&gt;</div><div class=\"line\">    &lt;title&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">title</span> %&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span></div><div class=\"line\">  &lt;<span class=\"regexp\">/head&gt;</span></div><div class=\"line\"><span class=\"regexp\">  &lt;body&gt;</span></div><div class=\"line\"><span class=\"regexp\">    &lt;div class=\"message\"&gt;</span></div><div class=\"line\"><span class=\"regexp\">      &lt;%= message %&gt;</span></div><div class=\"line\"><span class=\"regexp\">    &lt;/</span>div&gt;</div><div class=\"line\">    &lt;% <span class=\"keyword\">if</span> (showSecret) &#123; %&gt;</div><div class=\"line\">      &lt;div&gt;my secret&lt;<span class=\"regexp\">/div&gt;</span></div><div class=\"line\"><span class=\"regexp\">    &lt;% &#125; %&gt;</span></div><div class=\"line\"><span class=\"regexp\">  &lt;/</span>body&gt;</div><div class=\"line\">&lt;<span class=\"regexp\">/html&gt;</span></div></pre></td></tr></table></figure><h2 id=\"Express에서-EJS-사용하기\"><a href=\"#Express에서-EJS-사용하기\" class=\"headerlink\" title=\"Express에서 EJS 사용하기\"></a>Express에서 EJS 사용하기</h2><ul><li>ejs 설치</li></ul><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install --save ejs</div></pre></td></tr></table></figure><ul><li>template engine 설정</li></ul><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.set(<span class=\"string\">'view engine'</span>, <span class=\"string\">'ejs'</span>)</div></pre></td></tr></table></figure><ul><li>res.render()<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> data = &#123;</div><div class=\"line\">  title: <span class=\"string\">'Template Language'</span>,</div><div class=\"line\">  message: <span class=\"string\">'Hello EJS!'</span>,</div><div class=\"line\">  showSecret: <span class=\"literal\">true</span></div><div class=\"line\">&#125;</div><div class=\"line\">res.render(<span class=\"string\">'index.ejs'</span>, data)</div></pre></td></tr></table></figure></li></ul><h3 id=\"템플릿-태그\"><a href=\"#템플릿-태그\" class=\"headerlink\" title=\"템플릿 태그\"></a>템플릿 태그</h3><ul><li><p><code>&lt;% ... %&gt;</code>: 템플릿의 구조를 제어하기 위해 사용하며, 문자열을 내놓지 않는다.</p></li><li><p><code>&lt;%= ... %&gt;</code>: 내부의 식을 문자열로 변환해 HTML 문서 안에 삽입한다.</p></li><li><p><code>&lt;%# ... %&gt;</code>: EJS 주석입니다. HTML 주석과는 다르게 아예 HTML 문서에 포함되지 않는다. 일반 HTML 주석보다는 EJS 주석을 사용하는 것이 좋다.</p></li></ul><h3 id=\"HTML-escape\"><a href=\"#HTML-escape\" class=\"headerlink\" title=\"HTML escape\"></a>HTML escape</h3><p>데이터를 HTML에 삽입하는 <code>&lt;%= ... %&gt;</code> 템플릿 태그는 &lt;, &gt; 두 문자를 각각 <code>&amp;lt;</code>, <code>&amp;gt;</code>로 변환하여 HTML에 삽입합니다. 결과적으로 HTML 태그를 직접 템플릿에 삽입하지 못하게 막습니다. 이렇게 하는 이유는 보안 때문으로, XSS(Cross-site Scripting)를 당할 위험을 줄여줍니다. XSS에 대해서는 추후 자세히 배울 것입니다.</p><p><code>&lt;%- ... %&gt;</code> 템플릿 태그를 이용하면 HTML escape를 생략할 수 있으나, 아주 특별한 경우가 아니면 <code>&lt;%= ... %&gt;</code> 태그를 사용하기를 권장합니다.</p><p><a href=\"https://glitch.com/edit/#!/married-wing\" target=\"_blank\" rel=\"external\">example code</a></p><h3 id=\"Serving-Static-Files\"><a href=\"#Serving-Static-Files\" class=\"headerlink\" title=\"Serving Static Files\"></a>Serving Static Files</h3><p>static 파일 (변하지 않는 파일)은 static 경로를 사용해 주는 것이 좋다. EX. <code>/static/index.css</code></p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// `public` 폴더에 있는 파일을 `/static` 경로 아래에서 제공</span></div><div class=\"line\">app.use(<span class=\"string\">'/static'</span>, express.static(<span class=\"string\">'public'</span>))</div></pre></td></tr></table></figure><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 템플릿 파일에서 참조할 수 있음 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/static/index.css\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/static/index.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure><h3 id=\"실습\"><a href=\"#실습\" class=\"headerlink\" title=\"실습\"></a>실습</h3><ul><li><p><code>:slug</code> : 긴 영문 제목을 url에서 쓰기 위해 짧게 만든 것.</p></li><li><p>Array.find(): 콜백 함수는 foreach나 map과 비슷한 모양을 하고 있다. true인 첫번째 요소 반환</p></li></ul><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</div><div class=\"line\">arr.map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item*<span class=\"number\">2</span>) <span class=\"comment\">// [2, 4, 6]</span></div><div class=\"line\">arr.find(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item === <span class=\"number\">2</span>) <span class=\"comment\">// 2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> item = [&#123;<span class=\"attr\">value</span>: <span class=\"number\">1</span>&#125;, &#123;<span class=\"attr\">value</span>: <span class=\"number\">2</span>&#125;, &#123;<span class=\"attr\">value</span>: <span class=\"number\">1</span>, <span class=\"attr\">name</span>: <span class=\"string\">'second'</span>&#125;]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">item.find(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item.value === <span class=\"number\">2</span>) <span class=\"comment\">// &#123;value: 2&#125;</span></div><div class=\"line\"></div><div class=\"line\">item.find(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item.value === <span class=\"number\">1</span>) <span class=\"comment\">// &#123;value: 1&#125;</span></div></pre></td></tr></table></figure><ul><li>Array. filter(): true인 것을 모두 반환</li></ul><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">items.filter(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item.value === <span class=\"number\">2</span>) <span class=\"comment\">// [&#123;value:2&#125;]</span></div><div class=\"line\"></div><div class=\"line\">items.filter(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item.value === <span class=\"number\">1</span>) <span class=\"comment\">// [&#123;value: 1&#125;, &#123;value: 1, name: \"second\"&#125;]</span></div></pre></td></tr></table></figure><hr><h1 id=\"Another-template-Language\"><a href=\"#Another-template-Language\" class=\"headerlink\" title=\"# Another template Language\"></a># Another template Language</h1><h2 id=\"Pug-jade\"><a href=\"#Pug-jade\" class=\"headerlink\" title=\"Pug(=jade)\"></a><a href=\"https://pugjs.org/api/getting-started.html\" target=\"_blank\" rel=\"external\">Pug(=jade)</a></h2><ul><li><p>코드가 ejs보다 깔끔하다.</p></li><li><p>pug은 닫는 태그가 없다. 닫는 태그에 의한 에러를 걱정할 필요가 없다.</p></li></ul>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://allvectorlogo.com/img/2016/05/node-js-logo.png\" alt=\"\"></p><h1 id=\"Template-Language\"><a href=\"#Template-Language\" class=\"headerlink\" title=\"Template Language\"></a>Template Language</h1><h2 id=\"Web-Page\"><a href=\"#Web-Page\" class=\"headerlink\" title=\"Web Page\"></a>Web Page</h2><h3 id=\"1-Static-Web-Page\"><a href=\"#1-Static-Web-Page\" class=\"headerlink\" title=\"1) Static Web Page\"></a>1) Static Web Page</h3><p>누가 어떻게 요청하든 미리 저장되어 있던 HTML 파일을 그대로 응답</p><h3 id=\"2-Dynamic-Web-Page\"><a href=\"#2-Dynamic-Web-Page\" class=\"headerlink\" title=\"2) Dynamic Web Page\"></a>2) Dynamic Web Page</h3><p>요청한 사람과 요청한 내용에 따라 <strong>각각 다른 내용으로 편집한 HTML을 응답</strong></p><h2 id=\"Template-Engine\"><a href=\"#Template-Engine\" class=\"headerlink\" title=\"Template Engine\"></a>Template Engine</h2><p>템플릿과 데이터를 결합해 문서를 생성하는 프로그램, 혹은 라이브러리. 템플릿을 작성할 때 사용하는 언어를 템플릿 언어라고 한다.</p><h2 id=\"EJS-Embedded-JavaScript-Template\"><a href=\"#EJS-Embedded-JavaScript-Template\" class=\"headerlink\" title=\"EJS: Embedded JavaScript Template\"></a><a href=\"http://ejs.co/\" target=\"_blank\" rel=\"external\">EJS: Embedded JavaScript Template</a></h2><ul><li>Node.js 생태계에서 가장 많이 사용되는 템플릿 엔진</li><li>문법이 단순하다.</li><li>JavaScript 코드를 템플릿 안에서 그대로 쓸 수 있음</li><li>.ejs VSCode Extension</li></ul><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;%# index.ejs %&gt;</div><div class=\"line\">&lt;html&gt;</div><div class=\"line\">  &lt;head&gt;</div><div class=\"line\">    &lt;title&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">title</span> %&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span></div><div class=\"line\">  &lt;<span class=\"regexp\">/head&gt;</span></div><div class=\"line\"><span class=\"regexp\">  &lt;body&gt;</span></div><div class=\"line\"><span class=\"regexp\">    &lt;div class=\"message\"&gt;</span></div><div class=\"line\"><span class=\"regexp\">      &lt;%= message %&gt;</span></div><div class=\"line\"><span class=\"regexp\">    &lt;/</span>div&gt;</div><div class=\"line\">    &lt;% <span class=\"keyword\">if</span> (showSecret) &#123; %&gt;</div><div class=\"line\">      &lt;div&gt;my secret&lt;<span class=\"regexp\">/div&gt;</span></div><div class=\"line\"><span class=\"regexp\">    &lt;% &#125; %&gt;</span></div><div class=\"line\"><span class=\"regexp\">  &lt;/</span>body&gt;</div><div class=\"line\">&lt;<span class=\"regexp\">/html&gt;</span></div></pre></td></tr></table></figure><h2 id=\"Express에서-EJS-사용하기\"><a href=\"#Express에서-EJS-사용하기\" class=\"headerlink\" title=\"Express에서 EJS 사용하기\"></a>Express에서 EJS 사용하기</h2><ul><li>ejs 설치</li></ul><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install --save ejs</div></pre></td></tr></table></figure><ul><li>template engine 설정</li></ul><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.set(<span class=\"string\">'view engine'</span>, <span class=\"string\">'ejs'</span>)</div></pre></td></tr></table></figure><ul><li>res.render()<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> data = &#123;</div><div class=\"line\">  title: <span class=\"string\">'Template Language'</span>,</div><div class=\"line\">  message: <span class=\"string\">'Hello EJS!'</span>,</div><div class=\"line\">  showSecret: <span class=\"literal\">true</span></div><div class=\"line\">&#125;</div><div class=\"line\">res.render(<span class=\"string\">'index.ejs'</span>, data)</div></pre></td></tr></table></figure></li></ul><h3 id=\"템플릿-태그\"><a href=\"#템플릿-태그\" class=\"headerlink\" title=\"템플릿 태그\"></a>템플릿 태그</h3><ul><li><p><code>&lt;% ... %&gt;</code>: 템플릿의 구조를 제어하기 위해 사용하며, 문자열을 내놓지 않는다.</p></li><li><p><code>&lt;%= ... %&gt;</code>: 내부의 식을 문자열로 변환해 HTML 문서 안에 삽입한다.</p></li><li><p><code>&lt;%# ... %&gt;</code>: EJS 주석입니다. HTML 주석과는 다르게 아예 HTML 문서에 포함되지 않는다. 일반 HTML 주석보다는 EJS 주석을 사용하는 것이 좋다.</p></li></ul><h3 id=\"HTML-escape\"><a href=\"#HTML-escape\" class=\"headerlink\" title=\"HTML escape\"></a>HTML escape</h3><p>데이터를 HTML에 삽입하는 <code>&lt;%= ... %&gt;</code> 템플릿 태그는 &lt;, &gt; 두 문자를 각각 <code>&amp;lt;</code>, <code>&amp;gt;</code>로 변환하여 HTML에 삽입합니다. 결과적으로 HTML 태그를 직접 템플릿에 삽입하지 못하게 막습니다. 이렇게 하는 이유는 보안 때문으로, XSS(Cross-site Scripting)를 당할 위험을 줄여줍니다. XSS에 대해서는 추후 자세히 배울 것입니다.</p><p><code>&lt;%- ... %&gt;</code> 템플릿 태그를 이용하면 HTML escape를 생략할 수 있으나, 아주 특별한 경우가 아니면 <code>&lt;%= ... %&gt;</code> 태그를 사용하기를 권장합니다.</p><p><a href=\"https://glitch.com/edit/#!/married-wing\" target=\"_blank\" rel=\"external\">example code</a></p><h3 id=\"Serving-Static-Files\"><a href=\"#Serving-Static-Files\" class=\"headerlink\" title=\"Serving Static Files\"></a>Serving Static Files</h3><p>static 파일 (변하지 않는 파일)은 static 경로를 사용해 주는 것이 좋다. EX. <code>/static/index.css</code></p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// `public` 폴더에 있는 파일을 `/static` 경로 아래에서 제공</span></div><div class=\"line\">app.use(<span class=\"string\">'/static'</span>, express.static(<span class=\"string\">'public'</span>))</div></pre></td></tr></table></figure><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 템플릿 파일에서 참조할 수 있음 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/static/index.css\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/static/index.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure><h3 id=\"실습\"><a href=\"#실습\" class=\"headerlink\" title=\"실습\"></a>실습</h3><ul><li><p><code>:slug</code> : 긴 영문 제목을 url에서 쓰기 위해 짧게 만든 것.</p></li><li><p>Array.find(): 콜백 함수는 foreach나 map과 비슷한 모양을 하고 있다. true인 첫번째 요소 반환</p></li></ul><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</div><div class=\"line\">arr.map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item*<span class=\"number\">2</span>) <span class=\"comment\">// [2, 4, 6]</span></div><div class=\"line\">arr.find(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item === <span class=\"number\">2</span>) <span class=\"comment\">// 2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> item = [&#123;<span class=\"attr\">value</span>: <span class=\"number\">1</span>&#125;, &#123;<span class=\"attr\">value</span>: <span class=\"number\">2</span>&#125;, &#123;<span class=\"attr\">value</span>: <span class=\"number\">1</span>, <span class=\"attr\">name</span>: <span class=\"string\">'second'</span>&#125;]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">item.find(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item.value === <span class=\"number\">2</span>) <span class=\"comment\">// &#123;value: 2&#125;</span></div><div class=\"line\"></div><div class=\"line\">item.find(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item.value === <span class=\"number\">1</span>) <span class=\"comment\">// &#123;value: 1&#125;</span></div></pre></td></tr></table></figure><ul><li>Array. filter(): true인 것을 모두 반환</li></ul><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">items.filter(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item.value === <span class=\"number\">2</span>) <span class=\"comment\">// [&#123;value:2&#125;]</span></div><div class=\"line\"></div><div class=\"line\">items.filter(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item.value === <span class=\"number\">1</span>) <span class=\"comment\">// [&#123;value: 1&#125;, &#123;value: 1, name: \"second\"&#125;]</span></div></pre></td></tr></table></figure><hr><h1 id=\"Another-template-Language\"><a href=\"#Another-template-Language\" class=\"headerlink\" title=\"# Another template Language\"></a># Another template Language</h1><h2 id=\"Pug-jade\"><a href=\"#Pug-jade\" class=\"headerlink\" title=\"Pug(=jade)\"></a><a href=\"https://pugjs.org/api/getting-started.html\" target=\"_blank\" rel=\"external\">Pug(=jade)</a></h2><ul><li><p>코드가 ejs보다 깔끔하다.</p></li><li><p>pug은 닫는 태그가 없다. 닫는 태그에 의한 에러를 걱정할 필요가 없다.</p></li></ul>"},{"title":"[node] 미들웨어 express","date":"2017-08-29T15:40:50.000Z","_content":"\n![](http://allvectorlogo.com/img/2016/05/node-js-logo.png)\n\n# Middleware\n\n## 1. [Express](https://expressjs.com/ko/)\n\n* Node.js 생태계에서 가장 널리 쓰이는 웹 프레임워크\n* 내장하고 있는 기능은 매우 적으나, 미들웨어를 주입하는 방식으로 기능을 확장하는 생태계를 가지고 있음\n\n## 2. Express 앱의 기본 구조\n\n```js\n// Express 인스턴스 생성\nconst app = express()\n\n// 미들웨어 주입\napp.use(sessionMiddleware()) // 세션미들웨어\napp.use(authenticationMiddleware()) // 인증미들웨어\n\n// 라우트 핸들러 등록\n// 루트 경로('/')로 요청이 들어왔을 때, Hello express! 라는 응답을 한다.\napp.get('/', (request, response) => {\n  response.send('Hello express!')\n})\n\n// 서버 구동\n// 3000번 포트에서 서버 요청을 기다릴 것이고, 서버 구동에 성공하면 아래 콜백(console.log('Example app listening on port 3000!'))을 실행시켜라.\napp.listen(3000, () => {\n  console.log('Example app listening on port 3000!')\n})\n```\n\n### 1) Routing\n\n```js\n// HTTP 요청 메소드(GET, POST, ...)와 같은 이름의 메소드를 사용\napp.get('/articles', (req, res) => {\n  res.send('Hello Routing!')\n})\n\n// 특정 경로('/articles')에만 미들웨어를 주입하는 것도 가능\napp.post('/articles', bodyParserMiddleware(), (req, res) => {\n  database.articles.create(req.body)\n    .then(() => {\n      res.send({ok: true})\n    })\n})\n\n// 경로의 특정 부분을 함수의 인자처럼 입력받을 수 있음\n// ':id' 위치에 오는 값이 req.params.id에 저장된다.\napp.get('/articles/:id', (req, res) => {\n  database.articles.find(req.params.id) // `req.params`에 저장됨\n    .then(article => {\n      res.send(article)\n    })\n})\n```\n\n### 2) Request 객체\n\n* **req.body**\n  요청 바디를 적절한 형태의 자바스크립트 객체로 변환하여 이곳에 저장 (body-parser 미들웨어에 의해 처리됨)\n* **req.ip**\n  요청한 쪽의 IP\n* **req.params**\n  route parameter\n* **req.query**\n  query string이 객체로 저장됨\n\n\n### 3) 실습\n\n```js\nconst express = require('express')\nconst bodyParser = require('body-parser')\n\nconst app = express()\n\n// GET method\napp.get('/', (req, res) => {\n  res.send('Hello, Express!');\n})\n\n// POST method\napp.post('/', bodyParser.json(), (req, res) => {\n  /*\n  Mission:\n  요청의 바디에 실려 온 JSON에 name이라는 속성이 있으면 해당 값을 이용해 응답하고, 없으면 400 Bad Request를 응답한다.\n  응답 형태는 'Hello, <name>!' 으로 한다. \n  */\n  if (req.body.name) { // 포함되어 있으면(String) true, 없으면(undefined) false\n    res.send(`Hello, ${req.body.name}!`);\n  } else {\n    res.status(400);\n    res.send(`400 Bad Request`)\n  }\n})\n\n// query parameter, res.status\napp.get('/add', (req, res) => {\n  /* \n  Mission: \n  query parameter에 x와 y라는 이름을 가진 두 값을 정수로 바꾸어서 더한 후 응답한다.\n  값을 정수로 바꿀 수 없다면 400 Bad Request로 응답한다.\n  */\n  \n  //parseInt 사용 시에는 무조건 try-catch를 써주어야 한다.\n  \n  try {\n    const x = parseInt(req.query.x);\n    const y = parseInt(req.query.y);\n    const result = (x + y).toString();\n    res.send(result)\n  } catch (e) {\n    res.status(400)\n    res.send(`400 Bad Request`)\n  }\n})\n\n// req.ip\napp.get('/ip', (req, res) => {\n  /*\n  Mission: \n  요청한 쪽의 ip를 응답한다.\n  */\n  res.send(req.ip);\n})\n\n// req.get, res.set, res.end\napp.get('/header', (req, res) => {\n  /*\n  Mission:\n  요청의 X-Custom-Header 헤더를 그대로 응답에 포함시켜 응답한다.\n  응답에는 바디를 포함시키지 않도록 한다.\n  \n  hint 1: res.set 메소드는 응답에 새로운 헤더를 지정한다.\n  예) res.set('X-Custom-Header', value)\n  \n  hint 2: res.end 메소드는 응답을 보낸다. res.send와 비슷하지만, 바디를 인자로 받지 않는다.\n  */\n    const value = req.get(\"X-Custom-Header\")\n  // 표준이 아닌 헤더를 만들 때, 이름 앞에 X를 붙이는 것이 관례이다.\n  res.append('X-Custom.Header', value)\n  res.end() // send()\n})\n\n})\n\nconst listener = app.listen(process.env.PORT, function () {\n  console.log('listening on port ' + listener.address().port)\n})\n\n```\n","source":"_posts/nodejs/03.Middleware.md","raw":"---\ntitle: '[node] 미들웨어 express'\ndate: 2017-08-30 00:40:50\ncategory: Nodejs\ntags: express\n---\n\n![](http://allvectorlogo.com/img/2016/05/node-js-logo.png)\n\n# Middleware\n\n## 1. [Express](https://expressjs.com/ko/)\n\n* Node.js 생태계에서 가장 널리 쓰이는 웹 프레임워크\n* 내장하고 있는 기능은 매우 적으나, 미들웨어를 주입하는 방식으로 기능을 확장하는 생태계를 가지고 있음\n\n## 2. Express 앱의 기본 구조\n\n```js\n// Express 인스턴스 생성\nconst app = express()\n\n// 미들웨어 주입\napp.use(sessionMiddleware()) // 세션미들웨어\napp.use(authenticationMiddleware()) // 인증미들웨어\n\n// 라우트 핸들러 등록\n// 루트 경로('/')로 요청이 들어왔을 때, Hello express! 라는 응답을 한다.\napp.get('/', (request, response) => {\n  response.send('Hello express!')\n})\n\n// 서버 구동\n// 3000번 포트에서 서버 요청을 기다릴 것이고, 서버 구동에 성공하면 아래 콜백(console.log('Example app listening on port 3000!'))을 실행시켜라.\napp.listen(3000, () => {\n  console.log('Example app listening on port 3000!')\n})\n```\n\n### 1) Routing\n\n```js\n// HTTP 요청 메소드(GET, POST, ...)와 같은 이름의 메소드를 사용\napp.get('/articles', (req, res) => {\n  res.send('Hello Routing!')\n})\n\n// 특정 경로('/articles')에만 미들웨어를 주입하는 것도 가능\napp.post('/articles', bodyParserMiddleware(), (req, res) => {\n  database.articles.create(req.body)\n    .then(() => {\n      res.send({ok: true})\n    })\n})\n\n// 경로의 특정 부분을 함수의 인자처럼 입력받을 수 있음\n// ':id' 위치에 오는 값이 req.params.id에 저장된다.\napp.get('/articles/:id', (req, res) => {\n  database.articles.find(req.params.id) // `req.params`에 저장됨\n    .then(article => {\n      res.send(article)\n    })\n})\n```\n\n### 2) Request 객체\n\n* **req.body**\n  요청 바디를 적절한 형태의 자바스크립트 객체로 변환하여 이곳에 저장 (body-parser 미들웨어에 의해 처리됨)\n* **req.ip**\n  요청한 쪽의 IP\n* **req.params**\n  route parameter\n* **req.query**\n  query string이 객체로 저장됨\n\n\n### 3) 실습\n\n```js\nconst express = require('express')\nconst bodyParser = require('body-parser')\n\nconst app = express()\n\n// GET method\napp.get('/', (req, res) => {\n  res.send('Hello, Express!');\n})\n\n// POST method\napp.post('/', bodyParser.json(), (req, res) => {\n  /*\n  Mission:\n  요청의 바디에 실려 온 JSON에 name이라는 속성이 있으면 해당 값을 이용해 응답하고, 없으면 400 Bad Request를 응답한다.\n  응답 형태는 'Hello, <name>!' 으로 한다. \n  */\n  if (req.body.name) { // 포함되어 있으면(String) true, 없으면(undefined) false\n    res.send(`Hello, ${req.body.name}!`);\n  } else {\n    res.status(400);\n    res.send(`400 Bad Request`)\n  }\n})\n\n// query parameter, res.status\napp.get('/add', (req, res) => {\n  /* \n  Mission: \n  query parameter에 x와 y라는 이름을 가진 두 값을 정수로 바꾸어서 더한 후 응답한다.\n  값을 정수로 바꿀 수 없다면 400 Bad Request로 응답한다.\n  */\n  \n  //parseInt 사용 시에는 무조건 try-catch를 써주어야 한다.\n  \n  try {\n    const x = parseInt(req.query.x);\n    const y = parseInt(req.query.y);\n    const result = (x + y).toString();\n    res.send(result)\n  } catch (e) {\n    res.status(400)\n    res.send(`400 Bad Request`)\n  }\n})\n\n// req.ip\napp.get('/ip', (req, res) => {\n  /*\n  Mission: \n  요청한 쪽의 ip를 응답한다.\n  */\n  res.send(req.ip);\n})\n\n// req.get, res.set, res.end\napp.get('/header', (req, res) => {\n  /*\n  Mission:\n  요청의 X-Custom-Header 헤더를 그대로 응답에 포함시켜 응답한다.\n  응답에는 바디를 포함시키지 않도록 한다.\n  \n  hint 1: res.set 메소드는 응답에 새로운 헤더를 지정한다.\n  예) res.set('X-Custom-Header', value)\n  \n  hint 2: res.end 메소드는 응답을 보낸다. res.send와 비슷하지만, 바디를 인자로 받지 않는다.\n  */\n    const value = req.get(\"X-Custom-Header\")\n  // 표준이 아닌 헤더를 만들 때, 이름 앞에 X를 붙이는 것이 관례이다.\n  res.append('X-Custom.Header', value)\n  res.end() // send()\n})\n\n})\n\nconst listener = app.listen(process.env.PORT, function () {\n  console.log('listening on port ' + listener.address().port)\n})\n\n```\n","slug":"nodejs/03.Middleware","published":1,"updated":"2017-09-21T06:07:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjai8h18g0015vb9qr6jr7qgu","content":"<p><img src=\"http://allvectorlogo.com/img/2016/05/node-js-logo.png\" alt=\"\"></p><h1 id=\"Middleware\"><a href=\"#Middleware\" class=\"headerlink\" title=\"Middleware\"></a>Middleware</h1><h2 id=\"1-Express\"><a href=\"#1-Express\" class=\"headerlink\" title=\"1. Express\"></a>1. <a href=\"https://expressjs.com/ko/\" target=\"_blank\" rel=\"external\">Express</a></h2><ul><li>Node.js 생태계에서 가장 널리 쓰이는 웹 프레임워크</li><li>내장하고 있는 기능은 매우 적으나, 미들웨어를 주입하는 방식으로 기능을 확장하는 생태계를 가지고 있음</li></ul><h2 id=\"2-Express-앱의-기본-구조\"><a href=\"#2-Express-앱의-기본-구조\" class=\"headerlink\" title=\"2. Express 앱의 기본 구조\"></a>2. Express 앱의 기본 구조</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Express 인스턴스 생성</span></div><div class=\"line\"><span class=\"keyword\">const</span> app = express()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 미들웨어 주입</span></div><div class=\"line\">app.use(sessionMiddleware()) <span class=\"comment\">// 세션미들웨어</span></div><div class=\"line\">app.use(authenticationMiddleware()) <span class=\"comment\">// 인증미들웨어</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 라우트 핸들러 등록</span></div><div class=\"line\"><span class=\"comment\">// 루트 경로('/')로 요청이 들어왔을 때, Hello express! 라는 응답을 한다.</span></div><div class=\"line\">app.get(<span class=\"string\">'/'</span>, (request, response) =&gt; &#123;</div><div class=\"line\">  response.send(<span class=\"string\">'Hello express!'</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 서버 구동</span></div><div class=\"line\"><span class=\"comment\">// 3000번 포트에서 서버 요청을 기다릴 것이고, 서버 구동에 성공하면 아래 콜백(console.log('Example app listening on port 3000!'))을 실행시켜라.</span></div><div class=\"line\">app.listen(<span class=\"number\">3000</span>, () =&gt; &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Example app listening on port 3000!'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><h3 id=\"1-Routing\"><a href=\"#1-Routing\" class=\"headerlink\" title=\"1) Routing\"></a>1) Routing</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// HTTP 요청 메소드(GET, POST, ...)와 같은 이름의 메소드를 사용</span></div><div class=\"line\">app.get(<span class=\"string\">'/articles'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  res.send(<span class=\"string\">'Hello Routing!'</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 특정 경로('/articles')에만 미들웨어를 주입하는 것도 가능</span></div><div class=\"line\">app.post(<span class=\"string\">'/articles'</span>, bodyParserMiddleware(), (req, res) =&gt; &#123;</div><div class=\"line\">  database.articles.create(req.body)</div><div class=\"line\">    .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">      res.send(&#123;<span class=\"attr\">ok</span>: <span class=\"literal\">true</span>&#125;)</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 경로의 특정 부분을 함수의 인자처럼 입력받을 수 있음</span></div><div class=\"line\"><span class=\"comment\">// ':id' 위치에 오는 값이 req.params.id에 저장된다.</span></div><div class=\"line\">app.get(<span class=\"string\">'/articles/:id'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  database.articles.find(req.params.id) <span class=\"comment\">// `req.params`에 저장됨</span></div><div class=\"line\">    .then(<span class=\"function\"><span class=\"params\">article</span> =&gt;</span> &#123;</div><div class=\"line\">      res.send(article)</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><h3 id=\"2-Request-객체\"><a href=\"#2-Request-객체\" class=\"headerlink\" title=\"2) Request 객체\"></a>2) Request 객체</h3><ul><li><strong>req.body</strong><br>요청 바디를 적절한 형태의 자바스크립트 객체로 변환하여 이곳에 저장 (body-parser 미들웨어에 의해 처리됨)</li><li><strong>req.ip</strong><br>요청한 쪽의 IP</li><li><strong>req.params</strong><br>route parameter</li><li><strong>req.query</strong><br>query string이 객체로 저장됨</li></ul><h3 id=\"3-실습\"><a href=\"#3-실습\" class=\"headerlink\" title=\"3) 실습\"></a>3) 실습</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> bodyParser = <span class=\"built_in\">require</span>(<span class=\"string\">'body-parser'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> app = express()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// GET method</span></div><div class=\"line\">app.get(<span class=\"string\">'/'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  res.send(<span class=\"string\">'Hello, Express!'</span>);</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// POST method</span></div><div class=\"line\">app.post(<span class=\"string\">'/'</span>, bodyParser.json(), (req, res) =&gt; &#123;</div><div class=\"line\">  <span class=\"comment\">/*</span></div><div class=\"line\"><span class=\"comment\">  Mission:</span></div><div class=\"line\"><span class=\"comment\">  요청의 바디에 실려 온 JSON에 name이라는 속성이 있으면 해당 값을 이용해 응답하고, 없으면 400 Bad Request를 응답한다.</span></div><div class=\"line\"><span class=\"comment\">  응답 형태는 'Hello, &lt;name&gt;!' 으로 한다. </span></div><div class=\"line\"><span class=\"comment\">  */</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (req.body.name) &#123; <span class=\"comment\">// 포함되어 있으면(String) true, 없으면(undefined) false</span></div><div class=\"line\">    res.send(<span class=\"string\">`Hello, <span class=\"subst\">$&#123;req.body.name&#125;</span>!`</span>);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    res.status(<span class=\"number\">400</span>);</div><div class=\"line\">    res.send(<span class=\"string\">`400 Bad Request`</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// query parameter, res.status</span></div><div class=\"line\">app.get(<span class=\"string\">'/add'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  <span class=\"comment\">/* </span></div><div class=\"line\"><span class=\"comment\">  Mission: </span></div><div class=\"line\"><span class=\"comment\">  query parameter에 x와 y라는 이름을 가진 두 값을 정수로 바꾸어서 더한 후 응답한다.</span></div><div class=\"line\"><span class=\"comment\">  값을 정수로 바꿀 수 없다면 400 Bad Request로 응답한다.</span></div><div class=\"line\"><span class=\"comment\">  */</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">//parseInt 사용 시에는 무조건 try-catch를 써주어야 한다.</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> x = <span class=\"built_in\">parseInt</span>(req.query.x);</div><div class=\"line\">    <span class=\"keyword\">const</span> y = <span class=\"built_in\">parseInt</span>(req.query.y);</div><div class=\"line\">    <span class=\"keyword\">const</span> result = (x + y).toString();</div><div class=\"line\">    res.send(result)</div><div class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</div><div class=\"line\">    res.status(<span class=\"number\">400</span>)</div><div class=\"line\">    res.send(<span class=\"string\">`400 Bad Request`</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// req.ip</span></div><div class=\"line\">app.get(<span class=\"string\">'/ip'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  <span class=\"comment\">/*</span></div><div class=\"line\"><span class=\"comment\">  Mission: </span></div><div class=\"line\"><span class=\"comment\">  요청한 쪽의 ip를 응답한다.</span></div><div class=\"line\"><span class=\"comment\">  */</span></div><div class=\"line\">  res.send(req.ip);</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// req.get, res.set, res.end</span></div><div class=\"line\">app.get(<span class=\"string\">'/header'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  <span class=\"comment\">/*</span></div><div class=\"line\"><span class=\"comment\">  Mission:</span></div><div class=\"line\"><span class=\"comment\">  요청의 X-Custom-Header 헤더를 그대로 응답에 포함시켜 응답한다.</span></div><div class=\"line\"><span class=\"comment\">  응답에는 바디를 포함시키지 않도록 한다.</span></div><div class=\"line\"><span class=\"comment\">  </span></div><div class=\"line\"><span class=\"comment\">  hint 1: res.set 메소드는 응답에 새로운 헤더를 지정한다.</span></div><div class=\"line\"><span class=\"comment\">  예) res.set('X-Custom-Header', value)</span></div><div class=\"line\"><span class=\"comment\">  </span></div><div class=\"line\"><span class=\"comment\">  hint 2: res.end 메소드는 응답을 보낸다. res.send와 비슷하지만, 바디를 인자로 받지 않는다.</span></div><div class=\"line\"><span class=\"comment\">  */</span></div><div class=\"line\">    <span class=\"keyword\">const</span> value = req.get(<span class=\"string\">\"X-Custom-Header\"</span>)</div><div class=\"line\">  <span class=\"comment\">// 표준이 아닌 헤더를 만들 때, 이름 앞에 X를 붙이는 것이 관례이다.</span></div><div class=\"line\">  res.append(<span class=\"string\">'X-Custom.Header'</span>, value)</div><div class=\"line\">  res.end() <span class=\"comment\">// send()</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> listener = app.listen(process.env.PORT, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'listening on port '</span> + listener.address().port)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://allvectorlogo.com/img/2016/05/node-js-logo.png\" alt=\"\"></p><h1 id=\"Middleware\"><a href=\"#Middleware\" class=\"headerlink\" title=\"Middleware\"></a>Middleware</h1><h2 id=\"1-Express\"><a href=\"#1-Express\" class=\"headerlink\" title=\"1. Express\"></a>1. <a href=\"https://expressjs.com/ko/\" target=\"_blank\" rel=\"external\">Express</a></h2><ul><li>Node.js 생태계에서 가장 널리 쓰이는 웹 프레임워크</li><li>내장하고 있는 기능은 매우 적으나, 미들웨어를 주입하는 방식으로 기능을 확장하는 생태계를 가지고 있음</li></ul><h2 id=\"2-Express-앱의-기본-구조\"><a href=\"#2-Express-앱의-기본-구조\" class=\"headerlink\" title=\"2. Express 앱의 기본 구조\"></a>2. Express 앱의 기본 구조</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Express 인스턴스 생성</span></div><div class=\"line\"><span class=\"keyword\">const</span> app = express()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 미들웨어 주입</span></div><div class=\"line\">app.use(sessionMiddleware()) <span class=\"comment\">// 세션미들웨어</span></div><div class=\"line\">app.use(authenticationMiddleware()) <span class=\"comment\">// 인증미들웨어</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 라우트 핸들러 등록</span></div><div class=\"line\"><span class=\"comment\">// 루트 경로('/')로 요청이 들어왔을 때, Hello express! 라는 응답을 한다.</span></div><div class=\"line\">app.get(<span class=\"string\">'/'</span>, (request, response) =&gt; &#123;</div><div class=\"line\">  response.send(<span class=\"string\">'Hello express!'</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 서버 구동</span></div><div class=\"line\"><span class=\"comment\">// 3000번 포트에서 서버 요청을 기다릴 것이고, 서버 구동에 성공하면 아래 콜백(console.log('Example app listening on port 3000!'))을 실행시켜라.</span></div><div class=\"line\">app.listen(<span class=\"number\">3000</span>, () =&gt; &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Example app listening on port 3000!'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><h3 id=\"1-Routing\"><a href=\"#1-Routing\" class=\"headerlink\" title=\"1) Routing\"></a>1) Routing</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// HTTP 요청 메소드(GET, POST, ...)와 같은 이름의 메소드를 사용</span></div><div class=\"line\">app.get(<span class=\"string\">'/articles'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  res.send(<span class=\"string\">'Hello Routing!'</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 특정 경로('/articles')에만 미들웨어를 주입하는 것도 가능</span></div><div class=\"line\">app.post(<span class=\"string\">'/articles'</span>, bodyParserMiddleware(), (req, res) =&gt; &#123;</div><div class=\"line\">  database.articles.create(req.body)</div><div class=\"line\">    .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">      res.send(&#123;<span class=\"attr\">ok</span>: <span class=\"literal\">true</span>&#125;)</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 경로의 특정 부분을 함수의 인자처럼 입력받을 수 있음</span></div><div class=\"line\"><span class=\"comment\">// ':id' 위치에 오는 값이 req.params.id에 저장된다.</span></div><div class=\"line\">app.get(<span class=\"string\">'/articles/:id'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  database.articles.find(req.params.id) <span class=\"comment\">// `req.params`에 저장됨</span></div><div class=\"line\">    .then(<span class=\"function\"><span class=\"params\">article</span> =&gt;</span> &#123;</div><div class=\"line\">      res.send(article)</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><h3 id=\"2-Request-객체\"><a href=\"#2-Request-객체\" class=\"headerlink\" title=\"2) Request 객체\"></a>2) Request 객체</h3><ul><li><strong>req.body</strong><br>요청 바디를 적절한 형태의 자바스크립트 객체로 변환하여 이곳에 저장 (body-parser 미들웨어에 의해 처리됨)</li><li><strong>req.ip</strong><br>요청한 쪽의 IP</li><li><strong>req.params</strong><br>route parameter</li><li><strong>req.query</strong><br>query string이 객체로 저장됨</li></ul><h3 id=\"3-실습\"><a href=\"#3-실습\" class=\"headerlink\" title=\"3) 실습\"></a>3) 실습</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> bodyParser = <span class=\"built_in\">require</span>(<span class=\"string\">'body-parser'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> app = express()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// GET method</span></div><div class=\"line\">app.get(<span class=\"string\">'/'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  res.send(<span class=\"string\">'Hello, Express!'</span>);</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// POST method</span></div><div class=\"line\">app.post(<span class=\"string\">'/'</span>, bodyParser.json(), (req, res) =&gt; &#123;</div><div class=\"line\">  <span class=\"comment\">/*</span></div><div class=\"line\"><span class=\"comment\">  Mission:</span></div><div class=\"line\"><span class=\"comment\">  요청의 바디에 실려 온 JSON에 name이라는 속성이 있으면 해당 값을 이용해 응답하고, 없으면 400 Bad Request를 응답한다.</span></div><div class=\"line\"><span class=\"comment\">  응답 형태는 'Hello, &lt;name&gt;!' 으로 한다. </span></div><div class=\"line\"><span class=\"comment\">  */</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (req.body.name) &#123; <span class=\"comment\">// 포함되어 있으면(String) true, 없으면(undefined) false</span></div><div class=\"line\">    res.send(<span class=\"string\">`Hello, <span class=\"subst\">$&#123;req.body.name&#125;</span>!`</span>);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    res.status(<span class=\"number\">400</span>);</div><div class=\"line\">    res.send(<span class=\"string\">`400 Bad Request`</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// query parameter, res.status</span></div><div class=\"line\">app.get(<span class=\"string\">'/add'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  <span class=\"comment\">/* </span></div><div class=\"line\"><span class=\"comment\">  Mission: </span></div><div class=\"line\"><span class=\"comment\">  query parameter에 x와 y라는 이름을 가진 두 값을 정수로 바꾸어서 더한 후 응답한다.</span></div><div class=\"line\"><span class=\"comment\">  값을 정수로 바꿀 수 없다면 400 Bad Request로 응답한다.</span></div><div class=\"line\"><span class=\"comment\">  */</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">//parseInt 사용 시에는 무조건 try-catch를 써주어야 한다.</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> x = <span class=\"built_in\">parseInt</span>(req.query.x);</div><div class=\"line\">    <span class=\"keyword\">const</span> y = <span class=\"built_in\">parseInt</span>(req.query.y);</div><div class=\"line\">    <span class=\"keyword\">const</span> result = (x + y).toString();</div><div class=\"line\">    res.send(result)</div><div class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</div><div class=\"line\">    res.status(<span class=\"number\">400</span>)</div><div class=\"line\">    res.send(<span class=\"string\">`400 Bad Request`</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// req.ip</span></div><div class=\"line\">app.get(<span class=\"string\">'/ip'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  <span class=\"comment\">/*</span></div><div class=\"line\"><span class=\"comment\">  Mission: </span></div><div class=\"line\"><span class=\"comment\">  요청한 쪽의 ip를 응답한다.</span></div><div class=\"line\"><span class=\"comment\">  */</span></div><div class=\"line\">  res.send(req.ip);</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// req.get, res.set, res.end</span></div><div class=\"line\">app.get(<span class=\"string\">'/header'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  <span class=\"comment\">/*</span></div><div class=\"line\"><span class=\"comment\">  Mission:</span></div><div class=\"line\"><span class=\"comment\">  요청의 X-Custom-Header 헤더를 그대로 응답에 포함시켜 응답한다.</span></div><div class=\"line\"><span class=\"comment\">  응답에는 바디를 포함시키지 않도록 한다.</span></div><div class=\"line\"><span class=\"comment\">  </span></div><div class=\"line\"><span class=\"comment\">  hint 1: res.set 메소드는 응답에 새로운 헤더를 지정한다.</span></div><div class=\"line\"><span class=\"comment\">  예) res.set('X-Custom-Header', value)</span></div><div class=\"line\"><span class=\"comment\">  </span></div><div class=\"line\"><span class=\"comment\">  hint 2: res.end 메소드는 응답을 보낸다. res.send와 비슷하지만, 바디를 인자로 받지 않는다.</span></div><div class=\"line\"><span class=\"comment\">  */</span></div><div class=\"line\">    <span class=\"keyword\">const</span> value = req.get(<span class=\"string\">\"X-Custom-Header\"</span>)</div><div class=\"line\">  <span class=\"comment\">// 표준이 아닌 헤더를 만들 때, 이름 앞에 X를 붙이는 것이 관례이다.</span></div><div class=\"line\">  res.append(<span class=\"string\">'X-Custom.Header'</span>, value)</div><div class=\"line\">  res.end() <span class=\"comment\">// send()</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> listener = app.listen(process.env.PORT, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'listening on port '</span> + listener.address().port)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>"},{"title":"[node] Web form","date":"2017-08-30T08:08:08.000Z","_content":"\n![](http://allvectorlogo.com/img/2016/05/node-js-logo.png)\n\n# HTML Form\n\n## 1. 기본 동작\n\nHTML form을 전송하면, 입력된 정보가 기본적으로 percent encoding 되어 요청됨\n\n* GET method\n\n```\nGET /search?query=%EA%B0%9C&sort=latest HTTP/1.1\n...\n```\n\n* POST method\n\n```\nPOST /form HTTP/1.1\nContent-Type: application/x-www-form-urlencoded\n...\n\nhome=Cosby&favorite+flavor=flies\n```\n\n<br>\n\n## 2. multipart/form-data\n\n* 기본 설정(percent encoding)으로는 폼으로 파일을 업로드하는 것은 불가능\n* (클라이언트 측) form 태그에 enctype=\"multipart/form-data\" 속성을 적용하면 파일 업로드 가능\n* (서버 측) body-parser 미들웨어는 multipart/form-data 형태의 요청을 지원하지 않음 ([multer](https://www.npmjs.com/package/multer) 필요)\n\n<br>\n\n## 3.  예제\n\n[code](https://glitch.com/edit/#!/reflective-aries?path=server.js:44:45)\n\n* UUID (Universally unique identifier)\n  - 유효ID = 범용 고유 식별자\n\n  ![UUID](/images/uuid.png)\n\n  인터넷 상의 수많은 자료를 구분하기 위해 각 자료에 식별자(identifier)를 부여하는 일은 아주 중요합니다. 식별자를 부여하는 가장 쉬운 방법은 자료가 생성된 순서대로 번호를 붙이는 것입니다. 실제로 많은 데이터베이스에서 이런 방법을 사용하고 있습니다. 하지만 환경에 따라 자료가 생성되는 순서를 알 수 없는 경우도 있습니다.  \n\n  UUID는 식별자로 사용하기 위해 고안된 수 형식이며, 아래와 같은 형식으로 표현됩니다.  \n\n  424e19f5-f330-4be1-889f-4a9f7da75b69  \n\n  UUID는 표현할 수 있는 경우의 수가 무지무지무지무지 많습니다. (128bit = 2의 128제곱) UUID 난수를 생성하는 표준적인 방법(UUID version 4)을 사용하면, 언제 어디서 UUID를 생성해도 정확히 같은 UUID가 생성될 수 있는 확률이 매우매우매우매우 작기 때문에 안심하고 식별자로 사용할 수 있습니다.  \n\n  node에서의 uuid는 [npm uuid package](https://www.npmjs.com/package/uuid) 설치를 통해 사용할 수 있다.  \n\n* Redirection after submission  \n브라우저의 새로고침은 동일한 요청을 한번 더 보내는 것이다.  \nredirect를 하지 않으면 POST가 같은 요청을 또 보내기 때문에, 새로고침시 이전에 보냈던 요청을 한번 더 보내게 된다. 따라서 POST에 대해서는 redirect 하지 않으면 문제가 발생한다.  \n\n  ```js\n\n  // 할일 추가 endpoint\n  app.post('/todo', urlencodedParser, (req, res) => {\n    const title = req.body.title\n    // validation 유효성 검사 : title이 빈 문자열인지 확인\n    if (title && title.length!==0) {\n      const todo = {\n        id: uuidv4(), // slug\n        title // es6문법\n      }\n      todos.push(todo)\n      // redirect 하지 않으면 새로고침시 동일 요청을 한번 더 보낸다.\n      res.render('index.ejs', {todos}) // 이렇게 하면 안 됩니다!\n      // res.redirect(301, '/') // 이렇게 해도 안 됩니다!\n      // res.redirect('/') // res.redirect는 302 상태코드로 응답합니다.\n    } else {\n      res.status(400)\n      res.send('400 Bad Request')\n    }\n  })\n\n  ```\n\n  순수 HTML form으로 요청을 보낼 때는 반드시 redirect를 해야 한다.  \n  (AJAX로 하는 경우에는 요청을 새로 또 보내지 않으니, 굳이 하지 않아도 됨!)  \n\n\n  ```js\n\n  // 할일 추가 endpoint\n  app.post('/todo', urlencodedParser, (req, res) => {\n    const title = req.body.title\n    // validation 유효성 검사 : title이 빈 문자열인지 확인\n    if (title && title.length!==0) {\n      const todo = {\n        id: uuidv4(), // slug\n        title // es6문법\n      }\n      todos.push(todo)\n      //res.render('index.ejs', {todos}) // 이렇게 하면 안 됩니다!\n      res.redirect(301, '/') // 이렇게 해도 안 됩니다!\n      // res.redirect('/') // res.redirect는 302 상태코드로 응답합니다.\n    } else {\n      res.status(400)\n      res.send('400 Bad Request')\n    }\n  })\n\n  ```\n  #### # 301 vs 302\n\n  서버가 301응답을 보내면 웹 브라우저는 그것을 기억해뒀다가 똑같은 요청이 왔을 때 서버에 요청을 보내지 않고 브라우저에 저장해두었던 redirect 정보를 가지고 redirect를 한다. 즉 서버에 재요청하지 않고 웹브라우저에 기억해둔 정보를 꺼내와서 사용한다. 웹브라우저 주소가 완전히 이동했을 때, (사이트가 폐쇄된 경우 등) 301을 사용한다. (부수 효과: 검색엔진의 웹 크롤러는 301응답을 발견할 경우 그 사이트로 더이상 접근하지 않는다.)  \n\n  반면 똑같은 요청이 와도 서버에 해당 요청을 한번 더 전송하는 것이 302 응답이다.  \n\n* Form validation  \n\n  사용자가 입력하는 자료는 개발자가 기대하는 형식과는 영 딴판일 수 있습니다. 필요한 필드가 없을 수도 있고, 자료의 형식을 서버가 이해할 수 없는 경우도 있습니다. 이런 자료를 데이터베이스에 그냥 집어넣게 되면 데이터베이스가 뒤죽박죽이 되고 말 것입니다. 그래서, 사용자에게 입력받은 자료는 처리를 하기 전에 항상 올바른 형태인지 검증해야 합니다. 이런 검증 과정을 form validation이라고 합니다.  \n\n  form validation을 구현하는 전형적인 방법은 다음과 같습니다.  \n\n  * 사용자가 폼을 작성합니다.  \n  * 사용자가 폼을 서버에 전송합니다.\n  * 서버는 기대한대로 데이터가 들어왔는지 검사합니다.\n  * 서버는 데이터가 기대한 대로 잘 들어왔으면 다음 단계를 진행하고, 데이터에 문제가 있다면 어떤 문제가 있는지를 사용자에게 알려줍니다. (이 프로젝트에서는 데이터에 문제가 있으면 단순하게 400 Bad Request 응답을 하고 있지만 사용자 경험을 위해서는 이렇게 하면 안되겠죠?)  \n\n  서버 측에서 하는 form validation은 꼭 필요하지만, 사용자가 자료를 서버에 전송해야만 데이터에 어떤 문제가 있는지를 알 수 있다는 단점이 있습니다. 사용자 입장에서는 실컷 폼을 다 작성해서 전송했더니 폼에 에러가 있다고 하며 중간 단계부터 다시 시작해야 하니 짜증이 날 것입니다. 아마 여러분도 비슷한 경험이 있을 것입니다.  \n\n  서버 측 validation을 잘 구현해서 사용자가 덜 불편하게끔 만드는 방법도 있지만 폼을 서버에 전송해야 피드백을 받을 수 있다는 점은 변하지 않습니다. 더 나은 사용자 경험을 위해 클라이언트 측 validation을 하는 것을 고려해볼 수 있습니다.  \n\n  클라이언트 측 validation은 사용자가 폼을 작성하는 도중에 피드백을 받을 수 있다는 점에서 서버 측 validation보다 훨씬 나은 사용자 경험을 제공할 수 있습니다. 대신 서버 측 코드에서 하는 데이터 검사 로직을 클라이언트 측 코드에도 중복 구현해야 한다는 어려운 점이 있습니다. 다행히 HTML5에 추가된 form validation 기능을 이용하면 간단한 validation은 자바스크립트 코드를 하나도 짜지 않고도 구현할 수 있습니다. HTML5 form validation을 시험해 보려면, index.ejs 파일의 title 필드에 required 속성을 추가해보세요.  \n\n  HTML5 form validation은 사용하기 간편하고, 브라우저에 내장되어 있다는 점에서 (특히 모바일에서) 일관성있는 사용자 경험을 제공할 수 있다는 장점이 있습니다. 하지만 HTML5를 지원하지 않는 구형 브라우저에서는 사용할 수 없고, 또 복잡한 형태의 validation은 지원하지 않는다는 단점이 있습니다. (여러 필드의 자료를 합쳐서 validation을 한다거나, validation을 하기 위해 서버에 요청을 해야 하는 등)  \n\n  주의! 클라이언트 측 validation을 하더라도 서버 측에서는 반드시 validation을 따로 해주어야 합니다. 사용자가 언제나 우리가 제공하는 클라이언트를 사용한다는 보장은 없기 때문입니다. (예를 들면 악의적인 해커가 Postman 등을 이용해 이상한 요청을 보낼 수도 있겠죠?)  \n\n---\n","source":"_posts/nodejs/05.Web form.md","raw":"---\ntitle: '[node] Web form'\ndate: 2017-08-30 17:08:08\ncategory: Nodejs\ntags: webform\n---\n\n![](http://allvectorlogo.com/img/2016/05/node-js-logo.png)\n\n# HTML Form\n\n## 1. 기본 동작\n\nHTML form을 전송하면, 입력된 정보가 기본적으로 percent encoding 되어 요청됨\n\n* GET method\n\n```\nGET /search?query=%EA%B0%9C&sort=latest HTTP/1.1\n...\n```\n\n* POST method\n\n```\nPOST /form HTTP/1.1\nContent-Type: application/x-www-form-urlencoded\n...\n\nhome=Cosby&favorite+flavor=flies\n```\n\n<br>\n\n## 2. multipart/form-data\n\n* 기본 설정(percent encoding)으로는 폼으로 파일을 업로드하는 것은 불가능\n* (클라이언트 측) form 태그에 enctype=\"multipart/form-data\" 속성을 적용하면 파일 업로드 가능\n* (서버 측) body-parser 미들웨어는 multipart/form-data 형태의 요청을 지원하지 않음 ([multer](https://www.npmjs.com/package/multer) 필요)\n\n<br>\n\n## 3.  예제\n\n[code](https://glitch.com/edit/#!/reflective-aries?path=server.js:44:45)\n\n* UUID (Universally unique identifier)\n  - 유효ID = 범용 고유 식별자\n\n  ![UUID](/images/uuid.png)\n\n  인터넷 상의 수많은 자료를 구분하기 위해 각 자료에 식별자(identifier)를 부여하는 일은 아주 중요합니다. 식별자를 부여하는 가장 쉬운 방법은 자료가 생성된 순서대로 번호를 붙이는 것입니다. 실제로 많은 데이터베이스에서 이런 방법을 사용하고 있습니다. 하지만 환경에 따라 자료가 생성되는 순서를 알 수 없는 경우도 있습니다.  \n\n  UUID는 식별자로 사용하기 위해 고안된 수 형식이며, 아래와 같은 형식으로 표현됩니다.  \n\n  424e19f5-f330-4be1-889f-4a9f7da75b69  \n\n  UUID는 표현할 수 있는 경우의 수가 무지무지무지무지 많습니다. (128bit = 2의 128제곱) UUID 난수를 생성하는 표준적인 방법(UUID version 4)을 사용하면, 언제 어디서 UUID를 생성해도 정확히 같은 UUID가 생성될 수 있는 확률이 매우매우매우매우 작기 때문에 안심하고 식별자로 사용할 수 있습니다.  \n\n  node에서의 uuid는 [npm uuid package](https://www.npmjs.com/package/uuid) 설치를 통해 사용할 수 있다.  \n\n* Redirection after submission  \n브라우저의 새로고침은 동일한 요청을 한번 더 보내는 것이다.  \nredirect를 하지 않으면 POST가 같은 요청을 또 보내기 때문에, 새로고침시 이전에 보냈던 요청을 한번 더 보내게 된다. 따라서 POST에 대해서는 redirect 하지 않으면 문제가 발생한다.  \n\n  ```js\n\n  // 할일 추가 endpoint\n  app.post('/todo', urlencodedParser, (req, res) => {\n    const title = req.body.title\n    // validation 유효성 검사 : title이 빈 문자열인지 확인\n    if (title && title.length!==0) {\n      const todo = {\n        id: uuidv4(), // slug\n        title // es6문법\n      }\n      todos.push(todo)\n      // redirect 하지 않으면 새로고침시 동일 요청을 한번 더 보낸다.\n      res.render('index.ejs', {todos}) // 이렇게 하면 안 됩니다!\n      // res.redirect(301, '/') // 이렇게 해도 안 됩니다!\n      // res.redirect('/') // res.redirect는 302 상태코드로 응답합니다.\n    } else {\n      res.status(400)\n      res.send('400 Bad Request')\n    }\n  })\n\n  ```\n\n  순수 HTML form으로 요청을 보낼 때는 반드시 redirect를 해야 한다.  \n  (AJAX로 하는 경우에는 요청을 새로 또 보내지 않으니, 굳이 하지 않아도 됨!)  \n\n\n  ```js\n\n  // 할일 추가 endpoint\n  app.post('/todo', urlencodedParser, (req, res) => {\n    const title = req.body.title\n    // validation 유효성 검사 : title이 빈 문자열인지 확인\n    if (title && title.length!==0) {\n      const todo = {\n        id: uuidv4(), // slug\n        title // es6문법\n      }\n      todos.push(todo)\n      //res.render('index.ejs', {todos}) // 이렇게 하면 안 됩니다!\n      res.redirect(301, '/') // 이렇게 해도 안 됩니다!\n      // res.redirect('/') // res.redirect는 302 상태코드로 응답합니다.\n    } else {\n      res.status(400)\n      res.send('400 Bad Request')\n    }\n  })\n\n  ```\n  #### # 301 vs 302\n\n  서버가 301응답을 보내면 웹 브라우저는 그것을 기억해뒀다가 똑같은 요청이 왔을 때 서버에 요청을 보내지 않고 브라우저에 저장해두었던 redirect 정보를 가지고 redirect를 한다. 즉 서버에 재요청하지 않고 웹브라우저에 기억해둔 정보를 꺼내와서 사용한다. 웹브라우저 주소가 완전히 이동했을 때, (사이트가 폐쇄된 경우 등) 301을 사용한다. (부수 효과: 검색엔진의 웹 크롤러는 301응답을 발견할 경우 그 사이트로 더이상 접근하지 않는다.)  \n\n  반면 똑같은 요청이 와도 서버에 해당 요청을 한번 더 전송하는 것이 302 응답이다.  \n\n* Form validation  \n\n  사용자가 입력하는 자료는 개발자가 기대하는 형식과는 영 딴판일 수 있습니다. 필요한 필드가 없을 수도 있고, 자료의 형식을 서버가 이해할 수 없는 경우도 있습니다. 이런 자료를 데이터베이스에 그냥 집어넣게 되면 데이터베이스가 뒤죽박죽이 되고 말 것입니다. 그래서, 사용자에게 입력받은 자료는 처리를 하기 전에 항상 올바른 형태인지 검증해야 합니다. 이런 검증 과정을 form validation이라고 합니다.  \n\n  form validation을 구현하는 전형적인 방법은 다음과 같습니다.  \n\n  * 사용자가 폼을 작성합니다.  \n  * 사용자가 폼을 서버에 전송합니다.\n  * 서버는 기대한대로 데이터가 들어왔는지 검사합니다.\n  * 서버는 데이터가 기대한 대로 잘 들어왔으면 다음 단계를 진행하고, 데이터에 문제가 있다면 어떤 문제가 있는지를 사용자에게 알려줍니다. (이 프로젝트에서는 데이터에 문제가 있으면 단순하게 400 Bad Request 응답을 하고 있지만 사용자 경험을 위해서는 이렇게 하면 안되겠죠?)  \n\n  서버 측에서 하는 form validation은 꼭 필요하지만, 사용자가 자료를 서버에 전송해야만 데이터에 어떤 문제가 있는지를 알 수 있다는 단점이 있습니다. 사용자 입장에서는 실컷 폼을 다 작성해서 전송했더니 폼에 에러가 있다고 하며 중간 단계부터 다시 시작해야 하니 짜증이 날 것입니다. 아마 여러분도 비슷한 경험이 있을 것입니다.  \n\n  서버 측 validation을 잘 구현해서 사용자가 덜 불편하게끔 만드는 방법도 있지만 폼을 서버에 전송해야 피드백을 받을 수 있다는 점은 변하지 않습니다. 더 나은 사용자 경험을 위해 클라이언트 측 validation을 하는 것을 고려해볼 수 있습니다.  \n\n  클라이언트 측 validation은 사용자가 폼을 작성하는 도중에 피드백을 받을 수 있다는 점에서 서버 측 validation보다 훨씬 나은 사용자 경험을 제공할 수 있습니다. 대신 서버 측 코드에서 하는 데이터 검사 로직을 클라이언트 측 코드에도 중복 구현해야 한다는 어려운 점이 있습니다. 다행히 HTML5에 추가된 form validation 기능을 이용하면 간단한 validation은 자바스크립트 코드를 하나도 짜지 않고도 구현할 수 있습니다. HTML5 form validation을 시험해 보려면, index.ejs 파일의 title 필드에 required 속성을 추가해보세요.  \n\n  HTML5 form validation은 사용하기 간편하고, 브라우저에 내장되어 있다는 점에서 (특히 모바일에서) 일관성있는 사용자 경험을 제공할 수 있다는 장점이 있습니다. 하지만 HTML5를 지원하지 않는 구형 브라우저에서는 사용할 수 없고, 또 복잡한 형태의 validation은 지원하지 않는다는 단점이 있습니다. (여러 필드의 자료를 합쳐서 validation을 한다거나, validation을 하기 위해 서버에 요청을 해야 하는 등)  \n\n  주의! 클라이언트 측 validation을 하더라도 서버 측에서는 반드시 validation을 따로 해주어야 합니다. 사용자가 언제나 우리가 제공하는 클라이언트를 사용한다는 보장은 없기 때문입니다. (예를 들면 악의적인 해커가 Postman 등을 이용해 이상한 요청을 보낼 수도 있겠죠?)  \n\n---\n","slug":"nodejs/05.Web form","published":1,"updated":"2017-09-21T06:06:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjai8h18h0017vb9q3icsepvm","content":"<p><img src=\"http://allvectorlogo.com/img/2016/05/node-js-logo.png\" alt=\"\"></p><h1 id=\"HTML-Form\"><a href=\"#HTML-Form\" class=\"headerlink\" title=\"HTML Form\"></a>HTML Form</h1><h2 id=\"1-기본-동작\"><a href=\"#1-기본-동작\" class=\"headerlink\" title=\"1. 기본 동작\"></a>1. 기본 동작</h2><p>HTML form을 전송하면, 입력된 정보가 기본적으로 percent encoding 되어 요청됨</p><ul><li>GET method</li></ul><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">GET /search?query=%EA%B0%9C&amp;sort=latest HTTP/1.1</div><div class=\"line\">...</div></pre></td></tr></table></figure><ul><li>POST method</li></ul><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">POST /form HTTP/1.1</div><div class=\"line\">Content-Type: application/x-www-form-urlencoded</div><div class=\"line\">...</div><div class=\"line\"></div><div class=\"line\">home=Cosby&amp;favorite+flavor=flies</div></pre></td></tr></table></figure><p><br></p><h2 id=\"2-multipart-form-data\"><a href=\"#2-multipart-form-data\" class=\"headerlink\" title=\"2. multipart/form-data\"></a>2. multipart/form-data</h2><ul><li>기본 설정(percent encoding)으로는 폼으로 파일을 업로드하는 것은 불가능</li><li>(클라이언트 측) form 태그에 enctype=”multipart/form-data” 속성을 적용하면 파일 업로드 가능</li><li>(서버 측) body-parser 미들웨어는 multipart/form-data 형태의 요청을 지원하지 않음 (<a href=\"https://www.npmjs.com/package/multer\" target=\"_blank\" rel=\"external\">multer</a> 필요)</li></ul><p><br></p><h2 id=\"3-예제\"><a href=\"#3-예제\" class=\"headerlink\" title=\"3.  예제\"></a>3. 예제</h2><p><a href=\"https://glitch.com/edit/#!/reflective-aries?path=server.js:44:45\" target=\"_blank\" rel=\"external\">code</a></p><ul><li><p>UUID (Universally unique identifier)</p><ul><li>유효ID = 범용 고유 식별자</li></ul><p><img src=\"/images/uuid.png\" alt=\"UUID\"></p><p>인터넷 상의 수많은 자료를 구분하기 위해 각 자료에 식별자(identifier)를 부여하는 일은 아주 중요합니다. 식별자를 부여하는 가장 쉬운 방법은 자료가 생성된 순서대로 번호를 붙이는 것입니다. 실제로 많은 데이터베이스에서 이런 방법을 사용하고 있습니다. 하지만 환경에 따라 자료가 생성되는 순서를 알 수 없는 경우도 있습니다.</p><p>UUID는 식별자로 사용하기 위해 고안된 수 형식이며, 아래와 같은 형식으로 표현됩니다.</p><p>424e19f5-f330-4be1-889f-4a9f7da75b69</p><p>UUID는 표현할 수 있는 경우의 수가 무지무지무지무지 많습니다. (128bit = 2의 128제곱) UUID 난수를 생성하는 표준적인 방법(UUID version 4)을 사용하면, 언제 어디서 UUID를 생성해도 정확히 같은 UUID가 생성될 수 있는 확률이 매우매우매우매우 작기 때문에 안심하고 식별자로 사용할 수 있습니다.</p><p>node에서의 uuid는 <a href=\"https://www.npmjs.com/package/uuid\" target=\"_blank\" rel=\"external\">npm uuid package</a> 설치를 통해 사용할 수 있다.</p></li><li><p>Redirection after submission<br>브라우저의 새로고침은 동일한 요청을 한번 더 보내는 것이다.<br>redirect를 하지 않으면 POST가 같은 요청을 또 보내기 때문에, 새로고침시 이전에 보냈던 요청을 한번 더 보내게 된다. 따라서 POST에 대해서는 redirect 하지 않으면 문제가 발생한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 할일 추가 endpoint</span></div><div class=\"line\">app.post(<span class=\"string\">'/todo'</span>, urlencodedParser, (req, res) =&gt; &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> title = req.body.title</div><div class=\"line\">  <span class=\"comment\">// validation 유효성 검사 : title이 빈 문자열인지 확인</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (title &amp;&amp; title.length!==<span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> todo = &#123;</div><div class=\"line\">      id: uuidv4(), <span class=\"comment\">// slug</span></div><div class=\"line\">      title <span class=\"comment\">// es6문법</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    todos.push(todo)</div><div class=\"line\">    <span class=\"comment\">// redirect 하지 않으면 새로고침시 동일 요청을 한번 더 보낸다.</span></div><div class=\"line\">    res.render(<span class=\"string\">'index.ejs'</span>, &#123;todos&#125;) <span class=\"comment\">// 이렇게 하면 안 됩니다!</span></div><div class=\"line\">    <span class=\"comment\">// res.redirect(301, '/') // 이렇게 해도 안 됩니다!</span></div><div class=\"line\">    <span class=\"comment\">// res.redirect('/') // res.redirect는 302 상태코드로 응답합니다.</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    res.status(<span class=\"number\">400</span>)</div><div class=\"line\">    res.send(<span class=\"string\">'400 Bad Request'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p>순수 HTML form으로 요청을 보낼 때는 반드시 redirect를 해야 한다.<br>(AJAX로 하는 경우에는 요청을 새로 또 보내지 않으니, 굳이 하지 않아도 됨!)</p></li></ul><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 할일 추가 endpoint</span></div><div class=\"line\">app.post(<span class=\"string\">'/todo'</span>, urlencodedParser, (req, res) =&gt; &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> title = req.body.title</div><div class=\"line\">  <span class=\"comment\">// validation 유효성 검사 : title이 빈 문자열인지 확인</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (title &amp;&amp; title.length!==<span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> todo = &#123;</div><div class=\"line\">      id: uuidv4(), <span class=\"comment\">// slug</span></div><div class=\"line\">      title <span class=\"comment\">// es6문법</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    todos.push(todo)</div><div class=\"line\">    <span class=\"comment\">//res.render('index.ejs', &#123;todos&#125;) // 이렇게 하면 안 됩니다!</span></div><div class=\"line\">    res.redirect(<span class=\"number\">301</span>, <span class=\"string\">'/'</span>) <span class=\"comment\">// 이렇게 해도 안 됩니다!</span></div><div class=\"line\">    <span class=\"comment\">// res.redirect('/') // res.redirect는 302 상태코드로 응답합니다.</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    res.status(<span class=\"number\">400</span>)</div><div class=\"line\">    res.send(<span class=\"string\">'400 Bad Request'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><h4 id=\"301-vs-302\"><a href=\"#301-vs-302\" class=\"headerlink\" title=\"# 301 vs 302\"></a># 301 vs 302</h4><p>서버가 301응답을 보내면 웹 브라우저는 그것을 기억해뒀다가 똑같은 요청이 왔을 때 서버에 요청을 보내지 않고 브라우저에 저장해두었던 redirect 정보를 가지고 redirect를 한다. 즉 서버에 재요청하지 않고 웹브라우저에 기억해둔 정보를 꺼내와서 사용한다. 웹브라우저 주소가 완전히 이동했을 때, (사이트가 폐쇄된 경우 등) 301을 사용한다. (부수 효과: 검색엔진의 웹 크롤러는 301응답을 발견할 경우 그 사이트로 더이상 접근하지 않는다.)</p><p>반면 똑같은 요청이 와도 서버에 해당 요청을 한번 더 전송하는 것이 302 응답이다.</p><ul><li><p>Form validation</p><p>사용자가 입력하는 자료는 개발자가 기대하는 형식과는 영 딴판일 수 있습니다. 필요한 필드가 없을 수도 있고, 자료의 형식을 서버가 이해할 수 없는 경우도 있습니다. 이런 자료를 데이터베이스에 그냥 집어넣게 되면 데이터베이스가 뒤죽박죽이 되고 말 것입니다. 그래서, 사용자에게 입력받은 자료는 처리를 하기 전에 항상 올바른 형태인지 검증해야 합니다. 이런 검증 과정을 form validation이라고 합니다.</p><p>form validation을 구현하는 전형적인 방법은 다음과 같습니다.</p><ul><li>사용자가 폼을 작성합니다.</li><li>사용자가 폼을 서버에 전송합니다.</li><li>서버는 기대한대로 데이터가 들어왔는지 검사합니다.</li><li>서버는 데이터가 기대한 대로 잘 들어왔으면 다음 단계를 진행하고, 데이터에 문제가 있다면 어떤 문제가 있는지를 사용자에게 알려줍니다. (이 프로젝트에서는 데이터에 문제가 있으면 단순하게 400 Bad Request 응답을 하고 있지만 사용자 경험을 위해서는 이렇게 하면 안되겠죠?)</li></ul><p>서버 측에서 하는 form validation은 꼭 필요하지만, 사용자가 자료를 서버에 전송해야만 데이터에 어떤 문제가 있는지를 알 수 있다는 단점이 있습니다. 사용자 입장에서는 실컷 폼을 다 작성해서 전송했더니 폼에 에러가 있다고 하며 중간 단계부터 다시 시작해야 하니 짜증이 날 것입니다. 아마 여러분도 비슷한 경험이 있을 것입니다.</p><p>서버 측 validation을 잘 구현해서 사용자가 덜 불편하게끔 만드는 방법도 있지만 폼을 서버에 전송해야 피드백을 받을 수 있다는 점은 변하지 않습니다. 더 나은 사용자 경험을 위해 클라이언트 측 validation을 하는 것을 고려해볼 수 있습니다.</p><p>클라이언트 측 validation은 사용자가 폼을 작성하는 도중에 피드백을 받을 수 있다는 점에서 서버 측 validation보다 훨씬 나은 사용자 경험을 제공할 수 있습니다. 대신 서버 측 코드에서 하는 데이터 검사 로직을 클라이언트 측 코드에도 중복 구현해야 한다는 어려운 점이 있습니다. 다행히 HTML5에 추가된 form validation 기능을 이용하면 간단한 validation은 자바스크립트 코드를 하나도 짜지 않고도 구현할 수 있습니다. HTML5 form validation을 시험해 보려면, index.ejs 파일의 title 필드에 required 속성을 추가해보세요.</p><p>HTML5 form validation은 사용하기 간편하고, 브라우저에 내장되어 있다는 점에서 (특히 모바일에서) 일관성있는 사용자 경험을 제공할 수 있다는 장점이 있습니다. 하지만 HTML5를 지원하지 않는 구형 브라우저에서는 사용할 수 없고, 또 복잡한 형태의 validation은 지원하지 않는다는 단점이 있습니다. (여러 필드의 자료를 합쳐서 validation을 한다거나, validation을 하기 위해 서버에 요청을 해야 하는 등)</p><p>주의! 클라이언트 측 validation을 하더라도 서버 측에서는 반드시 validation을 따로 해주어야 합니다. 사용자가 언제나 우리가 제공하는 클라이언트를 사용한다는 보장은 없기 때문입니다. (예를 들면 악의적인 해커가 Postman 등을 이용해 이상한 요청을 보낼 수도 있겠죠?)</p></li></ul><hr>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://allvectorlogo.com/img/2016/05/node-js-logo.png\" alt=\"\"></p><h1 id=\"HTML-Form\"><a href=\"#HTML-Form\" class=\"headerlink\" title=\"HTML Form\"></a>HTML Form</h1><h2 id=\"1-기본-동작\"><a href=\"#1-기본-동작\" class=\"headerlink\" title=\"1. 기본 동작\"></a>1. 기본 동작</h2><p>HTML form을 전송하면, 입력된 정보가 기본적으로 percent encoding 되어 요청됨</p><ul><li>GET method</li></ul><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">GET /search?query=%EA%B0%9C&amp;sort=latest HTTP/1.1</div><div class=\"line\">...</div></pre></td></tr></table></figure><ul><li>POST method</li></ul><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">POST /form HTTP/1.1</div><div class=\"line\">Content-Type: application/x-www-form-urlencoded</div><div class=\"line\">...</div><div class=\"line\"></div><div class=\"line\">home=Cosby&amp;favorite+flavor=flies</div></pre></td></tr></table></figure><p><br></p><h2 id=\"2-multipart-form-data\"><a href=\"#2-multipart-form-data\" class=\"headerlink\" title=\"2. multipart/form-data\"></a>2. multipart/form-data</h2><ul><li>기본 설정(percent encoding)으로는 폼으로 파일을 업로드하는 것은 불가능</li><li>(클라이언트 측) form 태그에 enctype=”multipart/form-data” 속성을 적용하면 파일 업로드 가능</li><li>(서버 측) body-parser 미들웨어는 multipart/form-data 형태의 요청을 지원하지 않음 (<a href=\"https://www.npmjs.com/package/multer\" target=\"_blank\" rel=\"external\">multer</a> 필요)</li></ul><p><br></p><h2 id=\"3-예제\"><a href=\"#3-예제\" class=\"headerlink\" title=\"3.  예제\"></a>3. 예제</h2><p><a href=\"https://glitch.com/edit/#!/reflective-aries?path=server.js:44:45\" target=\"_blank\" rel=\"external\">code</a></p><ul><li><p>UUID (Universally unique identifier)</p><ul><li>유효ID = 범용 고유 식별자</li></ul><p><img src=\"/images/uuid.png\" alt=\"UUID\"></p><p>인터넷 상의 수많은 자료를 구분하기 위해 각 자료에 식별자(identifier)를 부여하는 일은 아주 중요합니다. 식별자를 부여하는 가장 쉬운 방법은 자료가 생성된 순서대로 번호를 붙이는 것입니다. 실제로 많은 데이터베이스에서 이런 방법을 사용하고 있습니다. 하지만 환경에 따라 자료가 생성되는 순서를 알 수 없는 경우도 있습니다.</p><p>UUID는 식별자로 사용하기 위해 고안된 수 형식이며, 아래와 같은 형식으로 표현됩니다.</p><p>424e19f5-f330-4be1-889f-4a9f7da75b69</p><p>UUID는 표현할 수 있는 경우의 수가 무지무지무지무지 많습니다. (128bit = 2의 128제곱) UUID 난수를 생성하는 표준적인 방법(UUID version 4)을 사용하면, 언제 어디서 UUID를 생성해도 정확히 같은 UUID가 생성될 수 있는 확률이 매우매우매우매우 작기 때문에 안심하고 식별자로 사용할 수 있습니다.</p><p>node에서의 uuid는 <a href=\"https://www.npmjs.com/package/uuid\" target=\"_blank\" rel=\"external\">npm uuid package</a> 설치를 통해 사용할 수 있다.</p></li><li><p>Redirection after submission<br>브라우저의 새로고침은 동일한 요청을 한번 더 보내는 것이다.<br>redirect를 하지 않으면 POST가 같은 요청을 또 보내기 때문에, 새로고침시 이전에 보냈던 요청을 한번 더 보내게 된다. 따라서 POST에 대해서는 redirect 하지 않으면 문제가 발생한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 할일 추가 endpoint</span></div><div class=\"line\">app.post(<span class=\"string\">'/todo'</span>, urlencodedParser, (req, res) =&gt; &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> title = req.body.title</div><div class=\"line\">  <span class=\"comment\">// validation 유효성 검사 : title이 빈 문자열인지 확인</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (title &amp;&amp; title.length!==<span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> todo = &#123;</div><div class=\"line\">      id: uuidv4(), <span class=\"comment\">// slug</span></div><div class=\"line\">      title <span class=\"comment\">// es6문법</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    todos.push(todo)</div><div class=\"line\">    <span class=\"comment\">// redirect 하지 않으면 새로고침시 동일 요청을 한번 더 보낸다.</span></div><div class=\"line\">    res.render(<span class=\"string\">'index.ejs'</span>, &#123;todos&#125;) <span class=\"comment\">// 이렇게 하면 안 됩니다!</span></div><div class=\"line\">    <span class=\"comment\">// res.redirect(301, '/') // 이렇게 해도 안 됩니다!</span></div><div class=\"line\">    <span class=\"comment\">// res.redirect('/') // res.redirect는 302 상태코드로 응답합니다.</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    res.status(<span class=\"number\">400</span>)</div><div class=\"line\">    res.send(<span class=\"string\">'400 Bad Request'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p>순수 HTML form으로 요청을 보낼 때는 반드시 redirect를 해야 한다.<br>(AJAX로 하는 경우에는 요청을 새로 또 보내지 않으니, 굳이 하지 않아도 됨!)</p></li></ul><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 할일 추가 endpoint</span></div><div class=\"line\">app.post(<span class=\"string\">'/todo'</span>, urlencodedParser, (req, res) =&gt; &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> title = req.body.title</div><div class=\"line\">  <span class=\"comment\">// validation 유효성 검사 : title이 빈 문자열인지 확인</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (title &amp;&amp; title.length!==<span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> todo = &#123;</div><div class=\"line\">      id: uuidv4(), <span class=\"comment\">// slug</span></div><div class=\"line\">      title <span class=\"comment\">// es6문법</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    todos.push(todo)</div><div class=\"line\">    <span class=\"comment\">//res.render('index.ejs', &#123;todos&#125;) // 이렇게 하면 안 됩니다!</span></div><div class=\"line\">    res.redirect(<span class=\"number\">301</span>, <span class=\"string\">'/'</span>) <span class=\"comment\">// 이렇게 해도 안 됩니다!</span></div><div class=\"line\">    <span class=\"comment\">// res.redirect('/') // res.redirect는 302 상태코드로 응답합니다.</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    res.status(<span class=\"number\">400</span>)</div><div class=\"line\">    res.send(<span class=\"string\">'400 Bad Request'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><h4 id=\"301-vs-302\"><a href=\"#301-vs-302\" class=\"headerlink\" title=\"# 301 vs 302\"></a># 301 vs 302</h4><p>서버가 301응답을 보내면 웹 브라우저는 그것을 기억해뒀다가 똑같은 요청이 왔을 때 서버에 요청을 보내지 않고 브라우저에 저장해두었던 redirect 정보를 가지고 redirect를 한다. 즉 서버에 재요청하지 않고 웹브라우저에 기억해둔 정보를 꺼내와서 사용한다. 웹브라우저 주소가 완전히 이동했을 때, (사이트가 폐쇄된 경우 등) 301을 사용한다. (부수 효과: 검색엔진의 웹 크롤러는 301응답을 발견할 경우 그 사이트로 더이상 접근하지 않는다.)</p><p>반면 똑같은 요청이 와도 서버에 해당 요청을 한번 더 전송하는 것이 302 응답이다.</p><ul><li><p>Form validation</p><p>사용자가 입력하는 자료는 개발자가 기대하는 형식과는 영 딴판일 수 있습니다. 필요한 필드가 없을 수도 있고, 자료의 형식을 서버가 이해할 수 없는 경우도 있습니다. 이런 자료를 데이터베이스에 그냥 집어넣게 되면 데이터베이스가 뒤죽박죽이 되고 말 것입니다. 그래서, 사용자에게 입력받은 자료는 처리를 하기 전에 항상 올바른 형태인지 검증해야 합니다. 이런 검증 과정을 form validation이라고 합니다.</p><p>form validation을 구현하는 전형적인 방법은 다음과 같습니다.</p><ul><li>사용자가 폼을 작성합니다.</li><li>사용자가 폼을 서버에 전송합니다.</li><li>서버는 기대한대로 데이터가 들어왔는지 검사합니다.</li><li>서버는 데이터가 기대한 대로 잘 들어왔으면 다음 단계를 진행하고, 데이터에 문제가 있다면 어떤 문제가 있는지를 사용자에게 알려줍니다. (이 프로젝트에서는 데이터에 문제가 있으면 단순하게 400 Bad Request 응답을 하고 있지만 사용자 경험을 위해서는 이렇게 하면 안되겠죠?)</li></ul><p>서버 측에서 하는 form validation은 꼭 필요하지만, 사용자가 자료를 서버에 전송해야만 데이터에 어떤 문제가 있는지를 알 수 있다는 단점이 있습니다. 사용자 입장에서는 실컷 폼을 다 작성해서 전송했더니 폼에 에러가 있다고 하며 중간 단계부터 다시 시작해야 하니 짜증이 날 것입니다. 아마 여러분도 비슷한 경험이 있을 것입니다.</p><p>서버 측 validation을 잘 구현해서 사용자가 덜 불편하게끔 만드는 방법도 있지만 폼을 서버에 전송해야 피드백을 받을 수 있다는 점은 변하지 않습니다. 더 나은 사용자 경험을 위해 클라이언트 측 validation을 하는 것을 고려해볼 수 있습니다.</p><p>클라이언트 측 validation은 사용자가 폼을 작성하는 도중에 피드백을 받을 수 있다는 점에서 서버 측 validation보다 훨씬 나은 사용자 경험을 제공할 수 있습니다. 대신 서버 측 코드에서 하는 데이터 검사 로직을 클라이언트 측 코드에도 중복 구현해야 한다는 어려운 점이 있습니다. 다행히 HTML5에 추가된 form validation 기능을 이용하면 간단한 validation은 자바스크립트 코드를 하나도 짜지 않고도 구현할 수 있습니다. HTML5 form validation을 시험해 보려면, index.ejs 파일의 title 필드에 required 속성을 추가해보세요.</p><p>HTML5 form validation은 사용하기 간편하고, 브라우저에 내장되어 있다는 점에서 (특히 모바일에서) 일관성있는 사용자 경험을 제공할 수 있다는 장점이 있습니다. 하지만 HTML5를 지원하지 않는 구형 브라우저에서는 사용할 수 없고, 또 복잡한 형태의 validation은 지원하지 않는다는 단점이 있습니다. (여러 필드의 자료를 합쳐서 validation을 한다거나, validation을 하기 위해 서버에 요청을 해야 하는 등)</p><p>주의! 클라이언트 측 validation을 하더라도 서버 측에서는 반드시 validation을 따로 해주어야 합니다. 사용자가 언제나 우리가 제공하는 클라이언트를 사용한다는 보장은 없기 때문입니다. (예를 들면 악의적인 해커가 Postman 등을 이용해 이상한 요청을 보낼 수도 있겠죠?)</p></li></ul><hr>"},{"title":"[node] URL shortner 만들기","date":"2017-08-30T08:08:01.000Z","_content":"\n![](http://allvectorlogo.com/img/2016/05/node-js-logo.png)\n\n\n# 프로젝트 세팅\n\n1) project folder 생성\n2) npm init\n3) git init\n3) .gitignore - node로 생성\n\n**node_modules는 깃 저장소에 넣지 않는 것이 원칙이다.**\n\nvscode의 gitignore 플러그인을 설치, cmd+shift+p -> add gitignore -> node를 선택하여 node_modules의 변경사항을 무시하는 gitignore를 생성할 수 있다.\n\n---\n\n#### node_modules를 깃에 올리지 않는 이유\n\n* git 저장소는 내 프로젝트의 코드를 관리하기 위한 곳이지 외부 패키지를 관리하기 위한 것이 아니다.\n\n* git 저장소의 용량이 커지고 git이 추적해야 할 파일이 많아지기 때문에 느려질 수 있다.\n\n---\n\n4) first commit\n\n5) git history\nvscode의 git History 플러그인을 설치하면 깃 로그를 볼 수 있다. cmd+shift+p -> git log -> 로그를 볼 브랜치 선택/ 실행\n\n6) npm install express --save\n\n7) server.js 생성\n\n단축키: `cmd+enter` 다음 줄로 이동!\n\n```js\nconst express = require('express')\nconst app = express()\n\napp.get('/', (req, res) => {\n  res.send('hello express')\n})\n\napp.listen(3000, () => {\n  console.log('listening');\n})\n```\n\n8) 서버 구동\n\n```bash\n$ node server.js\n```\n\n콘솔에 listening이라고 뜨면 로컬서버가 정상적으로 열린 것이다.\n웹 브라우저에서의 접속은 `localhost:3000` 으로 할 수 있다.\n\n`ctrl+c`를 누르면 서버가 종료된다.\n서버 재시작은 `ctrl+c` + `node server.js`\n\n하지만 프로젝트마다 서버 구동 명령어가 조금씩 달라질 수 있다. 보통 `npm start`를 서버 구동 명령어로 쓰는 것이 관례이다.\n\npackage.json을 열어 script를 아래와 같이 수정한다.\n\n```json\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"start\": \"node server.js\"\n  }\n```\n\n이제 `npm start`로 서버를 구동할 수 있다.\n\n9) ejs 추가\n\n```bash\n$ npm install ejs --save\n```\n\n아래 코드를 `app.get` 코드 위에 추가해준다.\n\n```js\n// server.js\napp.set('view engine', 'ejs')\n```\n\n10) views 폴더를 추가하고 폴더 안에 index.ejs 파일을 추가한다.\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>Document</title>\n</head>\n<body>\n  <h1>hello ejs</h1>\n</body>\n</html>\n```\n\n11) server.js 파일의 app.get 코드를 아래와 같이 수정한다.\n\n```js\napp.get('/', (req, res) => {\n  res.render('index.ejs')\n})\n```\n\n12) 서버를 구동하여 확인한다.\n\n```bash\n$ npm start\n```\n\n13) server.js 파일 app.set 다음 줄에 app.use 코드를 추가한다\n\n```js\napp.use('/static', express.static('public'))\n```\n\n14) 루트에 public 폴더를 생성하고 그 밑에 index.css를 생성하고 index.ejs의 head에 링크 태그를 추가해준다.\n\n```\n<프로젝트 폴더>\n|____public\n  |____index.css\n```\n\n```css\n/* index.css */\nbody {\n  background-color: skyblue;\n}\n```\n\n```html\n<link rel=\"stylesheet\" href=\"/static/index.css\">\n```\n\n15) 서버를 구동하여 확인한다.\n\n```bash\n$ npm start\n```\n\n<br>\n\n# 로깅과 인증\n\n## 1. morgan 설정\n\n1) 미들웨어 morgan 설치 후 server.js에 아래 코드를 삽입한다.\n\n```bash\n$ npm install --save morgan\n```\n\n```js\nconst morgan = require('morgan')\n\napp.use(morgan('tiny'))\n```\n\n지금까지의 전체 코드\n\n```js\n//server.js\n\nconst express = require('express')\nconst morgan = require('morgan')\n\nconst app = express()\n\n\napp.set('view engine', 'ejs')\napp.use('/static', express.static('public'))\napp.use(morgan('tiny'))\n\napp.get('/', (req, res) => {\n  res.render('index.ejs')\n})\n\napp.listen(3000, () => {\n  console.log('listening');\n})\n```\n\n셋팅이 완료된 후 server를 구동시키면 터미널에 아래와 같은 메시지가 뜨는 것을 확인할 수 있다.\n\n```\nGET / 200 322 - 11.862 ms\n```\n\n## 2. express-basic-auth 설정\n\n[npm-express-basic-auth](https://www.npmjs.com/package/express-basic-auth)에 접속하여 사용법을 확인한다.\n\n(1) basic-auth를 설치한다.\n\n```bash\n$ npm install express-basic-auth\n```\n\n(2) 설치한 패키지를 불러온다.\n\n```js\n//server.js\nvar app = require('express')()\nvar basicAuth = require('express-basic-auth')\n\napp.use(basicAuth({\n    users: { 'someuser': 'somepassword' },\n    challenge: true,\n    realm: 'Imb4T3st4pp'\n}))\n```\n\n위 코드에서 `var app = require('express')()`는 이미 하였으므로 그 아래부터 코드를 삽입해준다. someuser를 admin으로 somepassword도 admin으로 변경한다.\n\n서버 구동 후 localhost:3000으로 접속하면 로그인 화면이 뜨는데, ID: admin, Password: admin으로 로그인할 수 있다.\n\n\n# 초기 데이터 작업\n\n## 1. randomstring\n\n1) 데이터를 담을 배열 객체를 추가하고, app.get 코드를 수정한다.\n\n```js\n//server.js\nconst data = [\n  {longURL: 'http://google.com', id:'58DX37'}\n]\n\napp.get('/', (req, res) => {\n  res.render('index.ejs', {data})\n})\n```\n\n2) index.ejs의 body에 아래 소스를 추가한다.\n\n```js\n<table>\n    <thead>\n      <tr>\n        <td>Long URL</td>\n        <td>Short URL</td>\n      </tr>\n    </thead>\n    <tbody>\n      <% data.forEach(item => { %>\n      <tr>\n      <td><%= item.longURL %></td>\n      <td><%= item.id %></td>\n      </tr>\n      <% }) %> \n    </tbody>\n  </table>\n```\n\n서버 재구동 후 확인한다.\n\n```\nhello Express\n\nLong URL\tShort URL\nhttp://google.com\t58DX37\n```\n\n3) [randomstring](https://www.npmjs.com/package/randomstring) 패키지를 설치한다.\n\n```bash\n$ npm install --save randomstring\n```\n\n설치한 패키지 사용을 위해 randomstring 객체를 추가해주고, generate 메소드를 사용하여 id를 6자리 랜덤 스트링으로 생성한다.\n\n```js\n// server.js\nconst randomstring = require('randomstring')\n\nconst data = [\n  {longURL: 'http://google.com', id:randomstring.generate(6)}\n]\n```\n\n# 짧은 URL의 Redirection\n\n## 1. 라우터 핸들러 작성 (301 Moved Permanently)\n\n아래 코드를 `app.get('/', (req, res) ~~` 코드의 아래에 추가로 작성한다.\n\n```js\n// server.js\napp.get('/:id', (req, res) => {\n  const id = req.params.id\n  const matched = data.find(item => item.id === id)\n  if(matched) {\n    res.redirect(301, matched.longURL)\n  } else {\n    res.status(404)\n    res.send('404 Not Found')\n  }\n})\n```\n\n서버 구동 후 localhost:3000 뒤에 shorturl을 붙여 접속하면 (ex. localhost:3000/LL3L5c)longurl로 redirect되어 google.com으로 접속되는 것을 확인할 수 있다.\n\n2) html 수정\n\n```html\n<!-- index.ejs -->\n<td><a href=\"/<%= item.id%>\" target=\"_blank\"><%= item.id %></a></td>\n```\n\na태그로 감싸기 단축키: `cmd+shift+p -> wrap -> Emmet:wrap with Abbreviation`\n\n# 폼\n\n## [body-parser](https://www.npmjs.com/package/body-parser#examples)& 폼, 핸들러 작성  \n\n```bash\n$ npm install --save body-parser\n```\n\n```js\n// server.js\nconst bodyparser = require('body-parser')\n\napp.use(bodyParser.urlencoded({ extended: false }))\n```\n\n```html\n<!-- index.ejs -->\n<h1>hello Express</h1>\n  <form action=\"/\" method=\"post\">\n    <input type=\"url\" name=\"longURL\">\n    <input type=\"submit\" value=\"전송\">\n  </form>\n```\n\nform 전송을 받은 후 redirect시켜야 한다.\n\n```js\n// server.js\napp.post('/', (req, res) => {\n  const longURL = req.body.longURL\n  let id;\n\n  // id가 있으면 다시 만들고, 없으면 candidate를 저장하고 빠져나간다.\n  while(true){\n    // id가 될 후보\n    const candidate = randomstring.generate(6)\n    const matched = data.find(item => item.id === candidate)\n    //matched가 없으면, 잘 된 상황\n    if(!matched) {\n      id = candidate\n      break // 중복이 없는 아이디를 찾은 상황\n    }\n  }\n  data.push({id, longURL})\n  res.redirect('/')\n})\n```\n\n# \n\n현재는 로그인 인증을 app.use에 넣어뒀기 때문에, 로그인하지 않은 사용자는 짧은 url을 사용할 수 없다.\n\n```js\n// server.js\napp.use(basicAuth({\n  users: { 'admin': 'admin' },\n  challenge: true,\n  realm: 'Imb4T3st4pp'\n}))\n```\n\n위 코드를 아래와 같이 수정해준다.\n\n```js\nconst authMiddleware = basicAuth({\n  users: { 'admin': 'admin' },\n  challenge: true,\n  realm: 'Imb4T3st4pp'\n})\n```\n\nbody parser 미들웨어도 app.use에서 꺼내 따로 정의한다.\n\n```js\napp.use(bodyParser.urlencoded({ extended: false }))\n```\n\n위 코드를 아래처럼 바꾼다.\n\n```js\nconst bodyParserMiddleWare = bodyParser.urlencoded({ extended: false })\n```\n\n이제 분리한 미들웨어를 필요한 곳에만 주입할 수 있다.\n인증이 필요한 곳에만, 바디파서가 필요한 곳에만 넣을 수 있다.\n\n```js\nconst express = require('express')\nconst morgan = require('morgan')\nconst basicAuth = require('express-basic-auth')\nconst randomstring = require('randomstring')\nconst bodyParser = require('body-parser')\n\n\n// 실무에서는 데이터를 이렇게 관리하지 않는다.\n// 이렇게 만들어진 데이터는 메모리상에서 관리되는 것으로 새로고침시 사라지는 데이터이다.\nconst data = [\n  {longURL: 'http://google.com', id:randomstring.generate(6)}\n]\n\n// http://localhost:3000/58DX37\n// 302 응답\n\nconst app = express()\n\nconst authMiddleware = basicAuth({\n  users: { 'admin': 'admin' },\n  challenge: true,\n  realm: 'Imb4T3st4pp'\n})\n\nconst bodyParserMiddleWare = bodyParser.urlencoded({ extended: false })\n\napp.set('view engine', 'ejs')\napp.use('/static', express.static('public'))\napp.use(morgan('tiny'))\n\n\n\napp.get('/', authMiddleware, (req, res) => {\n  res.render('index.ejs', {data})\n})\n\napp.get('/:id', (req, res) => {\n  const id = req.params.id\n  const matched = data.find(item => item.id === id)\n  if(matched) {\n    res.redirect(301, matched.longURL)\n  } else {\n    res.status(404)\n    res.send('404 Not Found')\n  }\n})\n\napp.post('/', bodyParserMiddleWare, authMiddleware, (req, res) => {\n  const longURL = req.body.longURL\n  let id;\n\n  // id가 있으면 다시 만들고, 없으면 candidate를 저장하고 빠져나간다.\n  while(true){\n    // id가 될 후보\n    const candidate = randomstring.generate(6)\n    const matched = data.find(item => item.id === candidate)\n    //matched가 없으면, 잘 된 상황\n    if(!matched) {\n      id = candidate\n      break\n    }\n  }\n  data.push({id, longURL})\n  res.redirect('/')\n})\n\napp.listen(3000, () => {\n  console.log('listening');\n})\n```\n\n# 배포\n\n[now.sh](https://zeit.co/now)를 이용해 배포한다.\n\nnow를 글로벌로 설치한다.\n\n```bash\n$ npm install -g now\n$ now\n-> enter email: 이메일을 입력한다.\n-> 받은 메일의 링크로 접속하여 인증한다.\n\n$ now\n-> y 하고 enter\n```\n\nnow URL을 통해 배포가 완료되며 해당 url로 접속할 수 있다.\n[urlshortner](https://urlshortner-budejegbvb.now.sh)\n\n이렇게 배포된 서비스는 소스코드가 모두 공개되기 때문에 관리자 아이디와 비밀번호를 외부에서 열람하는 것이 가능하다. 따라서 개인정보는 밖으로 노출되지 않도록 않도록 해야한다.\n\n---\n","source":"_posts/nodejs/06.service development.md","raw":"---\ntitle: '[node] URL shortner 만들기'\ndate: 2017-08-30 17:08:01\ncategory: Nodejs\ntags: urlshortner\n---\n\n![](http://allvectorlogo.com/img/2016/05/node-js-logo.png)\n\n\n# 프로젝트 세팅\n\n1) project folder 생성\n2) npm init\n3) git init\n3) .gitignore - node로 생성\n\n**node_modules는 깃 저장소에 넣지 않는 것이 원칙이다.**\n\nvscode의 gitignore 플러그인을 설치, cmd+shift+p -> add gitignore -> node를 선택하여 node_modules의 변경사항을 무시하는 gitignore를 생성할 수 있다.\n\n---\n\n#### node_modules를 깃에 올리지 않는 이유\n\n* git 저장소는 내 프로젝트의 코드를 관리하기 위한 곳이지 외부 패키지를 관리하기 위한 것이 아니다.\n\n* git 저장소의 용량이 커지고 git이 추적해야 할 파일이 많아지기 때문에 느려질 수 있다.\n\n---\n\n4) first commit\n\n5) git history\nvscode의 git History 플러그인을 설치하면 깃 로그를 볼 수 있다. cmd+shift+p -> git log -> 로그를 볼 브랜치 선택/ 실행\n\n6) npm install express --save\n\n7) server.js 생성\n\n단축키: `cmd+enter` 다음 줄로 이동!\n\n```js\nconst express = require('express')\nconst app = express()\n\napp.get('/', (req, res) => {\n  res.send('hello express')\n})\n\napp.listen(3000, () => {\n  console.log('listening');\n})\n```\n\n8) 서버 구동\n\n```bash\n$ node server.js\n```\n\n콘솔에 listening이라고 뜨면 로컬서버가 정상적으로 열린 것이다.\n웹 브라우저에서의 접속은 `localhost:3000` 으로 할 수 있다.\n\n`ctrl+c`를 누르면 서버가 종료된다.\n서버 재시작은 `ctrl+c` + `node server.js`\n\n하지만 프로젝트마다 서버 구동 명령어가 조금씩 달라질 수 있다. 보통 `npm start`를 서버 구동 명령어로 쓰는 것이 관례이다.\n\npackage.json을 열어 script를 아래와 같이 수정한다.\n\n```json\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"start\": \"node server.js\"\n  }\n```\n\n이제 `npm start`로 서버를 구동할 수 있다.\n\n9) ejs 추가\n\n```bash\n$ npm install ejs --save\n```\n\n아래 코드를 `app.get` 코드 위에 추가해준다.\n\n```js\n// server.js\napp.set('view engine', 'ejs')\n```\n\n10) views 폴더를 추가하고 폴더 안에 index.ejs 파일을 추가한다.\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>Document</title>\n</head>\n<body>\n  <h1>hello ejs</h1>\n</body>\n</html>\n```\n\n11) server.js 파일의 app.get 코드를 아래와 같이 수정한다.\n\n```js\napp.get('/', (req, res) => {\n  res.render('index.ejs')\n})\n```\n\n12) 서버를 구동하여 확인한다.\n\n```bash\n$ npm start\n```\n\n13) server.js 파일 app.set 다음 줄에 app.use 코드를 추가한다\n\n```js\napp.use('/static', express.static('public'))\n```\n\n14) 루트에 public 폴더를 생성하고 그 밑에 index.css를 생성하고 index.ejs의 head에 링크 태그를 추가해준다.\n\n```\n<프로젝트 폴더>\n|____public\n  |____index.css\n```\n\n```css\n/* index.css */\nbody {\n  background-color: skyblue;\n}\n```\n\n```html\n<link rel=\"stylesheet\" href=\"/static/index.css\">\n```\n\n15) 서버를 구동하여 확인한다.\n\n```bash\n$ npm start\n```\n\n<br>\n\n# 로깅과 인증\n\n## 1. morgan 설정\n\n1) 미들웨어 morgan 설치 후 server.js에 아래 코드를 삽입한다.\n\n```bash\n$ npm install --save morgan\n```\n\n```js\nconst morgan = require('morgan')\n\napp.use(morgan('tiny'))\n```\n\n지금까지의 전체 코드\n\n```js\n//server.js\n\nconst express = require('express')\nconst morgan = require('morgan')\n\nconst app = express()\n\n\napp.set('view engine', 'ejs')\napp.use('/static', express.static('public'))\napp.use(morgan('tiny'))\n\napp.get('/', (req, res) => {\n  res.render('index.ejs')\n})\n\napp.listen(3000, () => {\n  console.log('listening');\n})\n```\n\n셋팅이 완료된 후 server를 구동시키면 터미널에 아래와 같은 메시지가 뜨는 것을 확인할 수 있다.\n\n```\nGET / 200 322 - 11.862 ms\n```\n\n## 2. express-basic-auth 설정\n\n[npm-express-basic-auth](https://www.npmjs.com/package/express-basic-auth)에 접속하여 사용법을 확인한다.\n\n(1) basic-auth를 설치한다.\n\n```bash\n$ npm install express-basic-auth\n```\n\n(2) 설치한 패키지를 불러온다.\n\n```js\n//server.js\nvar app = require('express')()\nvar basicAuth = require('express-basic-auth')\n\napp.use(basicAuth({\n    users: { 'someuser': 'somepassword' },\n    challenge: true,\n    realm: 'Imb4T3st4pp'\n}))\n```\n\n위 코드에서 `var app = require('express')()`는 이미 하였으므로 그 아래부터 코드를 삽입해준다. someuser를 admin으로 somepassword도 admin으로 변경한다.\n\n서버 구동 후 localhost:3000으로 접속하면 로그인 화면이 뜨는데, ID: admin, Password: admin으로 로그인할 수 있다.\n\n\n# 초기 데이터 작업\n\n## 1. randomstring\n\n1) 데이터를 담을 배열 객체를 추가하고, app.get 코드를 수정한다.\n\n```js\n//server.js\nconst data = [\n  {longURL: 'http://google.com', id:'58DX37'}\n]\n\napp.get('/', (req, res) => {\n  res.render('index.ejs', {data})\n})\n```\n\n2) index.ejs의 body에 아래 소스를 추가한다.\n\n```js\n<table>\n    <thead>\n      <tr>\n        <td>Long URL</td>\n        <td>Short URL</td>\n      </tr>\n    </thead>\n    <tbody>\n      <% data.forEach(item => { %>\n      <tr>\n      <td><%= item.longURL %></td>\n      <td><%= item.id %></td>\n      </tr>\n      <% }) %> \n    </tbody>\n  </table>\n```\n\n서버 재구동 후 확인한다.\n\n```\nhello Express\n\nLong URL\tShort URL\nhttp://google.com\t58DX37\n```\n\n3) [randomstring](https://www.npmjs.com/package/randomstring) 패키지를 설치한다.\n\n```bash\n$ npm install --save randomstring\n```\n\n설치한 패키지 사용을 위해 randomstring 객체를 추가해주고, generate 메소드를 사용하여 id를 6자리 랜덤 스트링으로 생성한다.\n\n```js\n// server.js\nconst randomstring = require('randomstring')\n\nconst data = [\n  {longURL: 'http://google.com', id:randomstring.generate(6)}\n]\n```\n\n# 짧은 URL의 Redirection\n\n## 1. 라우터 핸들러 작성 (301 Moved Permanently)\n\n아래 코드를 `app.get('/', (req, res) ~~` 코드의 아래에 추가로 작성한다.\n\n```js\n// server.js\napp.get('/:id', (req, res) => {\n  const id = req.params.id\n  const matched = data.find(item => item.id === id)\n  if(matched) {\n    res.redirect(301, matched.longURL)\n  } else {\n    res.status(404)\n    res.send('404 Not Found')\n  }\n})\n```\n\n서버 구동 후 localhost:3000 뒤에 shorturl을 붙여 접속하면 (ex. localhost:3000/LL3L5c)longurl로 redirect되어 google.com으로 접속되는 것을 확인할 수 있다.\n\n2) html 수정\n\n```html\n<!-- index.ejs -->\n<td><a href=\"/<%= item.id%>\" target=\"_blank\"><%= item.id %></a></td>\n```\n\na태그로 감싸기 단축키: `cmd+shift+p -> wrap -> Emmet:wrap with Abbreviation`\n\n# 폼\n\n## [body-parser](https://www.npmjs.com/package/body-parser#examples)& 폼, 핸들러 작성  \n\n```bash\n$ npm install --save body-parser\n```\n\n```js\n// server.js\nconst bodyparser = require('body-parser')\n\napp.use(bodyParser.urlencoded({ extended: false }))\n```\n\n```html\n<!-- index.ejs -->\n<h1>hello Express</h1>\n  <form action=\"/\" method=\"post\">\n    <input type=\"url\" name=\"longURL\">\n    <input type=\"submit\" value=\"전송\">\n  </form>\n```\n\nform 전송을 받은 후 redirect시켜야 한다.\n\n```js\n// server.js\napp.post('/', (req, res) => {\n  const longURL = req.body.longURL\n  let id;\n\n  // id가 있으면 다시 만들고, 없으면 candidate를 저장하고 빠져나간다.\n  while(true){\n    // id가 될 후보\n    const candidate = randomstring.generate(6)\n    const matched = data.find(item => item.id === candidate)\n    //matched가 없으면, 잘 된 상황\n    if(!matched) {\n      id = candidate\n      break // 중복이 없는 아이디를 찾은 상황\n    }\n  }\n  data.push({id, longURL})\n  res.redirect('/')\n})\n```\n\n# \n\n현재는 로그인 인증을 app.use에 넣어뒀기 때문에, 로그인하지 않은 사용자는 짧은 url을 사용할 수 없다.\n\n```js\n// server.js\napp.use(basicAuth({\n  users: { 'admin': 'admin' },\n  challenge: true,\n  realm: 'Imb4T3st4pp'\n}))\n```\n\n위 코드를 아래와 같이 수정해준다.\n\n```js\nconst authMiddleware = basicAuth({\n  users: { 'admin': 'admin' },\n  challenge: true,\n  realm: 'Imb4T3st4pp'\n})\n```\n\nbody parser 미들웨어도 app.use에서 꺼내 따로 정의한다.\n\n```js\napp.use(bodyParser.urlencoded({ extended: false }))\n```\n\n위 코드를 아래처럼 바꾼다.\n\n```js\nconst bodyParserMiddleWare = bodyParser.urlencoded({ extended: false })\n```\n\n이제 분리한 미들웨어를 필요한 곳에만 주입할 수 있다.\n인증이 필요한 곳에만, 바디파서가 필요한 곳에만 넣을 수 있다.\n\n```js\nconst express = require('express')\nconst morgan = require('morgan')\nconst basicAuth = require('express-basic-auth')\nconst randomstring = require('randomstring')\nconst bodyParser = require('body-parser')\n\n\n// 실무에서는 데이터를 이렇게 관리하지 않는다.\n// 이렇게 만들어진 데이터는 메모리상에서 관리되는 것으로 새로고침시 사라지는 데이터이다.\nconst data = [\n  {longURL: 'http://google.com', id:randomstring.generate(6)}\n]\n\n// http://localhost:3000/58DX37\n// 302 응답\n\nconst app = express()\n\nconst authMiddleware = basicAuth({\n  users: { 'admin': 'admin' },\n  challenge: true,\n  realm: 'Imb4T3st4pp'\n})\n\nconst bodyParserMiddleWare = bodyParser.urlencoded({ extended: false })\n\napp.set('view engine', 'ejs')\napp.use('/static', express.static('public'))\napp.use(morgan('tiny'))\n\n\n\napp.get('/', authMiddleware, (req, res) => {\n  res.render('index.ejs', {data})\n})\n\napp.get('/:id', (req, res) => {\n  const id = req.params.id\n  const matched = data.find(item => item.id === id)\n  if(matched) {\n    res.redirect(301, matched.longURL)\n  } else {\n    res.status(404)\n    res.send('404 Not Found')\n  }\n})\n\napp.post('/', bodyParserMiddleWare, authMiddleware, (req, res) => {\n  const longURL = req.body.longURL\n  let id;\n\n  // id가 있으면 다시 만들고, 없으면 candidate를 저장하고 빠져나간다.\n  while(true){\n    // id가 될 후보\n    const candidate = randomstring.generate(6)\n    const matched = data.find(item => item.id === candidate)\n    //matched가 없으면, 잘 된 상황\n    if(!matched) {\n      id = candidate\n      break\n    }\n  }\n  data.push({id, longURL})\n  res.redirect('/')\n})\n\napp.listen(3000, () => {\n  console.log('listening');\n})\n```\n\n# 배포\n\n[now.sh](https://zeit.co/now)를 이용해 배포한다.\n\nnow를 글로벌로 설치한다.\n\n```bash\n$ npm install -g now\n$ now\n-> enter email: 이메일을 입력한다.\n-> 받은 메일의 링크로 접속하여 인증한다.\n\n$ now\n-> y 하고 enter\n```\n\nnow URL을 통해 배포가 완료되며 해당 url로 접속할 수 있다.\n[urlshortner](https://urlshortner-budejegbvb.now.sh)\n\n이렇게 배포된 서비스는 소스코드가 모두 공개되기 때문에 관리자 아이디와 비밀번호를 외부에서 열람하는 것이 가능하다. 따라서 개인정보는 밖으로 노출되지 않도록 않도록 해야한다.\n\n---\n","slug":"nodejs/06.service development","published":1,"updated":"2017-09-21T06:06:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjai8h18k001bvb9q2o34f5wq","content":"<p><img src=\"http://allvectorlogo.com/img/2016/05/node-js-logo.png\" alt=\"\"></p><h1 id=\"프로젝트-세팅\"><a href=\"#프로젝트-세팅\" class=\"headerlink\" title=\"프로젝트 세팅\"></a>프로젝트 세팅</h1><p>1) project folder 생성<br>2) npm init<br>3) git init<br>3) .gitignore - node로 생성</p><p><strong>node_modules는 깃 저장소에 넣지 않는 것이 원칙이다.</strong></p><p>vscode의 gitignore 플러그인을 설치, cmd+shift+p -&gt; add gitignore -&gt; node를 선택하여 node_modules의 변경사항을 무시하는 gitignore를 생성할 수 있다.</p><hr><h4 id=\"node-modules를-깃에-올리지-않는-이유\"><a href=\"#node-modules를-깃에-올리지-않는-이유\" class=\"headerlink\" title=\"node_modules를 깃에 올리지 않는 이유\"></a>node_modules를 깃에 올리지 않는 이유</h4><ul><li><p>git 저장소는 내 프로젝트의 코드를 관리하기 위한 곳이지 외부 패키지를 관리하기 위한 것이 아니다.</p></li><li><p>git 저장소의 용량이 커지고 git이 추적해야 할 파일이 많아지기 때문에 느려질 수 있다.</p></li></ul><hr><p>4) first commit</p><p>5) git history<br>vscode의 git History 플러그인을 설치하면 깃 로그를 볼 수 있다. cmd+shift+p -&gt; git log -&gt; 로그를 볼 브랜치 선택/ 실행</p><p>6) npm install express –save</p><p>7) server.js 생성</p><p>단축키: <code>cmd+enter</code> 다음 줄로 이동!</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> app = express()</div><div class=\"line\"></div><div class=\"line\">app.get(<span class=\"string\">'/'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  res.send(<span class=\"string\">'hello express'</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">app.listen(<span class=\"number\">3000</span>, () =&gt; &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'listening'</span>);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p>8) 서버 구동</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ node server.js</div></pre></td></tr></table></figure><p>콘솔에 listening이라고 뜨면 로컬서버가 정상적으로 열린 것이다.<br>웹 브라우저에서의 접속은 <code>localhost:3000</code> 으로 할 수 있다.</p><p><code>ctrl+c</code>를 누르면 서버가 종료된다.<br>서버 재시작은 <code>ctrl+c</code> + <code>node server.js</code></p><p>하지만 프로젝트마다 서버 구동 명령어가 조금씩 달라질 수 있다. 보통 <code>npm start</code>를 서버 구동 명령어로 쓰는 것이 관례이다.</p><p>package.json을 열어 script를 아래와 같이 수정한다.</p><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">\"scripts\": &#123;</div><div class=\"line\">  \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\",</div><div class=\"line\">  \"start\": \"node server.js\"</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>이제 <code>npm start</code>로 서버를 구동할 수 있다.</p><p>9) ejs 추가</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install ejs --save</div></pre></td></tr></table></figure><p>아래 코드를 <code>app.get</code> 코드 위에 추가해준다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// server.js</span></div><div class=\"line\">app.set(<span class=\"string\">'view engine'</span>, <span class=\"string\">'ejs'</span>)</div></pre></td></tr></table></figure><p>10) views 폴더를 추가하고 폴더 안에 index.ejs 파일을 추가한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html lang=<span class=\"string\">\"en\"</span>&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">  &lt;meta charset=<span class=\"string\">\"UTF-8\"</span>&gt;</div><div class=\"line\">  &lt;meta name=<span class=\"string\">\"viewport\"</span> content=<span class=\"string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</div><div class=\"line\">  &lt;meta http-equiv=<span class=\"string\">\"X-UA-Compatible\"</span> content=<span class=\"string\">\"ie=edge\"</span>&gt;</div><div class=\"line\">  &lt;title&gt;Document&lt;<span class=\"regexp\">/title&gt;</span></div><div class=\"line\"><span class=\"regexp\">&lt;/</span>head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">  &lt;h1&gt;hello ejs&lt;<span class=\"regexp\">/h1&gt;</span></div><div class=\"line\"><span class=\"regexp\">&lt;/</span>body&gt;</div><div class=\"line\">&lt;<span class=\"regexp\">/html&gt;</span></div></pre></td></tr></table></figure><p>11) server.js 파일의 app.get 코드를 아래와 같이 수정한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.get(<span class=\"string\">'/'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  res.render(<span class=\"string\">'index.ejs'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p>12) 서버를 구동하여 확인한다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm start</div></pre></td></tr></table></figure><p>13) server.js 파일 app.set 다음 줄에 app.use 코드를 추가한다</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.use(<span class=\"string\">'/static'</span>, express.static(<span class=\"string\">'public'</span>))</div></pre></td></tr></table></figure><p>14) 루트에 public 폴더를 생성하고 그 밑에 index.css를 생성하고 index.ejs의 head에 링크 태그를 추가해준다.</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;프로젝트 폴더&gt;</div><div class=\"line\">|____public</div><div class=\"line\">  |____index.css</div></pre></td></tr></table></figure><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* index.css */</span></div><div class=\"line\"><span class=\"selector-tag\">body</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">background-color</span>: skyblue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/static/index.css\"</span>&gt;</span></div></pre></td></tr></table></figure><p>15) 서버를 구동하여 확인한다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm start</div></pre></td></tr></table></figure><p><br></p><h1 id=\"로깅과-인증\"><a href=\"#로깅과-인증\" class=\"headerlink\" title=\"로깅과 인증\"></a>로깅과 인증</h1><h2 id=\"1-morgan-설정\"><a href=\"#1-morgan-설정\" class=\"headerlink\" title=\"1. morgan 설정\"></a>1. morgan 설정</h2><p>1) 미들웨어 morgan 설치 후 server.js에 아래 코드를 삽입한다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install --save morgan</div></pre></td></tr></table></figure><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> morgan = <span class=\"built_in\">require</span>(<span class=\"string\">'morgan'</span>)</div><div class=\"line\"></div><div class=\"line\">app.use(morgan(<span class=\"string\">'tiny'</span>))</div></pre></td></tr></table></figure><p>지금까지의 전체 코드</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//server.js</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> morgan = <span class=\"built_in\">require</span>(<span class=\"string\">'morgan'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> app = express()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">app.set(<span class=\"string\">'view engine'</span>, <span class=\"string\">'ejs'</span>)</div><div class=\"line\">app.use(<span class=\"string\">'/static'</span>, express.static(<span class=\"string\">'public'</span>))</div><div class=\"line\">app.use(morgan(<span class=\"string\">'tiny'</span>))</div><div class=\"line\"></div><div class=\"line\">app.get(<span class=\"string\">'/'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  res.render(<span class=\"string\">'index.ejs'</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">app.listen(<span class=\"number\">3000</span>, () =&gt; &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'listening'</span>);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p>셋팅이 완료된 후 server를 구동시키면 터미널에 아래와 같은 메시지가 뜨는 것을 확인할 수 있다.</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">GET / 200 322 - 11.862 ms</div></pre></td></tr></table></figure><h2 id=\"2-express-basic-auth-설정\"><a href=\"#2-express-basic-auth-설정\" class=\"headerlink\" title=\"2. express-basic-auth 설정\"></a>2. express-basic-auth 설정</h2><p><a href=\"https://www.npmjs.com/package/express-basic-auth\" target=\"_blank\" rel=\"external\">npm-express-basic-auth</a>에 접속하여 사용법을 확인한다.</p><p>(1) basic-auth를 설치한다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install express-basic-auth</div></pre></td></tr></table></figure><p>(2) 설치한 패키지를 불러온다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//server.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)()</div><div class=\"line\"><span class=\"keyword\">var</span> basicAuth = <span class=\"built_in\">require</span>(<span class=\"string\">'express-basic-auth'</span>)</div><div class=\"line\"></div><div class=\"line\">app.use(basicAuth(&#123;</div><div class=\"line\">    users: &#123; <span class=\"string\">'someuser'</span>: <span class=\"string\">'somepassword'</span> &#125;,</div><div class=\"line\">    challenge: <span class=\"literal\">true</span>,</div><div class=\"line\">    realm: <span class=\"string\">'Imb4T3st4pp'</span></div><div class=\"line\">&#125;))</div></pre></td></tr></table></figure><p>위 코드에서 <code>var app = require(&#39;express&#39;)()</code>는 이미 하였으므로 그 아래부터 코드를 삽입해준다. someuser를 admin으로 somepassword도 admin으로 변경한다.</p><p>서버 구동 후 localhost:3000으로 접속하면 로그인 화면이 뜨는데, ID: admin, Password: admin으로 로그인할 수 있다.</p><h1 id=\"초기-데이터-작업\"><a href=\"#초기-데이터-작업\" class=\"headerlink\" title=\"초기 데이터 작업\"></a>초기 데이터 작업</h1><h2 id=\"1-randomstring\"><a href=\"#1-randomstring\" class=\"headerlink\" title=\"1. randomstring\"></a>1. randomstring</h2><p>1) 데이터를 담을 배열 객체를 추가하고, app.get 코드를 수정한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//server.js</span></div><div class=\"line\"><span class=\"keyword\">const</span> data = [</div><div class=\"line\">  &#123;<span class=\"attr\">longURL</span>: <span class=\"string\">'http://google.com'</span>, <span class=\"attr\">id</span>:<span class=\"string\">'58DX37'</span>&#125;</div><div class=\"line\">]</div><div class=\"line\"></div><div class=\"line\">app.get(<span class=\"string\">'/'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  res.render(<span class=\"string\">'index.ejs'</span>, &#123;data&#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p>2) index.ejs의 body에 아래 소스를 추가한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;table&gt;</div><div class=\"line\">    &lt;thead&gt;</div><div class=\"line\">      &lt;tr&gt;</div><div class=\"line\">        &lt;td&gt;Long URL&lt;<span class=\"regexp\">/td&gt;</span></div><div class=\"line\"><span class=\"regexp\">        &lt;td&gt;Short URL&lt;/</span>td&gt;</div><div class=\"line\">      &lt;<span class=\"regexp\">/tr&gt;</span></div><div class=\"line\"><span class=\"regexp\">    &lt;/</span>thead&gt;</div><div class=\"line\">    &lt;tbody&gt;</div><div class=\"line\">      &lt;% data.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123; %&gt;</div><div class=\"line\">      &lt;tr&gt;</div><div class=\"line\">      &lt;td&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">item.longURL</span> %&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span></div><div class=\"line\">      &lt;td&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">item.id</span> %&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span></div><div class=\"line\">      &lt;<span class=\"regexp\">/tr&gt;</span></div><div class=\"line\"><span class=\"regexp\">      &lt;% &#125;) %&gt; </span></div><div class=\"line\"><span class=\"regexp\">    &lt;/</span>tbody&gt;</div><div class=\"line\">  &lt;<span class=\"regexp\">/table&gt;</span></div></pre></td></tr></table></figure><p>서버 재구동 후 확인한다.</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">hello Express</div><div class=\"line\"></div><div class=\"line\">Long URL\tShort URL</div><div class=\"line\">http://google.com\t58DX37</div></pre></td></tr></table></figure><p>3) <a href=\"https://www.npmjs.com/package/randomstring\" target=\"_blank\" rel=\"external\">randomstring</a> 패키지를 설치한다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install --save randomstring</div></pre></td></tr></table></figure><p>설치한 패키지 사용을 위해 randomstring 객체를 추가해주고, generate 메소드를 사용하여 id를 6자리 랜덤 스트링으로 생성한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// server.js</span></div><div class=\"line\"><span class=\"keyword\">const</span> randomstring = <span class=\"built_in\">require</span>(<span class=\"string\">'randomstring'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> data = [</div><div class=\"line\">  &#123;<span class=\"attr\">longURL</span>: <span class=\"string\">'http://google.com'</span>, <span class=\"attr\">id</span>:randomstring.generate(<span class=\"number\">6</span>)&#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure><h1 id=\"짧은-URL의-Redirection\"><a href=\"#짧은-URL의-Redirection\" class=\"headerlink\" title=\"짧은 URL의 Redirection\"></a>짧은 URL의 Redirection</h1><h2 id=\"1-라우터-핸들러-작성-301-Moved-Permanently\"><a href=\"#1-라우터-핸들러-작성-301-Moved-Permanently\" class=\"headerlink\" title=\"1. 라우터 핸들러 작성 (301 Moved Permanently)\"></a>1. 라우터 핸들러 작성 (301 Moved Permanently)</h2><p>아래 코드를 <code>app.get(&#39;/&#39;, (req, res) ~~</code> 코드의 아래에 추가로 작성한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// server.js</span></div><div class=\"line\">app.get(<span class=\"string\">'/:id'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> id = req.params.id</div><div class=\"line\">  <span class=\"keyword\">const</span> matched = data.find(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item.id === id)</div><div class=\"line\">  <span class=\"keyword\">if</span>(matched) &#123;</div><div class=\"line\">    res.redirect(<span class=\"number\">301</span>, matched.longURL)</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    res.status(<span class=\"number\">404</span>)</div><div class=\"line\">    res.send(<span class=\"string\">'404 Not Found'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p>서버 구동 후 localhost:3000 뒤에 shorturl을 붙여 접속하면 (ex. localhost:3000/LL3L5c)longurl로 redirect되어 google.com으로 접속되는 것을 확인할 수 있다.</p><p>2) html 수정</p><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- index.ejs --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/&lt;%= item.id%&gt;\"</span> <span class=\"attr\">target</span>=<span class=\"string\">\"_blank\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">item.id</span> %&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div></pre></td></tr></table></figure><p>a태그로 감싸기 단축키: <code>cmd+shift+p -&gt; wrap -&gt; Emmet:wrap with Abbreviation</code></p><h1 id=\"폼\"><a href=\"#폼\" class=\"headerlink\" title=\"폼\"></a>폼</h1><h2 id=\"body-parser-amp-폼-핸들러-작성\"><a href=\"#body-parser-amp-폼-핸들러-작성\" class=\"headerlink\" title=\"body-parser&amp; 폼, 핸들러 작성\"></a><a href=\"https://www.npmjs.com/package/body-parser#examples\" target=\"_blank\" rel=\"external\">body-parser</a>&amp; 폼, 핸들러 작성</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install --save body-parser</div></pre></td></tr></table></figure><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// server.js</span></div><div class=\"line\"><span class=\"keyword\">const</span> bodyparser = <span class=\"built_in\">require</span>(<span class=\"string\">'body-parser'</span>)</div><div class=\"line\"></div><div class=\"line\">app.use(bodyParser.urlencoded(&#123; <span class=\"attr\">extended</span>: <span class=\"literal\">false</span> &#125;))</div></pre></td></tr></table></figure><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- index.ejs --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>hello Express<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"/\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"post\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"url\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"longURL\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"전송\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div></pre></td></tr></table></figure><p>form 전송을 받은 후 redirect시켜야 한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// server.js</span></div><div class=\"line\">app.post(<span class=\"string\">'/'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> longURL = req.body.longURL</div><div class=\"line\">  <span class=\"keyword\">let</span> id;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// id가 있으면 다시 만들고, 없으면 candidate를 저장하고 빠져나간다.</span></div><div class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</div><div class=\"line\">    <span class=\"comment\">// id가 될 후보</span></div><div class=\"line\">    <span class=\"keyword\">const</span> candidate = randomstring.generate(<span class=\"number\">6</span>)</div><div class=\"line\">    <span class=\"keyword\">const</span> matched = data.find(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item.id === candidate)</div><div class=\"line\">    <span class=\"comment\">//matched가 없으면, 잘 된 상황</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(!matched) &#123;</div><div class=\"line\">      id = candidate</div><div class=\"line\">      <span class=\"keyword\">break</span> <span class=\"comment\">// 중복이 없는 아이디를 찾은 상황</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  data.push(&#123;id, longURL&#125;)</div><div class=\"line\">  res.redirect(<span class=\"string\">'/'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p>#</p><p>현재는 로그인 인증을 app.use에 넣어뒀기 때문에, 로그인하지 않은 사용자는 짧은 url을 사용할 수 없다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// server.js</span></div><div class=\"line\">app.use(basicAuth(&#123;</div><div class=\"line\">  users: &#123; <span class=\"string\">'admin'</span>: <span class=\"string\">'admin'</span> &#125;,</div><div class=\"line\">  challenge: <span class=\"literal\">true</span>,</div><div class=\"line\">  realm: <span class=\"string\">'Imb4T3st4pp'</span></div><div class=\"line\">&#125;))</div></pre></td></tr></table></figure><p>위 코드를 아래와 같이 수정해준다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> authMiddleware = basicAuth(&#123;</div><div class=\"line\">  users: &#123; <span class=\"string\">'admin'</span>: <span class=\"string\">'admin'</span> &#125;,</div><div class=\"line\">  challenge: <span class=\"literal\">true</span>,</div><div class=\"line\">  realm: <span class=\"string\">'Imb4T3st4pp'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p>body parser 미들웨어도 app.use에서 꺼내 따로 정의한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.use(bodyParser.urlencoded(&#123; <span class=\"attr\">extended</span>: <span class=\"literal\">false</span> &#125;))</div></pre></td></tr></table></figure><p>위 코드를 아래처럼 바꾼다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> bodyParserMiddleWare = bodyParser.urlencoded(&#123; <span class=\"attr\">extended</span>: <span class=\"literal\">false</span> &#125;)</div></pre></td></tr></table></figure><p>이제 분리한 미들웨어를 필요한 곳에만 주입할 수 있다.<br>인증이 필요한 곳에만, 바디파서가 필요한 곳에만 넣을 수 있다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> morgan = <span class=\"built_in\">require</span>(<span class=\"string\">'morgan'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> basicAuth = <span class=\"built_in\">require</span>(<span class=\"string\">'express-basic-auth'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> randomstring = <span class=\"built_in\">require</span>(<span class=\"string\">'randomstring'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> bodyParser = <span class=\"built_in\">require</span>(<span class=\"string\">'body-parser'</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 실무에서는 데이터를 이렇게 관리하지 않는다.</span></div><div class=\"line\"><span class=\"comment\">// 이렇게 만들어진 데이터는 메모리상에서 관리되는 것으로 새로고침시 사라지는 데이터이다.</span></div><div class=\"line\"><span class=\"keyword\">const</span> data = [</div><div class=\"line\">  &#123;<span class=\"attr\">longURL</span>: <span class=\"string\">'http://google.com'</span>, <span class=\"attr\">id</span>:randomstring.generate(<span class=\"number\">6</span>)&#125;</div><div class=\"line\">]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// http://localhost:3000/58DX37</span></div><div class=\"line\"><span class=\"comment\">// 302 응답</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> app = express()</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> authMiddleware = basicAuth(&#123;</div><div class=\"line\">  users: &#123; <span class=\"string\">'admin'</span>: <span class=\"string\">'admin'</span> &#125;,</div><div class=\"line\">  challenge: <span class=\"literal\">true</span>,</div><div class=\"line\">  realm: <span class=\"string\">'Imb4T3st4pp'</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> bodyParserMiddleWare = bodyParser.urlencoded(&#123; <span class=\"attr\">extended</span>: <span class=\"literal\">false</span> &#125;)</div><div class=\"line\"></div><div class=\"line\">app.set(<span class=\"string\">'view engine'</span>, <span class=\"string\">'ejs'</span>)</div><div class=\"line\">app.use(<span class=\"string\">'/static'</span>, express.static(<span class=\"string\">'public'</span>))</div><div class=\"line\">app.use(morgan(<span class=\"string\">'tiny'</span>))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">app.get(<span class=\"string\">'/'</span>, authMiddleware, (req, res) =&gt; &#123;</div><div class=\"line\">  res.render(<span class=\"string\">'index.ejs'</span>, &#123;data&#125;)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">app.get(<span class=\"string\">'/:id'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> id = req.params.id</div><div class=\"line\">  <span class=\"keyword\">const</span> matched = data.find(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item.id === id)</div><div class=\"line\">  <span class=\"keyword\">if</span>(matched) &#123;</div><div class=\"line\">    res.redirect(<span class=\"number\">301</span>, matched.longURL)</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    res.status(<span class=\"number\">404</span>)</div><div class=\"line\">    res.send(<span class=\"string\">'404 Not Found'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">app.post(<span class=\"string\">'/'</span>, bodyParserMiddleWare, authMiddleware, (req, res) =&gt; &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> longURL = req.body.longURL</div><div class=\"line\">  <span class=\"keyword\">let</span> id;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// id가 있으면 다시 만들고, 없으면 candidate를 저장하고 빠져나간다.</span></div><div class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</div><div class=\"line\">    <span class=\"comment\">// id가 될 후보</span></div><div class=\"line\">    <span class=\"keyword\">const</span> candidate = randomstring.generate(<span class=\"number\">6</span>)</div><div class=\"line\">    <span class=\"keyword\">const</span> matched = data.find(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item.id === candidate)</div><div class=\"line\">    <span class=\"comment\">//matched가 없으면, 잘 된 상황</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(!matched) &#123;</div><div class=\"line\">      id = candidate</div><div class=\"line\">      <span class=\"keyword\">break</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  data.push(&#123;id, longURL&#125;)</div><div class=\"line\">  res.redirect(<span class=\"string\">'/'</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">app.listen(<span class=\"number\">3000</span>, () =&gt; &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'listening'</span>);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><h1 id=\"배포\"><a href=\"#배포\" class=\"headerlink\" title=\"배포\"></a>배포</h1><p><a href=\"https://zeit.co/now\" target=\"_blank\" rel=\"external\">now.sh</a>를 이용해 배포한다.</p><p>now를 글로벌로 설치한다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install -g now</div><div class=\"line\">$ now</div><div class=\"line\">-&gt; enter email: 이메일을 입력한다.</div><div class=\"line\">-&gt; 받은 메일의 링크로 접속하여 인증한다.</div><div class=\"line\"></div><div class=\"line\">$ now</div><div class=\"line\">-&gt; y 하고 enter</div></pre></td></tr></table></figure><p>now URL을 통해 배포가 완료되며 해당 url로 접속할 수 있다.<br><a href=\"https://urlshortner-budejegbvb.now.sh\" target=\"_blank\" rel=\"external\">urlshortner</a></p><p>이렇게 배포된 서비스는 소스코드가 모두 공개되기 때문에 관리자 아이디와 비밀번호를 외부에서 열람하는 것이 가능하다. 따라서 개인정보는 밖으로 노출되지 않도록 않도록 해야한다.</p><hr>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://allvectorlogo.com/img/2016/05/node-js-logo.png\" alt=\"\"></p><h1 id=\"프로젝트-세팅\"><a href=\"#프로젝트-세팅\" class=\"headerlink\" title=\"프로젝트 세팅\"></a>프로젝트 세팅</h1><p>1) project folder 생성<br>2) npm init<br>3) git init<br>3) .gitignore - node로 생성</p><p><strong>node_modules는 깃 저장소에 넣지 않는 것이 원칙이다.</strong></p><p>vscode의 gitignore 플러그인을 설치, cmd+shift+p -&gt; add gitignore -&gt; node를 선택하여 node_modules의 변경사항을 무시하는 gitignore를 생성할 수 있다.</p><hr><h4 id=\"node-modules를-깃에-올리지-않는-이유\"><a href=\"#node-modules를-깃에-올리지-않는-이유\" class=\"headerlink\" title=\"node_modules를 깃에 올리지 않는 이유\"></a>node_modules를 깃에 올리지 않는 이유</h4><ul><li><p>git 저장소는 내 프로젝트의 코드를 관리하기 위한 곳이지 외부 패키지를 관리하기 위한 것이 아니다.</p></li><li><p>git 저장소의 용량이 커지고 git이 추적해야 할 파일이 많아지기 때문에 느려질 수 있다.</p></li></ul><hr><p>4) first commit</p><p>5) git history<br>vscode의 git History 플러그인을 설치하면 깃 로그를 볼 수 있다. cmd+shift+p -&gt; git log -&gt; 로그를 볼 브랜치 선택/ 실행</p><p>6) npm install express –save</p><p>7) server.js 생성</p><p>단축키: <code>cmd+enter</code> 다음 줄로 이동!</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> app = express()</div><div class=\"line\"></div><div class=\"line\">app.get(<span class=\"string\">'/'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  res.send(<span class=\"string\">'hello express'</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">app.listen(<span class=\"number\">3000</span>, () =&gt; &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'listening'</span>);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p>8) 서버 구동</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ node server.js</div></pre></td></tr></table></figure><p>콘솔에 listening이라고 뜨면 로컬서버가 정상적으로 열린 것이다.<br>웹 브라우저에서의 접속은 <code>localhost:3000</code> 으로 할 수 있다.</p><p><code>ctrl+c</code>를 누르면 서버가 종료된다.<br>서버 재시작은 <code>ctrl+c</code> + <code>node server.js</code></p><p>하지만 프로젝트마다 서버 구동 명령어가 조금씩 달라질 수 있다. 보통 <code>npm start</code>를 서버 구동 명령어로 쓰는 것이 관례이다.</p><p>package.json을 열어 script를 아래와 같이 수정한다.</p><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">\"scripts\": &#123;</div><div class=\"line\">  \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\",</div><div class=\"line\">  \"start\": \"node server.js\"</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>이제 <code>npm start</code>로 서버를 구동할 수 있다.</p><p>9) ejs 추가</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install ejs --save</div></pre></td></tr></table></figure><p>아래 코드를 <code>app.get</code> 코드 위에 추가해준다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// server.js</span></div><div class=\"line\">app.set(<span class=\"string\">'view engine'</span>, <span class=\"string\">'ejs'</span>)</div></pre></td></tr></table></figure><p>10) views 폴더를 추가하고 폴더 안에 index.ejs 파일을 추가한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html lang=<span class=\"string\">\"en\"</span>&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">  &lt;meta charset=<span class=\"string\">\"UTF-8\"</span>&gt;</div><div class=\"line\">  &lt;meta name=<span class=\"string\">\"viewport\"</span> content=<span class=\"string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</div><div class=\"line\">  &lt;meta http-equiv=<span class=\"string\">\"X-UA-Compatible\"</span> content=<span class=\"string\">\"ie=edge\"</span>&gt;</div><div class=\"line\">  &lt;title&gt;Document&lt;<span class=\"regexp\">/title&gt;</span></div><div class=\"line\"><span class=\"regexp\">&lt;/</span>head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">  &lt;h1&gt;hello ejs&lt;<span class=\"regexp\">/h1&gt;</span></div><div class=\"line\"><span class=\"regexp\">&lt;/</span>body&gt;</div><div class=\"line\">&lt;<span class=\"regexp\">/html&gt;</span></div></pre></td></tr></table></figure><p>11) server.js 파일의 app.get 코드를 아래와 같이 수정한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.get(<span class=\"string\">'/'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  res.render(<span class=\"string\">'index.ejs'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p>12) 서버를 구동하여 확인한다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm start</div></pre></td></tr></table></figure><p>13) server.js 파일 app.set 다음 줄에 app.use 코드를 추가한다</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.use(<span class=\"string\">'/static'</span>, express.static(<span class=\"string\">'public'</span>))</div></pre></td></tr></table></figure><p>14) 루트에 public 폴더를 생성하고 그 밑에 index.css를 생성하고 index.ejs의 head에 링크 태그를 추가해준다.</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;프로젝트 폴더&gt;</div><div class=\"line\">|____public</div><div class=\"line\">  |____index.css</div></pre></td></tr></table></figure><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* index.css */</span></div><div class=\"line\"><span class=\"selector-tag\">body</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">background-color</span>: skyblue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/static/index.css\"</span>&gt;</span></div></pre></td></tr></table></figure><p>15) 서버를 구동하여 확인한다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm start</div></pre></td></tr></table></figure><p><br></p><h1 id=\"로깅과-인증\"><a href=\"#로깅과-인증\" class=\"headerlink\" title=\"로깅과 인증\"></a>로깅과 인증</h1><h2 id=\"1-morgan-설정\"><a href=\"#1-morgan-설정\" class=\"headerlink\" title=\"1. morgan 설정\"></a>1. morgan 설정</h2><p>1) 미들웨어 morgan 설치 후 server.js에 아래 코드를 삽입한다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install --save morgan</div></pre></td></tr></table></figure><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> morgan = <span class=\"built_in\">require</span>(<span class=\"string\">'morgan'</span>)</div><div class=\"line\"></div><div class=\"line\">app.use(morgan(<span class=\"string\">'tiny'</span>))</div></pre></td></tr></table></figure><p>지금까지의 전체 코드</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//server.js</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> morgan = <span class=\"built_in\">require</span>(<span class=\"string\">'morgan'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> app = express()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">app.set(<span class=\"string\">'view engine'</span>, <span class=\"string\">'ejs'</span>)</div><div class=\"line\">app.use(<span class=\"string\">'/static'</span>, express.static(<span class=\"string\">'public'</span>))</div><div class=\"line\">app.use(morgan(<span class=\"string\">'tiny'</span>))</div><div class=\"line\"></div><div class=\"line\">app.get(<span class=\"string\">'/'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  res.render(<span class=\"string\">'index.ejs'</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">app.listen(<span class=\"number\">3000</span>, () =&gt; &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'listening'</span>);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p>셋팅이 완료된 후 server를 구동시키면 터미널에 아래와 같은 메시지가 뜨는 것을 확인할 수 있다.</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">GET / 200 322 - 11.862 ms</div></pre></td></tr></table></figure><h2 id=\"2-express-basic-auth-설정\"><a href=\"#2-express-basic-auth-설정\" class=\"headerlink\" title=\"2. express-basic-auth 설정\"></a>2. express-basic-auth 설정</h2><p><a href=\"https://www.npmjs.com/package/express-basic-auth\" target=\"_blank\" rel=\"external\">npm-express-basic-auth</a>에 접속하여 사용법을 확인한다.</p><p>(1) basic-auth를 설치한다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install express-basic-auth</div></pre></td></tr></table></figure><p>(2) 설치한 패키지를 불러온다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//server.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)()</div><div class=\"line\"><span class=\"keyword\">var</span> basicAuth = <span class=\"built_in\">require</span>(<span class=\"string\">'express-basic-auth'</span>)</div><div class=\"line\"></div><div class=\"line\">app.use(basicAuth(&#123;</div><div class=\"line\">    users: &#123; <span class=\"string\">'someuser'</span>: <span class=\"string\">'somepassword'</span> &#125;,</div><div class=\"line\">    challenge: <span class=\"literal\">true</span>,</div><div class=\"line\">    realm: <span class=\"string\">'Imb4T3st4pp'</span></div><div class=\"line\">&#125;))</div></pre></td></tr></table></figure><p>위 코드에서 <code>var app = require(&#39;express&#39;)()</code>는 이미 하였으므로 그 아래부터 코드를 삽입해준다. someuser를 admin으로 somepassword도 admin으로 변경한다.</p><p>서버 구동 후 localhost:3000으로 접속하면 로그인 화면이 뜨는데, ID: admin, Password: admin으로 로그인할 수 있다.</p><h1 id=\"초기-데이터-작업\"><a href=\"#초기-데이터-작업\" class=\"headerlink\" title=\"초기 데이터 작업\"></a>초기 데이터 작업</h1><h2 id=\"1-randomstring\"><a href=\"#1-randomstring\" class=\"headerlink\" title=\"1. randomstring\"></a>1. randomstring</h2><p>1) 데이터를 담을 배열 객체를 추가하고, app.get 코드를 수정한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//server.js</span></div><div class=\"line\"><span class=\"keyword\">const</span> data = [</div><div class=\"line\">  &#123;<span class=\"attr\">longURL</span>: <span class=\"string\">'http://google.com'</span>, <span class=\"attr\">id</span>:<span class=\"string\">'58DX37'</span>&#125;</div><div class=\"line\">]</div><div class=\"line\"></div><div class=\"line\">app.get(<span class=\"string\">'/'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  res.render(<span class=\"string\">'index.ejs'</span>, &#123;data&#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p>2) index.ejs의 body에 아래 소스를 추가한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;table&gt;</div><div class=\"line\">    &lt;thead&gt;</div><div class=\"line\">      &lt;tr&gt;</div><div class=\"line\">        &lt;td&gt;Long URL&lt;<span class=\"regexp\">/td&gt;</span></div><div class=\"line\"><span class=\"regexp\">        &lt;td&gt;Short URL&lt;/</span>td&gt;</div><div class=\"line\">      &lt;<span class=\"regexp\">/tr&gt;</span></div><div class=\"line\"><span class=\"regexp\">    &lt;/</span>thead&gt;</div><div class=\"line\">    &lt;tbody&gt;</div><div class=\"line\">      &lt;% data.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123; %&gt;</div><div class=\"line\">      &lt;tr&gt;</div><div class=\"line\">      &lt;td&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">item.longURL</span> %&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span></div><div class=\"line\">      &lt;td&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">item.id</span> %&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span></div><div class=\"line\">      &lt;<span class=\"regexp\">/tr&gt;</span></div><div class=\"line\"><span class=\"regexp\">      &lt;% &#125;) %&gt; </span></div><div class=\"line\"><span class=\"regexp\">    &lt;/</span>tbody&gt;</div><div class=\"line\">  &lt;<span class=\"regexp\">/table&gt;</span></div></pre></td></tr></table></figure><p>서버 재구동 후 확인한다.</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">hello Express</div><div class=\"line\"></div><div class=\"line\">Long URL\tShort URL</div><div class=\"line\">http://google.com\t58DX37</div></pre></td></tr></table></figure><p>3) <a href=\"https://www.npmjs.com/package/randomstring\" target=\"_blank\" rel=\"external\">randomstring</a> 패키지를 설치한다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install --save randomstring</div></pre></td></tr></table></figure><p>설치한 패키지 사용을 위해 randomstring 객체를 추가해주고, generate 메소드를 사용하여 id를 6자리 랜덤 스트링으로 생성한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// server.js</span></div><div class=\"line\"><span class=\"keyword\">const</span> randomstring = <span class=\"built_in\">require</span>(<span class=\"string\">'randomstring'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> data = [</div><div class=\"line\">  &#123;<span class=\"attr\">longURL</span>: <span class=\"string\">'http://google.com'</span>, <span class=\"attr\">id</span>:randomstring.generate(<span class=\"number\">6</span>)&#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure><h1 id=\"짧은-URL의-Redirection\"><a href=\"#짧은-URL의-Redirection\" class=\"headerlink\" title=\"짧은 URL의 Redirection\"></a>짧은 URL의 Redirection</h1><h2 id=\"1-라우터-핸들러-작성-301-Moved-Permanently\"><a href=\"#1-라우터-핸들러-작성-301-Moved-Permanently\" class=\"headerlink\" title=\"1. 라우터 핸들러 작성 (301 Moved Permanently)\"></a>1. 라우터 핸들러 작성 (301 Moved Permanently)</h2><p>아래 코드를 <code>app.get(&#39;/&#39;, (req, res) ~~</code> 코드의 아래에 추가로 작성한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// server.js</span></div><div class=\"line\">app.get(<span class=\"string\">'/:id'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> id = req.params.id</div><div class=\"line\">  <span class=\"keyword\">const</span> matched = data.find(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item.id === id)</div><div class=\"line\">  <span class=\"keyword\">if</span>(matched) &#123;</div><div class=\"line\">    res.redirect(<span class=\"number\">301</span>, matched.longURL)</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    res.status(<span class=\"number\">404</span>)</div><div class=\"line\">    res.send(<span class=\"string\">'404 Not Found'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p>서버 구동 후 localhost:3000 뒤에 shorturl을 붙여 접속하면 (ex. localhost:3000/LL3L5c)longurl로 redirect되어 google.com으로 접속되는 것을 확인할 수 있다.</p><p>2) html 수정</p><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- index.ejs --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/&lt;%= item.id%&gt;\"</span> <span class=\"attr\">target</span>=<span class=\"string\">\"_blank\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">item.id</span> %&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div></pre></td></tr></table></figure><p>a태그로 감싸기 단축키: <code>cmd+shift+p -&gt; wrap -&gt; Emmet:wrap with Abbreviation</code></p><h1 id=\"폼\"><a href=\"#폼\" class=\"headerlink\" title=\"폼\"></a>폼</h1><h2 id=\"body-parser-amp-폼-핸들러-작성\"><a href=\"#body-parser-amp-폼-핸들러-작성\" class=\"headerlink\" title=\"body-parser&amp; 폼, 핸들러 작성\"></a><a href=\"https://www.npmjs.com/package/body-parser#examples\" target=\"_blank\" rel=\"external\">body-parser</a>&amp; 폼, 핸들러 작성</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install --save body-parser</div></pre></td></tr></table></figure><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// server.js</span></div><div class=\"line\"><span class=\"keyword\">const</span> bodyparser = <span class=\"built_in\">require</span>(<span class=\"string\">'body-parser'</span>)</div><div class=\"line\"></div><div class=\"line\">app.use(bodyParser.urlencoded(&#123; <span class=\"attr\">extended</span>: <span class=\"literal\">false</span> &#125;))</div></pre></td></tr></table></figure><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- index.ejs --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>hello Express<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"/\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"post\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"url\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"longURL\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"전송\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div></pre></td></tr></table></figure><p>form 전송을 받은 후 redirect시켜야 한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// server.js</span></div><div class=\"line\">app.post(<span class=\"string\">'/'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> longURL = req.body.longURL</div><div class=\"line\">  <span class=\"keyword\">let</span> id;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// id가 있으면 다시 만들고, 없으면 candidate를 저장하고 빠져나간다.</span></div><div class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</div><div class=\"line\">    <span class=\"comment\">// id가 될 후보</span></div><div class=\"line\">    <span class=\"keyword\">const</span> candidate = randomstring.generate(<span class=\"number\">6</span>)</div><div class=\"line\">    <span class=\"keyword\">const</span> matched = data.find(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item.id === candidate)</div><div class=\"line\">    <span class=\"comment\">//matched가 없으면, 잘 된 상황</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(!matched) &#123;</div><div class=\"line\">      id = candidate</div><div class=\"line\">      <span class=\"keyword\">break</span> <span class=\"comment\">// 중복이 없는 아이디를 찾은 상황</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  data.push(&#123;id, longURL&#125;)</div><div class=\"line\">  res.redirect(<span class=\"string\">'/'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p>#</p><p>현재는 로그인 인증을 app.use에 넣어뒀기 때문에, 로그인하지 않은 사용자는 짧은 url을 사용할 수 없다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// server.js</span></div><div class=\"line\">app.use(basicAuth(&#123;</div><div class=\"line\">  users: &#123; <span class=\"string\">'admin'</span>: <span class=\"string\">'admin'</span> &#125;,</div><div class=\"line\">  challenge: <span class=\"literal\">true</span>,</div><div class=\"line\">  realm: <span class=\"string\">'Imb4T3st4pp'</span></div><div class=\"line\">&#125;))</div></pre></td></tr></table></figure><p>위 코드를 아래와 같이 수정해준다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> authMiddleware = basicAuth(&#123;</div><div class=\"line\">  users: &#123; <span class=\"string\">'admin'</span>: <span class=\"string\">'admin'</span> &#125;,</div><div class=\"line\">  challenge: <span class=\"literal\">true</span>,</div><div class=\"line\">  realm: <span class=\"string\">'Imb4T3st4pp'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p>body parser 미들웨어도 app.use에서 꺼내 따로 정의한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.use(bodyParser.urlencoded(&#123; <span class=\"attr\">extended</span>: <span class=\"literal\">false</span> &#125;))</div></pre></td></tr></table></figure><p>위 코드를 아래처럼 바꾼다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> bodyParserMiddleWare = bodyParser.urlencoded(&#123; <span class=\"attr\">extended</span>: <span class=\"literal\">false</span> &#125;)</div></pre></td></tr></table></figure><p>이제 분리한 미들웨어를 필요한 곳에만 주입할 수 있다.<br>인증이 필요한 곳에만, 바디파서가 필요한 곳에만 넣을 수 있다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> morgan = <span class=\"built_in\">require</span>(<span class=\"string\">'morgan'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> basicAuth = <span class=\"built_in\">require</span>(<span class=\"string\">'express-basic-auth'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> randomstring = <span class=\"built_in\">require</span>(<span class=\"string\">'randomstring'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> bodyParser = <span class=\"built_in\">require</span>(<span class=\"string\">'body-parser'</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 실무에서는 데이터를 이렇게 관리하지 않는다.</span></div><div class=\"line\"><span class=\"comment\">// 이렇게 만들어진 데이터는 메모리상에서 관리되는 것으로 새로고침시 사라지는 데이터이다.</span></div><div class=\"line\"><span class=\"keyword\">const</span> data = [</div><div class=\"line\">  &#123;<span class=\"attr\">longURL</span>: <span class=\"string\">'http://google.com'</span>, <span class=\"attr\">id</span>:randomstring.generate(<span class=\"number\">6</span>)&#125;</div><div class=\"line\">]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// http://localhost:3000/58DX37</span></div><div class=\"line\"><span class=\"comment\">// 302 응답</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> app = express()</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> authMiddleware = basicAuth(&#123;</div><div class=\"line\">  users: &#123; <span class=\"string\">'admin'</span>: <span class=\"string\">'admin'</span> &#125;,</div><div class=\"line\">  challenge: <span class=\"literal\">true</span>,</div><div class=\"line\">  realm: <span class=\"string\">'Imb4T3st4pp'</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> bodyParserMiddleWare = bodyParser.urlencoded(&#123; <span class=\"attr\">extended</span>: <span class=\"literal\">false</span> &#125;)</div><div class=\"line\"></div><div class=\"line\">app.set(<span class=\"string\">'view engine'</span>, <span class=\"string\">'ejs'</span>)</div><div class=\"line\">app.use(<span class=\"string\">'/static'</span>, express.static(<span class=\"string\">'public'</span>))</div><div class=\"line\">app.use(morgan(<span class=\"string\">'tiny'</span>))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">app.get(<span class=\"string\">'/'</span>, authMiddleware, (req, res) =&gt; &#123;</div><div class=\"line\">  res.render(<span class=\"string\">'index.ejs'</span>, &#123;data&#125;)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">app.get(<span class=\"string\">'/:id'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> id = req.params.id</div><div class=\"line\">  <span class=\"keyword\">const</span> matched = data.find(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item.id === id)</div><div class=\"line\">  <span class=\"keyword\">if</span>(matched) &#123;</div><div class=\"line\">    res.redirect(<span class=\"number\">301</span>, matched.longURL)</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    res.status(<span class=\"number\">404</span>)</div><div class=\"line\">    res.send(<span class=\"string\">'404 Not Found'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">app.post(<span class=\"string\">'/'</span>, bodyParserMiddleWare, authMiddleware, (req, res) =&gt; &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> longURL = req.body.longURL</div><div class=\"line\">  <span class=\"keyword\">let</span> id;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// id가 있으면 다시 만들고, 없으면 candidate를 저장하고 빠져나간다.</span></div><div class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</div><div class=\"line\">    <span class=\"comment\">// id가 될 후보</span></div><div class=\"line\">    <span class=\"keyword\">const</span> candidate = randomstring.generate(<span class=\"number\">6</span>)</div><div class=\"line\">    <span class=\"keyword\">const</span> matched = data.find(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item.id === candidate)</div><div class=\"line\">    <span class=\"comment\">//matched가 없으면, 잘 된 상황</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(!matched) &#123;</div><div class=\"line\">      id = candidate</div><div class=\"line\">      <span class=\"keyword\">break</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  data.push(&#123;id, longURL&#125;)</div><div class=\"line\">  res.redirect(<span class=\"string\">'/'</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">app.listen(<span class=\"number\">3000</span>, () =&gt; &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'listening'</span>);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><h1 id=\"배포\"><a href=\"#배포\" class=\"headerlink\" title=\"배포\"></a>배포</h1><p><a href=\"https://zeit.co/now\" target=\"_blank\" rel=\"external\">now.sh</a>를 이용해 배포한다.</p><p>now를 글로벌로 설치한다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install -g now</div><div class=\"line\">$ now</div><div class=\"line\">-&gt; enter email: 이메일을 입력한다.</div><div class=\"line\">-&gt; 받은 메일의 링크로 접속하여 인증한다.</div><div class=\"line\"></div><div class=\"line\">$ now</div><div class=\"line\">-&gt; y 하고 enter</div></pre></td></tr></table></figure><p>now URL을 통해 배포가 완료되며 해당 url로 접속할 수 있다.<br><a href=\"https://urlshortner-budejegbvb.now.sh\" target=\"_blank\" rel=\"external\">urlshortner</a></p><p>이렇게 배포된 서비스는 소스코드가 모두 공개되기 때문에 관리자 아이디와 비밀번호를 외부에서 열람하는 것이 가능하다. 따라서 개인정보는 밖으로 노출되지 않도록 않도록 해야한다.</p><hr>"},{"title":"[node] 쿠키 Cookie","date":"2017-09-09T09:05:09.000Z","_content":"\n![](http://allvectorlogo.com/img/2016/05/node-js-logo.png)\n\n# 쿠키\n\n쿠키는 클라이언트 웹 브라우저에 저장되는 정보이다. 일정 기간 동안 저장하고 싶을 때 사용한다. 익스프레스에서는 `cookie-parser` 미들웨어를 사용하면 쿠키를 설정하거나 확인할 수 있다.\n\n## 쿠키의 필요성\n\n개별 클라이언트의 여러 요청에 걸친 정보의 유지가 필요한 경우\n\n* 장바구니\n* 로그인/로그아웃\n* 방문 기록 등\n\n\n<br>\n\n## HTTP Cookie\n\n* 서버가 응답을 통해 웹 브라우저에 저장하는 이름+값 형태의 정보\n* 웹 브라우저는 쿠키를 저장하기 위한 **저장소**를 가지고 있다.\n* 저장소는 자료의 유효기간과 접근 권한에 대한 다양한 옵션을 제공한다.\n\n<br>\n\n## 쿠키 전송 절차\n\n#### 1. Set-Cookie 헤더\n\n  서버가 브라우저에 **저장하고 싶은 정보를 응답과 같이 실어 보낸다.**\n\n  ```\n  HTTP/1.1 200 OK\n  Set-Cookie: cookieName = cookieValue; Secure; Max-Age = 60000\n  ...\n  ```\n\n\n#### 2. Cookie 헤더\n\n  브라우저는 같은 서버에 요청이 일어날 때 마다 해당 정보를 요청에 같이 실어서 서버에 보낸다.\n\n  ```\n  GET / HTTP/1.1\n  Cookie: cookieName=cookieValue; anotherName=anotherValue\n  ...\n  ```\n\n<br>\n\n#### 3. Set-Cookie Options\n\n**Expires, Max-Age**: 쿠키의 지속 시간 설정\n\n```js\n// maxAge 옵션은 쿠키가 해당 시간이 지났을 때 삭제되도록 합니다.\napp.get('/maxAge', (req, res) => {\n  res.cookie('maxAgeCookie', 'value', {\n    maxAge: 5000\n  })\n  res.redirect('/')\n})\n```\n\n**Secure**: HTTPS를 통해서만 쿠키가 전송되도록 설정\n\n```js\n// secure 옵션은 http 프로토콜을 통한 요청에는 쿠키가 포함되지 않게 합니다. (https로 했을 때만 포함시킴)\napp.get('/secure', (req, res) => {\n  res.cookie('secureCookie', 'value', {\n    secure: true\n  })\n  res.redirect('/')\n})\n```\n\n**HttpOnly**: 자바스크립트에서 쿠키를 읽지 못하도록 설정\n\n```js\n// httpOnly 옵션은 해당 쿠키를 자바스크립트에서 접근할 수 없게 합니다.\napp.get('/httpOnly', (req, res) => {\n  res.cookie('httpOnlyCookie', 'value', {\n    httpOnly: true\n  })\n  res.redirect('/')\n})\n```\n\n자바스크립트에서 쿠키를 읽지 못하게 해야 하는 이유는 누군가 악의적으로 웹사이트의 게시글에 스크립트 태그를 심을 가능성이 있기 때문이다. 이를 Cross-site Scripting(XSS)이라고 한다. 만약 로그인정보가 포함되어 있다면 이 공격에 의해 로그인 정보가 유출되는 위험이 발생할 수 있다.\n\n**Domain, Path**: 쿠키의 scope 설정 (쿠키가 전송되는 URL을 제한)\n\n```js\n// domain 옵션은 해당 도메인 및 서브도메인으로 쿠키가 전송되도록 합니다.\napp.get('/domain', (req, res) => {\n  res.cookie('domainCookie', 'value', {\n    domain: 'glitch.me'\n  })\n  res.redirect('/')\n})\n\n// path 옵션은 쿠키가 지정된 경로 및 그 하위 경로에 요청이 일어났을 때만 전송되도록 합니다.\napp.get('/path', (req, res) => {\n  res.cookie('pathCookie', 'value', {\n    path: '/somePath'\n  })\n  res.redirect('/')\n})\n\n```\n\n**multiple-options**: 위 옵션들을 한번에 다중으로 지정할 수 있다.\n\n```js\n// 여러 옵션을 한꺼번에 지정할 수도 있습니다.\napp.get('/multiple-options', (req, res) => {\n  res.cookie('multipleOption', 'value', {\n    secure: true,\n    httpOnly: true,\n    maxAge: 5000\n  })\n  res.redirect('/')\n})\n```\n\n<br>\n\n#### 4. Express + Cookie\n\n**쿠키 읽기 - req.cookies**\n\n요청에 실려온 쿠키가 객체로 변환되어 `req.cookies`에 저장됨 (`cookie-parser` 미들웨어 필요)\n\n```js\n// req.cookies를 사용하려면\n// cookieParser라는 미들웨어가 필요하다.\nconst cookieParser = require('cookie-parser')\napp.use(cookieParser())\n\napp.get('/', (req, res) => {\n  res.send(req.cookies)\n})\n\napp.get('/somePath', (req, res) => {\n  res.send(req.cookies)\n})\n\n```\n\n\n**쿠키 쓰기 - res.cookie(name, value)**\n\n쿠키의 생성 혹은 수정\n\n<br>\n\n#### 5. 쿠키 예제: [Link](https://glitch.com/edit/#!/wpsn-cookie-example)\n\n<br>\n\n## JavaScript + Cookie\n\n자바스크립트로도 쿠키를 읽고 쓰는 방법이 존재하지만, 보안 상 문제를 일으킬 수 있으므로 이런 접근 방식은 거의 사용되지 않는다.\n\n자바스크립트에서 쿠키에 접근하지 못하도록 `HttpOnly`를 항상 설정하는 것이 best practice\n\n<br>\n\n## 쿠키의 한계점\n\n* US-ASCII 밖에 저장하지 못해서 한글 표시가 안 된다. 한글 표시를 위해서 보통 percent encoding을 사용한다.\n\n* 4000 바이트 내외(영문 4000자, percent encoding 된 한글 444자 가량)밖에 저장하지 못한다.\n\n* 브라우저에 저장된다. 즉, 여러 브라우저에 걸쳐 공유되어야 하는 정보, 혹은 웹 브라우저가 아닌 클라이언트(모바일 앱)에 저장되어야 하는 정보를 다루기에는 부적절하다. (예를 들어 장바구니를 쿠키를 이용해서 구현하면, 다른 브라우저에서 켰을 때 보이지 않는 경우가 발생한다. 이런 한계가 존재하기 때문에, 쿠키로 모든 것을 다 할 수는 없다.)\n","source":"_posts/nodejs/08.cookie.md","raw":"---\ntitle: '[node] 쿠키 Cookie'\ndate: 2017-09-09 18:05:09\ncategory: Nodejs\ntags: cookie\n---\n\n![](http://allvectorlogo.com/img/2016/05/node-js-logo.png)\n\n# 쿠키\n\n쿠키는 클라이언트 웹 브라우저에 저장되는 정보이다. 일정 기간 동안 저장하고 싶을 때 사용한다. 익스프레스에서는 `cookie-parser` 미들웨어를 사용하면 쿠키를 설정하거나 확인할 수 있다.\n\n## 쿠키의 필요성\n\n개별 클라이언트의 여러 요청에 걸친 정보의 유지가 필요한 경우\n\n* 장바구니\n* 로그인/로그아웃\n* 방문 기록 등\n\n\n<br>\n\n## HTTP Cookie\n\n* 서버가 응답을 통해 웹 브라우저에 저장하는 이름+값 형태의 정보\n* 웹 브라우저는 쿠키를 저장하기 위한 **저장소**를 가지고 있다.\n* 저장소는 자료의 유효기간과 접근 권한에 대한 다양한 옵션을 제공한다.\n\n<br>\n\n## 쿠키 전송 절차\n\n#### 1. Set-Cookie 헤더\n\n  서버가 브라우저에 **저장하고 싶은 정보를 응답과 같이 실어 보낸다.**\n\n  ```\n  HTTP/1.1 200 OK\n  Set-Cookie: cookieName = cookieValue; Secure; Max-Age = 60000\n  ...\n  ```\n\n\n#### 2. Cookie 헤더\n\n  브라우저는 같은 서버에 요청이 일어날 때 마다 해당 정보를 요청에 같이 실어서 서버에 보낸다.\n\n  ```\n  GET / HTTP/1.1\n  Cookie: cookieName=cookieValue; anotherName=anotherValue\n  ...\n  ```\n\n<br>\n\n#### 3. Set-Cookie Options\n\n**Expires, Max-Age**: 쿠키의 지속 시간 설정\n\n```js\n// maxAge 옵션은 쿠키가 해당 시간이 지났을 때 삭제되도록 합니다.\napp.get('/maxAge', (req, res) => {\n  res.cookie('maxAgeCookie', 'value', {\n    maxAge: 5000\n  })\n  res.redirect('/')\n})\n```\n\n**Secure**: HTTPS를 통해서만 쿠키가 전송되도록 설정\n\n```js\n// secure 옵션은 http 프로토콜을 통한 요청에는 쿠키가 포함되지 않게 합니다. (https로 했을 때만 포함시킴)\napp.get('/secure', (req, res) => {\n  res.cookie('secureCookie', 'value', {\n    secure: true\n  })\n  res.redirect('/')\n})\n```\n\n**HttpOnly**: 자바스크립트에서 쿠키를 읽지 못하도록 설정\n\n```js\n// httpOnly 옵션은 해당 쿠키를 자바스크립트에서 접근할 수 없게 합니다.\napp.get('/httpOnly', (req, res) => {\n  res.cookie('httpOnlyCookie', 'value', {\n    httpOnly: true\n  })\n  res.redirect('/')\n})\n```\n\n자바스크립트에서 쿠키를 읽지 못하게 해야 하는 이유는 누군가 악의적으로 웹사이트의 게시글에 스크립트 태그를 심을 가능성이 있기 때문이다. 이를 Cross-site Scripting(XSS)이라고 한다. 만약 로그인정보가 포함되어 있다면 이 공격에 의해 로그인 정보가 유출되는 위험이 발생할 수 있다.\n\n**Domain, Path**: 쿠키의 scope 설정 (쿠키가 전송되는 URL을 제한)\n\n```js\n// domain 옵션은 해당 도메인 및 서브도메인으로 쿠키가 전송되도록 합니다.\napp.get('/domain', (req, res) => {\n  res.cookie('domainCookie', 'value', {\n    domain: 'glitch.me'\n  })\n  res.redirect('/')\n})\n\n// path 옵션은 쿠키가 지정된 경로 및 그 하위 경로에 요청이 일어났을 때만 전송되도록 합니다.\napp.get('/path', (req, res) => {\n  res.cookie('pathCookie', 'value', {\n    path: '/somePath'\n  })\n  res.redirect('/')\n})\n\n```\n\n**multiple-options**: 위 옵션들을 한번에 다중으로 지정할 수 있다.\n\n```js\n// 여러 옵션을 한꺼번에 지정할 수도 있습니다.\napp.get('/multiple-options', (req, res) => {\n  res.cookie('multipleOption', 'value', {\n    secure: true,\n    httpOnly: true,\n    maxAge: 5000\n  })\n  res.redirect('/')\n})\n```\n\n<br>\n\n#### 4. Express + Cookie\n\n**쿠키 읽기 - req.cookies**\n\n요청에 실려온 쿠키가 객체로 변환되어 `req.cookies`에 저장됨 (`cookie-parser` 미들웨어 필요)\n\n```js\n// req.cookies를 사용하려면\n// cookieParser라는 미들웨어가 필요하다.\nconst cookieParser = require('cookie-parser')\napp.use(cookieParser())\n\napp.get('/', (req, res) => {\n  res.send(req.cookies)\n})\n\napp.get('/somePath', (req, res) => {\n  res.send(req.cookies)\n})\n\n```\n\n\n**쿠키 쓰기 - res.cookie(name, value)**\n\n쿠키의 생성 혹은 수정\n\n<br>\n\n#### 5. 쿠키 예제: [Link](https://glitch.com/edit/#!/wpsn-cookie-example)\n\n<br>\n\n## JavaScript + Cookie\n\n자바스크립트로도 쿠키를 읽고 쓰는 방법이 존재하지만, 보안 상 문제를 일으킬 수 있으므로 이런 접근 방식은 거의 사용되지 않는다.\n\n자바스크립트에서 쿠키에 접근하지 못하도록 `HttpOnly`를 항상 설정하는 것이 best practice\n\n<br>\n\n## 쿠키의 한계점\n\n* US-ASCII 밖에 저장하지 못해서 한글 표시가 안 된다. 한글 표시를 위해서 보통 percent encoding을 사용한다.\n\n* 4000 바이트 내외(영문 4000자, percent encoding 된 한글 444자 가량)밖에 저장하지 못한다.\n\n* 브라우저에 저장된다. 즉, 여러 브라우저에 걸쳐 공유되어야 하는 정보, 혹은 웹 브라우저가 아닌 클라이언트(모바일 앱)에 저장되어야 하는 정보를 다루기에는 부적절하다. (예를 들어 장바구니를 쿠키를 이용해서 구현하면, 다른 브라우저에서 켰을 때 보이지 않는 경우가 발생한다. 이런 한계가 존재하기 때문에, 쿠키로 모든 것을 다 할 수는 없다.)\n","slug":"nodejs/08.cookie","published":1,"updated":"2017-09-21T06:06:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjai8h18n001evb9q4itsxo9q","content":"<p><img src=\"http://allvectorlogo.com/img/2016/05/node-js-logo.png\" alt=\"\"></p><h1 id=\"쿠키\"><a href=\"#쿠키\" class=\"headerlink\" title=\"쿠키\"></a>쿠키</h1><p>쿠키는 클라이언트 웹 브라우저에 저장되는 정보이다. 일정 기간 동안 저장하고 싶을 때 사용한다. 익스프레스에서는 <code>cookie-parser</code> 미들웨어를 사용하면 쿠키를 설정하거나 확인할 수 있다.</p><h2 id=\"쿠키의-필요성\"><a href=\"#쿠키의-필요성\" class=\"headerlink\" title=\"쿠키의 필요성\"></a>쿠키의 필요성</h2><p>개별 클라이언트의 여러 요청에 걸친 정보의 유지가 필요한 경우</p><ul><li>장바구니</li><li>로그인/로그아웃</li><li>방문 기록 등</li></ul><p><br></p><h2 id=\"HTTP-Cookie\"><a href=\"#HTTP-Cookie\" class=\"headerlink\" title=\"HTTP Cookie\"></a>HTTP Cookie</h2><ul><li>서버가 응답을 통해 웹 브라우저에 저장하는 이름+값 형태의 정보</li><li>웹 브라우저는 쿠키를 저장하기 위한 <strong>저장소</strong>를 가지고 있다.</li><li>저장소는 자료의 유효기간과 접근 권한에 대한 다양한 옵션을 제공한다.</li></ul><p><br></p><h2 id=\"쿠키-전송-절차\"><a href=\"#쿠키-전송-절차\" class=\"headerlink\" title=\"쿠키 전송 절차\"></a>쿠키 전송 절차</h2><h4 id=\"1-Set-Cookie-헤더\"><a href=\"#1-Set-Cookie-헤더\" class=\"headerlink\" title=\"1. Set-Cookie 헤더\"></a>1. Set-Cookie 헤더</h4><p>서버가 브라우저에 <strong>저장하고 싶은 정보를 응답과 같이 실어 보낸다.</strong></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">HTTP/1.1 200 OK</div><div class=\"line\">Set-Cookie: cookieName = cookieValue; Secure; Max-Age = 60000</div><div class=\"line\">...</div></pre></td></tr></table></figure><h4 id=\"2-Cookie-헤더\"><a href=\"#2-Cookie-헤더\" class=\"headerlink\" title=\"2. Cookie 헤더\"></a>2. Cookie 헤더</h4><p>브라우저는 같은 서버에 요청이 일어날 때 마다 해당 정보를 요청에 같이 실어서 서버에 보낸다.</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">GET / HTTP/1.1</div><div class=\"line\">Cookie: cookieName=cookieValue; anotherName=anotherValue</div><div class=\"line\">...</div></pre></td></tr></table></figure><p><br></p><h4 id=\"3-Set-Cookie-Options\"><a href=\"#3-Set-Cookie-Options\" class=\"headerlink\" title=\"3. Set-Cookie Options\"></a>3. Set-Cookie Options</h4><p><strong>Expires, Max-Age</strong>: 쿠키의 지속 시간 설정</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// maxAge 옵션은 쿠키가 해당 시간이 지났을 때 삭제되도록 합니다.</span></div><div class=\"line\">app.get(<span class=\"string\">'/maxAge'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  res.cookie(<span class=\"string\">'maxAgeCookie'</span>, <span class=\"string\">'value'</span>, &#123;</div><div class=\"line\">    maxAge: <span class=\"number\">5000</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">  res.redirect(<span class=\"string\">'/'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p><strong>Secure</strong>: HTTPS를 통해서만 쿠키가 전송되도록 설정</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// secure 옵션은 http 프로토콜을 통한 요청에는 쿠키가 포함되지 않게 합니다. (https로 했을 때만 포함시킴)</span></div><div class=\"line\">app.get(<span class=\"string\">'/secure'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  res.cookie(<span class=\"string\">'secureCookie'</span>, <span class=\"string\">'value'</span>, &#123;</div><div class=\"line\">    secure: <span class=\"literal\">true</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">  res.redirect(<span class=\"string\">'/'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p><strong>HttpOnly</strong>: 자바스크립트에서 쿠키를 읽지 못하도록 설정</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// httpOnly 옵션은 해당 쿠키를 자바스크립트에서 접근할 수 없게 합니다.</span></div><div class=\"line\">app.get(<span class=\"string\">'/httpOnly'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  res.cookie(<span class=\"string\">'httpOnlyCookie'</span>, <span class=\"string\">'value'</span>, &#123;</div><div class=\"line\">    httpOnly: <span class=\"literal\">true</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">  res.redirect(<span class=\"string\">'/'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p>자바스크립트에서 쿠키를 읽지 못하게 해야 하는 이유는 누군가 악의적으로 웹사이트의 게시글에 스크립트 태그를 심을 가능성이 있기 때문이다. 이를 Cross-site Scripting(XSS)이라고 한다. 만약 로그인정보가 포함되어 있다면 이 공격에 의해 로그인 정보가 유출되는 위험이 발생할 수 있다.</p><p><strong>Domain, Path</strong>: 쿠키의 scope 설정 (쿠키가 전송되는 URL을 제한)</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// domain 옵션은 해당 도메인 및 서브도메인으로 쿠키가 전송되도록 합니다.</span></div><div class=\"line\">app.get(<span class=\"string\">'/domain'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  res.cookie(<span class=\"string\">'domainCookie'</span>, <span class=\"string\">'value'</span>, &#123;</div><div class=\"line\">    domain: <span class=\"string\">'glitch.me'</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">  res.redirect(<span class=\"string\">'/'</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// path 옵션은 쿠키가 지정된 경로 및 그 하위 경로에 요청이 일어났을 때만 전송되도록 합니다.</span></div><div class=\"line\">app.get(<span class=\"string\">'/path'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  res.cookie(<span class=\"string\">'pathCookie'</span>, <span class=\"string\">'value'</span>, &#123;</div><div class=\"line\">    path: <span class=\"string\">'/somePath'</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">  res.redirect(<span class=\"string\">'/'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p><strong>multiple-options</strong>: 위 옵션들을 한번에 다중으로 지정할 수 있다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 여러 옵션을 한꺼번에 지정할 수도 있습니다.</span></div><div class=\"line\">app.get(<span class=\"string\">'/multiple-options'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  res.cookie(<span class=\"string\">'multipleOption'</span>, <span class=\"string\">'value'</span>, &#123;</div><div class=\"line\">    secure: <span class=\"literal\">true</span>,</div><div class=\"line\">    httpOnly: <span class=\"literal\">true</span>,</div><div class=\"line\">    maxAge: <span class=\"number\">5000</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">  res.redirect(<span class=\"string\">'/'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p><br></p><h4 id=\"4-Express-Cookie\"><a href=\"#4-Express-Cookie\" class=\"headerlink\" title=\"4. Express + Cookie\"></a>4. Express + Cookie</h4><p><strong>쿠키 읽기 - req.cookies</strong></p><p>요청에 실려온 쿠키가 객체로 변환되어 <code>req.cookies</code>에 저장됨 (<code>cookie-parser</code> 미들웨어 필요)</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// req.cookies를 사용하려면</span></div><div class=\"line\"><span class=\"comment\">// cookieParser라는 미들웨어가 필요하다.</span></div><div class=\"line\"><span class=\"keyword\">const</span> cookieParser = <span class=\"built_in\">require</span>(<span class=\"string\">'cookie-parser'</span>)</div><div class=\"line\">app.use(cookieParser())</div><div class=\"line\"></div><div class=\"line\">app.get(<span class=\"string\">'/'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  res.send(req.cookies)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">app.get(<span class=\"string\">'/somePath'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  res.send(req.cookies)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p><strong>쿠키 쓰기 - res.cookie(name, value)</strong></p><p>쿠키의 생성 혹은 수정</p><p><br></p><h4 id=\"5-쿠키-예제-Link\"><a href=\"#5-쿠키-예제-Link\" class=\"headerlink\" title=\"5. 쿠키 예제: Link\"></a>5. 쿠키 예제: <a href=\"https://glitch.com/edit/#!/wpsn-cookie-example\" target=\"_blank\" rel=\"external\">Link</a></h4><p><br></p><h2 id=\"JavaScript-Cookie\"><a href=\"#JavaScript-Cookie\" class=\"headerlink\" title=\"JavaScript + Cookie\"></a>JavaScript + Cookie</h2><p>자바스크립트로도 쿠키를 읽고 쓰는 방법이 존재하지만, 보안 상 문제를 일으킬 수 있으므로 이런 접근 방식은 거의 사용되지 않는다.</p><p>자바스크립트에서 쿠키에 접근하지 못하도록 <code>HttpOnly</code>를 항상 설정하는 것이 best practice</p><p><br></p><h2 id=\"쿠키의-한계점\"><a href=\"#쿠키의-한계점\" class=\"headerlink\" title=\"쿠키의 한계점\"></a>쿠키의 한계점</h2><ul><li><p>US-ASCII 밖에 저장하지 못해서 한글 표시가 안 된다. 한글 표시를 위해서 보통 percent encoding을 사용한다.</p></li><li><p>4000 바이트 내외(영문 4000자, percent encoding 된 한글 444자 가량)밖에 저장하지 못한다.</p></li><li><p>브라우저에 저장된다. 즉, 여러 브라우저에 걸쳐 공유되어야 하는 정보, 혹은 웹 브라우저가 아닌 클라이언트(모바일 앱)에 저장되어야 하는 정보를 다루기에는 부적절하다. (예를 들어 장바구니를 쿠키를 이용해서 구현하면, 다른 브라우저에서 켰을 때 보이지 않는 경우가 발생한다. 이런 한계가 존재하기 때문에, 쿠키로 모든 것을 다 할 수는 없다.)</p></li></ul>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://allvectorlogo.com/img/2016/05/node-js-logo.png\" alt=\"\"></p><h1 id=\"쿠키\"><a href=\"#쿠키\" class=\"headerlink\" title=\"쿠키\"></a>쿠키</h1><p>쿠키는 클라이언트 웹 브라우저에 저장되는 정보이다. 일정 기간 동안 저장하고 싶을 때 사용한다. 익스프레스에서는 <code>cookie-parser</code> 미들웨어를 사용하면 쿠키를 설정하거나 확인할 수 있다.</p><h2 id=\"쿠키의-필요성\"><a href=\"#쿠키의-필요성\" class=\"headerlink\" title=\"쿠키의 필요성\"></a>쿠키의 필요성</h2><p>개별 클라이언트의 여러 요청에 걸친 정보의 유지가 필요한 경우</p><ul><li>장바구니</li><li>로그인/로그아웃</li><li>방문 기록 등</li></ul><p><br></p><h2 id=\"HTTP-Cookie\"><a href=\"#HTTP-Cookie\" class=\"headerlink\" title=\"HTTP Cookie\"></a>HTTP Cookie</h2><ul><li>서버가 응답을 통해 웹 브라우저에 저장하는 이름+값 형태의 정보</li><li>웹 브라우저는 쿠키를 저장하기 위한 <strong>저장소</strong>를 가지고 있다.</li><li>저장소는 자료의 유효기간과 접근 권한에 대한 다양한 옵션을 제공한다.</li></ul><p><br></p><h2 id=\"쿠키-전송-절차\"><a href=\"#쿠키-전송-절차\" class=\"headerlink\" title=\"쿠키 전송 절차\"></a>쿠키 전송 절차</h2><h4 id=\"1-Set-Cookie-헤더\"><a href=\"#1-Set-Cookie-헤더\" class=\"headerlink\" title=\"1. Set-Cookie 헤더\"></a>1. Set-Cookie 헤더</h4><p>서버가 브라우저에 <strong>저장하고 싶은 정보를 응답과 같이 실어 보낸다.</strong></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">HTTP/1.1 200 OK</div><div class=\"line\">Set-Cookie: cookieName = cookieValue; Secure; Max-Age = 60000</div><div class=\"line\">...</div></pre></td></tr></table></figure><h4 id=\"2-Cookie-헤더\"><a href=\"#2-Cookie-헤더\" class=\"headerlink\" title=\"2. Cookie 헤더\"></a>2. Cookie 헤더</h4><p>브라우저는 같은 서버에 요청이 일어날 때 마다 해당 정보를 요청에 같이 실어서 서버에 보낸다.</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">GET / HTTP/1.1</div><div class=\"line\">Cookie: cookieName=cookieValue; anotherName=anotherValue</div><div class=\"line\">...</div></pre></td></tr></table></figure><p><br></p><h4 id=\"3-Set-Cookie-Options\"><a href=\"#3-Set-Cookie-Options\" class=\"headerlink\" title=\"3. Set-Cookie Options\"></a>3. Set-Cookie Options</h4><p><strong>Expires, Max-Age</strong>: 쿠키의 지속 시간 설정</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// maxAge 옵션은 쿠키가 해당 시간이 지났을 때 삭제되도록 합니다.</span></div><div class=\"line\">app.get(<span class=\"string\">'/maxAge'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  res.cookie(<span class=\"string\">'maxAgeCookie'</span>, <span class=\"string\">'value'</span>, &#123;</div><div class=\"line\">    maxAge: <span class=\"number\">5000</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">  res.redirect(<span class=\"string\">'/'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p><strong>Secure</strong>: HTTPS를 통해서만 쿠키가 전송되도록 설정</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// secure 옵션은 http 프로토콜을 통한 요청에는 쿠키가 포함되지 않게 합니다. (https로 했을 때만 포함시킴)</span></div><div class=\"line\">app.get(<span class=\"string\">'/secure'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  res.cookie(<span class=\"string\">'secureCookie'</span>, <span class=\"string\">'value'</span>, &#123;</div><div class=\"line\">    secure: <span class=\"literal\">true</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">  res.redirect(<span class=\"string\">'/'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p><strong>HttpOnly</strong>: 자바스크립트에서 쿠키를 읽지 못하도록 설정</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// httpOnly 옵션은 해당 쿠키를 자바스크립트에서 접근할 수 없게 합니다.</span></div><div class=\"line\">app.get(<span class=\"string\">'/httpOnly'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  res.cookie(<span class=\"string\">'httpOnlyCookie'</span>, <span class=\"string\">'value'</span>, &#123;</div><div class=\"line\">    httpOnly: <span class=\"literal\">true</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">  res.redirect(<span class=\"string\">'/'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p>자바스크립트에서 쿠키를 읽지 못하게 해야 하는 이유는 누군가 악의적으로 웹사이트의 게시글에 스크립트 태그를 심을 가능성이 있기 때문이다. 이를 Cross-site Scripting(XSS)이라고 한다. 만약 로그인정보가 포함되어 있다면 이 공격에 의해 로그인 정보가 유출되는 위험이 발생할 수 있다.</p><p><strong>Domain, Path</strong>: 쿠키의 scope 설정 (쿠키가 전송되는 URL을 제한)</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// domain 옵션은 해당 도메인 및 서브도메인으로 쿠키가 전송되도록 합니다.</span></div><div class=\"line\">app.get(<span class=\"string\">'/domain'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  res.cookie(<span class=\"string\">'domainCookie'</span>, <span class=\"string\">'value'</span>, &#123;</div><div class=\"line\">    domain: <span class=\"string\">'glitch.me'</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">  res.redirect(<span class=\"string\">'/'</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// path 옵션은 쿠키가 지정된 경로 및 그 하위 경로에 요청이 일어났을 때만 전송되도록 합니다.</span></div><div class=\"line\">app.get(<span class=\"string\">'/path'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  res.cookie(<span class=\"string\">'pathCookie'</span>, <span class=\"string\">'value'</span>, &#123;</div><div class=\"line\">    path: <span class=\"string\">'/somePath'</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">  res.redirect(<span class=\"string\">'/'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p><strong>multiple-options</strong>: 위 옵션들을 한번에 다중으로 지정할 수 있다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 여러 옵션을 한꺼번에 지정할 수도 있습니다.</span></div><div class=\"line\">app.get(<span class=\"string\">'/multiple-options'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  res.cookie(<span class=\"string\">'multipleOption'</span>, <span class=\"string\">'value'</span>, &#123;</div><div class=\"line\">    secure: <span class=\"literal\">true</span>,</div><div class=\"line\">    httpOnly: <span class=\"literal\">true</span>,</div><div class=\"line\">    maxAge: <span class=\"number\">5000</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">  res.redirect(<span class=\"string\">'/'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p><br></p><h4 id=\"4-Express-Cookie\"><a href=\"#4-Express-Cookie\" class=\"headerlink\" title=\"4. Express + Cookie\"></a>4. Express + Cookie</h4><p><strong>쿠키 읽기 - req.cookies</strong></p><p>요청에 실려온 쿠키가 객체로 변환되어 <code>req.cookies</code>에 저장됨 (<code>cookie-parser</code> 미들웨어 필요)</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// req.cookies를 사용하려면</span></div><div class=\"line\"><span class=\"comment\">// cookieParser라는 미들웨어가 필요하다.</span></div><div class=\"line\"><span class=\"keyword\">const</span> cookieParser = <span class=\"built_in\">require</span>(<span class=\"string\">'cookie-parser'</span>)</div><div class=\"line\">app.use(cookieParser())</div><div class=\"line\"></div><div class=\"line\">app.get(<span class=\"string\">'/'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  res.send(req.cookies)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">app.get(<span class=\"string\">'/somePath'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  res.send(req.cookies)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p><strong>쿠키 쓰기 - res.cookie(name, value)</strong></p><p>쿠키의 생성 혹은 수정</p><p><br></p><h4 id=\"5-쿠키-예제-Link\"><a href=\"#5-쿠키-예제-Link\" class=\"headerlink\" title=\"5. 쿠키 예제: Link\"></a>5. 쿠키 예제: <a href=\"https://glitch.com/edit/#!/wpsn-cookie-example\" target=\"_blank\" rel=\"external\">Link</a></h4><p><br></p><h2 id=\"JavaScript-Cookie\"><a href=\"#JavaScript-Cookie\" class=\"headerlink\" title=\"JavaScript + Cookie\"></a>JavaScript + Cookie</h2><p>자바스크립트로도 쿠키를 읽고 쓰는 방법이 존재하지만, 보안 상 문제를 일으킬 수 있으므로 이런 접근 방식은 거의 사용되지 않는다.</p><p>자바스크립트에서 쿠키에 접근하지 못하도록 <code>HttpOnly</code>를 항상 설정하는 것이 best practice</p><p><br></p><h2 id=\"쿠키의-한계점\"><a href=\"#쿠키의-한계점\" class=\"headerlink\" title=\"쿠키의 한계점\"></a>쿠키의 한계점</h2><ul><li><p>US-ASCII 밖에 저장하지 못해서 한글 표시가 안 된다. 한글 표시를 위해서 보통 percent encoding을 사용한다.</p></li><li><p>4000 바이트 내외(영문 4000자, percent encoding 된 한글 444자 가량)밖에 저장하지 못한다.</p></li><li><p>브라우저에 저장된다. 즉, 여러 브라우저에 걸쳐 공유되어야 하는 정보, 혹은 웹 브라우저가 아닌 클라이언트(모바일 앱)에 저장되어야 하는 정보를 다루기에는 부적절하다. (예를 들어 장바구니를 쿠키를 이용해서 구현하면, 다른 브라우저에서 켰을 때 보이지 않는 경우가 발생한다. 이런 한계가 존재하기 때문에, 쿠키로 모든 것을 다 할 수는 없다.)</p></li></ul>"},{"title":"[node] Middleware 미들웨어","date":"2017-09-09T09:04:11.000Z","_content":"\n![](http://allvectorlogo.com/img/2016/05/node-js-logo.png)\n\n# Express Middleware\n\n익스프레스는 개발자가 다양한 기능을 사용할 수 있도록 미리 만들어 둔 여러가지 미들웨어를 제공한다. npm을 통해서 다른 개발자들이 만든 미들웨어를 쉽게 다운 받아 사용할 수도 있다. 반대로 프로젝트 내에서 내가 직접 정의하고 로드(app.use)하여 사용하는 것도 가능하다.\n\n미들웨어 함수는 '요청 오브젝트(req)'와 '응답 오브젝트(res)', 그리고 애플리케이션의 요청-응답 주기 중 '다음 미들웨어 함수(next)'에 대한 액세스 권한을 갖는 함수이다.\n\n![middelware](../images/middleware.png)\n\n미들웨어는 인수로 요청 오브젝트(request 객체)와 응답 오브젝트(response 객체), next 함수를 인자로 받는다. 요청 오브젝트와 응답 오브젝트를 조작해서 기능을 구현하며, next 함수는 다음 미들웨어를 동작시키기 위해 사용되며, 인자 없이 호출된다.\n\n미들웨어는 기본적으로 **함수**이다. 따라서 내부에서 **어떤 작업이든** 가능하다. 미들웨어 함수로 수행하는 일은 아래와 같다.\n\n* 로깅\n* HTTP body를 객체로 변환\n* 사용자 인증\n* 권한 관리 등\n\n<br>\n\n## app.use()\n\n`app.use()`는 미들웨어 함수를 로드하기 위해 사용되는 메소드이다. 미들웨어 함수를 지정하고, `app.use()`를 통해 호출할 수 있다.\n\n```js\n//미들웨어 - 함수\nfunction helloMiddleware(res, req, next) {\n  console.log('hello');\n  next();\n}\n\napp.use(helloMiddleware);\n```\n\n위 예제는 hello를 콘솔에 출력하는 helloMiddleware 함수를 정의하고, `app.use()`를 통해 로드하였다. 위와 같은 로드 방식은 앱 전체에서 동작하게 하는 방식이다. 첫번째 인자로 경로를 지정하면, 특정 경로에서만 동작하게 할 수도 있다. 아래 예제를 참고하자.\n\n\n* 앱 전체에서 동작하게 하기\n\n```js\napp.use(helloMiddleware);\n```\n\n* 특정 경로에서만 동작하게 하기\n\n```js\n// some-path라는 경로 안에서만 동작하도록 로드\napp.use('/some-path', helloMiddleware);\n```\n\n* 한 번에 여러 개 로드하기\n\n```js\n// 다수의 미들웨어를 한번에 호출\napp.use(middleware1, middleware2, middleware3, ...)\n```\n\n## 호출 순서\n\n미들웨어의 실행 순서는 호출 순서에 의해 결정된다. 즉, 먼저 호출되는 것이 먼저 실행된다.\n\n```js\n// mylogger.js\n\nconst express = require('express');\n\nconst app = express();\n\nconst myLogger = (req, res, next) => {\n  console.log('LOGGED');\n  next();\n};\n\napp.use(myLogger);\n\napp.get('/', (req, res) => {\n  res.send('Hello World');\n});\n\napp.listen(3000);\n```\n\n```js\n// console\n% node mylogger.js\nLOGGED\n```\n\n위 예제는 라우팅 이전에 myLogger가 로드되었다. 실행하면 콘솔창에 LOGGED를 출력할 것이다.\n\n그런데 만약 myLogger가 라우팅 이후에 로드되었다면?\n\n```js\nconst express = require('express');\n\nconst app = express();\n\nconst myLogger = (req, res, next) => {\n  console.log('LOGGED');\n  next();\n};\n\n// 루트경로에 대한 라우팅\napp.get('/', (req, res) => {\n  res.send('Hello World');\n});\n\n// myLogger 미들웨어를 라우팅 이후에 로드하였다.\napp.use(myLogger);\n\napp.listen(3000);\n```\n\n이 경우, 루트 경로의 라우트 핸들러가 요청-응답 주기를 종료하므로 요청은 myLogger에 도달하지도 못한다. 따라서 LOGGED를 출력하지 않는다.\n\n```js\n// console\n% node mylogger.js\n// 아무것도 출력하지 않는다.\n```\n\n<br>\n\n## 자주 사용되는 미들웨어\n\n### 1. static 미들웨어\n\nstatic 미들웨어는 특정 폴더의 파일들을 특정 패스로 접근할 수 있도록 만들어준다.\n\nstatic 미들웨어는 외장 모듈로 만들어져 있기 때문에 npm을 통해 설치해야 한다. 터미널이나 명령 프롬프트(cmd)에서 아래 명령을 통해 설치한다.\n\n```bash\n$ npm install serve-static --save\n```\n\n아래는 static 사용의 예시이다. public 폴더에 있는 모든 파일을 웹 서버의 루트 패스로 접근할 수 있도록 하고 싶을 때 아래처럼 사용한다.\n\n```js\nconst static = require('serve-static');\n\n...\n\napp.use(static(path.join(__dirname, 'public')));\n```\n\n이 코드는 public 폴더 안에 있는 파일들을 클라이언트에서 바로 접근할 수 있게 한다. 예를 들어 프로젝트 폴더 안에 다음과 같은 폴더나 파일이 들어 있다면,\n\n```\nExpressExample/public/index.html\nExpressExample/public/house.png\nExpressExample/public/main.js\nExpressExample/public/style.css\n```\n\n웹 브라우저에서 다음과 같은 주소로 바로 접근할 수 있다.\n\n```\nhttp://localhost:3000/index.html\nhttp://localhost:3000/house.png\nhttp://localhost:3000/main.js\nhttp://localhost:3000/style.css\n```\n\n만약 파일을 사이트의 /public 패스로 접근하게 만들고 싶다면 위의 코드에서 첫번째 인자에 요청 패스 `/public`을 추가해주면 된다.\n\n```js\napp.use('/public', static(path.join(__dirname, 'public')));\n```\n<sub> * __dirname: 현재 디렉토리</sub>\n\n이렇게 하면 요청 패스와 특정 폴더(static 함수를 이용해 지정한 디렉터리)가 매핑(Mapping)되어 접근할 수 있게 된다.\n\n### 2. body-parser\n\n클라이언트의 요청(request) 방식에는 대표적으로 GET방식과 POST 방식이 있다.\nGET 방식은 주소 문자열에 요청 파라미터가 들어가므로 url을 통해 확인이 가능하다. 그에 반해 POST 방식은 본문인 Body 영역에 요청 파라미터가 들어간다. 따라서 GET 방식과는 다른 방식으로 요청 파라미터를 파싱해야 한다.\n\n`body-parser` 미들웨어는 POST 방식으로 요청할 때 body에 들어있는 요청 파라미터들을 파싱하여 request 객체의 body 속성에 넣어준다.\n\n`body-parser` 미들웨어 역시 외부 모듈이므로, npm을 통해 다운로드해야 사용할 수 있다.\n\n```bash\n$ npm install body-parser --save\n```\n\npublic 폴더 생성 후 그 안에login.html 파일을 생성한다.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>login test</title>\n</head>\n<body>\n  <h1>로그인</h1>\n  <form method=\"post\">\n    <table>\n      <tr>\n        <td><label>아이디</label></td>\n        <td><input type=\"text\" name=\"id\"></td>\n      </tr>\n      <tr>\n        <td><label>비밀번호</label></td>\n        <td><input type=\"text\" name = \"password\"></td>\n      </tr>\n    </table>\n    <input type=\"submit\" value=\"전송\" name=\"\">\n  </form>\n</body>\n</html>\n```\n\n```js\n// server.js\n\n// Express 기본 모듈 불러오기\nconst express = require('express');\nconst http = require('http');\nconst path = require('path');\n\n// Express의 미들웨어 불러오기\nconst bodyParser = require('body-parser');\nconst static = require('save-static');\n\n// 익스프레스 객체 생성\nconst app = express();\n\n// 기본 속성 설정\napp.set('port', process.env.PORT || 3000);\n\n// body-parser로 application/x-www-form-urlencoded 파싱\n// .urlencoded() 메소드를 호출하면서 미들웨어를 설정하면, 'application/x-www-form-urlencoded' 형식으로 전달된 요청 파라미터를 파싱할 수 있다.\n// 이 형식은 일반적인 요청 파라미터의 형식이다.\napp.use(bodyParser.urlencoded({ extended: false }));\n\n// body-parser를 사용해 application/json 파싱\n// .json() 메소드를 호출하면서 미들웨어를 설정하면 application/json 형식으로 전달된 요청 파라미터를 참조할 수 있다.\napp.use(bodyParser.json());\n\napp.use(static(path.join(__dirname, 'public')));\n\n// 미들웨어에서 파라미터 확인\napp.use((req, res, next) => {\n  console.log('첫번째 미들웨어에서 요청을 처리');\n\n  // body 안에 있는 요청 파라미터를 참조한다.\n  // 만약 클라이언트가 요청하는 방식이 GET 방식인지 POST 방식으로 요청할지 모른다면\n  // 두 가지 경우를 모두 고려해 두 가지 요청 파라미터를 모두 검사한다.\n  const paramId = req.body.id || req.query.id;\n  const paramPassword = req.body.password || req.query.password;\n\n  res.writeHead('200', {'Content-Type':'text/html;charset=utf-8'});\n  res.write('<h1>Express 서버에 응답한 결과입니다. </h1>');\n  res.write('<div><p>Param id: '+ paramId + '</p></div>');\n  res.write('<div><p>Param password: ' + paramPassword + '</p></div>');\n  res.end();\n});\n```\n\n```bash\n$ node server.js\n```\n\n```\nhttp://localhost:3000/login.html 접속\n```\n\n서버 코드에서 use() 메소드로 설정한 함수는 login.html 문서에 접근할 때는 호출되지 않는다. 처음에는 login.html 문서가 웹 브라우저에 보이고, 전송 버튼을 클릭해 POST로 요청했을 때 use() 메소드로 설정한 함수가 호출된다.\n\n전송 버튼을 누르면 POST 방식으로 요청을 보낼 때도 GET 방식과 마찬가지로 요청 파라미터를 확인할 수 있다.  \n\n<br>\n\n## Middleware를 사용하는 이유\n\n미들웨어로 할 수 있는 모든 일은 사실 라우트 핸들러에서도 할 수 있다. 그럼에도 미들웨어를 사용하는 이유는 여러 라우터에서 사용해야 하는 기능을 중복 작성하는 불편을 덜고, **코드를 재사용**하기 위함이다.\n\n## Middleware 생태계\n\n[Express resource](https://expressjs.com/ko/resources/middleware.html)\n[NPM search](https://www.npmjs.com/search?q=express+middleware)\n\n## 미들웨어 예제\n\nmiddlewares.js 파일에서 작성한 미들웨어를 server.js에서 불러와 사용하고 있다. 각각 어떤 방식으로 미들웨어를 사용하고 있는지 확인해보자.\n\n```js\n// middlewares.js\nexports.ipLoggingMiddleware = (req, res, next) => {\n  console.log(`request ip: ${req.ip}`)\n  next()\n}\n\nexports.urlLoggingMiddleware = (req, res, next) => {\n  console.log(`request url: ${req.originalUrl}`)\n  next()\n}\n\nexports.resLocalMiddleware = (req, res, next) => {\n  res.locals.myVar = 'FASTCAMPUS!'\n  next()\n}\n\nexports.lock = key => (req, res, next) => {\n  if (req.query.key === key) {\n    next()\n  } else {\n    res.status(403)\n    res.send('403 Forbidden')\n  }\n}\n```\n\n```js\n// server.js\nconst express = require('express')\nconst {\n  ipLoggingMiddleware, \n  urlLoggingMiddleware, \n  resLocalMiddleware,\n  lock\n} = require('./middlewares')\n\nconst app = express()\n\napp.set('view engine', 'ejs')\n\n// 앱 단위 미들웨어는 모든 라우트 핸들러에서 실행됩니다.\n// 미들웨어는 등록된 순서대로 실행됩니다.\n// 아래 미들웨어 적용 순서를 바꿔보세요.\napp.use(urlLoggingMiddleware)\napp.use(ipLoggingMiddleware)\n\n\n// 라우트 단위 미들웨어는 적용된 라우트에서만 실행됩니다.\napp.get('/', resLocalMiddleware, (req, res) => {\n  res.render('index.ejs')\n})\n\napp.get('/secret', lock('thisisthekey'), (req, res) => {\n  res.send('my secret is...')\n})\n\napp.listen(3000, function() {\n  console.log('listening...')\n})\n```\n\n```js\n// views/index.ejs\n<!DOCTYPE html>\n<html>\n  <head>\n  </head>\n  <body>\n    <div>\n      <%= myVar %>\n    </div>\n  </body>\n</html>\n```\n\n**next**\n\n미들웨어는 `req`, `res`에 더해서 `next`라는 함수를 추가로 인자로 받는다. `next` 함수를 호출하면 다음 미들웨어로 처리를 넘기는 효과가 있다. 만약에 미들웨어가 `next` 함수를 호출하지도 않고, 응답도 보내지 않으면 클라이언트는 응답을 받지 못하게 된다.\n\n**App Local, Response Local**\n\n`app.locals`와 `res.locals`는 특별한 객체를 담고 있다. 템플릿에서는 `res.render`를 통해 명시적으로 주입받지 않아도 저 두 객체의 속성에 바로 접근할 수 있다.\n\n템플릿을 가리지 않고 사용되는 정보들, 예를 들어 '현재 로그인 중인 사용자 정보' 같은 것을 `res.render`에 매번 인자로 넘기는 것은 귀찮을 뿐더러 빠뜨리기도 쉽다. 그런 정보들을 템플릿에서 쉽게 사용하기 위해 `app.locals`나 `res.locals`에 우리가 원하는 이름으로 속성을 주입할 수 있습니다.\n\n`app.locals`는 앱 단위로 공통적으로 쓰이는 정보를 담는 목적으로 사용된다. `res.locals`는 각 요청마다 달라지는 정보를 담는 목적으로 사용된다.\n\n`app.local` 객체를 조작하는 것은 매우 쉽다. `res` 객체는 매 요청마다 새로 생성되어 미들웨어 바깥에서 접근할 수 있는 방법이 없으므로, `res.locals`를 조작하려면 미들웨어를 사용해야 한다.\n\n## 미들웨어 VS 라우트 핸들러\n\n라우트 핸들러도 미들웨어이다. 즉, next 함수를 인자로 받는 것이 가능하다.\n\n```js\napp.get('/', (req, res, next) => {\n  if(!someCondition) {\n    next(); // 요청을 처리하지 않고 다른 핸들러로 넘긴다.\n  } else {\n    res.send('hello');\n  }\n});\n```\n\n**Example: custom 404**\n\n```js\n// views/404.ejs\nMy Awesome 404!\n```\n\n```js\n// 요청이 라우트 핸들러가 등록된 어떤 경로와도 일치하지 않을 때,\n// 맨 마지막 미들웨어를 실행시킬 수 있습니다. 이를 이용해 우리만의 404 페이지를 보여줄 수 있습니다.\n// [참고](http://expressjs.com/ko/starter/faq.html)\napp.use((req, res, next) => {\n  res.render('404.ejs')\n})\n```\n\n## 오류처리 미들웨어\n\n다른 미들웨어 함수와 정의하는 방법은 동일하지만, err라는 인수를 추가로 받는다는(총 4개의 인수) 차이가 있다.\n\n```js\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n```\n\n오류 처리 미들웨어는 다른 app.use() 및 라우트 호출을 정의한 후에 **마지막으로 정의**해야 한다.\n\n```js\nconst bodyParser = require('body-parser');\nconst methodOverride = require('method-override');\n\napp.use(bodyParser());\napp.use(methodOverride());\napp.use((err, req, res, next) => {\n  // logic\n});\n```\n\n미들웨어 함수 내부로부터의 응답은 HTML 오류 페이지, 단순 메시지, JSON 문자열 등으로, 클라이언트가 원하는 형식으로 설정할 수 있다.  \n\n오류처리 미들웨어 함수 역시 일반적인 미들웨어 함수처럼 직접 정의할 수 있다. 아래는 XHR을 이용한 요청 및 그렇지 않은 요청에 대한 오류처리 미들웨어 함수를 정의한 예이다.\n\n```js\nconst bodyParser = require('body-parser');\nconst methodOverride = require('method-override');\n\napp.use(bodyParser());\napp.use(methodOverride());\napp.use(logErrors);\napp.use(clientErrorHandler);\napp.use(errorHandler);\n```\n\nlogError는 요청 및 오류 정보를 stderr에 기록할 수 있다.\n\n```js\n// 오류정보를 기록하는 함수\nfunction logErrors (err, req, res, next) {\n  console.log(err.stack);\n  next(err);\n}\n```\n\n```js\n// 오류인 경우 500 error를 보내고 아닌 경우 다음 오류처리 미들웨어로 넘기는 함수\nfunction clientErrorHandler(err, req, res, next) {\n  if(req.xhr) {\n    res.status(500).send({ error: 'Something failed!'});\n  } else {\n    next(err);\n  }\n}\n```\n모든 오류를 처리하는(catch-all) errorHandler 함수는 다음과 같이 구현할 수 있다.\n\n```js\nfunction errorHandler(err, req, res, next) {\n  res.status(500);\n  res.render('error', { error: err });\n}\n```\n\n\n---\n\n[expressjs.com](http://expressjs.com/ko/guide/writing-middleware.html)\n\n[expressjs.com - 오류처리 미들웨어](https://expressjs.com/ko/guide/error-handling.html)\n\n[강사님 강의자료](seungha-kim.github.io)\n\n[참고서적: Do it! Node.js 프로그래밍](http://www.easyspub.co.kr/20_Menu/BookView/A001/127/PUB)\n","source":"_posts/nodejs/07.Express Middleware.md","raw":"---\ntitle: '[node] Middleware 미들웨어'\ndate: 2017-09-09 18:04:11\ncategory: Nodejs\ntags: middleware\n---\n\n![](http://allvectorlogo.com/img/2016/05/node-js-logo.png)\n\n# Express Middleware\n\n익스프레스는 개발자가 다양한 기능을 사용할 수 있도록 미리 만들어 둔 여러가지 미들웨어를 제공한다. npm을 통해서 다른 개발자들이 만든 미들웨어를 쉽게 다운 받아 사용할 수도 있다. 반대로 프로젝트 내에서 내가 직접 정의하고 로드(app.use)하여 사용하는 것도 가능하다.\n\n미들웨어 함수는 '요청 오브젝트(req)'와 '응답 오브젝트(res)', 그리고 애플리케이션의 요청-응답 주기 중 '다음 미들웨어 함수(next)'에 대한 액세스 권한을 갖는 함수이다.\n\n![middelware](../images/middleware.png)\n\n미들웨어는 인수로 요청 오브젝트(request 객체)와 응답 오브젝트(response 객체), next 함수를 인자로 받는다. 요청 오브젝트와 응답 오브젝트를 조작해서 기능을 구현하며, next 함수는 다음 미들웨어를 동작시키기 위해 사용되며, 인자 없이 호출된다.\n\n미들웨어는 기본적으로 **함수**이다. 따라서 내부에서 **어떤 작업이든** 가능하다. 미들웨어 함수로 수행하는 일은 아래와 같다.\n\n* 로깅\n* HTTP body를 객체로 변환\n* 사용자 인증\n* 권한 관리 등\n\n<br>\n\n## app.use()\n\n`app.use()`는 미들웨어 함수를 로드하기 위해 사용되는 메소드이다. 미들웨어 함수를 지정하고, `app.use()`를 통해 호출할 수 있다.\n\n```js\n//미들웨어 - 함수\nfunction helloMiddleware(res, req, next) {\n  console.log('hello');\n  next();\n}\n\napp.use(helloMiddleware);\n```\n\n위 예제는 hello를 콘솔에 출력하는 helloMiddleware 함수를 정의하고, `app.use()`를 통해 로드하였다. 위와 같은 로드 방식은 앱 전체에서 동작하게 하는 방식이다. 첫번째 인자로 경로를 지정하면, 특정 경로에서만 동작하게 할 수도 있다. 아래 예제를 참고하자.\n\n\n* 앱 전체에서 동작하게 하기\n\n```js\napp.use(helloMiddleware);\n```\n\n* 특정 경로에서만 동작하게 하기\n\n```js\n// some-path라는 경로 안에서만 동작하도록 로드\napp.use('/some-path', helloMiddleware);\n```\n\n* 한 번에 여러 개 로드하기\n\n```js\n// 다수의 미들웨어를 한번에 호출\napp.use(middleware1, middleware2, middleware3, ...)\n```\n\n## 호출 순서\n\n미들웨어의 실행 순서는 호출 순서에 의해 결정된다. 즉, 먼저 호출되는 것이 먼저 실행된다.\n\n```js\n// mylogger.js\n\nconst express = require('express');\n\nconst app = express();\n\nconst myLogger = (req, res, next) => {\n  console.log('LOGGED');\n  next();\n};\n\napp.use(myLogger);\n\napp.get('/', (req, res) => {\n  res.send('Hello World');\n});\n\napp.listen(3000);\n```\n\n```js\n// console\n% node mylogger.js\nLOGGED\n```\n\n위 예제는 라우팅 이전에 myLogger가 로드되었다. 실행하면 콘솔창에 LOGGED를 출력할 것이다.\n\n그런데 만약 myLogger가 라우팅 이후에 로드되었다면?\n\n```js\nconst express = require('express');\n\nconst app = express();\n\nconst myLogger = (req, res, next) => {\n  console.log('LOGGED');\n  next();\n};\n\n// 루트경로에 대한 라우팅\napp.get('/', (req, res) => {\n  res.send('Hello World');\n});\n\n// myLogger 미들웨어를 라우팅 이후에 로드하였다.\napp.use(myLogger);\n\napp.listen(3000);\n```\n\n이 경우, 루트 경로의 라우트 핸들러가 요청-응답 주기를 종료하므로 요청은 myLogger에 도달하지도 못한다. 따라서 LOGGED를 출력하지 않는다.\n\n```js\n// console\n% node mylogger.js\n// 아무것도 출력하지 않는다.\n```\n\n<br>\n\n## 자주 사용되는 미들웨어\n\n### 1. static 미들웨어\n\nstatic 미들웨어는 특정 폴더의 파일들을 특정 패스로 접근할 수 있도록 만들어준다.\n\nstatic 미들웨어는 외장 모듈로 만들어져 있기 때문에 npm을 통해 설치해야 한다. 터미널이나 명령 프롬프트(cmd)에서 아래 명령을 통해 설치한다.\n\n```bash\n$ npm install serve-static --save\n```\n\n아래는 static 사용의 예시이다. public 폴더에 있는 모든 파일을 웹 서버의 루트 패스로 접근할 수 있도록 하고 싶을 때 아래처럼 사용한다.\n\n```js\nconst static = require('serve-static');\n\n...\n\napp.use(static(path.join(__dirname, 'public')));\n```\n\n이 코드는 public 폴더 안에 있는 파일들을 클라이언트에서 바로 접근할 수 있게 한다. 예를 들어 프로젝트 폴더 안에 다음과 같은 폴더나 파일이 들어 있다면,\n\n```\nExpressExample/public/index.html\nExpressExample/public/house.png\nExpressExample/public/main.js\nExpressExample/public/style.css\n```\n\n웹 브라우저에서 다음과 같은 주소로 바로 접근할 수 있다.\n\n```\nhttp://localhost:3000/index.html\nhttp://localhost:3000/house.png\nhttp://localhost:3000/main.js\nhttp://localhost:3000/style.css\n```\n\n만약 파일을 사이트의 /public 패스로 접근하게 만들고 싶다면 위의 코드에서 첫번째 인자에 요청 패스 `/public`을 추가해주면 된다.\n\n```js\napp.use('/public', static(path.join(__dirname, 'public')));\n```\n<sub> * __dirname: 현재 디렉토리</sub>\n\n이렇게 하면 요청 패스와 특정 폴더(static 함수를 이용해 지정한 디렉터리)가 매핑(Mapping)되어 접근할 수 있게 된다.\n\n### 2. body-parser\n\n클라이언트의 요청(request) 방식에는 대표적으로 GET방식과 POST 방식이 있다.\nGET 방식은 주소 문자열에 요청 파라미터가 들어가므로 url을 통해 확인이 가능하다. 그에 반해 POST 방식은 본문인 Body 영역에 요청 파라미터가 들어간다. 따라서 GET 방식과는 다른 방식으로 요청 파라미터를 파싱해야 한다.\n\n`body-parser` 미들웨어는 POST 방식으로 요청할 때 body에 들어있는 요청 파라미터들을 파싱하여 request 객체의 body 속성에 넣어준다.\n\n`body-parser` 미들웨어 역시 외부 모듈이므로, npm을 통해 다운로드해야 사용할 수 있다.\n\n```bash\n$ npm install body-parser --save\n```\n\npublic 폴더 생성 후 그 안에login.html 파일을 생성한다.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>login test</title>\n</head>\n<body>\n  <h1>로그인</h1>\n  <form method=\"post\">\n    <table>\n      <tr>\n        <td><label>아이디</label></td>\n        <td><input type=\"text\" name=\"id\"></td>\n      </tr>\n      <tr>\n        <td><label>비밀번호</label></td>\n        <td><input type=\"text\" name = \"password\"></td>\n      </tr>\n    </table>\n    <input type=\"submit\" value=\"전송\" name=\"\">\n  </form>\n</body>\n</html>\n```\n\n```js\n// server.js\n\n// Express 기본 모듈 불러오기\nconst express = require('express');\nconst http = require('http');\nconst path = require('path');\n\n// Express의 미들웨어 불러오기\nconst bodyParser = require('body-parser');\nconst static = require('save-static');\n\n// 익스프레스 객체 생성\nconst app = express();\n\n// 기본 속성 설정\napp.set('port', process.env.PORT || 3000);\n\n// body-parser로 application/x-www-form-urlencoded 파싱\n// .urlencoded() 메소드를 호출하면서 미들웨어를 설정하면, 'application/x-www-form-urlencoded' 형식으로 전달된 요청 파라미터를 파싱할 수 있다.\n// 이 형식은 일반적인 요청 파라미터의 형식이다.\napp.use(bodyParser.urlencoded({ extended: false }));\n\n// body-parser를 사용해 application/json 파싱\n// .json() 메소드를 호출하면서 미들웨어를 설정하면 application/json 형식으로 전달된 요청 파라미터를 참조할 수 있다.\napp.use(bodyParser.json());\n\napp.use(static(path.join(__dirname, 'public')));\n\n// 미들웨어에서 파라미터 확인\napp.use((req, res, next) => {\n  console.log('첫번째 미들웨어에서 요청을 처리');\n\n  // body 안에 있는 요청 파라미터를 참조한다.\n  // 만약 클라이언트가 요청하는 방식이 GET 방식인지 POST 방식으로 요청할지 모른다면\n  // 두 가지 경우를 모두 고려해 두 가지 요청 파라미터를 모두 검사한다.\n  const paramId = req.body.id || req.query.id;\n  const paramPassword = req.body.password || req.query.password;\n\n  res.writeHead('200', {'Content-Type':'text/html;charset=utf-8'});\n  res.write('<h1>Express 서버에 응답한 결과입니다. </h1>');\n  res.write('<div><p>Param id: '+ paramId + '</p></div>');\n  res.write('<div><p>Param password: ' + paramPassword + '</p></div>');\n  res.end();\n});\n```\n\n```bash\n$ node server.js\n```\n\n```\nhttp://localhost:3000/login.html 접속\n```\n\n서버 코드에서 use() 메소드로 설정한 함수는 login.html 문서에 접근할 때는 호출되지 않는다. 처음에는 login.html 문서가 웹 브라우저에 보이고, 전송 버튼을 클릭해 POST로 요청했을 때 use() 메소드로 설정한 함수가 호출된다.\n\n전송 버튼을 누르면 POST 방식으로 요청을 보낼 때도 GET 방식과 마찬가지로 요청 파라미터를 확인할 수 있다.  \n\n<br>\n\n## Middleware를 사용하는 이유\n\n미들웨어로 할 수 있는 모든 일은 사실 라우트 핸들러에서도 할 수 있다. 그럼에도 미들웨어를 사용하는 이유는 여러 라우터에서 사용해야 하는 기능을 중복 작성하는 불편을 덜고, **코드를 재사용**하기 위함이다.\n\n## Middleware 생태계\n\n[Express resource](https://expressjs.com/ko/resources/middleware.html)\n[NPM search](https://www.npmjs.com/search?q=express+middleware)\n\n## 미들웨어 예제\n\nmiddlewares.js 파일에서 작성한 미들웨어를 server.js에서 불러와 사용하고 있다. 각각 어떤 방식으로 미들웨어를 사용하고 있는지 확인해보자.\n\n```js\n// middlewares.js\nexports.ipLoggingMiddleware = (req, res, next) => {\n  console.log(`request ip: ${req.ip}`)\n  next()\n}\n\nexports.urlLoggingMiddleware = (req, res, next) => {\n  console.log(`request url: ${req.originalUrl}`)\n  next()\n}\n\nexports.resLocalMiddleware = (req, res, next) => {\n  res.locals.myVar = 'FASTCAMPUS!'\n  next()\n}\n\nexports.lock = key => (req, res, next) => {\n  if (req.query.key === key) {\n    next()\n  } else {\n    res.status(403)\n    res.send('403 Forbidden')\n  }\n}\n```\n\n```js\n// server.js\nconst express = require('express')\nconst {\n  ipLoggingMiddleware, \n  urlLoggingMiddleware, \n  resLocalMiddleware,\n  lock\n} = require('./middlewares')\n\nconst app = express()\n\napp.set('view engine', 'ejs')\n\n// 앱 단위 미들웨어는 모든 라우트 핸들러에서 실행됩니다.\n// 미들웨어는 등록된 순서대로 실행됩니다.\n// 아래 미들웨어 적용 순서를 바꿔보세요.\napp.use(urlLoggingMiddleware)\napp.use(ipLoggingMiddleware)\n\n\n// 라우트 단위 미들웨어는 적용된 라우트에서만 실행됩니다.\napp.get('/', resLocalMiddleware, (req, res) => {\n  res.render('index.ejs')\n})\n\napp.get('/secret', lock('thisisthekey'), (req, res) => {\n  res.send('my secret is...')\n})\n\napp.listen(3000, function() {\n  console.log('listening...')\n})\n```\n\n```js\n// views/index.ejs\n<!DOCTYPE html>\n<html>\n  <head>\n  </head>\n  <body>\n    <div>\n      <%= myVar %>\n    </div>\n  </body>\n</html>\n```\n\n**next**\n\n미들웨어는 `req`, `res`에 더해서 `next`라는 함수를 추가로 인자로 받는다. `next` 함수를 호출하면 다음 미들웨어로 처리를 넘기는 효과가 있다. 만약에 미들웨어가 `next` 함수를 호출하지도 않고, 응답도 보내지 않으면 클라이언트는 응답을 받지 못하게 된다.\n\n**App Local, Response Local**\n\n`app.locals`와 `res.locals`는 특별한 객체를 담고 있다. 템플릿에서는 `res.render`를 통해 명시적으로 주입받지 않아도 저 두 객체의 속성에 바로 접근할 수 있다.\n\n템플릿을 가리지 않고 사용되는 정보들, 예를 들어 '현재 로그인 중인 사용자 정보' 같은 것을 `res.render`에 매번 인자로 넘기는 것은 귀찮을 뿐더러 빠뜨리기도 쉽다. 그런 정보들을 템플릿에서 쉽게 사용하기 위해 `app.locals`나 `res.locals`에 우리가 원하는 이름으로 속성을 주입할 수 있습니다.\n\n`app.locals`는 앱 단위로 공통적으로 쓰이는 정보를 담는 목적으로 사용된다. `res.locals`는 각 요청마다 달라지는 정보를 담는 목적으로 사용된다.\n\n`app.local` 객체를 조작하는 것은 매우 쉽다. `res` 객체는 매 요청마다 새로 생성되어 미들웨어 바깥에서 접근할 수 있는 방법이 없으므로, `res.locals`를 조작하려면 미들웨어를 사용해야 한다.\n\n## 미들웨어 VS 라우트 핸들러\n\n라우트 핸들러도 미들웨어이다. 즉, next 함수를 인자로 받는 것이 가능하다.\n\n```js\napp.get('/', (req, res, next) => {\n  if(!someCondition) {\n    next(); // 요청을 처리하지 않고 다른 핸들러로 넘긴다.\n  } else {\n    res.send('hello');\n  }\n});\n```\n\n**Example: custom 404**\n\n```js\n// views/404.ejs\nMy Awesome 404!\n```\n\n```js\n// 요청이 라우트 핸들러가 등록된 어떤 경로와도 일치하지 않을 때,\n// 맨 마지막 미들웨어를 실행시킬 수 있습니다. 이를 이용해 우리만의 404 페이지를 보여줄 수 있습니다.\n// [참고](http://expressjs.com/ko/starter/faq.html)\napp.use((req, res, next) => {\n  res.render('404.ejs')\n})\n```\n\n## 오류처리 미들웨어\n\n다른 미들웨어 함수와 정의하는 방법은 동일하지만, err라는 인수를 추가로 받는다는(총 4개의 인수) 차이가 있다.\n\n```js\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n```\n\n오류 처리 미들웨어는 다른 app.use() 및 라우트 호출을 정의한 후에 **마지막으로 정의**해야 한다.\n\n```js\nconst bodyParser = require('body-parser');\nconst methodOverride = require('method-override');\n\napp.use(bodyParser());\napp.use(methodOverride());\napp.use((err, req, res, next) => {\n  // logic\n});\n```\n\n미들웨어 함수 내부로부터의 응답은 HTML 오류 페이지, 단순 메시지, JSON 문자열 등으로, 클라이언트가 원하는 형식으로 설정할 수 있다.  \n\n오류처리 미들웨어 함수 역시 일반적인 미들웨어 함수처럼 직접 정의할 수 있다. 아래는 XHR을 이용한 요청 및 그렇지 않은 요청에 대한 오류처리 미들웨어 함수를 정의한 예이다.\n\n```js\nconst bodyParser = require('body-parser');\nconst methodOverride = require('method-override');\n\napp.use(bodyParser());\napp.use(methodOverride());\napp.use(logErrors);\napp.use(clientErrorHandler);\napp.use(errorHandler);\n```\n\nlogError는 요청 및 오류 정보를 stderr에 기록할 수 있다.\n\n```js\n// 오류정보를 기록하는 함수\nfunction logErrors (err, req, res, next) {\n  console.log(err.stack);\n  next(err);\n}\n```\n\n```js\n// 오류인 경우 500 error를 보내고 아닌 경우 다음 오류처리 미들웨어로 넘기는 함수\nfunction clientErrorHandler(err, req, res, next) {\n  if(req.xhr) {\n    res.status(500).send({ error: 'Something failed!'});\n  } else {\n    next(err);\n  }\n}\n```\n모든 오류를 처리하는(catch-all) errorHandler 함수는 다음과 같이 구현할 수 있다.\n\n```js\nfunction errorHandler(err, req, res, next) {\n  res.status(500);\n  res.render('error', { error: err });\n}\n```\n\n\n---\n\n[expressjs.com](http://expressjs.com/ko/guide/writing-middleware.html)\n\n[expressjs.com - 오류처리 미들웨어](https://expressjs.com/ko/guide/error-handling.html)\n\n[강사님 강의자료](seungha-kim.github.io)\n\n[참고서적: Do it! Node.js 프로그래밍](http://www.easyspub.co.kr/20_Menu/BookView/A001/127/PUB)\n","slug":"nodejs/07.Express Middleware","published":1,"updated":"2017-09-21T06:06:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjai8h18p001hvb9q5vfx0nsq","content":"<p><img src=\"http://allvectorlogo.com/img/2016/05/node-js-logo.png\" alt=\"\"></p><h1 id=\"Express-Middleware\"><a href=\"#Express-Middleware\" class=\"headerlink\" title=\"Express Middleware\"></a>Express Middleware</h1><p>익스프레스는 개발자가 다양한 기능을 사용할 수 있도록 미리 만들어 둔 여러가지 미들웨어를 제공한다. npm을 통해서 다른 개발자들이 만든 미들웨어를 쉽게 다운 받아 사용할 수도 있다. 반대로 프로젝트 내에서 내가 직접 정의하고 로드(app.use)하여 사용하는 것도 가능하다.</p><p>미들웨어 함수는 ‘요청 오브젝트(req)’와 ‘응답 오브젝트(res)’, 그리고 애플리케이션의 요청-응답 주기 중 ‘다음 미들웨어 함수(next)’에 대한 액세스 권한을 갖는 함수이다.</p><p><img src=\"../images/middleware.png\" alt=\"middelware\"></p><p>미들웨어는 인수로 요청 오브젝트(request 객체)와 응답 오브젝트(response 객체), next 함수를 인자로 받는다. 요청 오브젝트와 응답 오브젝트를 조작해서 기능을 구현하며, next 함수는 다음 미들웨어를 동작시키기 위해 사용되며, 인자 없이 호출된다.</p><p>미들웨어는 기본적으로 <strong>함수</strong>이다. 따라서 내부에서 <strong>어떤 작업이든</strong> 가능하다. 미들웨어 함수로 수행하는 일은 아래와 같다.</p><ul><li>로깅</li><li>HTTP body를 객체로 변환</li><li>사용자 인증</li><li>권한 관리 등</li></ul><p><br></p><h2 id=\"app-use\"><a href=\"#app-use\" class=\"headerlink\" title=\"app.use()\"></a>app.use()</h2><p><code>app.use()</code>는 미들웨어 함수를 로드하기 위해 사용되는 메소드이다. 미들웨어 함수를 지정하고, <code>app.use()</code>를 통해 호출할 수 있다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//미들웨어 - 함수</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">helloMiddleware</span>(<span class=\"params\">res, req, next</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>);</div><div class=\"line\">  next();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">app.use(helloMiddleware);</div></pre></td></tr></table></figure><p>위 예제는 hello를 콘솔에 출력하는 helloMiddleware 함수를 정의하고, <code>app.use()</code>를 통해 로드하였다. 위와 같은 로드 방식은 앱 전체에서 동작하게 하는 방식이다. 첫번째 인자로 경로를 지정하면, 특정 경로에서만 동작하게 할 수도 있다. 아래 예제를 참고하자.</p><ul><li>앱 전체에서 동작하게 하기</li></ul><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.use(helloMiddleware);</div></pre></td></tr></table></figure><ul><li>특정 경로에서만 동작하게 하기</li></ul><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// some-path라는 경로 안에서만 동작하도록 로드</span></div><div class=\"line\">app.use(<span class=\"string\">'/some-path'</span>, helloMiddleware);</div></pre></td></tr></table></figure><ul><li>한 번에 여러 개 로드하기</li></ul><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 다수의 미들웨어를 한번에 호출</span></div><div class=\"line\">app.use(middleware1, middleware2, middleware3, ...)</div></pre></td></tr></table></figure><h2 id=\"호출-순서\"><a href=\"#호출-순서\" class=\"headerlink\" title=\"호출 순서\"></a>호출 순서</h2><p>미들웨어의 실행 순서는 호출 순서에 의해 결정된다. 즉, 먼저 호출되는 것이 먼저 실행된다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// mylogger.js</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> app = express();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> myLogger = <span class=\"function\">(<span class=\"params\">req, res, next</span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'LOGGED'</span>);</div><div class=\"line\">  next();</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">app.use(myLogger);</div><div class=\"line\"></div><div class=\"line\">app.get(<span class=\"string\">'/'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  res.send(<span class=\"string\">'Hello World'</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">app.listen(<span class=\"number\">3000</span>);</div></pre></td></tr></table></figure><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// console</span></div><div class=\"line\">% node mylogger.js</div><div class=\"line\">LOGGED</div></pre></td></tr></table></figure><p>위 예제는 라우팅 이전에 myLogger가 로드되었다. 실행하면 콘솔창에 LOGGED를 출력할 것이다.</p><p>그런데 만약 myLogger가 라우팅 이후에 로드되었다면?</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> app = express();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> myLogger = <span class=\"function\">(<span class=\"params\">req, res, next</span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'LOGGED'</span>);</div><div class=\"line\">  next();</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 루트경로에 대한 라우팅</span></div><div class=\"line\">app.get(<span class=\"string\">'/'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  res.send(<span class=\"string\">'Hello World'</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// myLogger 미들웨어를 라우팅 이후에 로드하였다.</span></div><div class=\"line\">app.use(myLogger);</div><div class=\"line\"></div><div class=\"line\">app.listen(<span class=\"number\">3000</span>);</div></pre></td></tr></table></figure><p>이 경우, 루트 경로의 라우트 핸들러가 요청-응답 주기를 종료하므로 요청은 myLogger에 도달하지도 못한다. 따라서 LOGGED를 출력하지 않는다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// console</span></div><div class=\"line\">% node mylogger.js</div><div class=\"line\"><span class=\"comment\">// 아무것도 출력하지 않는다.</span></div></pre></td></tr></table></figure><p><br></p><h2 id=\"자주-사용되는-미들웨어\"><a href=\"#자주-사용되는-미들웨어\" class=\"headerlink\" title=\"자주 사용되는 미들웨어\"></a>자주 사용되는 미들웨어</h2><h3 id=\"1-static-미들웨어\"><a href=\"#1-static-미들웨어\" class=\"headerlink\" title=\"1. static 미들웨어\"></a>1. static 미들웨어</h3><p>static 미들웨어는 특정 폴더의 파일들을 특정 패스로 접근할 수 있도록 만들어준다.</p><p>static 미들웨어는 외장 모듈로 만들어져 있기 때문에 npm을 통해 설치해야 한다. 터미널이나 명령 프롬프트(cmd)에서 아래 명령을 통해 설치한다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install serve-static --save</div></pre></td></tr></table></figure><p>아래는 static 사용의 예시이다. public 폴더에 있는 모든 파일을 웹 서버의 루트 패스로 접근할 수 있도록 하고 싶을 때 아래처럼 사용한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">static</span> = <span class=\"built_in\">require</span>(<span class=\"string\">'serve-static'</span>);</div><div class=\"line\"></div><div class=\"line\">...</div><div class=\"line\"></div><div class=\"line\">app.use(<span class=\"keyword\">static</span>(path.join(__dirname, <span class=\"string\">'public'</span>)));</div></pre></td></tr></table></figure><p>이 코드는 public 폴더 안에 있는 파일들을 클라이언트에서 바로 접근할 수 있게 한다. 예를 들어 프로젝트 폴더 안에 다음과 같은 폴더나 파일이 들어 있다면,</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ExpressExample/public/index.html</div><div class=\"line\">ExpressExample/public/house.png</div><div class=\"line\">ExpressExample/public/main.js</div><div class=\"line\">ExpressExample/public/style.css</div></pre></td></tr></table></figure><p>웹 브라우저에서 다음과 같은 주소로 바로 접근할 수 있다.</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://localhost:3000/index.html</div><div class=\"line\">http://localhost:3000/house.png</div><div class=\"line\">http://localhost:3000/main.js</div><div class=\"line\">http://localhost:3000/style.css</div></pre></td></tr></table></figure><p>만약 파일을 사이트의 /public 패스로 접근하게 만들고 싶다면 위의 코드에서 첫번째 인자에 요청 패스 <code>/public</code>을 추가해주면 된다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.use(<span class=\"string\">'/public'</span>, <span class=\"keyword\">static</span>(path.join(__dirname, <span class=\"string\">'public'</span>)));</div></pre></td></tr></table></figure><p><sub>* __dirname: 현재 디렉토리</sub></p><p>이렇게 하면 요청 패스와 특정 폴더(static 함수를 이용해 지정한 디렉터리)가 매핑(Mapping)되어 접근할 수 있게 된다.</p><h3 id=\"2-body-parser\"><a href=\"#2-body-parser\" class=\"headerlink\" title=\"2. body-parser\"></a>2. body-parser</h3><p>클라이언트의 요청(request) 방식에는 대표적으로 GET방식과 POST 방식이 있다.<br>GET 방식은 주소 문자열에 요청 파라미터가 들어가므로 url을 통해 확인이 가능하다. 그에 반해 POST 방식은 본문인 Body 영역에 요청 파라미터가 들어간다. 따라서 GET 방식과는 다른 방식으로 요청 파라미터를 파싱해야 한다.</p><p><code>body-parser</code> 미들웨어는 POST 방식으로 요청할 때 body에 들어있는 요청 파라미터들을 파싱하여 request 객체의 body 속성에 넣어준다.</p><p><code>body-parser</code> 미들웨어 역시 외부 모듈이므로, npm을 통해 다운로드해야 사용할 수 있다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install body-parser --save</div></pre></td></tr></table></figure><p>public 폴더 생성 후 그 안에login.html 파일을 생성한다.</p><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"ie=edge\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>login test<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>로그인<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">method</span>=<span class=\"string\">\"post\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">table</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>아이디<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"id\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>비밀번호<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span> = <span class=\"string\">\"password\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"전송\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// server.js</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Express 기본 모듈 불러오기</span></div><div class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Express의 미들웨어 불러오기</span></div><div class=\"line\"><span class=\"keyword\">const</span> bodyParser = <span class=\"built_in\">require</span>(<span class=\"string\">'body-parser'</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">static</span> = <span class=\"built_in\">require</span>(<span class=\"string\">'save-static'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 익스프레스 객체 생성</span></div><div class=\"line\"><span class=\"keyword\">const</span> app = express();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 기본 속성 설정</span></div><div class=\"line\">app.set(<span class=\"string\">'port'</span>, process.env.PORT || <span class=\"number\">3000</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// body-parser로 application/x-www-form-urlencoded 파싱</span></div><div class=\"line\"><span class=\"comment\">// .urlencoded() 메소드를 호출하면서 미들웨어를 설정하면, 'application/x-www-form-urlencoded' 형식으로 전달된 요청 파라미터를 파싱할 수 있다.</span></div><div class=\"line\"><span class=\"comment\">// 이 형식은 일반적인 요청 파라미터의 형식이다.</span></div><div class=\"line\">app.use(bodyParser.urlencoded(&#123; <span class=\"attr\">extended</span>: <span class=\"literal\">false</span> &#125;));</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// body-parser를 사용해 application/json 파싱</span></div><div class=\"line\"><span class=\"comment\">// .json() 메소드를 호출하면서 미들웨어를 설정하면 application/json 형식으로 전달된 요청 파라미터를 참조할 수 있다.</span></div><div class=\"line\">app.use(bodyParser.json());</div><div class=\"line\"></div><div class=\"line\">app.use(<span class=\"keyword\">static</span>(path.join(__dirname, <span class=\"string\">'public'</span>)));</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 미들웨어에서 파라미터 확인</span></div><div class=\"line\">app.use(<span class=\"function\">(<span class=\"params\">req, res, next</span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'첫번째 미들웨어에서 요청을 처리'</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// body 안에 있는 요청 파라미터를 참조한다.</span></div><div class=\"line\">  <span class=\"comment\">// 만약 클라이언트가 요청하는 방식이 GET 방식인지 POST 방식으로 요청할지 모른다면</span></div><div class=\"line\">  <span class=\"comment\">// 두 가지 경우를 모두 고려해 두 가지 요청 파라미터를 모두 검사한다.</span></div><div class=\"line\">  <span class=\"keyword\">const</span> paramId = req.body.id || req.query.id;</div><div class=\"line\">  <span class=\"keyword\">const</span> paramPassword = req.body.password || req.query.password;</div><div class=\"line\"></div><div class=\"line\">  res.writeHead(<span class=\"string\">'200'</span>, &#123;<span class=\"string\">'Content-Type'</span>:<span class=\"string\">'text/html;charset=utf-8'</span>&#125;);</div><div class=\"line\">  res.write(<span class=\"string\">'&lt;h1&gt;Express 서버에 응답한 결과입니다. &lt;/h1&gt;'</span>);</div><div class=\"line\">  res.write(<span class=\"string\">'&lt;div&gt;&lt;p&gt;Param id: '</span>+ paramId + <span class=\"string\">'&lt;/p&gt;&lt;/div&gt;'</span>);</div><div class=\"line\">  res.write(<span class=\"string\">'&lt;div&gt;&lt;p&gt;Param password: '</span> + paramPassword + <span class=\"string\">'&lt;/p&gt;&lt;/div&gt;'</span>);</div><div class=\"line\">  res.end();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ node server.js</div></pre></td></tr></table></figure><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://localhost:3000/login.html 접속</div></pre></td></tr></table></figure><p>서버 코드에서 use() 메소드로 설정한 함수는 login.html 문서에 접근할 때는 호출되지 않는다. 처음에는 login.html 문서가 웹 브라우저에 보이고, 전송 버튼을 클릭해 POST로 요청했을 때 use() 메소드로 설정한 함수가 호출된다.</p><p>전송 버튼을 누르면 POST 방식으로 요청을 보낼 때도 GET 방식과 마찬가지로 요청 파라미터를 확인할 수 있다.</p><p><br></p><h2 id=\"Middleware를-사용하는-이유\"><a href=\"#Middleware를-사용하는-이유\" class=\"headerlink\" title=\"Middleware를 사용하는 이유\"></a>Middleware를 사용하는 이유</h2><p>미들웨어로 할 수 있는 모든 일은 사실 라우트 핸들러에서도 할 수 있다. 그럼에도 미들웨어를 사용하는 이유는 여러 라우터에서 사용해야 하는 기능을 중복 작성하는 불편을 덜고, <strong>코드를 재사용</strong>하기 위함이다.</p><h2 id=\"Middleware-생태계\"><a href=\"#Middleware-생태계\" class=\"headerlink\" title=\"Middleware 생태계\"></a>Middleware 생태계</h2><p><a href=\"https://expressjs.com/ko/resources/middleware.html\" target=\"_blank\" rel=\"external\">Express resource</a><br><a href=\"https://www.npmjs.com/search?q=express+middleware\" target=\"_blank\" rel=\"external\">NPM search</a></p><h2 id=\"미들웨어-예제\"><a href=\"#미들웨어-예제\" class=\"headerlink\" title=\"미들웨어 예제\"></a>미들웨어 예제</h2><p>middlewares.js 파일에서 작성한 미들웨어를 server.js에서 불러와 사용하고 있다. 각각 어떤 방식으로 미들웨어를 사용하고 있는지 확인해보자.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// middlewares.js</span></div><div class=\"line\">exports.ipLoggingMiddleware = <span class=\"function\">(<span class=\"params\">req, res, next</span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`request ip: <span class=\"subst\">$&#123;req.ip&#125;</span>`</span>)</div><div class=\"line\">  next()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.urlLoggingMiddleware = <span class=\"function\">(<span class=\"params\">req, res, next</span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`request url: <span class=\"subst\">$&#123;req.originalUrl&#125;</span>`</span>)</div><div class=\"line\">  next()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.resLocalMiddleware = <span class=\"function\">(<span class=\"params\">req, res, next</span>) =&gt;</span> &#123;</div><div class=\"line\">  res.locals.myVar = <span class=\"string\">'FASTCAMPUS!'</span></div><div class=\"line\">  next()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.lock = <span class=\"function\"><span class=\"params\">key</span> =&gt;</span> (req, res, next) =&gt; &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (req.query.key === key) &#123;</div><div class=\"line\">    next()</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    res.status(<span class=\"number\">403</span>)</div><div class=\"line\">    res.send(<span class=\"string\">'403 Forbidden'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// server.js</span></div><div class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> &#123;</div><div class=\"line\">  ipLoggingMiddleware, </div><div class=\"line\">  urlLoggingMiddleware, </div><div class=\"line\">  resLocalMiddleware,</div><div class=\"line\">  lock</div><div class=\"line\">&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'./middlewares'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> app = express()</div><div class=\"line\"></div><div class=\"line\">app.set(<span class=\"string\">'view engine'</span>, <span class=\"string\">'ejs'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 앱 단위 미들웨어는 모든 라우트 핸들러에서 실행됩니다.</span></div><div class=\"line\"><span class=\"comment\">// 미들웨어는 등록된 순서대로 실행됩니다.</span></div><div class=\"line\"><span class=\"comment\">// 아래 미들웨어 적용 순서를 바꿔보세요.</span></div><div class=\"line\">app.use(urlLoggingMiddleware)</div><div class=\"line\">app.use(ipLoggingMiddleware)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 라우트 단위 미들웨어는 적용된 라우트에서만 실행됩니다.</span></div><div class=\"line\">app.get(<span class=\"string\">'/'</span>, resLocalMiddleware, (req, res) =&gt; &#123;</div><div class=\"line\">  res.render(<span class=\"string\">'index.ejs'</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">app.get(<span class=\"string\">'/secret'</span>, lock(<span class=\"string\">'thisisthekey'</span>), (req, res) =&gt; &#123;</div><div class=\"line\">  res.send(<span class=\"string\">'my secret is...'</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'listening...'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// views/index.ejs</span></div><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html&gt;</div><div class=\"line\">  &lt;head&gt;</div><div class=\"line\">  &lt;<span class=\"regexp\">/head&gt;</span></div><div class=\"line\"><span class=\"regexp\">  &lt;body&gt;</span></div><div class=\"line\"><span class=\"regexp\">    &lt;div&gt;</span></div><div class=\"line\"><span class=\"regexp\">      &lt;%= myVar %&gt;</span></div><div class=\"line\"><span class=\"regexp\">    &lt;/</span>div&gt;</div><div class=\"line\">  &lt;<span class=\"regexp\">/body&gt;</span></div><div class=\"line\"><span class=\"regexp\">&lt;/</span>html&gt;</div></pre></td></tr></table></figure><p><strong>next</strong></p><p>미들웨어는 <code>req</code>, <code>res</code>에 더해서 <code>next</code>라는 함수를 추가로 인자로 받는다. <code>next</code> 함수를 호출하면 다음 미들웨어로 처리를 넘기는 효과가 있다. 만약에 미들웨어가 <code>next</code> 함수를 호출하지도 않고, 응답도 보내지 않으면 클라이언트는 응답을 받지 못하게 된다.</p><p><strong>App Local, Response Local</strong></p><p><code>app.locals</code>와 <code>res.locals</code>는 특별한 객체를 담고 있다. 템플릿에서는 <code>res.render</code>를 통해 명시적으로 주입받지 않아도 저 두 객체의 속성에 바로 접근할 수 있다.</p><p>템플릿을 가리지 않고 사용되는 정보들, 예를 들어 ‘현재 로그인 중인 사용자 정보’ 같은 것을 <code>res.render</code>에 매번 인자로 넘기는 것은 귀찮을 뿐더러 빠뜨리기도 쉽다. 그런 정보들을 템플릿에서 쉽게 사용하기 위해 <code>app.locals</code>나 <code>res.locals</code>에 우리가 원하는 이름으로 속성을 주입할 수 있습니다.</p><p><code>app.locals</code>는 앱 단위로 공통적으로 쓰이는 정보를 담는 목적으로 사용된다. <code>res.locals</code>는 각 요청마다 달라지는 정보를 담는 목적으로 사용된다.</p><p><code>app.local</code> 객체를 조작하는 것은 매우 쉽다. <code>res</code> 객체는 매 요청마다 새로 생성되어 미들웨어 바깥에서 접근할 수 있는 방법이 없으므로, <code>res.locals</code>를 조작하려면 미들웨어를 사용해야 한다.</p><h2 id=\"미들웨어-VS-라우트-핸들러\"><a href=\"#미들웨어-VS-라우트-핸들러\" class=\"headerlink\" title=\"미들웨어 VS 라우트 핸들러\"></a>미들웨어 VS 라우트 핸들러</h2><p>라우트 핸들러도 미들웨어이다. 즉, next 함수를 인자로 받는 것이 가능하다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.get(<span class=\"string\">'/'</span>, (req, res, next) =&gt; &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(!someCondition) &#123;</div><div class=\"line\">    next(); <span class=\"comment\">// 요청을 처리하지 않고 다른 핸들러로 넘긴다.</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    res.send(<span class=\"string\">'hello'</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure><p><strong>Example: custom 404</strong></p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// views/404.ejs</span></div><div class=\"line\">My Awesome <span class=\"number\">404</span>!</div></pre></td></tr></table></figure><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 요청이 라우트 핸들러가 등록된 어떤 경로와도 일치하지 않을 때,</span></div><div class=\"line\"><span class=\"comment\">// 맨 마지막 미들웨어를 실행시킬 수 있습니다. 이를 이용해 우리만의 404 페이지를 보여줄 수 있습니다.</span></div><div class=\"line\"><span class=\"comment\">// [참고](http://expressjs.com/ko/starter/faq.html)</span></div><div class=\"line\">app.use(<span class=\"function\">(<span class=\"params\">req, res, next</span>) =&gt;</span> &#123;</div><div class=\"line\">  res.render(<span class=\"string\">'404.ejs'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><h2 id=\"오류처리-미들웨어\"><a href=\"#오류처리-미들웨어\" class=\"headerlink\" title=\"오류처리 미들웨어\"></a>오류처리 미들웨어</h2><p>다른 미들웨어 함수와 정의하는 방법은 동일하지만, err라는 인수를 추가로 받는다는(총 4개의 인수) 차이가 있다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.use(<span class=\"function\">(<span class=\"params\">err, req, res, next</span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.error(err.stack);</div><div class=\"line\">  res.status(<span class=\"number\">500</span>).send(<span class=\"string\">'Something broke!'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure><p>오류 처리 미들웨어는 다른 app.use() 및 라우트 호출을 정의한 후에 <strong>마지막으로 정의</strong>해야 한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> bodyParser = <span class=\"built_in\">require</span>(<span class=\"string\">'body-parser'</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> methodOverride = <span class=\"built_in\">require</span>(<span class=\"string\">'method-override'</span>);</div><div class=\"line\"></div><div class=\"line\">app.use(bodyParser());</div><div class=\"line\">app.use(methodOverride());</div><div class=\"line\">app.use(<span class=\"function\">(<span class=\"params\">err, req, res, next</span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"comment\">// logic</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure><p>미들웨어 함수 내부로부터의 응답은 HTML 오류 페이지, 단순 메시지, JSON 문자열 등으로, 클라이언트가 원하는 형식으로 설정할 수 있다.</p><p>오류처리 미들웨어 함수 역시 일반적인 미들웨어 함수처럼 직접 정의할 수 있다. 아래는 XHR을 이용한 요청 및 그렇지 않은 요청에 대한 오류처리 미들웨어 함수를 정의한 예이다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> bodyParser = <span class=\"built_in\">require</span>(<span class=\"string\">'body-parser'</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> methodOverride = <span class=\"built_in\">require</span>(<span class=\"string\">'method-override'</span>);</div><div class=\"line\"></div><div class=\"line\">app.use(bodyParser());</div><div class=\"line\">app.use(methodOverride());</div><div class=\"line\">app.use(logErrors);</div><div class=\"line\">app.use(clientErrorHandler);</div><div class=\"line\">app.use(errorHandler);</div></pre></td></tr></table></figure><p>logError는 요청 및 오류 정보를 stderr에 기록할 수 있다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 오류정보를 기록하는 함수</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logErrors</span> (<span class=\"params\">err, req, res, next</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(err.stack);</div><div class=\"line\">  next(err);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 오류인 경우 500 error를 보내고 아닌 경우 다음 오류처리 미들웨어로 넘기는 함수</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clientErrorHandler</span>(<span class=\"params\">err, req, res, next</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(req.xhr) &#123;</div><div class=\"line\">    res.status(<span class=\"number\">500</span>).send(&#123; <span class=\"attr\">error</span>: <span class=\"string\">'Something failed!'</span>&#125;);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    next(err);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>모든 오류를 처리하는(catch-all) errorHandler 함수는 다음과 같이 구현할 수 있다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">errorHandler</span>(<span class=\"params\">err, req, res, next</span>) </span>&#123;</div><div class=\"line\">  res.status(<span class=\"number\">500</span>);</div><div class=\"line\">  res.render(<span class=\"string\">'error'</span>, &#123; <span class=\"attr\">error</span>: err &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><hr><p><a href=\"http://expressjs.com/ko/guide/writing-middleware.html\" target=\"_blank\" rel=\"external\">expressjs.com</a></p><p><a href=\"https://expressjs.com/ko/guide/error-handling.html\" target=\"_blank\" rel=\"external\">expressjs.com - 오류처리 미들웨어</a></p><p><a href=\"seungha-kim.github.io\">강사님 강의자료</a></p><p><a href=\"http://www.easyspub.co.kr/20_Menu/BookView/A001/127/PUB\" target=\"_blank\" rel=\"external\">참고서적: Do it! Node.js 프로그래밍</a></p>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://allvectorlogo.com/img/2016/05/node-js-logo.png\" alt=\"\"></p><h1 id=\"Express-Middleware\"><a href=\"#Express-Middleware\" class=\"headerlink\" title=\"Express Middleware\"></a>Express Middleware</h1><p>익스프레스는 개발자가 다양한 기능을 사용할 수 있도록 미리 만들어 둔 여러가지 미들웨어를 제공한다. npm을 통해서 다른 개발자들이 만든 미들웨어를 쉽게 다운 받아 사용할 수도 있다. 반대로 프로젝트 내에서 내가 직접 정의하고 로드(app.use)하여 사용하는 것도 가능하다.</p><p>미들웨어 함수는 ‘요청 오브젝트(req)’와 ‘응답 오브젝트(res)’, 그리고 애플리케이션의 요청-응답 주기 중 ‘다음 미들웨어 함수(next)’에 대한 액세스 권한을 갖는 함수이다.</p><p><img src=\"../images/middleware.png\" alt=\"middelware\"></p><p>미들웨어는 인수로 요청 오브젝트(request 객체)와 응답 오브젝트(response 객체), next 함수를 인자로 받는다. 요청 오브젝트와 응답 오브젝트를 조작해서 기능을 구현하며, next 함수는 다음 미들웨어를 동작시키기 위해 사용되며, 인자 없이 호출된다.</p><p>미들웨어는 기본적으로 <strong>함수</strong>이다. 따라서 내부에서 <strong>어떤 작업이든</strong> 가능하다. 미들웨어 함수로 수행하는 일은 아래와 같다.</p><ul><li>로깅</li><li>HTTP body를 객체로 변환</li><li>사용자 인증</li><li>권한 관리 등</li></ul><p><br></p><h2 id=\"app-use\"><a href=\"#app-use\" class=\"headerlink\" title=\"app.use()\"></a>app.use()</h2><p><code>app.use()</code>는 미들웨어 함수를 로드하기 위해 사용되는 메소드이다. 미들웨어 함수를 지정하고, <code>app.use()</code>를 통해 호출할 수 있다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//미들웨어 - 함수</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">helloMiddleware</span>(<span class=\"params\">res, req, next</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>);</div><div class=\"line\">  next();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">app.use(helloMiddleware);</div></pre></td></tr></table></figure><p>위 예제는 hello를 콘솔에 출력하는 helloMiddleware 함수를 정의하고, <code>app.use()</code>를 통해 로드하였다. 위와 같은 로드 방식은 앱 전체에서 동작하게 하는 방식이다. 첫번째 인자로 경로를 지정하면, 특정 경로에서만 동작하게 할 수도 있다. 아래 예제를 참고하자.</p><ul><li>앱 전체에서 동작하게 하기</li></ul><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.use(helloMiddleware);</div></pre></td></tr></table></figure><ul><li>특정 경로에서만 동작하게 하기</li></ul><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// some-path라는 경로 안에서만 동작하도록 로드</span></div><div class=\"line\">app.use(<span class=\"string\">'/some-path'</span>, helloMiddleware);</div></pre></td></tr></table></figure><ul><li>한 번에 여러 개 로드하기</li></ul><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 다수의 미들웨어를 한번에 호출</span></div><div class=\"line\">app.use(middleware1, middleware2, middleware3, ...)</div></pre></td></tr></table></figure><h2 id=\"호출-순서\"><a href=\"#호출-순서\" class=\"headerlink\" title=\"호출 순서\"></a>호출 순서</h2><p>미들웨어의 실행 순서는 호출 순서에 의해 결정된다. 즉, 먼저 호출되는 것이 먼저 실행된다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// mylogger.js</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> app = express();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> myLogger = <span class=\"function\">(<span class=\"params\">req, res, next</span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'LOGGED'</span>);</div><div class=\"line\">  next();</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">app.use(myLogger);</div><div class=\"line\"></div><div class=\"line\">app.get(<span class=\"string\">'/'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  res.send(<span class=\"string\">'Hello World'</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">app.listen(<span class=\"number\">3000</span>);</div></pre></td></tr></table></figure><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// console</span></div><div class=\"line\">% node mylogger.js</div><div class=\"line\">LOGGED</div></pre></td></tr></table></figure><p>위 예제는 라우팅 이전에 myLogger가 로드되었다. 실행하면 콘솔창에 LOGGED를 출력할 것이다.</p><p>그런데 만약 myLogger가 라우팅 이후에 로드되었다면?</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> app = express();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> myLogger = <span class=\"function\">(<span class=\"params\">req, res, next</span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'LOGGED'</span>);</div><div class=\"line\">  next();</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 루트경로에 대한 라우팅</span></div><div class=\"line\">app.get(<span class=\"string\">'/'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  res.send(<span class=\"string\">'Hello World'</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// myLogger 미들웨어를 라우팅 이후에 로드하였다.</span></div><div class=\"line\">app.use(myLogger);</div><div class=\"line\"></div><div class=\"line\">app.listen(<span class=\"number\">3000</span>);</div></pre></td></tr></table></figure><p>이 경우, 루트 경로의 라우트 핸들러가 요청-응답 주기를 종료하므로 요청은 myLogger에 도달하지도 못한다. 따라서 LOGGED를 출력하지 않는다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// console</span></div><div class=\"line\">% node mylogger.js</div><div class=\"line\"><span class=\"comment\">// 아무것도 출력하지 않는다.</span></div></pre></td></tr></table></figure><p><br></p><h2 id=\"자주-사용되는-미들웨어\"><a href=\"#자주-사용되는-미들웨어\" class=\"headerlink\" title=\"자주 사용되는 미들웨어\"></a>자주 사용되는 미들웨어</h2><h3 id=\"1-static-미들웨어\"><a href=\"#1-static-미들웨어\" class=\"headerlink\" title=\"1. static 미들웨어\"></a>1. static 미들웨어</h3><p>static 미들웨어는 특정 폴더의 파일들을 특정 패스로 접근할 수 있도록 만들어준다.</p><p>static 미들웨어는 외장 모듈로 만들어져 있기 때문에 npm을 통해 설치해야 한다. 터미널이나 명령 프롬프트(cmd)에서 아래 명령을 통해 설치한다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install serve-static --save</div></pre></td></tr></table></figure><p>아래는 static 사용의 예시이다. public 폴더에 있는 모든 파일을 웹 서버의 루트 패스로 접근할 수 있도록 하고 싶을 때 아래처럼 사용한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">static</span> = <span class=\"built_in\">require</span>(<span class=\"string\">'serve-static'</span>);</div><div class=\"line\"></div><div class=\"line\">...</div><div class=\"line\"></div><div class=\"line\">app.use(<span class=\"keyword\">static</span>(path.join(__dirname, <span class=\"string\">'public'</span>)));</div></pre></td></tr></table></figure><p>이 코드는 public 폴더 안에 있는 파일들을 클라이언트에서 바로 접근할 수 있게 한다. 예를 들어 프로젝트 폴더 안에 다음과 같은 폴더나 파일이 들어 있다면,</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ExpressExample/public/index.html</div><div class=\"line\">ExpressExample/public/house.png</div><div class=\"line\">ExpressExample/public/main.js</div><div class=\"line\">ExpressExample/public/style.css</div></pre></td></tr></table></figure><p>웹 브라우저에서 다음과 같은 주소로 바로 접근할 수 있다.</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://localhost:3000/index.html</div><div class=\"line\">http://localhost:3000/house.png</div><div class=\"line\">http://localhost:3000/main.js</div><div class=\"line\">http://localhost:3000/style.css</div></pre></td></tr></table></figure><p>만약 파일을 사이트의 /public 패스로 접근하게 만들고 싶다면 위의 코드에서 첫번째 인자에 요청 패스 <code>/public</code>을 추가해주면 된다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.use(<span class=\"string\">'/public'</span>, <span class=\"keyword\">static</span>(path.join(__dirname, <span class=\"string\">'public'</span>)));</div></pre></td></tr></table></figure><p><sub>* __dirname: 현재 디렉토리</sub></p><p>이렇게 하면 요청 패스와 특정 폴더(static 함수를 이용해 지정한 디렉터리)가 매핑(Mapping)되어 접근할 수 있게 된다.</p><h3 id=\"2-body-parser\"><a href=\"#2-body-parser\" class=\"headerlink\" title=\"2. body-parser\"></a>2. body-parser</h3><p>클라이언트의 요청(request) 방식에는 대표적으로 GET방식과 POST 방식이 있다.<br>GET 방식은 주소 문자열에 요청 파라미터가 들어가므로 url을 통해 확인이 가능하다. 그에 반해 POST 방식은 본문인 Body 영역에 요청 파라미터가 들어간다. 따라서 GET 방식과는 다른 방식으로 요청 파라미터를 파싱해야 한다.</p><p><code>body-parser</code> 미들웨어는 POST 방식으로 요청할 때 body에 들어있는 요청 파라미터들을 파싱하여 request 객체의 body 속성에 넣어준다.</p><p><code>body-parser</code> 미들웨어 역시 외부 모듈이므로, npm을 통해 다운로드해야 사용할 수 있다.</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install body-parser --save</div></pre></td></tr></table></figure><p>public 폴더 생성 후 그 안에login.html 파일을 생성한다.</p><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"ie=edge\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>login test<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>로그인<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">method</span>=<span class=\"string\">\"post\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">table</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>아이디<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"id\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>비밀번호<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span> = <span class=\"string\">\"password\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"전송\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// server.js</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Express 기본 모듈 불러오기</span></div><div class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Express의 미들웨어 불러오기</span></div><div class=\"line\"><span class=\"keyword\">const</span> bodyParser = <span class=\"built_in\">require</span>(<span class=\"string\">'body-parser'</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">static</span> = <span class=\"built_in\">require</span>(<span class=\"string\">'save-static'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 익스프레스 객체 생성</span></div><div class=\"line\"><span class=\"keyword\">const</span> app = express();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 기본 속성 설정</span></div><div class=\"line\">app.set(<span class=\"string\">'port'</span>, process.env.PORT || <span class=\"number\">3000</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// body-parser로 application/x-www-form-urlencoded 파싱</span></div><div class=\"line\"><span class=\"comment\">// .urlencoded() 메소드를 호출하면서 미들웨어를 설정하면, 'application/x-www-form-urlencoded' 형식으로 전달된 요청 파라미터를 파싱할 수 있다.</span></div><div class=\"line\"><span class=\"comment\">// 이 형식은 일반적인 요청 파라미터의 형식이다.</span></div><div class=\"line\">app.use(bodyParser.urlencoded(&#123; <span class=\"attr\">extended</span>: <span class=\"literal\">false</span> &#125;));</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// body-parser를 사용해 application/json 파싱</span></div><div class=\"line\"><span class=\"comment\">// .json() 메소드를 호출하면서 미들웨어를 설정하면 application/json 형식으로 전달된 요청 파라미터를 참조할 수 있다.</span></div><div class=\"line\">app.use(bodyParser.json());</div><div class=\"line\"></div><div class=\"line\">app.use(<span class=\"keyword\">static</span>(path.join(__dirname, <span class=\"string\">'public'</span>)));</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 미들웨어에서 파라미터 확인</span></div><div class=\"line\">app.use(<span class=\"function\">(<span class=\"params\">req, res, next</span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'첫번째 미들웨어에서 요청을 처리'</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// body 안에 있는 요청 파라미터를 참조한다.</span></div><div class=\"line\">  <span class=\"comment\">// 만약 클라이언트가 요청하는 방식이 GET 방식인지 POST 방식으로 요청할지 모른다면</span></div><div class=\"line\">  <span class=\"comment\">// 두 가지 경우를 모두 고려해 두 가지 요청 파라미터를 모두 검사한다.</span></div><div class=\"line\">  <span class=\"keyword\">const</span> paramId = req.body.id || req.query.id;</div><div class=\"line\">  <span class=\"keyword\">const</span> paramPassword = req.body.password || req.query.password;</div><div class=\"line\"></div><div class=\"line\">  res.writeHead(<span class=\"string\">'200'</span>, &#123;<span class=\"string\">'Content-Type'</span>:<span class=\"string\">'text/html;charset=utf-8'</span>&#125;);</div><div class=\"line\">  res.write(<span class=\"string\">'&lt;h1&gt;Express 서버에 응답한 결과입니다. &lt;/h1&gt;'</span>);</div><div class=\"line\">  res.write(<span class=\"string\">'&lt;div&gt;&lt;p&gt;Param id: '</span>+ paramId + <span class=\"string\">'&lt;/p&gt;&lt;/div&gt;'</span>);</div><div class=\"line\">  res.write(<span class=\"string\">'&lt;div&gt;&lt;p&gt;Param password: '</span> + paramPassword + <span class=\"string\">'&lt;/p&gt;&lt;/div&gt;'</span>);</div><div class=\"line\">  res.end();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ node server.js</div></pre></td></tr></table></figure><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://localhost:3000/login.html 접속</div></pre></td></tr></table></figure><p>서버 코드에서 use() 메소드로 설정한 함수는 login.html 문서에 접근할 때는 호출되지 않는다. 처음에는 login.html 문서가 웹 브라우저에 보이고, 전송 버튼을 클릭해 POST로 요청했을 때 use() 메소드로 설정한 함수가 호출된다.</p><p>전송 버튼을 누르면 POST 방식으로 요청을 보낼 때도 GET 방식과 마찬가지로 요청 파라미터를 확인할 수 있다.</p><p><br></p><h2 id=\"Middleware를-사용하는-이유\"><a href=\"#Middleware를-사용하는-이유\" class=\"headerlink\" title=\"Middleware를 사용하는 이유\"></a>Middleware를 사용하는 이유</h2><p>미들웨어로 할 수 있는 모든 일은 사실 라우트 핸들러에서도 할 수 있다. 그럼에도 미들웨어를 사용하는 이유는 여러 라우터에서 사용해야 하는 기능을 중복 작성하는 불편을 덜고, <strong>코드를 재사용</strong>하기 위함이다.</p><h2 id=\"Middleware-생태계\"><a href=\"#Middleware-생태계\" class=\"headerlink\" title=\"Middleware 생태계\"></a>Middleware 생태계</h2><p><a href=\"https://expressjs.com/ko/resources/middleware.html\" target=\"_blank\" rel=\"external\">Express resource</a><br><a href=\"https://www.npmjs.com/search?q=express+middleware\" target=\"_blank\" rel=\"external\">NPM search</a></p><h2 id=\"미들웨어-예제\"><a href=\"#미들웨어-예제\" class=\"headerlink\" title=\"미들웨어 예제\"></a>미들웨어 예제</h2><p>middlewares.js 파일에서 작성한 미들웨어를 server.js에서 불러와 사용하고 있다. 각각 어떤 방식으로 미들웨어를 사용하고 있는지 확인해보자.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// middlewares.js</span></div><div class=\"line\">exports.ipLoggingMiddleware = <span class=\"function\">(<span class=\"params\">req, res, next</span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`request ip: <span class=\"subst\">$&#123;req.ip&#125;</span>`</span>)</div><div class=\"line\">  next()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.urlLoggingMiddleware = <span class=\"function\">(<span class=\"params\">req, res, next</span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`request url: <span class=\"subst\">$&#123;req.originalUrl&#125;</span>`</span>)</div><div class=\"line\">  next()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.resLocalMiddleware = <span class=\"function\">(<span class=\"params\">req, res, next</span>) =&gt;</span> &#123;</div><div class=\"line\">  res.locals.myVar = <span class=\"string\">'FASTCAMPUS!'</span></div><div class=\"line\">  next()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.lock = <span class=\"function\"><span class=\"params\">key</span> =&gt;</span> (req, res, next) =&gt; &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (req.query.key === key) &#123;</div><div class=\"line\">    next()</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    res.status(<span class=\"number\">403</span>)</div><div class=\"line\">    res.send(<span class=\"string\">'403 Forbidden'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// server.js</span></div><div class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> &#123;</div><div class=\"line\">  ipLoggingMiddleware, </div><div class=\"line\">  urlLoggingMiddleware, </div><div class=\"line\">  resLocalMiddleware,</div><div class=\"line\">  lock</div><div class=\"line\">&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'./middlewares'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> app = express()</div><div class=\"line\"></div><div class=\"line\">app.set(<span class=\"string\">'view engine'</span>, <span class=\"string\">'ejs'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 앱 단위 미들웨어는 모든 라우트 핸들러에서 실행됩니다.</span></div><div class=\"line\"><span class=\"comment\">// 미들웨어는 등록된 순서대로 실행됩니다.</span></div><div class=\"line\"><span class=\"comment\">// 아래 미들웨어 적용 순서를 바꿔보세요.</span></div><div class=\"line\">app.use(urlLoggingMiddleware)</div><div class=\"line\">app.use(ipLoggingMiddleware)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 라우트 단위 미들웨어는 적용된 라우트에서만 실행됩니다.</span></div><div class=\"line\">app.get(<span class=\"string\">'/'</span>, resLocalMiddleware, (req, res) =&gt; &#123;</div><div class=\"line\">  res.render(<span class=\"string\">'index.ejs'</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">app.get(<span class=\"string\">'/secret'</span>, lock(<span class=\"string\">'thisisthekey'</span>), (req, res) =&gt; &#123;</div><div class=\"line\">  res.send(<span class=\"string\">'my secret is...'</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'listening...'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// views/index.ejs</span></div><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html&gt;</div><div class=\"line\">  &lt;head&gt;</div><div class=\"line\">  &lt;<span class=\"regexp\">/head&gt;</span></div><div class=\"line\"><span class=\"regexp\">  &lt;body&gt;</span></div><div class=\"line\"><span class=\"regexp\">    &lt;div&gt;</span></div><div class=\"line\"><span class=\"regexp\">      &lt;%= myVar %&gt;</span></div><div class=\"line\"><span class=\"regexp\">    &lt;/</span>div&gt;</div><div class=\"line\">  &lt;<span class=\"regexp\">/body&gt;</span></div><div class=\"line\"><span class=\"regexp\">&lt;/</span>html&gt;</div></pre></td></tr></table></figure><p><strong>next</strong></p><p>미들웨어는 <code>req</code>, <code>res</code>에 더해서 <code>next</code>라는 함수를 추가로 인자로 받는다. <code>next</code> 함수를 호출하면 다음 미들웨어로 처리를 넘기는 효과가 있다. 만약에 미들웨어가 <code>next</code> 함수를 호출하지도 않고, 응답도 보내지 않으면 클라이언트는 응답을 받지 못하게 된다.</p><p><strong>App Local, Response Local</strong></p><p><code>app.locals</code>와 <code>res.locals</code>는 특별한 객체를 담고 있다. 템플릿에서는 <code>res.render</code>를 통해 명시적으로 주입받지 않아도 저 두 객체의 속성에 바로 접근할 수 있다.</p><p>템플릿을 가리지 않고 사용되는 정보들, 예를 들어 ‘현재 로그인 중인 사용자 정보’ 같은 것을 <code>res.render</code>에 매번 인자로 넘기는 것은 귀찮을 뿐더러 빠뜨리기도 쉽다. 그런 정보들을 템플릿에서 쉽게 사용하기 위해 <code>app.locals</code>나 <code>res.locals</code>에 우리가 원하는 이름으로 속성을 주입할 수 있습니다.</p><p><code>app.locals</code>는 앱 단위로 공통적으로 쓰이는 정보를 담는 목적으로 사용된다. <code>res.locals</code>는 각 요청마다 달라지는 정보를 담는 목적으로 사용된다.</p><p><code>app.local</code> 객체를 조작하는 것은 매우 쉽다. <code>res</code> 객체는 매 요청마다 새로 생성되어 미들웨어 바깥에서 접근할 수 있는 방법이 없으므로, <code>res.locals</code>를 조작하려면 미들웨어를 사용해야 한다.</p><h2 id=\"미들웨어-VS-라우트-핸들러\"><a href=\"#미들웨어-VS-라우트-핸들러\" class=\"headerlink\" title=\"미들웨어 VS 라우트 핸들러\"></a>미들웨어 VS 라우트 핸들러</h2><p>라우트 핸들러도 미들웨어이다. 즉, next 함수를 인자로 받는 것이 가능하다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.get(<span class=\"string\">'/'</span>, (req, res, next) =&gt; &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(!someCondition) &#123;</div><div class=\"line\">    next(); <span class=\"comment\">// 요청을 처리하지 않고 다른 핸들러로 넘긴다.</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    res.send(<span class=\"string\">'hello'</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure><p><strong>Example: custom 404</strong></p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// views/404.ejs</span></div><div class=\"line\">My Awesome <span class=\"number\">404</span>!</div></pre></td></tr></table></figure><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 요청이 라우트 핸들러가 등록된 어떤 경로와도 일치하지 않을 때,</span></div><div class=\"line\"><span class=\"comment\">// 맨 마지막 미들웨어를 실행시킬 수 있습니다. 이를 이용해 우리만의 404 페이지를 보여줄 수 있습니다.</span></div><div class=\"line\"><span class=\"comment\">// [참고](http://expressjs.com/ko/starter/faq.html)</span></div><div class=\"line\">app.use(<span class=\"function\">(<span class=\"params\">req, res, next</span>) =&gt;</span> &#123;</div><div class=\"line\">  res.render(<span class=\"string\">'404.ejs'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><h2 id=\"오류처리-미들웨어\"><a href=\"#오류처리-미들웨어\" class=\"headerlink\" title=\"오류처리 미들웨어\"></a>오류처리 미들웨어</h2><p>다른 미들웨어 함수와 정의하는 방법은 동일하지만, err라는 인수를 추가로 받는다는(총 4개의 인수) 차이가 있다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.use(<span class=\"function\">(<span class=\"params\">err, req, res, next</span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.error(err.stack);</div><div class=\"line\">  res.status(<span class=\"number\">500</span>).send(<span class=\"string\">'Something broke!'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure><p>오류 처리 미들웨어는 다른 app.use() 및 라우트 호출을 정의한 후에 <strong>마지막으로 정의</strong>해야 한다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> bodyParser = <span class=\"built_in\">require</span>(<span class=\"string\">'body-parser'</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> methodOverride = <span class=\"built_in\">require</span>(<span class=\"string\">'method-override'</span>);</div><div class=\"line\"></div><div class=\"line\">app.use(bodyParser());</div><div class=\"line\">app.use(methodOverride());</div><div class=\"line\">app.use(<span class=\"function\">(<span class=\"params\">err, req, res, next</span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"comment\">// logic</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure><p>미들웨어 함수 내부로부터의 응답은 HTML 오류 페이지, 단순 메시지, JSON 문자열 등으로, 클라이언트가 원하는 형식으로 설정할 수 있다.</p><p>오류처리 미들웨어 함수 역시 일반적인 미들웨어 함수처럼 직접 정의할 수 있다. 아래는 XHR을 이용한 요청 및 그렇지 않은 요청에 대한 오류처리 미들웨어 함수를 정의한 예이다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> bodyParser = <span class=\"built_in\">require</span>(<span class=\"string\">'body-parser'</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> methodOverride = <span class=\"built_in\">require</span>(<span class=\"string\">'method-override'</span>);</div><div class=\"line\"></div><div class=\"line\">app.use(bodyParser());</div><div class=\"line\">app.use(methodOverride());</div><div class=\"line\">app.use(logErrors);</div><div class=\"line\">app.use(clientErrorHandler);</div><div class=\"line\">app.use(errorHandler);</div></pre></td></tr></table></figure><p>logError는 요청 및 오류 정보를 stderr에 기록할 수 있다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 오류정보를 기록하는 함수</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logErrors</span> (<span class=\"params\">err, req, res, next</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(err.stack);</div><div class=\"line\">  next(err);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 오류인 경우 500 error를 보내고 아닌 경우 다음 오류처리 미들웨어로 넘기는 함수</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clientErrorHandler</span>(<span class=\"params\">err, req, res, next</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(req.xhr) &#123;</div><div class=\"line\">    res.status(<span class=\"number\">500</span>).send(&#123; <span class=\"attr\">error</span>: <span class=\"string\">'Something failed!'</span>&#125;);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    next(err);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>모든 오류를 처리하는(catch-all) errorHandler 함수는 다음과 같이 구현할 수 있다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">errorHandler</span>(<span class=\"params\">err, req, res, next</span>) </span>&#123;</div><div class=\"line\">  res.status(<span class=\"number\">500</span>);</div><div class=\"line\">  res.render(<span class=\"string\">'error'</span>, &#123; <span class=\"attr\">error</span>: err &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><hr><p><a href=\"http://expressjs.com/ko/guide/writing-middleware.html\" target=\"_blank\" rel=\"external\">expressjs.com</a></p><p><a href=\"https://expressjs.com/ko/guide/error-handling.html\" target=\"_blank\" rel=\"external\">expressjs.com - 오류처리 미들웨어</a></p><p><a href=\"seungha-kim.github.io\">강사님 강의자료</a></p><p><a href=\"http://www.easyspub.co.kr/20_Menu/BookView/A001/127/PUB\" target=\"_blank\" rel=\"external\">참고서적: Do it! Node.js 프로그래밍</a></p>"},{"title":"[node] 세션 Session","date":"2017-09-09T09:16:41.000Z","_content":"\n![](http://allvectorlogo.com/img/2016/05/node-js-logo.png)\n\n# 세션 Session\n\n### 세션의 의미\n\n**사전적 의미**\n1) (특정한 활동을 위한) 시간\n2) (의회 등의) 회기; (법정의) 개정 (기간)\n\n**실질적 의미**\n1) 시작 조건과 종료 조건이 있는 시간, 또는 회기\n2) 정보 교환이 지속되는 시간, 또는 회기\n\n\n### 세션의 예\n\n**HTTP session**: 요청 - 응답\n\n**로그인 세션**: 로그인 - 로그아웃\n\n**Google Analytics 세션**:\n페이지 접속 - 30분간 접속이 없으면 종료로 간주 (커스터마이징 가능)  \n\n\n## 웹 서비스를 위한 세션의 구현\n\n1. 세션이 시작되면(ex. 로그인하면), 세션이 시작되었다는 사실을 쿠키에 저장\n2. 세션에 대한 정보를 여러 요청에 걸쳐서 지속시키기 위해, 정보를 어딘가에 저장\n3. 세션이 만료되면(ex. 로그아웃하면), 세션이 만료되었다는 사실을 쿠키에 반영  \n\n<sub> * 위 방식은 널리 사용되는 방식일 뿐, 반드시 위와 같이 구현해야 하는 것은 아니다.</sub>\n\n---\n만약, 브라우저가 갑자기 꺼지면 쿠키는 어떻게 되는가?  \n\n**세션쿠키**라는 것이 있다. 브라우저가 꺼지면 쿠키가 삭제되는 옵션이다. 이 옵션이 정의되어있다면 브라우저가 꺼지는 순간 쿠키가 삭제된다.하지만 지속시간이 긴 쿠키라면(직접 정의할 수 있다.) 브라우저를 껐다가 켜도 쿠키가 지속된다. \n\n---\n\n## 세션 스토어\n세션에 대한 정보를 저장하는 어딘가\n\n* 쿠키\n* 데이터베이스\n* 파일\n* 기타 정보를 저장할 수 있는 곳 어디든\n\n### 세션 스토어의 선택\n\n서비스의 요구사항에 맞춰서 적절한 저장소를 선택하면 된다.\n\n* 쿠키: 정보의 형태가 간단하고 자주 바뀔 일이 없다면\n\n* 데이터베이스: 저장해야 할 정보의 양이 많다면\n\n* 메모리 기반 저장소: 정보가 굉장히 자주 변경된다면\n\n## 세션? 세션 스토어?\n'세션'과 '세션 스토어'는 혼용되는 경우가 많지만 엄연히 다른 말이다.\n\n'세션에 정보를 저장한다'는 말은 '세션 스토어에 정보를 저장한다'는 말과 같은 의미이다.   \n\n## Express + Session\n\n**cookie-session**\n\n  쿠키에 모든 정보를 저장하는 세션 스토어. 첫 방문시 무조건 세션 시작.\n\n**express-session**\n\n  쿠키에는 세션 식별자만 저장하고 실제 정보의 저장은 외부 저장소(데이터베이스 등)를 이용하는 세션 스토어. 외부 저장소에 대한 별도의 설정 필요\n\n## 익스프레스 세션 예제\n[link](https://glitch.com/edit/#!/laser-teal?path=README.md:1:0)\n\n```js\n// server.js\n\n// cookie-session 설정\n// name: 쿠키 이름으로 사용할 문자열\n// secret: 세션 정보를 서명할 때 사용할 키\n// secret은 비밀 정보. 공개되어서는 안 된다.\napp.use(cookieSession({\n  name: 'session',\n  secret: process.env.SECRET\n}))\n\n// req.session.count를 처리하는 미들웨어\nconst countMiddleware = (req, res, next) => {\n  if ('count' in req.session) {\n    // count 속성이 있으면 1으.\n    req.session.count += 1\n  } else {\n    // count 속성이 없으면 처음 방문한 것이므로 1로 설정한다.\n    req.session.count = 1\n  }\n  next()\n}\n\n// 첫 방문 후, 쿠키 관련 헤더가 요청과 응답에 잘 포함되는지 살펴보고,\n// 실제로 쿠키가 어떻게 저장되어있는지 살펴보세요.\napp.get('/', countMiddleware, (req, res) => {\n  res.render('index.ejs', {count: req.session.count})\n})\n\napp.post('/reset-count', (req, res) => {\n  delete req.session.count\n  res.redirect('/')\n})\n\napp.listen(3000, function() {\n  console.log('listening...')\n})\n\n```\n\n```js\n// index. ejs\n<!DOCTYPE html>\n<html>\n  <head>\n  </head>\n  <body>\n    <div>\n      <%= count %>번 째 방문하셨습니다.\n    </div>\n    <form action=\"/reset-count\" method=\"post\">\n      <button type=\"submit\">\n        초기화\n      </button>\n    </form>\n  </body>\n</html>\n```\n\n## 인증/인가 예제\n[link](https://glitch.com/edit/#!/brave-picture?path=README.md:1:0)\n\n**인증(Authentication)과 인가(Authorization)**\n\n인증(Authentication)은 클라이언트가 누구인지를 확인하는 과정이다. 지금은 '인증과 로그인은 같은 말'이라고 생각하셔도 무방하다.\n\n인가(=허가)는 클라이언트가 하려고 하는 작업이 해당 클라이언트에게 허가된 작업인지를 확인하는 과정이다. '권한 설정'이라고 생각하셔도 무방하다. 예를 들어 다음 카페나 네이버 클럽에서는 관리자만이 게시판을 만들거나 없앨 수 있도록 인가된다.\n\n<br>\n\n**인증 구현 전략**\n\n인증은 여러가지 방식으로 구현될 수 있으며, 여기에서는 우리가 쓰고 있는 cookie-session 의 기능에 맞추어서 구현해보도록 한다.\n\ncookie-session이 제공하는 미들웨어는 첫 방문시 바로 세션을 시작하고 (이를 guest session이라 부릅니다) 쿠키에 빈 세션 정보(빈 객체)를 저장한다. 그래서 첫 방문자에 대해서도 session 객체를 바로 쓸 수 있다.\n\n아래와 같은 규칙으로 인증을 구현해보도록 한다.\n\n1. `req.session.username === undefined`이면 로그인된 사용자가 없는 것으로 간주한다.\n\n2. 사용자가 로그인 폼을 전송하면 accounts 배열에 저장된 계정 정보 중에 일치하는 것이 있는지 확인하고, 있다면 `req.session.username`에 해당 사용자 이름을 저장한다. 만약 일치하는 계정이 없으면 `400 Bad Request` 응답을 보낸다.\n\n3. `req.session.username`에 저장된 값이 있다면 해당 사용자로 로그인이 되어 있다고 간주한다.\n\n4. 로그아웃을 하기 위해 `req.session = null`와 같이 대입해서 세션을 초기화한다.\n\n(인증이 된 뒤에는 `req.user`와 `res.locals.user`에 계정 객체를 주입해서 라우트 핸들러와 템플릿에서 편하게 접근할 수 있도록 미리 코드를 짜 두었다.)\n\n```js\n// sever.js - account\nconst accounts = [\n  {\n    username: 'seungha',\n    password: 'kim',\n    name: '김승하'\n  },\n  {\n    username: 'fast',\n    password: 'campus',\n    name: '패스트캠퍼스',\n    admin: true\n  }\n]\n```\n\n```js\n//server.js - login\napp.post('/login', urlencodedMiddleware, (req, res) => {\n  \n  // 인증 과정을 작성해주세요.\n  if(accounts.find( acc => acc.username === req.body.username && acc.password === req.body.password)){\n    req.session.username = req.body.username;\n    \n    res.redirect('/');\n    \n  } else {\n    res.status(404);\n    res.send('404 Not Found');\n  }\n  res.redirect('/');\n})\n```\n\n```js\n//server.js - logout\napp.post('/logout', urlencodedMiddleware, (req, res) => {\n  // 세션 초기화\n  req.session = null\n  res.redirect('/')\n})\n```\n\n<br>\n\n**인가 구현 전략**\n\n관리자만이 비밀 정보(/secret)에 접근할 수 있도록 한다. 사용자가 관리자인지 아닌지의 여부는 계정 객체의 admin 속성에 저장되어 있다.\n\n```js\n// server.js - admin\nfunction onlyAdminMiddleware(req, res, next) {\n  // `/secret`에 접속했을 때 이 미들웨어가 작동합니다.\n  const user = req.session.username;\n  if(accounts.find( acc => acc.username === user && acc.admin)){\n    // admin이면 통과!\n    next();\n  } else {\n    res.status(403);\n    res.send('403 Forbidden');\n  }\n}\n\napp.get('/secret', onlyAdminMiddleware, (req, res) => {\n  res.send('It is my secret')\n})\n```\n","source":"_posts/nodejs/09.session.md","raw":"---\ntitle: '[node] 세션 Session'\ndate: 2017-09-09 18:16:41\ncategory: Nodejs\ntags: session\n---\n\n![](http://allvectorlogo.com/img/2016/05/node-js-logo.png)\n\n# 세션 Session\n\n### 세션의 의미\n\n**사전적 의미**\n1) (특정한 활동을 위한) 시간\n2) (의회 등의) 회기; (법정의) 개정 (기간)\n\n**실질적 의미**\n1) 시작 조건과 종료 조건이 있는 시간, 또는 회기\n2) 정보 교환이 지속되는 시간, 또는 회기\n\n\n### 세션의 예\n\n**HTTP session**: 요청 - 응답\n\n**로그인 세션**: 로그인 - 로그아웃\n\n**Google Analytics 세션**:\n페이지 접속 - 30분간 접속이 없으면 종료로 간주 (커스터마이징 가능)  \n\n\n## 웹 서비스를 위한 세션의 구현\n\n1. 세션이 시작되면(ex. 로그인하면), 세션이 시작되었다는 사실을 쿠키에 저장\n2. 세션에 대한 정보를 여러 요청에 걸쳐서 지속시키기 위해, 정보를 어딘가에 저장\n3. 세션이 만료되면(ex. 로그아웃하면), 세션이 만료되었다는 사실을 쿠키에 반영  \n\n<sub> * 위 방식은 널리 사용되는 방식일 뿐, 반드시 위와 같이 구현해야 하는 것은 아니다.</sub>\n\n---\n만약, 브라우저가 갑자기 꺼지면 쿠키는 어떻게 되는가?  \n\n**세션쿠키**라는 것이 있다. 브라우저가 꺼지면 쿠키가 삭제되는 옵션이다. 이 옵션이 정의되어있다면 브라우저가 꺼지는 순간 쿠키가 삭제된다.하지만 지속시간이 긴 쿠키라면(직접 정의할 수 있다.) 브라우저를 껐다가 켜도 쿠키가 지속된다. \n\n---\n\n## 세션 스토어\n세션에 대한 정보를 저장하는 어딘가\n\n* 쿠키\n* 데이터베이스\n* 파일\n* 기타 정보를 저장할 수 있는 곳 어디든\n\n### 세션 스토어의 선택\n\n서비스의 요구사항에 맞춰서 적절한 저장소를 선택하면 된다.\n\n* 쿠키: 정보의 형태가 간단하고 자주 바뀔 일이 없다면\n\n* 데이터베이스: 저장해야 할 정보의 양이 많다면\n\n* 메모리 기반 저장소: 정보가 굉장히 자주 변경된다면\n\n## 세션? 세션 스토어?\n'세션'과 '세션 스토어'는 혼용되는 경우가 많지만 엄연히 다른 말이다.\n\n'세션에 정보를 저장한다'는 말은 '세션 스토어에 정보를 저장한다'는 말과 같은 의미이다.   \n\n## Express + Session\n\n**cookie-session**\n\n  쿠키에 모든 정보를 저장하는 세션 스토어. 첫 방문시 무조건 세션 시작.\n\n**express-session**\n\n  쿠키에는 세션 식별자만 저장하고 실제 정보의 저장은 외부 저장소(데이터베이스 등)를 이용하는 세션 스토어. 외부 저장소에 대한 별도의 설정 필요\n\n## 익스프레스 세션 예제\n[link](https://glitch.com/edit/#!/laser-teal?path=README.md:1:0)\n\n```js\n// server.js\n\n// cookie-session 설정\n// name: 쿠키 이름으로 사용할 문자열\n// secret: 세션 정보를 서명할 때 사용할 키\n// secret은 비밀 정보. 공개되어서는 안 된다.\napp.use(cookieSession({\n  name: 'session',\n  secret: process.env.SECRET\n}))\n\n// req.session.count를 처리하는 미들웨어\nconst countMiddleware = (req, res, next) => {\n  if ('count' in req.session) {\n    // count 속성이 있으면 1으.\n    req.session.count += 1\n  } else {\n    // count 속성이 없으면 처음 방문한 것이므로 1로 설정한다.\n    req.session.count = 1\n  }\n  next()\n}\n\n// 첫 방문 후, 쿠키 관련 헤더가 요청과 응답에 잘 포함되는지 살펴보고,\n// 실제로 쿠키가 어떻게 저장되어있는지 살펴보세요.\napp.get('/', countMiddleware, (req, res) => {\n  res.render('index.ejs', {count: req.session.count})\n})\n\napp.post('/reset-count', (req, res) => {\n  delete req.session.count\n  res.redirect('/')\n})\n\napp.listen(3000, function() {\n  console.log('listening...')\n})\n\n```\n\n```js\n// index. ejs\n<!DOCTYPE html>\n<html>\n  <head>\n  </head>\n  <body>\n    <div>\n      <%= count %>번 째 방문하셨습니다.\n    </div>\n    <form action=\"/reset-count\" method=\"post\">\n      <button type=\"submit\">\n        초기화\n      </button>\n    </form>\n  </body>\n</html>\n```\n\n## 인증/인가 예제\n[link](https://glitch.com/edit/#!/brave-picture?path=README.md:1:0)\n\n**인증(Authentication)과 인가(Authorization)**\n\n인증(Authentication)은 클라이언트가 누구인지를 확인하는 과정이다. 지금은 '인증과 로그인은 같은 말'이라고 생각하셔도 무방하다.\n\n인가(=허가)는 클라이언트가 하려고 하는 작업이 해당 클라이언트에게 허가된 작업인지를 확인하는 과정이다. '권한 설정'이라고 생각하셔도 무방하다. 예를 들어 다음 카페나 네이버 클럽에서는 관리자만이 게시판을 만들거나 없앨 수 있도록 인가된다.\n\n<br>\n\n**인증 구현 전략**\n\n인증은 여러가지 방식으로 구현될 수 있으며, 여기에서는 우리가 쓰고 있는 cookie-session 의 기능에 맞추어서 구현해보도록 한다.\n\ncookie-session이 제공하는 미들웨어는 첫 방문시 바로 세션을 시작하고 (이를 guest session이라 부릅니다) 쿠키에 빈 세션 정보(빈 객체)를 저장한다. 그래서 첫 방문자에 대해서도 session 객체를 바로 쓸 수 있다.\n\n아래와 같은 규칙으로 인증을 구현해보도록 한다.\n\n1. `req.session.username === undefined`이면 로그인된 사용자가 없는 것으로 간주한다.\n\n2. 사용자가 로그인 폼을 전송하면 accounts 배열에 저장된 계정 정보 중에 일치하는 것이 있는지 확인하고, 있다면 `req.session.username`에 해당 사용자 이름을 저장한다. 만약 일치하는 계정이 없으면 `400 Bad Request` 응답을 보낸다.\n\n3. `req.session.username`에 저장된 값이 있다면 해당 사용자로 로그인이 되어 있다고 간주한다.\n\n4. 로그아웃을 하기 위해 `req.session = null`와 같이 대입해서 세션을 초기화한다.\n\n(인증이 된 뒤에는 `req.user`와 `res.locals.user`에 계정 객체를 주입해서 라우트 핸들러와 템플릿에서 편하게 접근할 수 있도록 미리 코드를 짜 두었다.)\n\n```js\n// sever.js - account\nconst accounts = [\n  {\n    username: 'seungha',\n    password: 'kim',\n    name: '김승하'\n  },\n  {\n    username: 'fast',\n    password: 'campus',\n    name: '패스트캠퍼스',\n    admin: true\n  }\n]\n```\n\n```js\n//server.js - login\napp.post('/login', urlencodedMiddleware, (req, res) => {\n  \n  // 인증 과정을 작성해주세요.\n  if(accounts.find( acc => acc.username === req.body.username && acc.password === req.body.password)){\n    req.session.username = req.body.username;\n    \n    res.redirect('/');\n    \n  } else {\n    res.status(404);\n    res.send('404 Not Found');\n  }\n  res.redirect('/');\n})\n```\n\n```js\n//server.js - logout\napp.post('/logout', urlencodedMiddleware, (req, res) => {\n  // 세션 초기화\n  req.session = null\n  res.redirect('/')\n})\n```\n\n<br>\n\n**인가 구현 전략**\n\n관리자만이 비밀 정보(/secret)에 접근할 수 있도록 한다. 사용자가 관리자인지 아닌지의 여부는 계정 객체의 admin 속성에 저장되어 있다.\n\n```js\n// server.js - admin\nfunction onlyAdminMiddleware(req, res, next) {\n  // `/secret`에 접속했을 때 이 미들웨어가 작동합니다.\n  const user = req.session.username;\n  if(accounts.find( acc => acc.username === user && acc.admin)){\n    // admin이면 통과!\n    next();\n  } else {\n    res.status(403);\n    res.send('403 Forbidden');\n  }\n}\n\napp.get('/secret', onlyAdminMiddleware, (req, res) => {\n  res.send('It is my secret')\n})\n```\n","slug":"nodejs/09.session","published":1,"updated":"2017-11-27T12:24:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjai8h18s001jvb9qnj3aa8a4","content":"<p><img src=\"http://allvectorlogo.com/img/2016/05/node-js-logo.png\" alt=\"\"></p><h1 id=\"세션-Session\"><a href=\"#세션-Session\" class=\"headerlink\" title=\"세션 Session\"></a>세션 Session</h1><h3 id=\"세션의-의미\"><a href=\"#세션의-의미\" class=\"headerlink\" title=\"세션의 의미\"></a>세션의 의미</h3><p><strong>사전적 의미</strong><br>1) (특정한 활동을 위한) 시간<br>2) (의회 등의) 회기; (법정의) 개정 (기간)</p><p><strong>실질적 의미</strong><br>1) 시작 조건과 종료 조건이 있는 시간, 또는 회기<br>2) 정보 교환이 지속되는 시간, 또는 회기</p><h3 id=\"세션의-예\"><a href=\"#세션의-예\" class=\"headerlink\" title=\"세션의 예\"></a>세션의 예</h3><p><strong>HTTP session</strong>: 요청 - 응답</p><p><strong>로그인 세션</strong>: 로그인 - 로그아웃</p><p><strong>Google Analytics 세션</strong>:<br>페이지 접속 - 30분간 접속이 없으면 종료로 간주 (커스터마이징 가능)</p><h2 id=\"웹-서비스를-위한-세션의-구현\"><a href=\"#웹-서비스를-위한-세션의-구현\" class=\"headerlink\" title=\"웹 서비스를 위한 세션의 구현\"></a>웹 서비스를 위한 세션의 구현</h2><ol><li>세션이 시작되면(ex. 로그인하면), 세션이 시작되었다는 사실을 쿠키에 저장</li><li>세션에 대한 정보를 여러 요청에 걸쳐서 지속시키기 위해, 정보를 어딘가에 저장</li><li>세션이 만료되면(ex. 로그아웃하면), 세션이 만료되었다는 사실을 쿠키에 반영</li></ol><p><sub>* 위 방식은 널리 사용되는 방식일 뿐, 반드시 위와 같이 구현해야 하는 것은 아니다.</sub></p><hr><p>만약, 브라우저가 갑자기 꺼지면 쿠키는 어떻게 되는가?</p><p><strong>세션쿠키</strong>라는 것이 있다. 브라우저가 꺼지면 쿠키가 삭제되는 옵션이다. 이 옵션이 정의되어있다면 브라우저가 꺼지는 순간 쿠키가 삭제된다.하지만 지속시간이 긴 쿠키라면(직접 정의할 수 있다.) 브라우저를 껐다가 켜도 쿠키가 지속된다.</p><hr><h2 id=\"세션-스토어\"><a href=\"#세션-스토어\" class=\"headerlink\" title=\"세션 스토어\"></a>세션 스토어</h2><p>세션에 대한 정보를 저장하는 어딘가</p><ul><li>쿠키</li><li>데이터베이스</li><li>파일</li><li>기타 정보를 저장할 수 있는 곳 어디든</li></ul><h3 id=\"세션-스토어의-선택\"><a href=\"#세션-스토어의-선택\" class=\"headerlink\" title=\"세션 스토어의 선택\"></a>세션 스토어의 선택</h3><p>서비스의 요구사항에 맞춰서 적절한 저장소를 선택하면 된다.</p><ul><li><p>쿠키: 정보의 형태가 간단하고 자주 바뀔 일이 없다면</p></li><li><p>데이터베이스: 저장해야 할 정보의 양이 많다면</p></li><li><p>메모리 기반 저장소: 정보가 굉장히 자주 변경된다면</p></li></ul><h2 id=\"세션-세션-스토어\"><a href=\"#세션-세션-스토어\" class=\"headerlink\" title=\"세션? 세션 스토어?\"></a>세션? 세션 스토어?</h2><p>‘세션’과 ‘세션 스토어’는 혼용되는 경우가 많지만 엄연히 다른 말이다.</p><p>‘세션에 정보를 저장한다’는 말은 ‘세션 스토어에 정보를 저장한다’는 말과 같은 의미이다.</p><h2 id=\"Express-Session\"><a href=\"#Express-Session\" class=\"headerlink\" title=\"Express + Session\"></a>Express + Session</h2><p><strong>cookie-session</strong></p><p>쿠키에 모든 정보를 저장하는 세션 스토어. 첫 방문시 무조건 세션 시작.</p><p><strong>express-session</strong></p><p>쿠키에는 세션 식별자만 저장하고 실제 정보의 저장은 외부 저장소(데이터베이스 등)를 이용하는 세션 스토어. 외부 저장소에 대한 별도의 설정 필요</p><h2 id=\"익스프레스-세션-예제\"><a href=\"#익스프레스-세션-예제\" class=\"headerlink\" title=\"익스프레스 세션 예제\"></a>익스프레스 세션 예제</h2><p><a href=\"https://glitch.com/edit/#!/laser-teal?path=README.md:1:0\" target=\"_blank\" rel=\"external\">link</a></p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// server.js</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// cookie-session 설정</span></div><div class=\"line\"><span class=\"comment\">// name: 쿠키 이름으로 사용할 문자열</span></div><div class=\"line\"><span class=\"comment\">// secret: 세션 정보를 서명할 때 사용할 키</span></div><div class=\"line\"><span class=\"comment\">// secret은 비밀 정보. 공개되어서는 안 된다.</span></div><div class=\"line\">app.use(cookieSession(&#123;</div><div class=\"line\">  name: <span class=\"string\">'session'</span>,</div><div class=\"line\">  secret: process.env.SECRET</div><div class=\"line\">&#125;))</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// req.session.count를 처리하는 미들웨어</span></div><div class=\"line\"><span class=\"keyword\">const</span> countMiddleware = <span class=\"function\">(<span class=\"params\">req, res, next</span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"string\">'count'</span> <span class=\"keyword\">in</span> req.session) &#123;</div><div class=\"line\">    <span class=\"comment\">// count 속성이 있으면 1으.</span></div><div class=\"line\">    req.session.count += <span class=\"number\">1</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// count 속성이 없으면 처음 방문한 것이므로 1로 설정한다.</span></div><div class=\"line\">    req.session.count = <span class=\"number\">1</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  next()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 첫 방문 후, 쿠키 관련 헤더가 요청과 응답에 잘 포함되는지 살펴보고,</span></div><div class=\"line\"><span class=\"comment\">// 실제로 쿠키가 어떻게 저장되어있는지 살펴보세요.</span></div><div class=\"line\">app.get(<span class=\"string\">'/'</span>, countMiddleware, (req, res) =&gt; &#123;</div><div class=\"line\">  res.render(<span class=\"string\">'index.ejs'</span>, &#123;<span class=\"attr\">count</span>: req.session.count&#125;)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">app.post(<span class=\"string\">'/reset-count'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  <span class=\"keyword\">delete</span> req.session.count</div><div class=\"line\">  res.redirect(<span class=\"string\">'/'</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'listening...'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// index. ejs</span></div><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html&gt;</div><div class=\"line\">  &lt;head&gt;</div><div class=\"line\">  &lt;<span class=\"regexp\">/head&gt;</span></div><div class=\"line\"><span class=\"regexp\">  &lt;body&gt;</span></div><div class=\"line\"><span class=\"regexp\">    &lt;div&gt;</span></div><div class=\"line\"><span class=\"regexp\">      &lt;%= count %&gt;번 째 방문하셨습니다.</span></div><div class=\"line\"><span class=\"regexp\">    &lt;/</span>div&gt;</div><div class=\"line\">    &lt;form action=<span class=\"string\">\"/reset-count\"</span> method=<span class=\"string\">\"post\"</span>&gt;</div><div class=\"line\">      &lt;button type=<span class=\"string\">\"submit\"</span>&gt;</div><div class=\"line\">        초기화</div><div class=\"line\">      &lt;<span class=\"regexp\">/button&gt;</span></div><div class=\"line\"><span class=\"regexp\">    &lt;/</span>form&gt;</div><div class=\"line\">  &lt;<span class=\"regexp\">/body&gt;</span></div><div class=\"line\"><span class=\"regexp\">&lt;/</span>html&gt;</div></pre></td></tr></table></figure><h2 id=\"인증-인가-예제\"><a href=\"#인증-인가-예제\" class=\"headerlink\" title=\"인증/인가 예제\"></a>인증/인가 예제</h2><p><a href=\"https://glitch.com/edit/#!/brave-picture?path=README.md:1:0\" target=\"_blank\" rel=\"external\">link</a></p><p><strong>인증(Authentication)과 인가(Authorization)</strong></p><p>인증(Authentication)은 클라이언트가 누구인지를 확인하는 과정이다. 지금은 ‘인증과 로그인은 같은 말’이라고 생각하셔도 무방하다.</p><p>인가(=허가)는 클라이언트가 하려고 하는 작업이 해당 클라이언트에게 허가된 작업인지를 확인하는 과정이다. ‘권한 설정’이라고 생각하셔도 무방하다. 예를 들어 다음 카페나 네이버 클럽에서는 관리자만이 게시판을 만들거나 없앨 수 있도록 인가된다.</p><p><br></p><p><strong>인증 구현 전략</strong></p><p>인증은 여러가지 방식으로 구현될 수 있으며, 여기에서는 우리가 쓰고 있는 cookie-session 의 기능에 맞추어서 구현해보도록 한다.</p><p>cookie-session이 제공하는 미들웨어는 첫 방문시 바로 세션을 시작하고 (이를 guest session이라 부릅니다) 쿠키에 빈 세션 정보(빈 객체)를 저장한다. 그래서 첫 방문자에 대해서도 session 객체를 바로 쓸 수 있다.</p><p>아래와 같은 규칙으로 인증을 구현해보도록 한다.</p><ol><li><p><code>req.session.username === undefined</code>이면 로그인된 사용자가 없는 것으로 간주한다.</p></li><li><p>사용자가 로그인 폼을 전송하면 accounts 배열에 저장된 계정 정보 중에 일치하는 것이 있는지 확인하고, 있다면 <code>req.session.username</code>에 해당 사용자 이름을 저장한다. 만약 일치하는 계정이 없으면 <code>400 Bad Request</code> 응답을 보낸다.</p></li><li><p><code>req.session.username</code>에 저장된 값이 있다면 해당 사용자로 로그인이 되어 있다고 간주한다.</p></li><li><p>로그아웃을 하기 위해 <code>req.session = null</code>와 같이 대입해서 세션을 초기화한다.</p></li></ol><p>(인증이 된 뒤에는 <code>req.user</code>와 <code>res.locals.user</code>에 계정 객체를 주입해서 라우트 핸들러와 템플릿에서 편하게 접근할 수 있도록 미리 코드를 짜 두었다.)</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// sever.js - account</span></div><div class=\"line\"><span class=\"keyword\">const</span> accounts = [</div><div class=\"line\">  &#123;</div><div class=\"line\">    username: <span class=\"string\">'seungha'</span>,</div><div class=\"line\">    password: <span class=\"string\">'kim'</span>,</div><div class=\"line\">    name: <span class=\"string\">'김승하'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  &#123;</div><div class=\"line\">    username: <span class=\"string\">'fast'</span>,</div><div class=\"line\">    password: <span class=\"string\">'campus'</span>,</div><div class=\"line\">    name: <span class=\"string\">'패스트캠퍼스'</span>,</div><div class=\"line\">    admin: <span class=\"literal\">true</span></div><div class=\"line\">  &#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//server.js - login</span></div><div class=\"line\">app.post(<span class=\"string\">'/login'</span>, urlencodedMiddleware, (req, res) =&gt; &#123;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 인증 과정을 작성해주세요.</span></div><div class=\"line\">  <span class=\"keyword\">if</span>(accounts.find( <span class=\"function\"><span class=\"params\">acc</span> =&gt;</span> acc.username === req.body.username &amp;&amp; acc.password === req.body.password))&#123;</div><div class=\"line\">    req.session.username = req.body.username;</div><div class=\"line\">    </div><div class=\"line\">    res.redirect(<span class=\"string\">'/'</span>);</div><div class=\"line\">    </div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    res.status(<span class=\"number\">404</span>);</div><div class=\"line\">    res.send(<span class=\"string\">'404 Not Found'</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  res.redirect(<span class=\"string\">'/'</span>);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//server.js - logout</span></div><div class=\"line\">app.post(<span class=\"string\">'/logout'</span>, urlencodedMiddleware, (req, res) =&gt; &#123;</div><div class=\"line\">  <span class=\"comment\">// 세션 초기화</span></div><div class=\"line\">  req.session = <span class=\"literal\">null</span></div><div class=\"line\">  res.redirect(<span class=\"string\">'/'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p><br></p><p><strong>인가 구현 전략</strong></p><p>관리자만이 비밀 정보(/secret)에 접근할 수 있도록 한다. 사용자가 관리자인지 아닌지의 여부는 계정 객체의 admin 속성에 저장되어 있다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// server.js - admin</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onlyAdminMiddleware</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// `/secret`에 접속했을 때 이 미들웨어가 작동합니다.</span></div><div class=\"line\">  <span class=\"keyword\">const</span> user = req.session.username;</div><div class=\"line\">  <span class=\"keyword\">if</span>(accounts.find( <span class=\"function\"><span class=\"params\">acc</span> =&gt;</span> acc.username === user &amp;&amp; acc.admin))&#123;</div><div class=\"line\">    <span class=\"comment\">// admin이면 통과!</span></div><div class=\"line\">    next();</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    res.status(<span class=\"number\">403</span>);</div><div class=\"line\">    res.send(<span class=\"string\">'403 Forbidden'</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">app.get(<span class=\"string\">'/secret'</span>, onlyAdminMiddleware, (req, res) =&gt; &#123;</div><div class=\"line\">  res.send(<span class=\"string\">'It is my secret'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://allvectorlogo.com/img/2016/05/node-js-logo.png\" alt=\"\"></p><h1 id=\"세션-Session\"><a href=\"#세션-Session\" class=\"headerlink\" title=\"세션 Session\"></a>세션 Session</h1><h3 id=\"세션의-의미\"><a href=\"#세션의-의미\" class=\"headerlink\" title=\"세션의 의미\"></a>세션의 의미</h3><p><strong>사전적 의미</strong><br>1) (특정한 활동을 위한) 시간<br>2) (의회 등의) 회기; (법정의) 개정 (기간)</p><p><strong>실질적 의미</strong><br>1) 시작 조건과 종료 조건이 있는 시간, 또는 회기<br>2) 정보 교환이 지속되는 시간, 또는 회기</p><h3 id=\"세션의-예\"><a href=\"#세션의-예\" class=\"headerlink\" title=\"세션의 예\"></a>세션의 예</h3><p><strong>HTTP session</strong>: 요청 - 응답</p><p><strong>로그인 세션</strong>: 로그인 - 로그아웃</p><p><strong>Google Analytics 세션</strong>:<br>페이지 접속 - 30분간 접속이 없으면 종료로 간주 (커스터마이징 가능)</p><h2 id=\"웹-서비스를-위한-세션의-구현\"><a href=\"#웹-서비스를-위한-세션의-구현\" class=\"headerlink\" title=\"웹 서비스를 위한 세션의 구현\"></a>웹 서비스를 위한 세션의 구현</h2><ol><li>세션이 시작되면(ex. 로그인하면), 세션이 시작되었다는 사실을 쿠키에 저장</li><li>세션에 대한 정보를 여러 요청에 걸쳐서 지속시키기 위해, 정보를 어딘가에 저장</li><li>세션이 만료되면(ex. 로그아웃하면), 세션이 만료되었다는 사실을 쿠키에 반영</li></ol><p><sub>* 위 방식은 널리 사용되는 방식일 뿐, 반드시 위와 같이 구현해야 하는 것은 아니다.</sub></p><hr><p>만약, 브라우저가 갑자기 꺼지면 쿠키는 어떻게 되는가?</p><p><strong>세션쿠키</strong>라는 것이 있다. 브라우저가 꺼지면 쿠키가 삭제되는 옵션이다. 이 옵션이 정의되어있다면 브라우저가 꺼지는 순간 쿠키가 삭제된다.하지만 지속시간이 긴 쿠키라면(직접 정의할 수 있다.) 브라우저를 껐다가 켜도 쿠키가 지속된다.</p><hr><h2 id=\"세션-스토어\"><a href=\"#세션-스토어\" class=\"headerlink\" title=\"세션 스토어\"></a>세션 스토어</h2><p>세션에 대한 정보를 저장하는 어딘가</p><ul><li>쿠키</li><li>데이터베이스</li><li>파일</li><li>기타 정보를 저장할 수 있는 곳 어디든</li></ul><h3 id=\"세션-스토어의-선택\"><a href=\"#세션-스토어의-선택\" class=\"headerlink\" title=\"세션 스토어의 선택\"></a>세션 스토어의 선택</h3><p>서비스의 요구사항에 맞춰서 적절한 저장소를 선택하면 된다.</p><ul><li><p>쿠키: 정보의 형태가 간단하고 자주 바뀔 일이 없다면</p></li><li><p>데이터베이스: 저장해야 할 정보의 양이 많다면</p></li><li><p>메모리 기반 저장소: 정보가 굉장히 자주 변경된다면</p></li></ul><h2 id=\"세션-세션-스토어\"><a href=\"#세션-세션-스토어\" class=\"headerlink\" title=\"세션? 세션 스토어?\"></a>세션? 세션 스토어?</h2><p>‘세션’과 ‘세션 스토어’는 혼용되는 경우가 많지만 엄연히 다른 말이다.</p><p>‘세션에 정보를 저장한다’는 말은 ‘세션 스토어에 정보를 저장한다’는 말과 같은 의미이다.</p><h2 id=\"Express-Session\"><a href=\"#Express-Session\" class=\"headerlink\" title=\"Express + Session\"></a>Express + Session</h2><p><strong>cookie-session</strong></p><p>쿠키에 모든 정보를 저장하는 세션 스토어. 첫 방문시 무조건 세션 시작.</p><p><strong>express-session</strong></p><p>쿠키에는 세션 식별자만 저장하고 실제 정보의 저장은 외부 저장소(데이터베이스 등)를 이용하는 세션 스토어. 외부 저장소에 대한 별도의 설정 필요</p><h2 id=\"익스프레스-세션-예제\"><a href=\"#익스프레스-세션-예제\" class=\"headerlink\" title=\"익스프레스 세션 예제\"></a>익스프레스 세션 예제</h2><p><a href=\"https://glitch.com/edit/#!/laser-teal?path=README.md:1:0\" target=\"_blank\" rel=\"external\">link</a></p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// server.js</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// cookie-session 설정</span></div><div class=\"line\"><span class=\"comment\">// name: 쿠키 이름으로 사용할 문자열</span></div><div class=\"line\"><span class=\"comment\">// secret: 세션 정보를 서명할 때 사용할 키</span></div><div class=\"line\"><span class=\"comment\">// secret은 비밀 정보. 공개되어서는 안 된다.</span></div><div class=\"line\">app.use(cookieSession(&#123;</div><div class=\"line\">  name: <span class=\"string\">'session'</span>,</div><div class=\"line\">  secret: process.env.SECRET</div><div class=\"line\">&#125;))</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// req.session.count를 처리하는 미들웨어</span></div><div class=\"line\"><span class=\"keyword\">const</span> countMiddleware = <span class=\"function\">(<span class=\"params\">req, res, next</span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"string\">'count'</span> <span class=\"keyword\">in</span> req.session) &#123;</div><div class=\"line\">    <span class=\"comment\">// count 속성이 있으면 1으.</span></div><div class=\"line\">    req.session.count += <span class=\"number\">1</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// count 속성이 없으면 처음 방문한 것이므로 1로 설정한다.</span></div><div class=\"line\">    req.session.count = <span class=\"number\">1</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  next()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 첫 방문 후, 쿠키 관련 헤더가 요청과 응답에 잘 포함되는지 살펴보고,</span></div><div class=\"line\"><span class=\"comment\">// 실제로 쿠키가 어떻게 저장되어있는지 살펴보세요.</span></div><div class=\"line\">app.get(<span class=\"string\">'/'</span>, countMiddleware, (req, res) =&gt; &#123;</div><div class=\"line\">  res.render(<span class=\"string\">'index.ejs'</span>, &#123;<span class=\"attr\">count</span>: req.session.count&#125;)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">app.post(<span class=\"string\">'/reset-count'</span>, (req, res) =&gt; &#123;</div><div class=\"line\">  <span class=\"keyword\">delete</span> req.session.count</div><div class=\"line\">  res.redirect(<span class=\"string\">'/'</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'listening...'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// index. ejs</span></div><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html&gt;</div><div class=\"line\">  &lt;head&gt;</div><div class=\"line\">  &lt;<span class=\"regexp\">/head&gt;</span></div><div class=\"line\"><span class=\"regexp\">  &lt;body&gt;</span></div><div class=\"line\"><span class=\"regexp\">    &lt;div&gt;</span></div><div class=\"line\"><span class=\"regexp\">      &lt;%= count %&gt;번 째 방문하셨습니다.</span></div><div class=\"line\"><span class=\"regexp\">    &lt;/</span>div&gt;</div><div class=\"line\">    &lt;form action=<span class=\"string\">\"/reset-count\"</span> method=<span class=\"string\">\"post\"</span>&gt;</div><div class=\"line\">      &lt;button type=<span class=\"string\">\"submit\"</span>&gt;</div><div class=\"line\">        초기화</div><div class=\"line\">      &lt;<span class=\"regexp\">/button&gt;</span></div><div class=\"line\"><span class=\"regexp\">    &lt;/</span>form&gt;</div><div class=\"line\">  &lt;<span class=\"regexp\">/body&gt;</span></div><div class=\"line\"><span class=\"regexp\">&lt;/</span>html&gt;</div></pre></td></tr></table></figure><h2 id=\"인증-인가-예제\"><a href=\"#인증-인가-예제\" class=\"headerlink\" title=\"인증/인가 예제\"></a>인증/인가 예제</h2><p><a href=\"https://glitch.com/edit/#!/brave-picture?path=README.md:1:0\" target=\"_blank\" rel=\"external\">link</a></p><p><strong>인증(Authentication)과 인가(Authorization)</strong></p><p>인증(Authentication)은 클라이언트가 누구인지를 확인하는 과정이다. 지금은 ‘인증과 로그인은 같은 말’이라고 생각하셔도 무방하다.</p><p>인가(=허가)는 클라이언트가 하려고 하는 작업이 해당 클라이언트에게 허가된 작업인지를 확인하는 과정이다. ‘권한 설정’이라고 생각하셔도 무방하다. 예를 들어 다음 카페나 네이버 클럽에서는 관리자만이 게시판을 만들거나 없앨 수 있도록 인가된다.</p><p><br></p><p><strong>인증 구현 전략</strong></p><p>인증은 여러가지 방식으로 구현될 수 있으며, 여기에서는 우리가 쓰고 있는 cookie-session 의 기능에 맞추어서 구현해보도록 한다.</p><p>cookie-session이 제공하는 미들웨어는 첫 방문시 바로 세션을 시작하고 (이를 guest session이라 부릅니다) 쿠키에 빈 세션 정보(빈 객체)를 저장한다. 그래서 첫 방문자에 대해서도 session 객체를 바로 쓸 수 있다.</p><p>아래와 같은 규칙으로 인증을 구현해보도록 한다.</p><ol><li><p><code>req.session.username === undefined</code>이면 로그인된 사용자가 없는 것으로 간주한다.</p></li><li><p>사용자가 로그인 폼을 전송하면 accounts 배열에 저장된 계정 정보 중에 일치하는 것이 있는지 확인하고, 있다면 <code>req.session.username</code>에 해당 사용자 이름을 저장한다. 만약 일치하는 계정이 없으면 <code>400 Bad Request</code> 응답을 보낸다.</p></li><li><p><code>req.session.username</code>에 저장된 값이 있다면 해당 사용자로 로그인이 되어 있다고 간주한다.</p></li><li><p>로그아웃을 하기 위해 <code>req.session = null</code>와 같이 대입해서 세션을 초기화한다.</p></li></ol><p>(인증이 된 뒤에는 <code>req.user</code>와 <code>res.locals.user</code>에 계정 객체를 주입해서 라우트 핸들러와 템플릿에서 편하게 접근할 수 있도록 미리 코드를 짜 두었다.)</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// sever.js - account</span></div><div class=\"line\"><span class=\"keyword\">const</span> accounts = [</div><div class=\"line\">  &#123;</div><div class=\"line\">    username: <span class=\"string\">'seungha'</span>,</div><div class=\"line\">    password: <span class=\"string\">'kim'</span>,</div><div class=\"line\">    name: <span class=\"string\">'김승하'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  &#123;</div><div class=\"line\">    username: <span class=\"string\">'fast'</span>,</div><div class=\"line\">    password: <span class=\"string\">'campus'</span>,</div><div class=\"line\">    name: <span class=\"string\">'패스트캠퍼스'</span>,</div><div class=\"line\">    admin: <span class=\"literal\">true</span></div><div class=\"line\">  &#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//server.js - login</span></div><div class=\"line\">app.post(<span class=\"string\">'/login'</span>, urlencodedMiddleware, (req, res) =&gt; &#123;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 인증 과정을 작성해주세요.</span></div><div class=\"line\">  <span class=\"keyword\">if</span>(accounts.find( <span class=\"function\"><span class=\"params\">acc</span> =&gt;</span> acc.username === req.body.username &amp;&amp; acc.password === req.body.password))&#123;</div><div class=\"line\">    req.session.username = req.body.username;</div><div class=\"line\">    </div><div class=\"line\">    res.redirect(<span class=\"string\">'/'</span>);</div><div class=\"line\">    </div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    res.status(<span class=\"number\">404</span>);</div><div class=\"line\">    res.send(<span class=\"string\">'404 Not Found'</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  res.redirect(<span class=\"string\">'/'</span>);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//server.js - logout</span></div><div class=\"line\">app.post(<span class=\"string\">'/logout'</span>, urlencodedMiddleware, (req, res) =&gt; &#123;</div><div class=\"line\">  <span class=\"comment\">// 세션 초기화</span></div><div class=\"line\">  req.session = <span class=\"literal\">null</span></div><div class=\"line\">  res.redirect(<span class=\"string\">'/'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p><br></p><p><strong>인가 구현 전략</strong></p><p>관리자만이 비밀 정보(/secret)에 접근할 수 있도록 한다. 사용자가 관리자인지 아닌지의 여부는 계정 객체의 admin 속성에 저장되어 있다.</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// server.js - admin</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onlyAdminMiddleware</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// `/secret`에 접속했을 때 이 미들웨어가 작동합니다.</span></div><div class=\"line\">  <span class=\"keyword\">const</span> user = req.session.username;</div><div class=\"line\">  <span class=\"keyword\">if</span>(accounts.find( <span class=\"function\"><span class=\"params\">acc</span> =&gt;</span> acc.username === user &amp;&amp; acc.admin))&#123;</div><div class=\"line\">    <span class=\"comment\">// admin이면 통과!</span></div><div class=\"line\">    next();</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    res.status(<span class=\"number\">403</span>);</div><div class=\"line\">    res.send(<span class=\"string\">'403 Forbidden'</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">app.get(<span class=\"string\">'/secret'</span>, onlyAdminMiddleware, (req, res) =&gt; &#123;</div><div class=\"line\">  res.send(<span class=\"string\">'It is my secret'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>"},{"title":"[node] Mac OS에서 Node 삭제하기 ","date":"2017-11-27T13:31:29.000Z","_content":"\n> *일부 번역 & 정리한 글입니다.  \n  [원문: How to Uninstall Node.js from Mac OSX ](http://stackabuse.com/how-to-uninstall-node-js-from-mac-osx/)  \n  By Scott Robinson • January 20, 2016*\n\n# Manually\n\n소스 또는 바이너리 배포판을 통해 Node를 설치했다면 실행 파일과 기타 리소스를 수동으로 삭제해야 할 가능성이 높습니다. npm과 node_modules와 같은 Node 리소스가 포함 된 디렉토리가 꽤 많기 때문에 안타깝게도 상당히 귀찮을 겁니다.\n\n아래 나열된 것들을 전부 찾아서 직접 지워야 합니다. Node를 설치 했던 방법에 따라 없는 것들도 있을 수 있습니다. 앞에 `.` 이 붙은 것은 숨김 폴더 혹은 숨김 파일 입니다. 기본적으로 보이지 않도록 설정 되어 있습니다. Finder에 포커스를 두고 `Command+Shift+.(>)` 키를 누르면 숨김 파일 및 폴더를 볼 수 있습니다.\n\n|위치|대상|\n|---|---|\n|홈디렉터리|`.npmrc`(npm 설정 파일, 노드를 곧바로 재설치할 게 아니면 지우지 마세요.)|\n|홈디렉터리|`.npm`, `.node-gyp`, `.node_repl_history` |\n|/usr/local/lib|`node` 또는 `node_modules` (혹은 둘 다)|\n|/usr/local/lib/dtrace/|`node.d`|\n|/usr/local/bin|`node`, `node-debug`, `node-gyp`|\n|/usr/local/include|`node` 또는 `node_modules` (혹은 둘 다)|\n|/usr/local/share/doc/|`node`|\n|/usr/local/share/systemtap/tapset/|`node.stp`|\n|/usr/local/share/man/man1/|`node`나 `npm`으로 시작하는 파일/폴더 전체|\n|/opt/local/bin/|`node`|\n|/opt/local/include/|`node`|\n|/opt/local/lib/|`node_modules`|\n\n이외에도 시스템 내 Node에 관한 모든 참조 파일/폴더가 삭제 되어야 합니다. 앞서 말했듯 설치했던 방법에 따라 관련 파일이 더 존재하거나 없을 수 있으니 주의하세요.\n\n<br>\n\n# Homebrew\n\n홈브루를 이용하여 삭제할 수도 있습니다.\n\n```\n$ brew uninstall node\n```\n\n다만, homebrew는 노드를 버전별로 선택적으로 삭제하는 기능은 제공하지 않습니다. 여러 버전의 노드가 설치되어 있더라도 전체 삭제만 가능합니다. 만약 특정 버전의 노드만 선택적으로 삭제하고 싶다면 아래 nvm을 이용한 삭제 방법을 따르셔야 합니다.\n\n<br>\n\n# nvm\n\n```\n$ nvm uninstall <version>\n```\n\n만약 6.12.0 버전만 삭제하고 싶다면 아래와 같이 입력하면 됩니다.\n\n```\n& nvm uninstall v6.12.0\n```\n\n# Phantom Installs\n\n만약 위 세 방법 중 어느 방법도 Node를 제대로 삭제하지 못한다면, 터미널로 node 실행 파일의 위치를 검색해 봅니다. 아래 명령을 통해 시스템에 Node가 설치된 위치를 찾을 수 있습니다.\n\n```\n$ which node\n/Users/ihyeseung/.nvm/versions/node/v8.9.1/bin/node\n```\n\n노드가 nvm 아래에 설치된 것을 확인할 수 있습니다. 해당 경로로 들어가 수동으로 삭제하면 됩니다.\n\n---\n","source":"_posts/nodejs/10.how-to-uninstall-node.md","raw":"---\ntitle: '[node] Mac OS에서 Node 삭제하기 '\ndate: 2017-11-27 22:31:29\ncategory: Nodejs\ntags: \n  - nodejs\n  - uninstall node\n  - how to uninstall node\n---\n\n> *일부 번역 & 정리한 글입니다.  \n  [원문: How to Uninstall Node.js from Mac OSX ](http://stackabuse.com/how-to-uninstall-node-js-from-mac-osx/)  \n  By Scott Robinson • January 20, 2016*\n\n# Manually\n\n소스 또는 바이너리 배포판을 통해 Node를 설치했다면 실행 파일과 기타 리소스를 수동으로 삭제해야 할 가능성이 높습니다. npm과 node_modules와 같은 Node 리소스가 포함 된 디렉토리가 꽤 많기 때문에 안타깝게도 상당히 귀찮을 겁니다.\n\n아래 나열된 것들을 전부 찾아서 직접 지워야 합니다. Node를 설치 했던 방법에 따라 없는 것들도 있을 수 있습니다. 앞에 `.` 이 붙은 것은 숨김 폴더 혹은 숨김 파일 입니다. 기본적으로 보이지 않도록 설정 되어 있습니다. Finder에 포커스를 두고 `Command+Shift+.(>)` 키를 누르면 숨김 파일 및 폴더를 볼 수 있습니다.\n\n|위치|대상|\n|---|---|\n|홈디렉터리|`.npmrc`(npm 설정 파일, 노드를 곧바로 재설치할 게 아니면 지우지 마세요.)|\n|홈디렉터리|`.npm`, `.node-gyp`, `.node_repl_history` |\n|/usr/local/lib|`node` 또는 `node_modules` (혹은 둘 다)|\n|/usr/local/lib/dtrace/|`node.d`|\n|/usr/local/bin|`node`, `node-debug`, `node-gyp`|\n|/usr/local/include|`node` 또는 `node_modules` (혹은 둘 다)|\n|/usr/local/share/doc/|`node`|\n|/usr/local/share/systemtap/tapset/|`node.stp`|\n|/usr/local/share/man/man1/|`node`나 `npm`으로 시작하는 파일/폴더 전체|\n|/opt/local/bin/|`node`|\n|/opt/local/include/|`node`|\n|/opt/local/lib/|`node_modules`|\n\n이외에도 시스템 내 Node에 관한 모든 참조 파일/폴더가 삭제 되어야 합니다. 앞서 말했듯 설치했던 방법에 따라 관련 파일이 더 존재하거나 없을 수 있으니 주의하세요.\n\n<br>\n\n# Homebrew\n\n홈브루를 이용하여 삭제할 수도 있습니다.\n\n```\n$ brew uninstall node\n```\n\n다만, homebrew는 노드를 버전별로 선택적으로 삭제하는 기능은 제공하지 않습니다. 여러 버전의 노드가 설치되어 있더라도 전체 삭제만 가능합니다. 만약 특정 버전의 노드만 선택적으로 삭제하고 싶다면 아래 nvm을 이용한 삭제 방법을 따르셔야 합니다.\n\n<br>\n\n# nvm\n\n```\n$ nvm uninstall <version>\n```\n\n만약 6.12.0 버전만 삭제하고 싶다면 아래와 같이 입력하면 됩니다.\n\n```\n& nvm uninstall v6.12.0\n```\n\n# Phantom Installs\n\n만약 위 세 방법 중 어느 방법도 Node를 제대로 삭제하지 못한다면, 터미널로 node 실행 파일의 위치를 검색해 봅니다. 아래 명령을 통해 시스템에 Node가 설치된 위치를 찾을 수 있습니다.\n\n```\n$ which node\n/Users/ihyeseung/.nvm/versions/node/v8.9.1/bin/node\n```\n\n노드가 nvm 아래에 설치된 것을 확인할 수 있습니다. 해당 경로로 들어가 수동으로 삭제하면 됩니다.\n\n---\n","slug":"nodejs/10.how-to-uninstall-node","published":1,"updated":"2017-11-27T13:31:23.446Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjai8h18u001nvb9qb632wizh","content":"<blockquote><p><em>일부 번역 &amp; 정리한 글입니다.<br><a href=\"http://stackabuse.com/how-to-uninstall-node-js-from-mac-osx/\" target=\"_blank\" rel=\"external\">원문: How to Uninstall Node.js from Mac OSX</a><br>By Scott Robinson • January 20, 2016</em></p></blockquote><h1 id=\"Manually\"><a href=\"#Manually\" class=\"headerlink\" title=\"Manually\"></a>Manually</h1><p>소스 또는 바이너리 배포판을 통해 Node를 설치했다면 실행 파일과 기타 리소스를 수동으로 삭제해야 할 가능성이 높습니다. npm과 node_modules와 같은 Node 리소스가 포함 된 디렉토리가 꽤 많기 때문에 안타깝게도 상당히 귀찮을 겁니다.</p><p>아래 나열된 것들을 전부 찾아서 직접 지워야 합니다. Node를 설치 했던 방법에 따라 없는 것들도 있을 수 있습니다. 앞에 <code>.</code> 이 붙은 것은 숨김 폴더 혹은 숨김 파일 입니다. 기본적으로 보이지 않도록 설정 되어 있습니다. Finder에 포커스를 두고 <code>Command+Shift+.(&gt;)</code> 키를 누르면 숨김 파일 및 폴더를 볼 수 있습니다.</p><table><thead><tr><th>위치</th><th>대상</th></tr></thead><tbody><tr><td>홈디렉터리</td><td><code>.npmrc</code>(npm 설정 파일, 노드를 곧바로 재설치할 게 아니면 지우지 마세요.)</td></tr><tr><td>홈디렉터리</td><td><code>.npm</code>, <code>.node-gyp</code>, <code>.node_repl_history</code></td></tr><tr><td>/usr/local/lib</td><td><code>node</code> 또는 <code>node_modules</code> (혹은 둘 다)</td></tr><tr><td>/usr/local/lib/dtrace/</td><td><code>node.d</code></td></tr><tr><td>/usr/local/bin</td><td><code>node</code>, <code>node-debug</code>, <code>node-gyp</code></td></tr><tr><td>/usr/local/include</td><td><code>node</code> 또는 <code>node_modules</code> (혹은 둘 다)</td></tr><tr><td>/usr/local/share/doc/</td><td><code>node</code></td></tr><tr><td>/usr/local/share/systemtap/tapset/</td><td><code>node.stp</code></td></tr><tr><td>/usr/local/share/man/man1/</td><td><code>node</code>나 <code>npm</code>으로 시작하는 파일/폴더 전체</td></tr><tr><td>/opt/local/bin/</td><td><code>node</code></td></tr><tr><td>/opt/local/include/</td><td><code>node</code></td></tr><tr><td>/opt/local/lib/</td><td><code>node_modules</code></td></tr></tbody></table><p>이외에도 시스템 내 Node에 관한 모든 참조 파일/폴더가 삭제 되어야 합니다. 앞서 말했듯 설치했던 방법에 따라 관련 파일이 더 존재하거나 없을 수 있으니 주의하세요.</p><p><br></p><h1 id=\"Homebrew\"><a href=\"#Homebrew\" class=\"headerlink\" title=\"Homebrew\"></a>Homebrew</h1><p>홈브루를 이용하여 삭제할 수도 있습니다.</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ brew uninstall node</div></pre></td></tr></table></figure><p>다만, homebrew는 노드를 버전별로 선택적으로 삭제하는 기능은 제공하지 않습니다. 여러 버전의 노드가 설치되어 있더라도 전체 삭제만 가능합니다. 만약 특정 버전의 노드만 선택적으로 삭제하고 싶다면 아래 nvm을 이용한 삭제 방법을 따르셔야 합니다.</p><p><br></p><h1 id=\"nvm\"><a href=\"#nvm\" class=\"headerlink\" title=\"nvm\"></a>nvm</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ nvm uninstall &lt;version&gt;</div></pre></td></tr></table></figure><p>만약 6.12.0 버전만 삭제하고 싶다면 아래와 같이 입력하면 됩니다.</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&amp; nvm uninstall v6.12.0</div></pre></td></tr></table></figure><h1 id=\"Phantom-Installs\"><a href=\"#Phantom-Installs\" class=\"headerlink\" title=\"Phantom Installs\"></a>Phantom Installs</h1><p>만약 위 세 방법 중 어느 방법도 Node를 제대로 삭제하지 못한다면, 터미널로 node 실행 파일의 위치를 검색해 봅니다. 아래 명령을 통해 시스템에 Node가 설치된 위치를 찾을 수 있습니다.</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ which node</div><div class=\"line\">/Users/ihyeseung/.nvm/versions/node/v8.9.1/bin/node</div></pre></td></tr></table></figure><p>노드가 nvm 아래에 설치된 것을 확인할 수 있습니다. 해당 경로로 들어가 수동으로 삭제하면 됩니다.</p><hr>","site":{"data":{}},"excerpt":"","more":"<blockquote><p><em>일부 번역 &amp; 정리한 글입니다.<br><a href=\"http://stackabuse.com/how-to-uninstall-node-js-from-mac-osx/\" target=\"_blank\" rel=\"external\">원문: How to Uninstall Node.js from Mac OSX</a><br>By Scott Robinson • January 20, 2016</em></p></blockquote><h1 id=\"Manually\"><a href=\"#Manually\" class=\"headerlink\" title=\"Manually\"></a>Manually</h1><p>소스 또는 바이너리 배포판을 통해 Node를 설치했다면 실행 파일과 기타 리소스를 수동으로 삭제해야 할 가능성이 높습니다. npm과 node_modules와 같은 Node 리소스가 포함 된 디렉토리가 꽤 많기 때문에 안타깝게도 상당히 귀찮을 겁니다.</p><p>아래 나열된 것들을 전부 찾아서 직접 지워야 합니다. Node를 설치 했던 방법에 따라 없는 것들도 있을 수 있습니다. 앞에 <code>.</code> 이 붙은 것은 숨김 폴더 혹은 숨김 파일 입니다. 기본적으로 보이지 않도록 설정 되어 있습니다. Finder에 포커스를 두고 <code>Command+Shift+.(&gt;)</code> 키를 누르면 숨김 파일 및 폴더를 볼 수 있습니다.</p><table><thead><tr><th>위치</th><th>대상</th></tr></thead><tbody><tr><td>홈디렉터리</td><td><code>.npmrc</code>(npm 설정 파일, 노드를 곧바로 재설치할 게 아니면 지우지 마세요.)</td></tr><tr><td>홈디렉터리</td><td><code>.npm</code>, <code>.node-gyp</code>, <code>.node_repl_history</code></td></tr><tr><td>/usr/local/lib</td><td><code>node</code> 또는 <code>node_modules</code> (혹은 둘 다)</td></tr><tr><td>/usr/local/lib/dtrace/</td><td><code>node.d</code></td></tr><tr><td>/usr/local/bin</td><td><code>node</code>, <code>node-debug</code>, <code>node-gyp</code></td></tr><tr><td>/usr/local/include</td><td><code>node</code> 또는 <code>node_modules</code> (혹은 둘 다)</td></tr><tr><td>/usr/local/share/doc/</td><td><code>node</code></td></tr><tr><td>/usr/local/share/systemtap/tapset/</td><td><code>node.stp</code></td></tr><tr><td>/usr/local/share/man/man1/</td><td><code>node</code>나 <code>npm</code>으로 시작하는 파일/폴더 전체</td></tr><tr><td>/opt/local/bin/</td><td><code>node</code></td></tr><tr><td>/opt/local/include/</td><td><code>node</code></td></tr><tr><td>/opt/local/lib/</td><td><code>node_modules</code></td></tr></tbody></table><p>이외에도 시스템 내 Node에 관한 모든 참조 파일/폴더가 삭제 되어야 합니다. 앞서 말했듯 설치했던 방법에 따라 관련 파일이 더 존재하거나 없을 수 있으니 주의하세요.</p><p><br></p><h1 id=\"Homebrew\"><a href=\"#Homebrew\" class=\"headerlink\" title=\"Homebrew\"></a>Homebrew</h1><p>홈브루를 이용하여 삭제할 수도 있습니다.</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ brew uninstall node</div></pre></td></tr></table></figure><p>다만, homebrew는 노드를 버전별로 선택적으로 삭제하는 기능은 제공하지 않습니다. 여러 버전의 노드가 설치되어 있더라도 전체 삭제만 가능합니다. 만약 특정 버전의 노드만 선택적으로 삭제하고 싶다면 아래 nvm을 이용한 삭제 방법을 따르셔야 합니다.</p><p><br></p><h1 id=\"nvm\"><a href=\"#nvm\" class=\"headerlink\" title=\"nvm\"></a>nvm</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ nvm uninstall &lt;version&gt;</div></pre></td></tr></table></figure><p>만약 6.12.0 버전만 삭제하고 싶다면 아래와 같이 입력하면 됩니다.</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&amp; nvm uninstall v6.12.0</div></pre></td></tr></table></figure><h1 id=\"Phantom-Installs\"><a href=\"#Phantom-Installs\" class=\"headerlink\" title=\"Phantom Installs\"></a>Phantom Installs</h1><p>만약 위 세 방법 중 어느 방법도 Node를 제대로 삭제하지 못한다면, 터미널로 node 실행 파일의 위치를 검색해 봅니다. 아래 명령을 통해 시스템에 Node가 설치된 위치를 찾을 수 있습니다.</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ which node</div><div class=\"line\">/Users/ihyeseung/.nvm/versions/node/v8.9.1/bin/node</div></pre></td></tr></table></figure><p>노드가 nvm 아래에 설치된 것을 확인할 수 있습니다. 해당 경로로 들어가 수동으로 삭제하면 됩니다.</p><hr>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjai8h17g0003vb9qm6jfelfq","category_id":"cjai8h17o0005vb9qhga6hdan","_id":"cjai8h17x000dvb9q90uz7y8z"},{"post_id":"cjai8h17m0004vb9qnz0fmvwe","category_id":"cjai8h17o0005vb9qhga6hdan","_id":"cjai8h182000ivb9qm0mj1mbi"},{"post_id":"cjai8h17r0007vb9q8f41c8kb","category_id":"cjai8h17o0005vb9qhga6hdan","_id":"cjai8h185000ovb9qfszsx0b2"},{"post_id":"cjai8h17s0008vb9qm7mn7rs6","category_id":"cjai8h183000kvb9qps1vz8oe","_id":"cjai8h18a000wvb9q6vnz54s8"},{"post_id":"cjai8h17t0009vb9q54ztmnqq","category_id":"cjai8h186000qvb9qvx387cb0","_id":"cjai8h18f0012vb9qak0i74wv"},{"post_id":"cjai8h17w000cvb9q5akg1lji","category_id":"cjai8h18a000yvb9qk6kjbzwo","_id":"cjai8h18j0018vb9qk9a4b2xp"},{"post_id":"cjai8h17y000evb9q5hx79lzv","category_id":"cjai8h18a000yvb9qk6kjbzwo","_id":"cjai8h18o001fvb9qngew8f3v"},{"post_id":"cjai8h180000hvb9qsuoujbly","category_id":"cjai8h18a000yvb9qk6kjbzwo","_id":"cjai8h18t001lvb9qz7h21m4b"},{"post_id":"cjai8h182000jvb9q3xx88nd9","category_id":"cjai8h18a000yvb9qk6kjbzwo","_id":"cjai8h18w001qvb9qw12p7i0n"},{"post_id":"cjai8h184000mvb9qz7u1q1it","category_id":"cjai8h18t001mvb9qnqe71blv","_id":"cjai8h18x001uvb9q0wmg9br8"},{"post_id":"cjai8h185000pvb9qv0v5fvlz","category_id":"cjai8h18t001mvb9qnqe71blv","_id":"cjai8h190001xvb9qcjvyl98s"},{"post_id":"cjai8h187000tvb9qmy3la3ls","category_id":"cjai8h18z001vvb9q7w11b51l","_id":"cjai8h1910021vb9qkobdn2xe"},{"post_id":"cjai8h189000vvb9qwknochl1","category_id":"cjai8h18z001vvb9q7w11b51l","_id":"cjai8h1930025vb9qfixvx955"},{"post_id":"cjai8h18b0010vb9q08cpfgmg","category_id":"cjai8h18z001vvb9q7w11b51l","_id":"cjai8h1940029vb9q05u63ndm"},{"post_id":"cjai8h18e0011vb9qcuescbq6","category_id":"cjai8h18z001vvb9q7w11b51l","_id":"cjai8h195002cvb9qka46y491"},{"post_id":"cjai8h18g0015vb9qr6jr7qgu","category_id":"cjai8h18z001vvb9q7w11b51l","_id":"cjai8h196002gvb9qin2jaa0b"},{"post_id":"cjai8h18h0017vb9q3icsepvm","category_id":"cjai8h18z001vvb9q7w11b51l","_id":"cjai8h198002kvb9qcu0c8whz"},{"post_id":"cjai8h18k001bvb9q2o34f5wq","category_id":"cjai8h18z001vvb9q7w11b51l","_id":"cjai8h19b002ovb9qs0bcql7z"},{"post_id":"cjai8h18n001evb9q4itsxo9q","category_id":"cjai8h18z001vvb9q7w11b51l","_id":"cjai8h19d002svb9qaml49ckf"},{"post_id":"cjai8h18p001hvb9q5vfx0nsq","category_id":"cjai8h18z001vvb9q7w11b51l","_id":"cjai8h19f002wvb9qg0r0jrsq"},{"post_id":"cjai8h18s001jvb9qnj3aa8a4","category_id":"cjai8h18z001vvb9q7w11b51l","_id":"cjai8h19h002zvb9qsq1f1ze7"},{"post_id":"cjai8h18u001nvb9qb632wizh","category_id":"cjai8h18z001vvb9q7w11b51l","_id":"cjai8h19h0032vb9qzedct7pq"}],"PostTag":[{"post_id":"cjai8h17g0003vb9qm6jfelfq","tag_id":"cjai8h17q0006vb9qn3imwgu9","_id":"cjai8h185000nvb9qw0ihjybz"},{"post_id":"cjai8h17g0003vb9qm6jfelfq","tag_id":"cjai8h17u000bvb9qpn7yrusn","_id":"cjai8h186000rvb9q0ydanmyk"},{"post_id":"cjai8h17g0003vb9qm6jfelfq","tag_id":"cjai8h17z000gvb9qz6gt7zyo","_id":"cjai8h189000uvb9q0u08mo38"},{"post_id":"cjai8h17m0004vb9qnz0fmvwe","tag_id":"cjai8h17u000bvb9qpn7yrusn","_id":"cjai8h18a000xvb9q77qpbxfa"},{"post_id":"cjai8h17r0007vb9q8f41c8kb","tag_id":"cjai8h17u000bvb9qpn7yrusn","_id":"cjai8h18h0016vb9q5p9ogi6o"},{"post_id":"cjai8h17r0007vb9q8f41c8kb","tag_id":"cjai8h18a000zvb9qy7vj3311","_id":"cjai8h18j0019vb9qip0o01vr"},{"post_id":"cjai8h17s0008vb9qm7mn7rs6","tag_id":"cjai8h18g0014vb9qqhbrs7yk","_id":"cjai8h18m001dvb9qbvi74owg"},{"post_id":"cjai8h17t0009vb9q54ztmnqq","tag_id":"cjai8h18m001cvb9qr1jvriqg","_id":"cjai8h18t001kvb9q9wbgp3f5"},{"post_id":"cjai8h17w000cvb9q5akg1lji","tag_id":"cjai8h18r001ivb9qvrhyw48c","_id":"cjai8h18w001pvb9q9373xkwn"},{"post_id":"cjai8h17y000evb9q5hx79lzv","tag_id":"cjai8h18v001ovb9qh4f5fsae","_id":"cjai8h18x001tvb9qjh8zmrso"},{"post_id":"cjai8h180000hvb9qsuoujbly","tag_id":"cjai8h18w001svb9q9ih3nmgu","_id":"cjai8h190001yvb9qum8wp70t"},{"post_id":"cjai8h182000jvb9q3xx88nd9","tag_id":"cjai8h190001wvb9qaoj3o7hy","_id":"cjai8h1920022vb9qnd2735p6"},{"post_id":"cjai8h184000mvb9qz7u1q1it","tag_id":"cjai8h1910020vb9qa5568ukg","_id":"cjai8h1930027vb9qgz19ts3a"},{"post_id":"cjai8h185000pvb9qv0v5fvlz","tag_id":"cjai8h1920024vb9ql7liklr1","_id":"cjai8h195002bvb9qrhxipr3i"},{"post_id":"cjai8h187000tvb9qmy3la3ls","tag_id":"cjai8h1940028vb9qxqlkne8v","_id":"cjai8h196002fvb9qykuyvzzn"},{"post_id":"cjai8h189000vvb9qwknochl1","tag_id":"cjai8h195002dvb9qivcqidxl","_id":"cjai8h197002jvb9qfllbw6o9"},{"post_id":"cjai8h18b0010vb9q08cpfgmg","tag_id":"cjai8h197002ivb9qvi49vo43","_id":"cjai8h19a002nvb9qse86rp1z"},{"post_id":"cjai8h18e0011vb9qcuescbq6","tag_id":"cjai8h199002mvb9qaltin1tv","_id":"cjai8h19d002rvb9qbit9ba2z"},{"post_id":"cjai8h18g0015vb9qr6jr7qgu","tag_id":"cjai8h19c002qvb9qhf05838d","_id":"cjai8h19f002vvb9qu77wuv3f"},{"post_id":"cjai8h18h0017vb9q3icsepvm","tag_id":"cjai8h19e002uvb9qntqu8624","_id":"cjai8h19h0030vb9q0gg2r92h"},{"post_id":"cjai8h18k001bvb9q2o34f5wq","tag_id":"cjai8h19g002yvb9qkkhn15yk","_id":"cjai8h19i0033vb9q93539rhu"},{"post_id":"cjai8h18n001evb9q4itsxo9q","tag_id":"cjai8h19h0031vb9qxqlwpp93","_id":"cjai8h19i0035vb9qy7otinoa"},{"post_id":"cjai8h18p001hvb9q5vfx0nsq","tag_id":"cjai8h19i0034vb9q7xkl4dm5","_id":"cjai8h19j0037vb9qbb40fzjk"},{"post_id":"cjai8h18s001jvb9qnj3aa8a4","tag_id":"cjai8h19i0036vb9qdfv3nxbi","_id":"cjai8h19j0039vb9qjnra9orp"},{"post_id":"cjai8h18u001nvb9qb632wizh","tag_id":"cjai8h19j0038vb9qcebvaybk","_id":"cjai8h19k003cvb9q771wb8sp"},{"post_id":"cjai8h18u001nvb9qb632wizh","tag_id":"cjai8h19k003avb9q925d6u4t","_id":"cjai8h19l003dvb9q7ff7xu6l"},{"post_id":"cjai8h18u001nvb9qb632wizh","tag_id":"cjai8h19k003bvb9q4xut97e0","_id":"cjai8h19l003evb9q1r4lcw6n"}],"Tag":[{"name":"github","_id":"cjai8h17q0006vb9qn3imwgu9"},{"name":"git","_id":"cjai8h17u000bvb9qpn7yrusn"},{"name":"remote","_id":"cjai8h17z000gvb9qz6gt7zyo"},{"name":"prune","_id":"cjai8h18a000zvb9qy7vj3311"},{"name":"react","_id":"cjai8h18g0014vb9qqhbrs7yk"},{"name":"semantic-ui-react","_id":"cjai8h18m001cvb9qr1jvriqg"},{"name":"object","_id":"cjai8h18r001ivb9qvrhyw48c"},{"name":"prototype","_id":"cjai8h18v001ovb9qh4f5fsae"},{"name":"closure","_id":"cjai8h18w001svb9q9ih3nmgu"},{"name":"asynchronous","_id":"cjai8h190001wvb9qaoj3o7hy"},{"name":"nesting","_id":"cjai8h1910020vb9qa5568ukg"},{"name":"sass syntax","_id":"cjai8h1920024vb9ql7liklr1"},{"name":"idempotent","_id":"cjai8h1940028vb9qxqlkne8v"},{"name":"http","_id":"cjai8h195002dvb9qivcqidxl"},{"name":"nvm","_id":"cjai8h197002ivb9qvi49vo43"},{"name":"ejs","_id":"cjai8h199002mvb9qaltin1tv"},{"name":"express","_id":"cjai8h19c002qvb9qhf05838d"},{"name":"webform","_id":"cjai8h19e002uvb9qntqu8624"},{"name":"urlshortner","_id":"cjai8h19g002yvb9qkkhn15yk"},{"name":"cookie","_id":"cjai8h19h0031vb9qxqlwpp93"},{"name":"middleware","_id":"cjai8h19i0034vb9q7xkl4dm5"},{"name":"session","_id":"cjai8h19i0036vb9qdfv3nxbi"},{"name":"nodejs","_id":"cjai8h19j0038vb9qcebvaybk"},{"name":"uninstall node","_id":"cjai8h19k003avb9q925d6u4t"},{"name":"how to uninstall node","_id":"cjai8h19k003bvb9q4xut97e0"}]}}