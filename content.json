{"meta":{"title":"Huusz's Log","subtitle":null,"description":null,"author":"huusz","url":"http://huusz.github.io"},"pages":[],"posts":[{"title":"[node]  REST API: POST VS PUT","slug":"nodejs/POST VS PUT","date":"2017-09-09T09:42:28.000Z","updated":"2017-09-09T09:44:21.000Z","comments":true,"path":"2017/Nodejs/nodejs/POST VS PUT/","link":"","permalink":"http://huusz.github.io/2017/Nodejs/nodejs/POST VS PUT/","excerpt":"","text":"REST API: POST VS PUTPOST와 PUT은 CRUD로직중 Create와 Update의 속성을 가진 http 메소드이다. 정의만 보면 둘은 동일한 작업을 하는 것 같다. 둘은 어떤 차이가 있는가? Idempotent첫번째 차이는 멱등성(Idempotent)이다. 멱등성이란 단항연산 ƒ에 대해 결과 값이 항상 자기 자신을 향하는 성질이다. 이러한 성질을 수식으로 표현하면 아래와 같다. ƒ(ƒ(x))=ƒ(x) 한마디로, 같은 연산을 무한정 반복해도 결과는 항상 동일한 값을 갖는다는 말이다. RESTful 서비스 관점에서, 연산(서비스 호출)이 idempotent하려면, 클라이언트가 (의도했거나 말거나) 동일한 요청을 반복적으로 보내도 한번 요청했을 때와 같은 결과를 산출할 수 있어야 한다. 결론부터 말하면, PUT은 멱등성을 가지고 있지만 POST는 그렇지 못하다. 리소스 결정권URI에 대한 결정권이 서버측에 있는가 클라이언트측에 있는가의 차이가 있다. PUT은 클라이언트에 있으며 POST는 서버에게 있다. POSTPOST는 새로운 리소스(자원)를 생성(create)할 때 주로 사용된다. 특히 하위 리소스를 만드는 데 주로 사용된다. 즉, POST로 생성하는 리소스는 상위 리소스에 종속된다. 부모(상위) 리소스에 POST를 보내면 서비스가 부모와 새로 생성할 리소스를 연결하고 ID(새 리소스의 URI)를 할당하는 등의 작업을 처리한다. 클라이언트는 저장해야할 리소스의 위치를 모르기 때문에 지정해줄 수 없다. 즉, 리소스의 URI 결정권이 전적으로 서버측에 있다. 1234POST /customers HTTP/1.1&#123; \"name\": \"Bob\", \"age\": 17 &#125;HTTP/1.1 201 Created 위 예제에서 { &quot;name&quot;: &quot;Bob&quot;, &quot;age&quot;: 17 }는 POST요청으로 새롭게 생성될 리소스(하위 리소스)이며 부모(싱위 리소스)인 customers 아래에 생성된다. POST로 생성되는 리소스는 요청마다 다른 위치에 배정된다. 위 리소스의 위치는 /customers/2로 지정되며 만약 동일한 리소스에 대한 POST 요청을 한번 더 보내면 위치만 다르게(/customers/3) 같은 리소스가 생성될 것이다. 이처럼 POST는 not idempotent하다. POST 요청은 보내는 족족 서버는 새로운 위치에 새로운 리소스를 만든다. PUTPUT은 클라이언트가 지정한 위치에 리소스를 생성하거나 업데이트(update/replace)한다. 클라이언트가 리소스를 저장할 위치를 알고 있으며, URI에 대한 결정권은 전적으로 클라이언트측에 있다. PUT은 리소스의 생성보다는 수정/업데이트 기능에 가장 많이 사용된다. 12PUT /customers/3 HTTP/1.1&#123; \"name\": \"Ash\", \"age\": 28 &#125; PUT은 지정된 특정 위치의 리소스에 대해 제어하므로 동일 요청을 여러번으로 보내도 한번 보낸 것과 동일한 효과를 낸다. 즉, idempotent하다. Reference 멱등성 REST API: POST VS PUT What Is Idempotence? When should we use PUT and when should we use POST? POST vs PUT","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://huusz.github.io/categories/Nodejs/"}],"tags":[{"name":"idempotent","slug":"idempotent","permalink":"http://huusz.github.io/tags/idempotent/"}]},{"title":"[node]  세션 Session","slug":"nodejs/9. session","date":"2017-09-09T09:16:41.000Z","updated":"2017-09-09T09:42:46.000Z","comments":true,"path":"2017/Nodejs/nodejs/9. session/","link":"","permalink":"http://huusz.github.io/2017/Nodejs/nodejs/9. session/","excerpt":"","text":"세션 Session세션의 의미사전적 의미1) (특정한 활동을 위한) 시간2) (의회 등의) 회기; (법정의) 개정 (기간) 실질적 의미1) 시작 조건과 종료 조건이 있는 시간, 또는 회기2) 정보 교환이 지속되는 시간, 또는 회기 세션의 예HTTP session: 요청 - 응답 로그인 세션: 로그인 - 로그아웃 Google Analytics 세션:페이지 접속 - 30분간 접속이 없으면 종료로 간주 (커스터마이징 가능) 웹 서비스를 위한 세션의 구현 세션이 시작되면(ex. 로그인하면), 세션이 시작되었다는 사실을 쿠키에 저장 세션에 대한 정보를 여러 요청에 걸쳐서 지속시키기 위해, 정보를 어딘가에 저장 세션이 만료되면(ex. 로그아웃하면), 세션이 만료되었다는 사실을 쿠키에 반영 * 위 방식은 널리 사용되는 방식일 뿐, 반드시 위와 같이 구현해야 하는 것은 아니다. 만약, 브라우저가 갑자기 꺼지면 쿠키는 어떻게 되는가? 세션쿠키라는 것이 있다. 브라우저가 꺼지면 쿠키가 삭제되는 옵션이다. 이 옵션이 정의되어있다면 브라우저가 꺼지는 순간 쿠키가 삭제된다.하지만 지속시간이 긴 쿠키라면(직접 정의할 수 있다.) 브라우저를 껐다가 켜도 쿠키가 지속된다. 세션 스토어세션에 대한 정보를 저장하는 어딘가 쿠키 데이터베이스 파일 기타 정보를 저장할 수 있는 곳 어디든 세션 스토어의 선택서비스의 요구사항에 맞춰서 적절한 저장소를 선택하면 된다. 쿠키: 정보의 형태가 간단하고 자주 바뀔 일이 없다면 데이터베이스: 저장해야 할 정보의 양이 많다면 메모리 기반 저장소: 정보가 굉장히 자주 변경된다면 세션? 세션 스토어?‘세션’과 ‘세션 스토어’는 혼용되는 경우가 많지만 엄연히 다른 말이다. ‘세션에 정보를 저장한다’는 말은 ‘세션 스토어에 정보를 저장한다’는 말과 같은 의미이다. Express + Sessioncookie-session 쿠키에 모든 정보를 저장하는 세션 스토어. 첫 방문시 무조건 세션 시작. express-session 쿠키에는 세션 식별자만 저장하고 실제 정보의 저장은 외부 저장소(데이터베이스 등)를 이용하는 세션 스토어. 외부 저장소에 대한 별도의 설정 필요 익스프레스 세션 예제link 12345678910111213141516171819202122232425262728293031323334353637// server.js// cookie-session 설정// name: 쿠키 이름으로 사용할 문자열// secret: 세션 정보를 서명할 때 사용할 키// secret은 비밀 정보. 공개되어서는 안 된다.app.use(cookieSession(&#123; name: 'session', secret: process.env.SECRET&#125;))// req.session.count를 처리하는 미들웨어const countMiddleware = (req, res, next) =&gt; &#123; if ('count' in req.session) &#123; // count 속성이 있으면 1으. req.session.count += 1 &#125; else &#123; // count 속성이 없으면 처음 방문한 것이므로 1로 설정한다. req.session.count = 1 &#125; next()&#125;// 첫 방문 후, 쿠키 관련 헤더가 요청과 응답에 잘 포함되는지 살펴보고,// 실제로 쿠키가 어떻게 저장되어있는지 살펴보세요.app.get('/', countMiddleware, (req, res) =&gt; &#123; res.render('index.ejs', &#123;count: req.session.count&#125;)&#125;)app.post('/reset-count', (req, res) =&gt; &#123; delete req.session.count res.redirect('/')&#125;)app.listen(3000, function() &#123; console.log('listening...')&#125;) 12345678910111213141516// index. ejs&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;%= count %&gt;번 째 방문하셨습니다. &lt;/div&gt; &lt;form action=\"/reset-count\" method=\"post\"&gt; &lt;button type=\"submit\"&gt; 초기화 &lt;/button&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 인증/인가 예제link 인증(Authentication)과 인가(Authorization) 인증(Authentication)은 클라이언트가 누구인지를 확인하는 과정이다. 지금은 ‘인증과 로그인은 같은 말’이라고 생각하셔도 무방하다. 인가(=허가)는 클라이언트가 하려고 하는 작업이 해당 클라이언트에게 허가된 작업인지를 확인하는 과정이다. ‘권한 설정’이라고 생각하셔도 무방하다. 예를 들어 다음 카페나 네이버 클럽에서는 관리자만이 게시판을 만들거나 없앨 수 있도록 인가된다. 인증 구현 전략 인증은 여러가지 방식으로 구현될 수 있으며, 여기에서는 우리가 쓰고 있는 cookie-session 의 기능에 맞추어서 구현해보도록 한다. cookie-session이 제공하는 미들웨어는 첫 방문시 바로 세션을 시작하고 (이를 guest session이라 부릅니다) 쿠키에 빈 세션 정보(빈 객체)를 저장한다. 그래서 첫 방문자에 대해서도 session 객체를 바로 쓸 수 있다. 아래와 같은 규칙으로 인증을 구현해보도록 한다. req.session.username === undefined이면 로그인된 사용자가 없는 것으로 간주한다. 사용자가 로그인 폼을 전송하면 accounts 배열에 저장된 계정 정보 중에 일치하는 것이 있는지 확인하고, 있다면 req.session.username에 해당 사용자 이름을 저장한다. 만약 일치하는 계정이 없으면 400 Bad Request 응답을 보낸다. req.session.username에 저장된 값이 있다면 해당 사용자로 로그인이 되어 있다고 간주한다. 로그아웃을 하기 위해 req.session = null와 같이 대입해서 세션을 초기화한다. (인증이 된 뒤에는 req.user와 res.locals.user에 계정 객체를 주입해서 라우트 핸들러와 템플릿에서 편하게 접근할 수 있도록 미리 코드를 짜 두었다.) 1234567891011121314// sever.js - accountconst accounts = [ &#123; username: 'seungha', password: 'kim', name: '김승하' &#125;, &#123; username: 'fast', password: 'campus', name: '패스트캠퍼스', admin: true &#125;] 123456789101112131415//server.js - loginapp.post('/login', urlencodedMiddleware, (req, res) =&gt; &#123; // 인증 과정을 작성해주세요. if(accounts.find( acc =&gt; acc.username === req.body.username &amp;&amp; acc.password === req.body.password))&#123; req.session.username = req.body.username; res.redirect('/'); &#125; else &#123; res.status(404); res.send('404 Not Found'); &#125; res.redirect('/');&#125;) 123456//server.js - logoutapp.post('/logout', urlencodedMiddleware, (req, res) =&gt; &#123; // 세션 초기화 req.session = null res.redirect('/')&#125;) 인가 구현 전략 관리자만이 비밀 정보(/secret)에 접근할 수 있도록 한다. 사용자가 관리자인지 아닌지의 여부는 계정 객체의 admin 속성에 저장되어 있다. 12345678910111213141516// server.js - adminfunction onlyAdminMiddleware(req, res, next) &#123; // `/secret`에 접속했을 때 이 미들웨어가 작동합니다. const user = req.session.username; if(accounts.find( acc =&gt; acc.username === user &amp;&amp; acc.admin))&#123; // admin이면 통과! next(); &#125; else &#123; res.status(403); res.send('403 Forbidden'); &#125;&#125;app.get('/secret', onlyAdminMiddleware, (req, res) =&gt; &#123; res.send('It is my secret')&#125;)","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://huusz.github.io/categories/Nodejs/"}],"tags":[{"name":"session","slug":"session","permalink":"http://huusz.github.io/tags/session/"}]},{"title":"[node] Cookie","slug":"nodejs/8. cookie","date":"2017-09-09T09:05:09.000Z","updated":"2017-09-09T09:42:24.000Z","comments":true,"path":"2017/Nodejs/nodejs/8. cookie/","link":"","permalink":"http://huusz.github.io/2017/Nodejs/nodejs/8. cookie/","excerpt":"","text":"쿠키쿠키는 클라이언트 웹 브라우저에 저장되는 정보이다. 일정 기간 동안 저장하고 싶을 때 사용한다. 익스프레스에서는 cookie-parser 미들웨어를 사용하면 쿠키를 설정하거나 확인할 수 있다. 쿠키의 필요성개별 클라이언트의 여러 요청에 걸친 정보의 유지가 필요한 경우 장바구니 로그인/로그아웃 방문 기록 등 HTTP Cookie 서버가 응답을 통해 웹 브라우저에 저장하는 이름+값 형태의 정보 웹 브라우저는 쿠키를 저장하기 위한 저장소를 가지고 있다. 저장소는 자료의 유효기간과 접근 권한에 대한 다양한 옵션을 제공한다. 쿠키 전송 절차1. Set-Cookie 헤더 서버가 브라우저에 저장하고 싶은 정보를 응답과 같이 실어 보낸다. 123HTTP/1.1 200 OKSet-Cookie: cookieName = cookieValue; Secure; Max-Age = 60000... 2. Cookie 헤더 브라우저는 같은 서버에 요청이 일어날 때 마다 해당 정보를 요청에 같이 실어서 서버에 보낸다. 123GET / HTTP/1.1Cookie: cookieName=cookieValue; anotherName=anotherValue... 3. Set-Cookie OptionsExpires, Max-Age: 쿠키의 지속 시간 설정 1234567// maxAge 옵션은 쿠키가 해당 시간이 지났을 때 삭제되도록 합니다.app.get('/maxAge', (req, res) =&gt; &#123; res.cookie('maxAgeCookie', 'value', &#123; maxAge: 5000 &#125;) res.redirect('/')&#125;) Secure: HTTPS를 통해서만 쿠키가 전송되도록 설정 1234567// secure 옵션은 http 프로토콜을 통한 요청에는 쿠키가 포함되지 않게 합니다. (https로 했을 때만 포함시킴)app.get('/secure', (req, res) =&gt; &#123; res.cookie('secureCookie', 'value', &#123; secure: true &#125;) res.redirect('/')&#125;) HttpOnly: 자바스크립트에서 쿠키를 읽지 못하도록 설정 1234567// httpOnly 옵션은 해당 쿠키를 자바스크립트에서 접근할 수 없게 합니다.app.get('/httpOnly', (req, res) =&gt; &#123; res.cookie('httpOnlyCookie', 'value', &#123; httpOnly: true &#125;) res.redirect('/')&#125;) 자바스크립트에서 쿠키를 읽지 못하게 해야 하는 이유는 누군가 악의적으로 웹사이트의 게시글에 스크립트 태그를 심을 가능성이 있기 때문이다. 이를 Cross-site Scripting(XSS)이라고 한다. 만약 로그인정보가 포함되어 있다면 이 공격에 의해 로그인 정보가 유출되는 위험이 발생할 수 있다. Domain, Path: 쿠키의 scope 설정 (쿠키가 전송되는 URL을 제한) 123456789101112131415// domain 옵션은 해당 도메인 및 서브도메인으로 쿠키가 전송되도록 합니다.app.get('/domain', (req, res) =&gt; &#123; res.cookie('domainCookie', 'value', &#123; domain: 'glitch.me' &#125;) res.redirect('/')&#125;)// path 옵션은 쿠키가 지정된 경로 및 그 하위 경로에 요청이 일어났을 때만 전송되도록 합니다.app.get('/path', (req, res) =&gt; &#123; res.cookie('pathCookie', 'value', &#123; path: '/somePath' &#125;) res.redirect('/')&#125;) multiple-options: 위 옵션들을 한번에 다중으로 지정할 수 있다. 123456789// 여러 옵션을 한꺼번에 지정할 수도 있습니다.app.get('/multiple-options', (req, res) =&gt; &#123; res.cookie('multipleOption', 'value', &#123; secure: true, httpOnly: true, maxAge: 5000 &#125;) res.redirect('/')&#125;) 4. Express + Cookie쿠키 읽기 - req.cookies 요청에 실려온 쿠키가 객체로 변환되어 req.cookies에 저장됨 (cookie-parser 미들웨어 필요) 123456789101112// req.cookies를 사용하려면// cookieParser라는 미들웨어가 필요하다.const cookieParser = require('cookie-parser')app.use(cookieParser())app.get('/', (req, res) =&gt; &#123; res.send(req.cookies)&#125;)app.get('/somePath', (req, res) =&gt; &#123; res.send(req.cookies)&#125;) 쿠키 쓰기 - res.cookie(name, value) 쿠키의 생성 혹은 수정 5. 쿠키 예제: Link JavaScript + Cookie자바스크립트로도 쿠키를 읽고 쓰는 방법이 존재하지만, 보안 상 문제를 일으킬 수 있으므로 이런 접근 방식은 거의 사용되지 않는다. 자바스크립트에서 쿠키에 접근하지 못하도록 HttpOnly를 항상 설정하는 것이 best practice 쿠키의 한계점 US-ASCII 밖에 저장하지 못해서 한글 표시가 안 된다. 한글 표시를 위해서 보통 percent encoding을 사용한다. 4000 바이트 내외(영문 4000자, percent encoding 된 한글 444자 가량)밖에 저장하지 못한다. 브라우저에 저장된다. 즉, 여러 브라우저에 걸쳐 공유되어야 하는 정보, 혹은 웹 브라우저가 아닌 클라이언트(모바일 앱)에 저장되어야 하는 정보를 다루기에는 부적절하다. (예를 들어 장바구니를 쿠키를 이용해서 구현하면, 다른 브라우저에서 켰을 때 보이지 않는 경우가 발생한다. 이런 한계가 존재하기 때문에, 쿠키로 모든 것을 다 할 수는 없다.)","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://huusz.github.io/categories/Nodejs/"}],"tags":[{"name":"cookie","slug":"cookie","permalink":"http://huusz.github.io/tags/cookie/"}]},{"title":"[node] Express Middleware","slug":"nodejs/7. Express Middleware","date":"2017-09-09T09:04:11.000Z","updated":"2017-09-09T09:41:53.000Z","comments":true,"path":"2017/Nodejs/nodejs/7. Express Middleware/","link":"","permalink":"http://huusz.github.io/2017/Nodejs/nodejs/7. Express Middleware/","excerpt":"","text":"Express Middleware익스프레스는 개발자가 다양한 기능을 사용할 수 있도록 미리 만들어 둔 여러가지 미들웨어를 제공한다. npm을 통해서 다른 개발자들이 만든 미들웨어를 쉽게 다운 받아 사용할 수도 있다. 반대로 프로젝트 내에서 내가 직접 정의하고 로드(app.use)하여 사용하는 것도 가능하다. 미들웨어 함수는 ‘요청 오브젝트(req)’와 ‘응답 오브젝트(res)’, 그리고 애플리케이션의 요청-응답 주기 중 ‘다음 미들웨어 함수(next)’에 대한 액세스 권한을 갖는 함수이다. 미들웨어는 인수로 요청 오브젝트(request 객체)와 응답 오브젝트(response 객체), next 함수를 인자로 받는다. 요청 오브젝트와 응답 오브젝트를 조작해서 기능을 구현하며, next 함수는 다음 미들웨어를 동작시키기 위해 사용되며, 인자 없이 호출된다. 미들웨어는 기본적으로 함수이다. 따라서 내부에서 어떤 작업이든 가능하다. 미들웨어 함수로 수행하는 일은 아래와 같다. 로깅 HTTP body를 객체로 변환 사용자 인증 권한 관리 등 app.use()app.use()는 미들웨어 함수를 로드하기 위해 사용되는 메소드이다. 미들웨어 함수를 지정하고, app.use()를 통해 호출할 수 있다. 1234567//미들웨어 - 함수function helloMiddleware(res, req, next) &#123; console.log('hello'); next();&#125;app.use(helloMiddleware); 위 예제는 hello를 콘솔에 출력하는 helloMiddleware 함수를 정의하고, app.use()를 통해 로드하였다. 위와 같은 로드 방식은 앱 전체에서 동작하게 하는 방식이다. 첫번째 인자로 경로를 지정하면, 특정 경로에서만 동작하게 할 수도 있다. 아래 예제를 참고하자. 앱 전체에서 동작하게 하기 1app.use(helloMiddleware); 특정 경로에서만 동작하게 하기 12// some-path라는 경로 안에서만 동작하도록 로드app.use('/some-path', helloMiddleware); 한 번에 여러 개 로드하기 12// 다수의 미들웨어를 한번에 호출app.use(middleware1, middleware2, middleware3, ...) 호출 순서미들웨어의 실행 순서는 호출 순서에 의해 결정된다. 즉, 먼저 호출되는 것이 먼저 실행된다. 123456789101112131415161718// mylogger.jsconst express = require('express');const app = express();const myLogger = (req, res, next) =&gt; &#123; console.log('LOGGED'); next();&#125;;app.use(myLogger);app.get('/', (req, res) =&gt; &#123; res.send('Hello World');&#125;);app.listen(3000); 123// console% node mylogger.jsLOGGED 위 예제는 라우팅 이전에 myLogger가 로드되었다. 실행하면 콘솔창에 LOGGED를 출력할 것이다. 그런데 만약 myLogger가 라우팅 이후에 로드되었다면? 123456789101112131415161718const express = require('express');const app = express();const myLogger = (req, res, next) =&gt; &#123; console.log('LOGGED'); next();&#125;;// 루트경로에 대한 라우팅app.get('/', (req, res) =&gt; &#123; res.send('Hello World');&#125;);// myLogger 미들웨어를 라우팅 이후에 로드하였다.app.use(myLogger);app.listen(3000); 이 경우, 루트 경로의 라우트 핸들러가 요청-응답 주기를 종료하므로 요청은 myLogger에 도달하지도 못한다. 따라서 LOGGED를 출력하지 않는다. 123// console% node mylogger.js// 아무것도 출력하지 않는다. 자주 사용되는 미들웨어1. static 미들웨어static 미들웨어는 특정 폴더의 파일들을 특정 패스로 접근할 수 있도록 만들어준다. static 미들웨어는 외장 모듈로 만들어져 있기 때문에 npm을 통해 설치해야 한다. 터미널이나 명령 프롬프트(cmd)에서 아래 명령을 통해 설치한다. 1$ npm install serve-static --save 아래는 static 사용의 예시이다. public 폴더에 있는 모든 파일을 웹 서버의 루트 패스로 접근할 수 있도록 하고 싶을 때 아래처럼 사용한다. 12345const static = require('serve-static');...app.use(static(path.join(__dirname, 'public'))); 이 코드는 public 폴더 안에 있는 파일들을 클라이언트에서 바로 접근할 수 있게 한다. 예를 들어 프로젝트 폴더 안에 다음과 같은 폴더나 파일이 들어 있다면, 1234ExpressExample/public/index.htmlExpressExample/public/house.pngExpressExample/public/main.jsExpressExample/public/style.css 웹 브라우저에서 다음과 같은 주소로 바로 접근할 수 있다. 1234http://localhost:3000/index.htmlhttp://localhost:3000/house.pnghttp://localhost:3000/main.jshttp://localhost:3000/style.css 만약 파일을 사이트의 /public 패스로 접근하게 만들고 싶다면 위의 코드에서 첫번째 인자에 요청 패스 /public을 추가해주면 된다. 1app.use('/public', static(path.join(__dirname, 'public'))); * __dirname: 현재 디렉토리 이렇게 하면 요청 패스와 특정 폴더(static 함수를 이용해 지정한 디렉터리)가 매핑(Mapping)되어 접근할 수 있게 된다. 2. body-parser클라이언트의 요청(request) 방식에는 대표적으로 GET방식과 POST 방식이 있다.GET 방식은 주소 문자열에 요청 파라미터가 들어가므로 url을 통해 확인이 가능하다. 그에 반해 POST 방식은 본문인 Body 영역에 요청 파라미터가 들어간다. 따라서 GET 방식과는 다른 방식으로 요청 파라미터를 파싱해야 한다. body-parser 미들웨어는 POST 방식으로 요청할 때 body에 들어있는 요청 파라미터들을 파싱하여 request 객체의 body 속성에 넣어준다. body-parser 미들웨어 역시 외부 모듈이므로, npm을 통해 다운로드해야 사용할 수 있다. 1$ npm install body-parser --save public 폴더 생성 후 그 안에login.html 파일을 생성한다. 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;login test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;로그인&lt;/h1&gt; &lt;form method=\"post\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;label&gt;아이디&lt;/label&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"id\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;label&gt;비밀번호&lt;/label&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name = \"password\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;input type=\"submit\" value=\"전송\" name=\"\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344// server.js// Express 기본 모듈 불러오기const express = require('express');const http = require('http');const path = require('path');// Express의 미들웨어 불러오기const bodyParser = require('body-parser');const static = require('save-static');// 익스프레스 객체 생성const app = express();// 기본 속성 설정app.set('port', process.env.PORT || 3000);// body-parser로 application/x-www-form-urlencoded 파싱// .urlencoded() 메소드를 호출하면서 미들웨어를 설정하면, 'application/x-www-form-urlencoded' 형식으로 전달된 요청 파라미터를 파싱할 수 있다.// 이 형식은 일반적인 요청 파라미터의 형식이다.app.use(bodyParser.urlencoded(&#123; extended: false &#125;));// body-parser를 사용해 application/json 파싱// .json() 메소드를 호출하면서 미들웨어를 설정하면 application/json 형식으로 전달된 요청 파라미터를 참조할 수 있다.app.use(bodyParser.json());app.use(static(path.join(__dirname, 'public')));// 미들웨어에서 파라미터 확인app.use((req, res, next) =&gt; &#123; console.log('첫번째 미들웨어에서 요청을 처리'); // body 안에 있는 요청 파라미터를 참조한다. // 만약 클라이언트가 요청하는 방식이 GET 방식인지 POST 방식으로 요청할지 모른다면 // 두 가지 경우를 모두 고려해 두 가지 요청 파라미터를 모두 검사한다. const paramId = req.body.id || req.query.id; const paramPassword = req.body.password || req.query.password; res.writeHead('200', &#123;'Content-Type':'text/html;charset=utf-8'&#125;); res.write('&lt;h1&gt;Express 서버에 응답한 결과입니다. &lt;/h1&gt;'); res.write('&lt;div&gt;&lt;p&gt;Param id: '+ paramId + '&lt;/p&gt;&lt;/div&gt;'); res.write('&lt;div&gt;&lt;p&gt;Param password: ' + paramPassword + '&lt;/p&gt;&lt;/div&gt;'); res.end();&#125;); 1$ node server.js 1http://localhost:3000/login.html 접속 서버 코드에서 use() 메소드로 설정한 함수는 login.html 문서에 접근할 때는 호출되지 않는다. 처음에는 login.html 문서가 웹 브라우저에 보이고, 전송 버튼을 클릭해 POST로 요청했을 때 use() 메소드로 설정한 함수가 호출된다. 전송 버튼을 누르면 POST 방식으로 요청을 보낼 때도 GET 방식과 마찬가지로 요청 파라미터를 확인할 수 있다. Middleware를 사용하는 이유미들웨어로 할 수 있는 모든 일은 사실 라우트 핸들러에서도 할 수 있다. 그럼에도 미들웨어를 사용하는 이유는 여러 라우터에서 사용해야 하는 기능을 중복 작성하는 불편을 덜고, 코드를 재사용하기 위함이다. Middleware 생태계Express resourceNPM search 미들웨어 예제middlewares.js 파일에서 작성한 미들웨어를 server.js에서 불러와 사용하고 있다. 각각 어떤 방식으로 미들웨어를 사용하고 있는지 확인해보자. 123456789101112131415161718192021222324// middlewares.jsexports.ipLoggingMiddleware = (req, res, next) =&gt; &#123; console.log(`request ip: $&#123;req.ip&#125;`) next()&#125;exports.urlLoggingMiddleware = (req, res, next) =&gt; &#123; console.log(`request url: $&#123;req.originalUrl&#125;`) next()&#125;exports.resLocalMiddleware = (req, res, next) =&gt; &#123; res.locals.myVar = 'FASTCAMPUS!' next()&#125;exports.lock = key =&gt; (req, res, next) =&gt; &#123; if (req.query.key === key) &#123; next() &#125; else &#123; res.status(403) res.send('403 Forbidden') &#125;&#125; 1234567891011121314151617181920212223242526272829303132// server.jsconst express = require('express')const &#123; ipLoggingMiddleware, urlLoggingMiddleware, resLocalMiddleware, lock&#125; = require('./middlewares')const app = express()app.set('view engine', 'ejs')// 앱 단위 미들웨어는 모든 라우트 핸들러에서 실행됩니다.// 미들웨어는 등록된 순서대로 실행됩니다.// 아래 미들웨어 적용 순서를 바꿔보세요.app.use(urlLoggingMiddleware)app.use(ipLoggingMiddleware)// 라우트 단위 미들웨어는 적용된 라우트에서만 실행됩니다.app.get('/', resLocalMiddleware, (req, res) =&gt; &#123; res.render('index.ejs')&#125;)app.get('/secret', lock('thisisthekey'), (req, res) =&gt; &#123; res.send('my secret is...')&#125;)app.listen(3000, function() &#123; console.log('listening...')&#125;) 1234567891011// views/index.ejs&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;%= myVar %&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; next 미들웨어는 req, res에 더해서 next라는 함수를 추가로 인자로 받는다. next 함수를 호출하면 다음 미들웨어로 처리를 넘기는 효과가 있다. 만약에 미들웨어가 next 함수를 호출하지도 않고, 응답도 보내지 않으면 클라이언트는 응답을 받지 못하게 된다. App Local, Response Local app.locals와 res.locals는 특별한 객체를 담고 있다. 템플릿에서는 res.render를 통해 명시적으로 주입받지 않아도 저 두 객체의 속성에 바로 접근할 수 있다. 템플릿을 가리지 않고 사용되는 정보들, 예를 들어 ‘현재 로그인 중인 사용자 정보’ 같은 것을 res.render에 매번 인자로 넘기는 것은 귀찮을 뿐더러 빠뜨리기도 쉽다. 그런 정보들을 템플릿에서 쉽게 사용하기 위해 app.locals나 res.locals에 우리가 원하는 이름으로 속성을 주입할 수 있습니다. app.locals는 앱 단위로 공통적으로 쓰이는 정보를 담는 목적으로 사용된다. res.locals는 각 요청마다 달라지는 정보를 담는 목적으로 사용된다. app.local 객체를 조작하는 것은 매우 쉽다. res 객체는 매 요청마다 새로 생성되어 미들웨어 바깥에서 접근할 수 있는 방법이 없으므로, res.locals를 조작하려면 미들웨어를 사용해야 한다. 미들웨어 VS 라우트 핸들러라우트 핸들러도 미들웨어이다. 즉, next 함수를 인자로 받는 것이 가능하다. 1234567app.get('/', (req, res, next) =&gt; &#123; if(!someCondition) &#123; next(); // 요청을 처리하지 않고 다른 핸들러로 넘긴다. &#125; else &#123; res.send('hello'); &#125;&#125;); Example: custom 404 12// views/404.ejsMy Awesome 404! 123456// 요청이 라우트 핸들러가 등록된 어떤 경로와도 일치하지 않을 때,// 맨 마지막 미들웨어를 실행시킬 수 있습니다. 이를 이용해 우리만의 404 페이지를 보여줄 수 있습니다.// [참고](http://expressjs.com/ko/starter/faq.html)app.use((req, res, next) =&gt; &#123; res.render('404.ejs')&#125;) 오류처리 미들웨어다른 미들웨어 함수와 정의하는 방법은 동일하지만, err라는 인수를 추가로 받는다는(총 4개의 인수) 차이가 있다. 1234app.use((err, req, res, next) =&gt; &#123; console.error(err.stack); res.status(500).send('Something broke!');&#125;); 오류 처리 미들웨어는 다른 app.use() 및 라우트 호출을 정의한 후에 마지막으로 정의해야 한다. 12345678const bodyParser = require('body-parser');const methodOverride = require('method-override');app.use(bodyParser());app.use(methodOverride());app.use((err, req, res, next) =&gt; &#123; // logic&#125;); 미들웨어 함수 내부로부터의 응답은 HTML 오류 페이지, 단순 메시지, JSON 문자열 등으로, 클라이언트가 원하는 형식으로 설정할 수 있다. 오류처리 미들웨어 함수 역시 일반적인 미들웨어 함수처럼 직접 정의할 수 있다. 아래는 XHR을 이용한 요청 및 그렇지 않은 요청에 대한 오류처리 미들웨어 함수를 정의한 예이다. 12345678const bodyParser = require('body-parser');const methodOverride = require('method-override');app.use(bodyParser());app.use(methodOverride());app.use(logErrors);app.use(clientErrorHandler);app.use(errorHandler); logError는 요청 및 오류 정보를 stderr에 기록할 수 있다. 12345// 오류정보를 기록하는 함수function logErrors (err, req, res, next) &#123; console.log(err.stack); next(err);&#125; 12345678// 오류인 경우 500 error를 보내고 아닌 경우 다음 오류처리 미들웨어로 넘기는 함수function clientErrorHandler(err, req, res, next) &#123; if(req.xhr) &#123; res.status(500).send(&#123; error: 'Something failed!'&#125;); &#125; else &#123; next(err); &#125;&#125; 모든 오류를 처리하는(catch-all) errorHandler 함수는 다음과 같이 구현할 수 있다. 1234function errorHandler(err, req, res, next) &#123; res.status(500); res.render('error', &#123; error: err &#125;);&#125; expressjs.com expressjs.com - 오류처리 미들웨어 강사님 강의자료 참고서적: Do it! Node.js 프로그래밍","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://huusz.github.io/categories/Nodejs/"}],"tags":[{"name":"middleware","slug":"middleware","permalink":"http://huusz.github.io/tags/middleware/"}]},{"title":"[node] Web form","slug":"nodejs/5. Web form","date":"2017-08-30T08:08:08.000Z","updated":"2017-08-30T08:11:02.000Z","comments":true,"path":"2017/Nodejs/nodejs/5. Web form/","link":"","permalink":"http://huusz.github.io/2017/Nodejs/nodejs/5. Web form/","excerpt":"","text":"HTML Form1. 기본 동작HTML form을 전송하면, 입력된 정보가 기본적으로 percent encoding 되어 요청됨 GET method 12GET /search?query=%EA%B0%9C&amp;sort=latest HTTP/1.1... POST method 12345POST /form HTTP/1.1Content-Type: application/x-www-form-urlencoded...home=Cosby&amp;favorite+flavor=flies 2. multipart/form-data 기본 설정(percent encoding)으로는 폼으로 파일을 업로드하는 것은 불가능 (클라이언트 측) form 태그에 enctype=”multipart/form-data” 속성을 적용하면 파일 업로드 가능 (서버 측) body-parser 미들웨어는 multipart/form-data 형태의 요청을 지원하지 않음 (multer 필요) 3. 예제code UUID (Universally unique identifier) 유효ID = 범용 고유 식별자 인터넷 상의 수많은 자료를 구분하기 위해 각 자료에 식별자(identifier)를 부여하는 일은 아주 중요합니다. 식별자를 부여하는 가장 쉬운 방법은 자료가 생성된 순서대로 번호를 붙이는 것입니다. 실제로 많은 데이터베이스에서 이런 방법을 사용하고 있습니다. 하지만 환경에 따라 자료가 생성되는 순서를 알 수 없는 경우도 있습니다. UUID는 식별자로 사용하기 위해 고안된 수 형식이며, 아래와 같은 형식으로 표현됩니다. 424e19f5-f330-4be1-889f-4a9f7da75b69 UUID는 표현할 수 있는 경우의 수가 무지무지무지무지 많습니다. (128bit = 2의 128제곱) UUID 난수를 생성하는 표준적인 방법(UUID version 4)을 사용하면, 언제 어디서 UUID를 생성해도 정확히 같은 UUID가 생성될 수 있는 확률이 매우매우매우매우 작기 때문에 안심하고 식별자로 사용할 수 있습니다. node에서의 uuid는 npm uuid package 설치를 통해 사용할 수 있다. Redirection after submission브라우저의 새로고침은 동일한 요청을 한번 더 보내는 것이다.redirect를 하지 않으면 POST가 같은 요청을 또 보내기 때문에, 새로고침시 이전에 보냈던 요청을 한번 더 보내게 된다. 따라서 POST에 대해서는 redirect 하지 않으면 문제가 발생한다. 1234567891011121314151617181920// 할일 추가 endpointapp.post('/todo', urlencodedParser, (req, res) =&gt; &#123; const title = req.body.title // validation 유효성 검사 : title이 빈 문자열인지 확인 if (title &amp;&amp; title.length!==0) &#123; const todo = &#123; id: uuidv4(), // slug title // es6문법 &#125; todos.push(todo) // redirect 하지 않으면 새로고침시 동일 요청을 한번 더 보낸다. res.render('index.ejs', &#123;todos&#125;) // 이렇게 하면 안 됩니다! // res.redirect(301, '/') // 이렇게 해도 안 됩니다! // res.redirect('/') // res.redirect는 302 상태코드로 응답합니다. &#125; else &#123; res.status(400) res.send('400 Bad Request') &#125;&#125;) 순수 HTML form으로 요청을 보낼 때는 반드시 redirect를 해야 한다.(AJAX로 하는 경우에는 요청을 새로 또 보내지 않으니, 굳이 하지 않아도 됨!) 12345678910111213141516171819// 할일 추가 endpointapp.post('/todo', urlencodedParser, (req, res) =&gt; &#123; const title = req.body.title // validation 유효성 검사 : title이 빈 문자열인지 확인 if (title &amp;&amp; title.length!==0) &#123; const todo = &#123; id: uuidv4(), // slug title // es6문법 &#125; todos.push(todo) //res.render('index.ejs', &#123;todos&#125;) // 이렇게 하면 안 됩니다! res.redirect(301, '/') // 이렇게 해도 안 됩니다! // res.redirect('/') // res.redirect는 302 상태코드로 응답합니다. &#125; else &#123; res.status(400) res.send('400 Bad Request') &#125;&#125;) # 301 vs 302 서버가 301응답을 보내면 웹 브라우저는 그것을 기억해뒀다가 똑같은 요청이 왔을 때 서버에 요청을 보내지 않고 브라우저에 저장해두었던 redirect 정보를 가지고 redirect를 한다. 즉 서버에 재요청하지 않고 웹브라우저에 기억해둔 정보를 꺼내와서 사용한다. 웹브라우저 주소가 완전히 이동했을 때, (사이트가 폐쇄된 경우 등) 301을 사용한다. (부수 효과: 검색엔진의 웹 크롤러는 301응답을 발견할 경우 그 사이트로 더이상 접근하지 않는다.) 반면 똑같은 요청이 와도 서버에 해당 요청을 한번 더 전송하는 것이 302 응답이다. Form validation 사용자가 입력하는 자료는 개발자가 기대하는 형식과는 영 딴판일 수 있습니다. 필요한 필드가 없을 수도 있고, 자료의 형식을 서버가 이해할 수 없는 경우도 있습니다. 이런 자료를 데이터베이스에 그냥 집어넣게 되면 데이터베이스가 뒤죽박죽이 되고 말 것입니다. 그래서, 사용자에게 입력받은 자료는 처리를 하기 전에 항상 올바른 형태인지 검증해야 합니다. 이런 검증 과정을 form validation이라고 합니다. form validation을 구현하는 전형적인 방법은 다음과 같습니다. 사용자가 폼을 작성합니다. 사용자가 폼을 서버에 전송합니다. 서버는 기대한대로 데이터가 들어왔는지 검사합니다. 서버는 데이터가 기대한 대로 잘 들어왔으면 다음 단계를 진행하고, 데이터에 문제가 있다면 어떤 문제가 있는지를 사용자에게 알려줍니다. (이 프로젝트에서는 데이터에 문제가 있으면 단순하게 400 Bad Request 응답을 하고 있지만 사용자 경험을 위해서는 이렇게 하면 안되겠죠?) 서버 측에서 하는 form validation은 꼭 필요하지만, 사용자가 자료를 서버에 전송해야만 데이터에 어떤 문제가 있는지를 알 수 있다는 단점이 있습니다. 사용자 입장에서는 실컷 폼을 다 작성해서 전송했더니 폼에 에러가 있다고 하며 중간 단계부터 다시 시작해야 하니 짜증이 날 것입니다. 아마 여러분도 비슷한 경험이 있을 것입니다. 서버 측 validation을 잘 구현해서 사용자가 덜 불편하게끔 만드는 방법도 있지만 폼을 서버에 전송해야 피드백을 받을 수 있다는 점은 변하지 않습니다. 더 나은 사용자 경험을 위해 클라이언트 측 validation을 하는 것을 고려해볼 수 있습니다. 클라이언트 측 validation은 사용자가 폼을 작성하는 도중에 피드백을 받을 수 있다는 점에서 서버 측 validation보다 훨씬 나은 사용자 경험을 제공할 수 있습니다. 대신 서버 측 코드에서 하는 데이터 검사 로직을 클라이언트 측 코드에도 중복 구현해야 한다는 어려운 점이 있습니다. 다행히 HTML5에 추가된 form validation 기능을 이용하면 간단한 validation은 자바스크립트 코드를 하나도 짜지 않고도 구현할 수 있습니다. HTML5 form validation을 시험해 보려면, index.ejs 파일의 title 필드에 required 속성을 추가해보세요. HTML5 form validation은 사용하기 간편하고, 브라우저에 내장되어 있다는 점에서 (특히 모바일에서) 일관성있는 사용자 경험을 제공할 수 있다는 장점이 있습니다. 하지만 HTML5를 지원하지 않는 구형 브라우저에서는 사용할 수 없고, 또 복잡한 형태의 validation은 지원하지 않는다는 단점이 있습니다. (여러 필드의 자료를 합쳐서 validation을 한다거나, validation을 하기 위해 서버에 요청을 해야 하는 등) 주의! 클라이언트 측 validation을 하더라도 서버 측에서는 반드시 validation을 따로 해주어야 합니다. 사용자가 언제나 우리가 제공하는 클라이언트를 사용한다는 보장은 없기 때문입니다. (예를 들면 악의적인 해커가 Postman 등을 이용해 이상한 요청을 보낼 수도 있겠죠?)","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://huusz.github.io/categories/Nodejs/"}],"tags":[{"name":"webform","slug":"webform","permalink":"http://huusz.github.io/tags/webform/"}]},{"title":"[node] URL shortner 만들기","slug":"nodejs/6. service development","date":"2017-08-30T08:08:01.000Z","updated":"2017-09-09T09:38:13.000Z","comments":true,"path":"2017/Nodejs/nodejs/6. service development/","link":"","permalink":"http://huusz.github.io/2017/Nodejs/nodejs/6. service development/","excerpt":"","text":"프로젝트 세팅1) project folder 생성2) npm init3) git init3) .gitignore - node로 생성 node_modules는 깃 저장소에 넣지 않는 것이 원칙이다. vscode의 gitignore 플러그인을 설치, cmd+shift+p -&gt; add gitignore -&gt; node를 선택하여 node_modules의 변경사항을 무시하는 gitignore를 생성할 수 있다. node_modules를 깃에 올리지 않는 이유 git 저장소는 내 프로젝트의 코드를 관리하기 위한 곳이지 외부 패키지를 관리하기 위한 것이 아니다. git 저장소의 용량이 커지고 git이 추적해야 할 파일이 많아지기 때문에 느려질 수 있다. 4) first commit 5) git historyvscode의 git History 플러그인을 설치하면 깃 로그를 볼 수 있다. cmd+shift+p -&gt; git log -&gt; 로그를 볼 브랜치 선택/ 실행 6) npm install express –save 7) server.js 생성 단축키: cmd+enter 다음 줄로 이동! 12345678910const express = require('express')const app = express()app.get('/', (req, res) =&gt; &#123; res.send('hello express')&#125;)app.listen(3000, () =&gt; &#123; console.log('listening');&#125;) 8) 서버 구동 1$ node server.js 콘솔에 listening이라고 뜨면 로컬서버가 정상적으로 열린 것이다.웹 브라우저에서의 접속은 localhost:3000 으로 할 수 있다. ctrl+c를 누르면 서버가 종료된다.서버 재시작은 ctrl+c + node server.js 하지만 프로젝트마다 서버 구동 명령어가 조금씩 달라질 수 있다. 보통 npm start를 서버 구동 명령어로 쓰는 것이 관례이다. package.json을 열어 script를 아래와 같이 수정한다. 1234\"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"start\": \"node server.js\"&#125; 이제 npm start로 서버를 구동할 수 있다. 9) ejs 추가 1$ npm install ejs --save 아래 코드를 app.get 코드 위에 추가해준다. 12// server.jsapp.set('view engine', 'ejs') 10) views 폴더를 추가하고 폴더 안에 index.ejs 파일을 추가한다. 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;hello ejs&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 11) server.js 파일의 app.get 코드를 아래와 같이 수정한다. 123app.get('/', (req, res) =&gt; &#123; res.render('index.ejs')&#125;) 12) 서버를 구동하여 확인한다. 1$ npm start 13) server.js 파일 app.set 다음 줄에 app.use 코드를 추가한다 1app.use('/static', express.static('public')) 14) 루트에 public 폴더를 생성하고 그 밑에 index.css를 생성하고 index.ejs의 head에 링크 태그를 추가해준다. 123&lt;프로젝트 폴더&gt;|____public |____index.css 1234/* index.css */body &#123; background-color: skyblue;&#125; 1&lt;link rel=\"stylesheet\" href=\"/static/index.css\"&gt; 15) 서버를 구동하여 확인한다. 1$ npm start 로깅과 인증1. morgan 설정1) 미들웨어 morgan 설치 후 server.js에 아래 코드를 삽입한다. 1$ npm install --save morgan 123const morgan = require('morgan')app.use(morgan('tiny')) 지금까지의 전체 코드 12345678910111213141516171819//server.jsconst express = require('express')const morgan = require('morgan')const app = express()app.set('view engine', 'ejs')app.use('/static', express.static('public'))app.use(morgan('tiny'))app.get('/', (req, res) =&gt; &#123; res.render('index.ejs')&#125;)app.listen(3000, () =&gt; &#123; console.log('listening');&#125;) 셋팅이 완료된 후 server를 구동시키면 터미널에 아래와 같은 메시지가 뜨는 것을 확인할 수 있다. 1GET / 200 322 - 11.862 ms 2. express-basic-auth 설정npm-express-basic-auth에 접속하여 사용법을 확인한다. (1) basic-auth를 설치한다. 1$ npm install express-basic-auth (2) 설치한 패키지를 불러온다. 123456789//server.jsvar app = require('express')()var basicAuth = require('express-basic-auth')app.use(basicAuth(&#123; users: &#123; 'someuser': 'somepassword' &#125;, challenge: true, realm: 'Imb4T3st4pp'&#125;)) 위 코드에서 var app = require(&#39;express&#39;)()는 이미 하였으므로 그 아래부터 코드를 삽입해준다. someuser를 admin으로 somepassword도 admin으로 변경한다. 서버 구동 후 localhost:3000으로 접속하면 로그인 화면이 뜨는데, ID: admin, Password: admin으로 로그인할 수 있다. 초기 데이터 작업1. randomstring1) 데이터를 담을 배열 객체를 추가하고, app.get 코드를 수정한다. 12345678//server.jsconst data = [ &#123;longURL: 'http://google.com', id:'58DX37'&#125;]app.get('/', (req, res) =&gt; &#123; res.render('index.ejs', &#123;data&#125;)&#125;) 2) index.ejs의 body에 아래 소스를 추가한다. 12345678910111213141516&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;Long URL&lt;/td&gt; &lt;td&gt;Short URL&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;% data.forEach(item =&gt; &#123; %&gt; &lt;tr&gt; &lt;td&gt;&lt;%= item.longURL %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= item.id %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% &#125;) %&gt; &lt;/tbody&gt; &lt;/table&gt; 서버 재구동 후 확인한다. 1234hello ExpressLong URL Short URLhttp://google.com 58DX37 3) randomstring 패키지를 설치한다. 1$ npm install --save randomstring 설치한 패키지 사용을 위해 randomstring 객체를 추가해주고, generate 메소드를 사용하여 id를 6자리 랜덤 스트링으로 생성한다. 123456// server.jsconst randomstring = require('randomstring')const data = [ &#123;longURL: 'http://google.com', id:randomstring.generate(6)&#125;] 짧은 URL의 Redirection1. 라우터 핸들러 작성 (301 Moved Permanently)아래 코드를 app.get(&#39;/&#39;, (req, res) ~~ 코드의 아래에 추가로 작성한다. 1234567891011// server.jsapp.get('/:id', (req, res) =&gt; &#123; const id = req.params.id const matched = data.find(item =&gt; item.id === id) if(matched) &#123; res.redirect(301, matched.longURL) &#125; else &#123; res.status(404) res.send('404 Not Found') &#125;&#125;) 서버 구동 후 localhost:3000 뒤에 shorturl을 붙여 접속하면 (ex. localhost:3000/LL3L5c)longurl로 redirect되어 google.com으로 접속되는 것을 확인할 수 있다. 2) html 수정 12&lt;!-- index.ejs --&gt;&lt;td&gt;&lt;a href=\"/&lt;%= item.id%&gt;\" target=\"_blank\"&gt;&lt;%= item.id %&gt;&lt;/a&gt;&lt;/td&gt; a태그로 감싸기 단축키: cmd+shift+p -&gt; wrap -&gt; Emmet:wrap with Abbreviation 폼body-parser&amp; 폼, 핸들러 작성1$ npm install --save body-parser 1234// server.jsconst bodyparser = require('body-parser')app.use(bodyParser.urlencoded(&#123; extended: false &#125;)) 123456&lt;!-- index.ejs --&gt;&lt;h1&gt;hello Express&lt;/h1&gt; &lt;form action=\"/\" method=\"post\"&gt; &lt;input type=\"url\" name=\"longURL\"&gt; &lt;input type=\"submit\" value=\"전송\"&gt; &lt;/form&gt; form 전송을 받은 후 redirect시켜야 한다. 12345678910111213141516171819// server.jsapp.post('/', (req, res) =&gt; &#123; const longURL = req.body.longURL let id; // id가 있으면 다시 만들고, 없으면 candidate를 저장하고 빠져나간다. while(true)&#123; // id가 될 후보 const candidate = randomstring.generate(6) const matched = data.find(item =&gt; item.id === candidate) //matched가 없으면, 잘 된 상황 if(!matched) &#123; id = candidate break // 중복이 없는 아이디를 찾은 상황 &#125; &#125; data.push(&#123;id, longURL&#125;) res.redirect('/')&#125;) # 현재는 로그인 인증을 app.use에 넣어뒀기 때문에, 로그인하지 않은 사용자는 짧은 url을 사용할 수 없다. 123456// server.jsapp.use(basicAuth(&#123; users: &#123; 'admin': 'admin' &#125;, challenge: true, realm: 'Imb4T3st4pp'&#125;)) 위 코드를 아래와 같이 수정해준다. 12345const authMiddleware = basicAuth(&#123; users: &#123; 'admin': 'admin' &#125;, challenge: true, realm: 'Imb4T3st4pp'&#125;) body parser 미들웨어도 app.use에서 꺼내 따로 정의한다. 1app.use(bodyParser.urlencoded(&#123; extended: false &#125;)) 위 코드를 아래처럼 바꾼다. 1const bodyParserMiddleWare = bodyParser.urlencoded(&#123; extended: false &#125;) 이제 분리한 미들웨어를 필요한 곳에만 주입할 수 있다.인증이 필요한 곳에만, 바디파서가 필요한 곳에만 넣을 수 있다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869const express = require('express')const morgan = require('morgan')const basicAuth = require('express-basic-auth')const randomstring = require('randomstring')const bodyParser = require('body-parser')// 실무에서는 데이터를 이렇게 관리하지 않는다.// 이렇게 만들어진 데이터는 메모리상에서 관리되는 것으로 새로고침시 사라지는 데이터이다.const data = [ &#123;longURL: 'http://google.com', id:randomstring.generate(6)&#125;]// http://localhost:3000/58DX37// 302 응답const app = express()const authMiddleware = basicAuth(&#123; users: &#123; 'admin': 'admin' &#125;, challenge: true, realm: 'Imb4T3st4pp'&#125;)const bodyParserMiddleWare = bodyParser.urlencoded(&#123; extended: false &#125;)app.set('view engine', 'ejs')app.use('/static', express.static('public'))app.use(morgan('tiny'))app.get('/', authMiddleware, (req, res) =&gt; &#123; res.render('index.ejs', &#123;data&#125;)&#125;)app.get('/:id', (req, res) =&gt; &#123; const id = req.params.id const matched = data.find(item =&gt; item.id === id) if(matched) &#123; res.redirect(301, matched.longURL) &#125; else &#123; res.status(404) res.send('404 Not Found') &#125;&#125;)app.post('/', bodyParserMiddleWare, authMiddleware, (req, res) =&gt; &#123; const longURL = req.body.longURL let id; // id가 있으면 다시 만들고, 없으면 candidate를 저장하고 빠져나간다. while(true)&#123; // id가 될 후보 const candidate = randomstring.generate(6) const matched = data.find(item =&gt; item.id === candidate) //matched가 없으면, 잘 된 상황 if(!matched) &#123; id = candidate break &#125; &#125; data.push(&#123;id, longURL&#125;) res.redirect('/')&#125;)app.listen(3000, () =&gt; &#123; console.log('listening');&#125;) 배포now.sh를 이용해 배포한다. now를 글로벌로 설치한다. 1234567$ npm install -g now$ now-&gt; enter email: 이메일을 입력한다.-&gt; 받은 메일의 링크로 접속하여 인증한다.$ now-&gt; y 하고 enter now URL을 통해 배포가 완료되며 해당 url로 접속할 수 있다.urlshortner 이렇게 배포된 서비스는 소스코드가 모두 공개되기 때문에 관리자 아이디와 비밀번호를 외부에서 열람하는 것이 가능하다. 따라서 개인정보는 밖으로 노출되지 않도록 않도록 해야한다.","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://huusz.github.io/categories/Nodejs/"}],"tags":[{"name":"urlshortner","slug":"urlshortner","permalink":"http://huusz.github.io/tags/urlshortner/"}]},{"title":"[Git] 로컬 저장소와 원격 저장소 연결하기","slug":"GIT/case1","date":"2017-08-30T02:22:01.000Z","updated":"2017-09-09T07:33:59.000Z","comments":true,"path":"2017/Git/GIT/case1/","link":"","permalink":"http://huusz.github.io/2017/Git/GIT/case1/","excerpt":"","text":"로컬 저장소를 github 저장소와 연결하기로컬 저장소 만들기1. 프로젝트 폴더 만들기우선 git 관리를 할 프로젝트 폴더를 적당한 디렉터리에 생성한다. 터미널에서 cd 디렉터리 명령어를 통해 원하는 디렉터리로 이동한다. mkdir 폴더명을 입력하면 현 위치에 새로운 폴더(디렉터리)를 만들어준다. (mkdir은 ‘make directory’이다.) cd 명령어를 이용해 새로 만들어진 폴더로 이동한다. 123$ cd 이동할 디렉터리$ mkdir 생성할 폴더명$ cd 생성한 폴더명 아래 예제는 desktop 디렉터리로 이동한 후, gitTest라는 폴더를 생성하였다. 그리고나서 생성한 gitTest 폴더로 이동하였다. 터미널의 오른쪽에서 디렉터리가 이동되는 것을 확인할 수 있다. 2. git init앞에서처럼 새로운 폴더를 만들고 git 저장소로 만든 후 프로젝트를 진행할수도 있지만, 기존에 진행하던 (git 저장소가 아니던) 프로젝트 폴더를 git 저장소로 만들 수도 있다. git init 명령어는 ‘git 관리를 하겠다’는 일종의 선언 같은 것이다. 이 명령어를 터미널에 입력하면 현 위치(디렉터리)에 .git이라는 폴더(하위 디렉터리)를 만든다. .git 디렉터리에는 저장소에 필요한 뼈대 파일(Skeleton)이 들어 있다. 구조는 아래와 같다. git init 명령어를 적용하면 이제 이 디렉터리는 git에 의해 관리되는 워킹 디렉터리가 된다. 하지만 이 명령은 앞에서도 말했듯, 관리를 하겠다는 선언한 것일 뿐 이것 만으로는 어떠한 버전 관리도 이루어지지 않는다. 현재 gitTest폴더에 아무것도 없는 상태이므로 변경 사항을 만들기 위해 파일 하나를 생성한다. 예시로 new.txt 파일을 생성하였다. 만약 기존에 진행하던 프로젝트 폴더를 git 저장소로 추가하고 있다면 새 파일을 만드는 이 과정은 생략해도 무방하다. 3. git statusgit은 워킹 디렉터리의 변경 사항(파일 또는 폴더의 수정/삭제/생성 등)을 감지할 수 있다. git status 명령어는 현재 git 관리 상태가 어떠한지를 보여준다. 1$ git status 위 상황은 현재 new.txt라는 관리대상이 아닌 (untracked) 파일이 감지되었으며 커밋되지 않았고, stage에 올라가지 않은 상태임을 의미한다. 즉 기존에 git이 관리하던 대상(파일이나 폴더)이 아닌 것이 발견되었다는 것이다. 이는 앞에서 new.txt 파일을 새롭게 생성했던 것이 git에 의해 감지된 것이다. 워킹 디렉토리의 모든 파일은 크게 Tracked(관리대상임)와 Untracked(관리대상이 아님)로 나눈다. Tracked 파일은 이미 스냅샷에 포함돼 있던 파일이다. Tracked 파일은 또 Unmodified(수정하지 않음)와 Modified(수정함) 그리고 Staged(커밋하면 저장소에 기록되는) 상태 중 하나이다. 그리고 나머지 파일은 모두 Untracked 파일이다. Untracked 파일은 워킹 디렉토리에 있는 모든 파일이 스냅샷에 포함돼 있는 것은 아니고 Staging Area에 있는 것도 아니다. 처음 저장소를 Clone하면 모든 파일은 Tracked이면서 Unmodified 상태가 된다. 파일을 Checkout하고 나서 아무것도 수정하지 않았기 때문에 그렇다. 마지막 커밋 이후 아직 아무것도 수정하지 않은 상태에서 어떤 파일이 수정되면 Git은 그 즉시 파일을 Modified 상태로 인식한다. 그리고 이 수정한 파일을 Stage하고 Staged 상태인 파일을 커밋한다. 이 라이프사이클을 그림처럼 계속 반복한다. status에 대한 더 자세한 내용은 링크를 참고한다. 4. git addcommit은 내 로컬 디렉터리에서 감지된 변경 사항을 확정하는 것이다. (HEAD에 반영한다고 말한다.) add는 변화가 감지된 파일들 중에서 git에 반영할(commit할) 후보를 선정하여 목록에 올리는 것이다. 메뉴얼에서는 ‘stage에 올린다’라고 표현한다. add는 특정 변화만 선택적으로 stage에 올릴 수도 있고, 변화 전체를 한꺼번에 올릴 수도 있다. 아래 예제는 변화된 파일 전체를 스테이지에 올리는 명령이다. 1$ git add . 만약 여러 파일 중 하나의 파일만 선택적으로 stage에 올리고 싶다면 .대신 파일명을 입력하면 된다. 1$ git add new.txt 5. git commit이제 스테이지에 올린 변경 사항들을 commit 명령을 통해 저장한다. 1$ git commit -m \"첫번째 버전\" -m과 &quot;&quot;는 커밋 메시지를 추가하는 명령이다. &quot;&quot;안에 메시지를 입력하면 된다. 해석해보면 master 브랜치에 2fb5223이라는 ID를 갖는 커밋 로그가 추가되었으며, 커밋 메시지는 ‘첫번째 버전’이다. 이 커밋으로 1개의 파일이 변화하였으며, 1줄의 삽입(+)이 있었다라는 의미이다. 로컬 저장소를 github 저장소에 연결하기지금까지는 내 PC에서만 관리 가능한 로컬 저장소를 만들었다. 로컬 저장소만으로는 다른 이들과 프로젝트를 공유할 수 없기 때문에 공동 작업(협업)이 불가하다. 따라서 협업이나 프로젝트의 공유를 위해서는 특정 서버에 git 저장소를 만들고, 서버를 통해 관리할 필요가 있다. 가장 많이 사용되는 github 홈페이지를 통해 git 원격 저장소를 생성할 수 있다. 1. 계정 만들기github.com에 접속하여 계정을 생성하고 로그인한다. 2. 원격 저장소 생성하기github에 새 프로젝트를 생성하면 원격 저장소가 만들어진다. 아래 예제에서는 test라는 이름의 원격 저장소를 생성하였다. readme.md는 저장소의 프로젝트에 대한 설명을 작성하는 용도로 흔히 사용된다. 지금은 있어도 되고, 없어도 크게 상관 없다. 3. 로컬 저장소와 원격 저장소 연결하기지금까지는 로컬 저장소와 원격 저장소 별개로 존재할 뿐 아직 연결되지 않은 상태이다. git remotegit remote는 리모트 저장소를 생성한다. 리모트 저장소란 인터넷이나 네트워크 어딘가에 있는 저장소를 말한다. remote 명령어를 통해 저장소를 추가하는 것은 네트워크 어딘가에 있는 원격 저장소를 관리할 저장소로 등록하는 행위이다. remote 명령은 아래와 같이 실행할 수 있다. 12345$ git remote add 단축이름 원격저장소url$ git remote$ git remote -v 첫번째 명령은 원격저장소를 내 리모트 저장소로 등록(추가)한다. 이때 저장소의 단축 이름을 직접 지정할 수 있다. 저장소명은 특별하지 않다면 origin을 사용하는 것이 일반적이다. git remote 명령은 내가 등록한 모든 리모트 저장소 목록을 설정한 단축 이름으로 보여준다. git remote -v는 단축 이름과 url을 함께 보여준다. git clone 사실 remote 명령을 생략하고 바로 clone 명령을 사용할 수도 있다. clone은 대상이 되는 원격 저장소를 통째로 나의 로컬 저장소(PC)에 복제해온다. 저장소를 clone하면 origin이라는 이름의 리모트 저장소가 자동으로 등록된다. 따라서 remote하는 과정을 생략하고 바로 git clone 저장소url 명령을 수행하여도 무방하다. 4. 로컬 저장소와 원격 저장소 동기화하기로컬 저장소와 원격 저장소를 동기화 즉, 같은 상태로 만들어주는 방법에는 두 가지가 있다. (사실 더 많지만 일단은 크게 두 가지만 다룬다.) git pushpush 명령은 내 로컬 저장소의 확정 변경 사항(commit)을 원격 저장소에도 반영하는 것이다. 1$ git push --set-upstream origin master --set-upstream은 push할 리모트 저장소를 지정해준다. 위에서는 origin이라는 리모트 저장소의 master 브랜치에 push 명령을 내리겠다는 의미이다. --set-upstream은 한번만 지정해두면 새로운 저장소 브랜치를 set하기 전까지는 git push 입력만으로 간편하게 push 할 수 있다. remote 후 바로 push하는 중 발생할 수 있는 오류 몇 가지를 소개한다! 아래와 같은 에러메시지를 만날 수 있다. 12 ! [rejected] master -&gt; master (non-fast-forward)error: failed to push some refs to &apos;https://github.com/huusz/test.git&apos; rejected: push가 거부되었다.master -&gt; master: 로컬 저장소의 master 브랜치의 변경 사항을 원격 저장소의 master 브랜치에 반영하려 하였는데,non-fast-forward: 원격 저장소의 master 브랜치가 로컬 저장소의 버전보다 이전 버전이 아니다! 라는 의미이다. 즉, 오류가 발생하게 된 원인은 github에서 새로운 프로젝트를 생성하면서 만들어진 원격 저장소에 함께 만들어진 readme.md 파일 때문이다. 더 정확히 말하면 readme.md 파일의 존재가 문제가 되는 것이 아니고, 원격 저장소에서 이루어진 readme.md를 추가하는 커밋이 로컬 저장소의 커밋 로그에 없기 때문이다. push 명령은 로컬 저장소의 commit 목록과 원격 저장소의 commit 목록을 비교한다. 그런 다음 원격 저장소의 마지막 commit id와 동일한 commit id를 가진 로컬 저장소의 commit 시점을 찾아낸 뒤, 원격 저장소의 마지막 커밋과 연결한다. 이제 무엇이 이해가 될 것이다. 원격 저장소의 첫번째이자 마지막 commit인 readme를 추가하는 commit이 원격 저장소에는 존재하지 않고, 따라서 현 상태에서는 둘을 연결할 수 없다. 이 상황을 해결하는 방법은, 원격 저장소를 삭제하고 다시 만들거나, (물론 readme 파일 없이 만들어야 합니다. readme 파일을 함께 생성하면 자동으로 커밋이 생성되기 때문이다.) fetch나 pull 명령으로 원격 저장소의 마지막 커밋을 로컬 저장소 커밋 로그의 맨 앞으로 받아와야 한다. 두 번째 방법으로 해결해본다. 1$ git pull origin master 한번에 해결되면 좋겠지만, 안타깝게도 또다른 오류가 발생한다. 1fetal: refusing to merge unrelated histories 에러 내용은 원격 저장소의 master 브랜치에서 로컬 저장소의 FETCH_HEAD를 merge하는 것이 거부되었다. 커밋 히스토리가 서로 관련이 없다. 즉 서로 관련성이 없기 때문에 merge할 수 없다는 것이다. 뒤에서도 설명하겠지만, pull 명령은 fetch + merge 작업을 한번에 처리한다. 현 상황은 fetch는 되었지만, merge가 되지 않은 상태이다. 기본적으로 merge는 원격 저장소와 로컬 저장소가 공통으로 가지고 있는 commit 지점이 존재해야 한다. 그 지점부터 병합을 시도하기 때문이다. 애초에 공통되는 commit 지점이 존재하지 않아 pull 명령도 사용할 수 없는 것이다. 해결하기 앞서 상황을 이해하기 위해 간단하게 짚고 넘어갈 개념이 있다. pull과 fetch이다. fetch는 리모트 저장소에 있는 내용을 가져오지만 자동으로 내 로컬 저장소에 merge하지 않는다. 원격 저장소의 내용을 확인만 하고 로컬에 병합(merge)하고 싶지는 않을 때 fetch를 사용한다. HEAD에는 가장 마지막에 행해진 commit 정보가 담긴다. 마찬가지로 FETCH_HEAD는 리모트 저장소의 가장 최신 commit 이력이 담기게 된다. FETCH_HEAD는 이름 없는 브랜치로 로컬에 가져오게 된다. 이 브랜치는 FETCH_HEAD로 checkout도 가능하다. pull 명령은 리모트 저장소에 있는 내용을 가져올 뿐 아니라 자동으로 로컬 저장소에 merge한다. 즉, git pull은 git fetch + merge FETCH_HEAD인 셈이다. 복잡하고 긴 설명 끝에 결론은 어쨌든 연결되는 공통된 커밋 포인트가 없다는 것이다. 결국은 clone으로 원격 저장소를 복제해오는 것이 가장 간단하다. 1$ git clone 저장소url 이렇게 하면 원격 저장소의 커밋이 내 로컬 저장소에 복사된다. 이후 add -&gt; commit -&gt; push를 통해 내 로컬 저장소에 있던 커밋 로그를 clone으로 불러온 커밋 로그 뒤에 merge할 수 있으며 이를 원격 저장소에도 반영할 수 있게 된다. clone은 자동으로 로컬의 master 브랜치가 리모트 저장소의 master 브랜치를 추적하도록 한다. git pull 명령은 clone한 저장소에서 데이터를 가져오고 그 데이터를 자동으로 현재 작업하는 코드와 merge시킨다. Reference git-scm.com stack overflow git tutorial - fetch","categories":[{"name":"Git","slug":"Git","permalink":"http://huusz.github.io/categories/Git/"}],"tags":[{"name":"github","slug":"github","permalink":"http://huusz.github.io/tags/github/"}]},{"title":"[node] 템플릿 언어 ejs","slug":"nodejs/4. Template Language","date":"2017-08-29T15:42:01.000Z","updated":"2017-08-29T15:43:15.000Z","comments":true,"path":"2017/Nodejs/nodejs/4. Template Language/","link":"","permalink":"http://huusz.github.io/2017/Nodejs/nodejs/4. Template Language/","excerpt":"","text":"Template LanguageWeb Page1) Static Web Page누가 어떻게 요청하든 미리 저장되어 있던 HTML 파일을 그대로 응답 2) Dynamic Web Page요청한 사람과 요청한 내용에 따라 각각 다른 내용으로 편집한 HTML을 응답 Template Engine템플릿과 데이터를 결합해 문서를 생성하는 프로그램, 혹은 라이브러리. 템플릿을 작성할 때 사용하는 언어를 템플릿 언어라고 한다. EJS: Embedded JavaScript Template Node.js 생태계에서 가장 많이 사용되는 템플릿 엔진 문법이 단순하다. JavaScript 코드를 템플릿 안에서 그대로 쓸 수 있음 .ejs VSCode Extension 1234567891011121314&lt;%# index.ejs %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"message\"&gt; &lt;%= message %&gt; &lt;/div&gt; &lt;% if (showSecret) &#123; %&gt; &lt;div&gt;my secret&lt;/div&gt; &lt;% &#125; %&gt; &lt;/body&gt;&lt;/html&gt; Express에서 EJS 사용하기 ejs 설치 1$ npm install --save ejs template engine 설정 1app.set('view engine', 'ejs') res.render()123456const data = &#123; title: 'Template Language', message: 'Hello EJS!', showSecret: true&#125;res.render('index.ejs', data) 템플릿 태그 &lt;% ... %&gt;: 템플릿의 구조를 제어하기 위해 사용하며, 문자열을 내놓지 않는다. &lt;%= ... %&gt;: 내부의 식을 문자열로 변환해 HTML 문서 안에 삽입한다. &lt;%# ... %&gt;: EJS 주석입니다. HTML 주석과는 다르게 아예 HTML 문서에 포함되지 않는다. 일반 HTML 주석보다는 EJS 주석을 사용하는 것이 좋다. HTML escape데이터를 HTML에 삽입하는 &lt;%= ... %&gt; 템플릿 태그는 &lt;, &gt; 두 문자를 각각 &amp;lt;, &amp;gt;로 변환하여 HTML에 삽입합니다. 결과적으로 HTML 태그를 직접 템플릿에 삽입하지 못하게 막습니다. 이렇게 하는 이유는 보안 때문으로, XSS(Cross-site Scripting)를 당할 위험을 줄여줍니다. XSS에 대해서는 추후 자세히 배울 것입니다. &lt;%- ... %&gt; 템플릿 태그를 이용하면 HTML escape를 생략할 수 있으나, 아주 특별한 경우가 아니면 &lt;%= ... %&gt; 태그를 사용하기를 권장합니다. example code Serving Static Filesstatic 파일 (변하지 않는 파일)은 static 경로를 사용해 주는 것이 좋다. EX. /static/index.css 12// `public` 폴더에 있는 파일을 `/static` 경로 아래에서 제공app.use('/static', express.static('public')) 123&lt;!-- 템플릿 파일에서 참조할 수 있음 --&gt;&lt;link rel=\"stylesheet\" href=\"/static/index.css\"&gt;&lt;script type=\"text/javascript\" src=\"/static/index.js\"&gt;&lt;/script&gt; 실습 :slug : 긴 영문 제목을 url에서 쓰기 위해 짧게 만든 것. Array.find(): 콜백 함수는 foreach나 map과 비슷한 모양을 하고 있다. true인 첫번째 요소 반환 12345678910const arr = [1,2,3];arr.map(item =&gt; item*2) // [2, 4, 6]arr.find(item =&gt; item === 2) // 2const item = [&#123;value: 1&#125;, &#123;value: 2&#125;, &#123;value: 1, name: 'second'&#125;]item.find(item =&gt; item.value === 2) // &#123;value: 2&#125;item.find(item =&gt; item.value === 1) // &#123;value: 1&#125; Array. filter(): true인 것을 모두 반환 123items.filter(item =&gt; item.value === 2) // [&#123;value:2&#125;]items.filter(item =&gt; item.value === 1) // [&#123;value: 1&#125;, &#123;value: 1, name: \"second\"&#125;] # Another template LanguagePug(=jade) 코드가 ejs보다 깔끔하다. pug은 닫는 태그가 없다. 닫는 태그에 의한 에러를 걱정할 필요가 없다.","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://huusz.github.io/categories/Nodejs/"}],"tags":[{"name":"ejs","slug":"ejs","permalink":"http://huusz.github.io/tags/ejs/"}]},{"title":"[node] 미들웨어 express","slug":"nodejs/3. Middleware","date":"2017-08-29T15:40:50.000Z","updated":"2017-08-29T15:43:20.000Z","comments":true,"path":"2017/Nodejs/nodejs/3. Middleware/","link":"","permalink":"http://huusz.github.io/2017/Nodejs/nodejs/3. Middleware/","excerpt":"","text":"Middleware1. Express Node.js 생태계에서 가장 널리 쓰이는 웹 프레임워크 내장하고 있는 기능은 매우 적으나, 미들웨어를 주입하는 방식으로 기능을 확장하는 생태계를 가지고 있음 2. Express 앱의 기본 구조123456789101112131415161718// Express 인스턴스 생성const app = express()// 미들웨어 주입app.use(sessionMiddleware()) // 세션미들웨어app.use(authenticationMiddleware()) // 인증미들웨어// 라우트 핸들러 등록// 루트 경로('/')로 요청이 들어왔을 때, Hello express! 라는 응답을 한다.app.get('/', (request, response) =&gt; &#123; response.send('Hello express!')&#125;)// 서버 구동// 3000번 포트에서 서버 요청을 기다릴 것이고, 서버 구동에 성공하면 아래 콜백(console.log('Example app listening on port 3000!'))을 실행시켜라.app.listen(3000, () =&gt; &#123; console.log('Example app listening on port 3000!')&#125;) 1) Routing123456789101112131415161718192021// HTTP 요청 메소드(GET, POST, ...)와 같은 이름의 메소드를 사용app.get('/articles', (req, res) =&gt; &#123; res.send('Hello Routing!')&#125;)// 특정 경로('/articles')에만 미들웨어를 주입하는 것도 가능app.post('/articles', bodyParserMiddleware(), (req, res) =&gt; &#123; database.articles.create(req.body) .then(() =&gt; &#123; res.send(&#123;ok: true&#125;) &#125;)&#125;)// 경로의 특정 부분을 함수의 인자처럼 입력받을 수 있음// ':id' 위치에 오는 값이 req.params.id에 저장된다.app.get('/articles/:id', (req, res) =&gt; &#123; database.articles.find(req.params.id) // `req.params`에 저장됨 .then(article =&gt; &#123; res.send(article) &#125;)&#125;) 2) Request 객체 req.body요청 바디를 적절한 형태의 자바스크립트 객체로 변환하여 이곳에 저장 (body-parser 미들웨어에 의해 처리됨) req.ip요청한 쪽의 IP req.paramsroute parameter req.queryquery string이 객체로 저장됨 3) 실습123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778const express = require('express')const bodyParser = require('body-parser')const app = express()// GET methodapp.get('/', (req, res) =&gt; &#123; res.send('Hello, Express!');&#125;)// POST methodapp.post('/', bodyParser.json(), (req, res) =&gt; &#123; /* Mission: 요청의 바디에 실려 온 JSON에 name이라는 속성이 있으면 해당 값을 이용해 응답하고, 없으면 400 Bad Request를 응답한다. 응답 형태는 'Hello, &lt;name&gt;!' 으로 한다. */ if (req.body.name) &#123; // 포함되어 있으면(String) true, 없으면(undefined) false res.send(`Hello, $&#123;req.body.name&#125;!`); &#125; else &#123; res.status(400); res.send(`400 Bad Request`) &#125;&#125;)// query parameter, res.statusapp.get('/add', (req, res) =&gt; &#123; /* Mission: query parameter에 x와 y라는 이름을 가진 두 값을 정수로 바꾸어서 더한 후 응답한다. 값을 정수로 바꿀 수 없다면 400 Bad Request로 응답한다. */ //parseInt 사용 시에는 무조건 try-catch를 써주어야 한다. try &#123; const x = parseInt(req.query.x); const y = parseInt(req.query.y); const result = (x + y).toString(); res.send(result) &#125; catch (e) &#123; res.status(400) res.send(`400 Bad Request`) &#125;&#125;)// req.ipapp.get('/ip', (req, res) =&gt; &#123; /* Mission: 요청한 쪽의 ip를 응답한다. */ res.send(req.ip);&#125;)// req.get, res.set, res.endapp.get('/header', (req, res) =&gt; &#123; /* Mission: 요청의 X-Custom-Header 헤더를 그대로 응답에 포함시켜 응답한다. 응답에는 바디를 포함시키지 않도록 한다. hint 1: res.set 메소드는 응답에 새로운 헤더를 지정한다. 예) res.set('X-Custom-Header', value) hint 2: res.end 메소드는 응답을 보낸다. res.send와 비슷하지만, 바디를 인자로 받지 않는다. */ const value = req.get(\"X-Custom-Header\") // 표준이 아닌 헤더를 만들 때, 이름 앞에 X를 붙이는 것이 관례이다. res.append('X-Custom.Header', value) res.end() // send()&#125;)&#125;)const listener = app.listen(process.env.PORT, function () &#123; console.log('listening on port ' + listener.address().port)&#125;)","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://huusz.github.io/categories/Nodejs/"}],"tags":[{"name":"express","slug":"express","permalink":"http://huusz.github.io/tags/express/"}]},{"title":"[node] HTTP","slug":"nodejs/2. http","date":"2017-08-29T15:40:30.000Z","updated":"2017-08-30T02:25:21.000Z","comments":true,"path":"2017/Nodejs/nodejs/2. http/","link":"","permalink":"http://huusz.github.io/2017/Nodejs/nodejs/2. http/","excerpt":"","text":"HTTP네트워크 확인하기1) wireshark 2) 크롬 개발자도구 HTTP 웹 브라우저와 웹 서버 간의 통신을 위해 개발된 통신규약 최근에는 REST API의 부상와 함께 다른 용도로도 널리 사용된다. 모바일 앱 - 서버 간 통신 서버 - 서버 간 통신 80번 포트를 기본으로 사용 클라이언트의 요청(request)과 서버의 응답(response)으로 이루어진다. 1) http의 역사1991HTTP 초기버전 발표. 텍스트만 전송할 수 있는 극도로 단순한 프로토콜. 1990년대 초 인터넷 붐을 일으킴 1996여러 인터넷 서비스 업체들이 자체적으로 사용하던 HTTP 구현들을 모아 HTTP 1.0 발표 19991.0의 문제를 해결하고 여러가지 기능을 추가한 HTTP 1.1을 발표. 지금까지 사용되고 있는 버전 2) HTTPS HTTP over SSL HTTP 통신을 암호화해 주고 받는 내용을 중간에서 가로챌 수 없도록 한다. 443번 포트를 기본으로 사용한다. 3) HTTP/2 구글의 SPDY 프로토콜을 기반으로 2015년에 확정된 새로운 HTTP 표준 0,1만으로 통신하는 프로토콜로 더이상 텍스트 기반이 아님 오로지 속도 개선에 중점을 두고 개발됨 반드시 HTTPS를 사용해야 함 현재 전체 웹사이트 중 16% 이상이 사용중 HTTP 작동방식1) Request &amp; Response 요청 Request: 웹 브라우저(또는 다른 클라이언트)는 웹 서버에 요청(request)를 보냄 응답 Response: 그에 따라 서버는 클라이언트에 응답(response)를 보냄 웹 브라우저의 경우, HTML 문서 형태의 응답이 오면 해당 문서를 분석한 후, 문서에 포함된 모든 자원에 대한 요청을 각각 추가로 보냄 (이미지, 동영상, 오디오, CSS, JS, 폰트, …) 2) Request Methods HTTP 명세에는 8 종류가 등록되어 있고, 각각의 역할과 충족해야 하는 성질이 명시되어 있음 웹 브라우저는 특정 상황에서 특정 메소드로 요청을 보내도록 만들어져 있음 Ajax와 같이 요청을 보내는 코드를 직접 짤 때는 요청 메소드를 선택할 수 있음 자료의 본문을 요청하는 GET 메소드와, 새로운 자료를 등록하는 POST 메소드가 가장 많이 쓰임 웹 브라우저는 순수 HTML만으로는 GET과 POST 메소드만 사용할 수 있도록 강제하고 있다. AJAX등으로 코드를 직접 작성할 때에는 메소드를 자유롭게 선택하여 사용할 수 있다. 서버가 충족시켜야하는 메소드의 성질 Safe 요청이 서버의 상태에 영향을 미치지 않아야 함. 즉, 읽기 전용이어야 함이 표준에 명시되어 있다. Idempotent 여러 번 같은 요청을 해도 한 번 요청한 것과 같은 효과여야 함. 네트워크가 불안정해도 안전하게 요청을 보낼 수 있음 DELETE, GET은 Idempotent을 만족해야 한다. 게시글의 삭제 요청을 여러번 보내도 한 번의 삭제 작업이 이루어져야 한다. GET도 마찬가지로, 여러번 요청이 가도 한 번만 GET 작업을 해야한다. POST는 데이터를 서버로 보내는 방법이다. 자료를 새로 만들 때 사용된다. 게시물을 만드는 요청을 서버에 보내다가 네트워크가 끊어진 상황을 가정했을 때, 서버에는 이미 해당 데이터가 만들어졌으므로 이후 같은 요청을 보내면 에러가 나야 한다. 따라서 POST는 Idempotent를 만족시켜서는 안 된다. Cacheable (특정 조건을 만족하면) 응답을 클라이언트에 저장해두었다가 다음 번 요청 때 다시 쓸 수 있음 3) URL &lt;서버의 위치&gt; 스키마 서브 도메인 도메인 탑레벨 도메인 포트 &lt;서버에서 얻고자 하는 자원의 위치&gt; 경로(path) 쿼리 스트링 해시 (fragment identifier) 4) Percent Encoding URL은 ASCII 문자(128개의 영문자+특수문자+제어문자)밖에 사용하지 못하기 때문에, non-ASCII 문자를 위한 표현방법이 필요함 # Percent encoding은 non-ASCII 문자를 위한 웹 표준 인코딩 방법으로, JavaScript에 관련 기능이 포함되어 있음 1234&gt; encodeURIComponent(&quot;한글&quot;)&quot;%ED%95%9C%EA%B8%80&quot;&gt; decodeURIComponent(&quot;%ED%95%9C%EA%B8%80&quot;)&quot;한글&quot; 5) Request Target일반적인 경우 아래와 같은 구조가 사용됨 absolute path + query string + fragment id 절대 경로 + 쿼리스트링 + 해시 GET /path/to/resource?foo=bar&amp;spam=hoge#fragid HTTP/1.1 6) Response Status응답의 성공, 실패 여부와 종류를 나타내며, 상태 코드 + 상태 메시지의 형태로 응답에 포함됨 HTTP/1.1 200 OK [Status Category]2xx 성공 200 OK - 성공 201 Created - 자료가 성공적으로 생성되었다. 3xx 추가 작업이 필요하다. 301 Moved Permanently (Redirection) - 자료가 완전히 다른 곳으로 이동했다. 302 Found (Redirection) - 자료가 일시적으로 다른 곳에 있다. 304 Not Modified (Cache) - 클라이언트가 이미 가지고 있던 자료가 수정되지 않았다. (그대로 사용하면 된다.) CSS나 Javascript에 대한 응답인 경우가 많다. 4xx 실패 - 클라이언트 책임 400 Bad Request - 요청의 형태가 잘못되어 응답할 수 없다. 403 Forbidden - 요청한 자료에 접근할 권한이 없다. 404 Not Found - 요청한 자료가 없다. 5xx 실패 - 서버 책임 500 Internal Server Error - 요청을 처리하던 중에 예상치 못한 요류가 발생했다. 503 Service Unavailable - 서버가 일시적으로 응답을 할 수 없다. 7) Header 요청과 응답에 대한 추가 정보를 표현하는 데 사용 인증, 캐싱, 쿠키, 보안, 내용협상, 프록시 등 웹 표준에 정의된 많은 기능을 제어하는 데 사용됨 Authorization요청의 인증 정보 User-Agent요청 중인 클라이언트의 정보 Location301, 302 응답에서 자료의 위치 Accept요청이 어떤 형태의 자료를 원하는지 나타냄 Content-Type요청 혹은 응답이 어떤 형태의 자료인지 나타냄 8) Content Negotiation요청의 Accept, Accept-Language 등의 헤더를 보고 서버가 그에 맞는 형태의 자료를 응답하는 절차를 content negotiation(내용 협상)이라고 함 클라이언트가 JSON이 필요하다는 요청을 보내면, 서버가 JSON포맷의 데이터를 보내준다. 만약 없다면 XML 또는 기타 다른 포맷의 데이터를 대신 보내주는데, 이 과정을 content negotiation: 내용 협상이라고 한다.","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://huusz.github.io/categories/Nodejs/"}],"tags":[{"name":"http","slug":"http","permalink":"http://huusz.github.io/tags/http/"}]},{"title":"[node] node 시작하기","slug":"nodejs/1. basic","date":"2017-08-29T15:40:12.000Z","updated":"2017-08-29T15:43:26.000Z","comments":true,"path":"2017/Nodejs/nodejs/1. basic/","link":"","permalink":"http://huusz.github.io/2017/Nodejs/nodejs/1. basic/","excerpt":"","text":"nvm(node version manager)12345# 주석: `#`으로 시작하는 명령은 bash에서 무시됩니다.# 아래 명령을 한 줄씩 차례대로 입력하세요$ nvm install 8.4$ nvm use 8.4$ nvm alias default 8.4 # nvm-windows는 필요없음 Node.js REPLREPL(Read Eval Print Loop): 윈도우 커맨드, 혹은 UNIX/LINUX Shell처럼 사용자가 커맨드를 입력하면 시스템이 값을 반환하는 환경을 일컫는다. Node.js는 REPL 환경과 함께 제공되며 다음과 같은 기능을 수행할 수 있다. Read: 유저의 값을 입력 받아 Javascript 데이터 구조로 메모리에 저장한다. Eval: 데이터를 처리(Evaluate)한다. Print: 결과값을 출력한다. Loop: Read, Eval, Print를 유저가 Ctrl+C를 두 번 눌러 종료할 때까지 반복한다. Node.js 의 REPL 환경은 자바스크립트 코드의 테스팅 및 디버깅할 때 유용하게 사용된다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// REPL 시작하기$ node// 한 줄 짜리 코드 입력하기&gt; 'hello node''hello node'// 위쪽 화살표 키를 입력해서 이전 명령 불러오기&gt; 'hello node''hello node'// Underscore(_) 변수밑줄 _변수는 최근 결과값을 지칭한다.&gt; var x = 10;undefined&gt; var y = 5;undefined&gt; x+y;15&gt; var sum = _undefined&gt;console.log(sum)15undefined// 변수 사용하기&gt; const factorial = n =&gt; n &lt; 1 ? 1 : n * factorial(n-1)undefined&gt; factorial(3)6// 여러 줄에 나눠서 입력하기&gt; function factorial2(n) &#123;... return n &lt; 1 ? 1 : n * factorial(n-1)... &#125;undefined&gt; factorial2(4)24// `.exit`를 입력하거나 `Ctrl+C`를 두 번 입력해서 나가기&gt; .exit// Node.js module 사용하기&gt; const os = require('os') // 급할땐 `os = ...`undefined&gt; os.platform()'linux'&gt; os.freemem()658300928 node.js로 파일 실행시키기1$ node (파일 경로) node.jsNode.js®은 chrome의 v8 자바스크립트 엔진에 기반한 자바스크립트 런타임이다. Node.js는 가볍고 효율적인 event-driven, non-blocking I/O model을 사용한다. Node.js의 패키지 에코 시스템인 npm은 전 세계 오픈 소스 라이브러리 중 가장 큰 생태계(ecosystem)이다. 1) JavaScript Runtime이란? JavaScript는 언어 JavaScript 런타임(runtime)은 JS를 구동하기 위해 필요한 실행 환경 프로그래머는 런타임이 제공하는 도구를 응용해서 프로그램을 개발 웹 브라우저나 Node.js도 JavaScript 런타임의 일종 2) JavaScript Runtime 종류 Chrome이 제공하는 웹 브라우저용 런타임 Node.js가 제공하는 서버용 런타임 MongoDB가 제공하는 데이터 처리용 런타임 Photoshop이 제공하는 전용 런타임… V8 JavaScript EngineJIT(Just-In-Time) compilationCode OptimizationUsed inGoogle ChromeNode.jsMongoDB… V8 엔진의 작동 방식?1) Event-driven Programming프로그램의 흐름이 외부 요인에 의해 일어나는 사건에 의해 결정되는 프로그래밍 양식약속된 방식으로 이벤트 핸들러를 작성함으로써 외부 이벤트가 일어났을 때 코드를 실행 마우스 입력 키보드 입력 다른 프로그램/컴퓨터로부터의 통신 123456789101112 // DOM 이벤트 핸들러 등록 (웹 브라우저)domElement.addEventListener('click', function(e) &#123; e.stopPropagation() alert('hello')&#125;)// 서버도 똑같이 합니다.// (단, 프레임워크를 쓸 때는 직접 이벤트를 다룰 일이 별로 없음)// HTTP 응답 이벤트 핸들러 등록 (Node.js)httpResponse.on('data', data =&gt; &#123; console.log(data)&#125;) 2) Non-blocking I/OBlocking I/O는 스레드가 입력/출력이 완료될 때까지 기다렸다가 다음 코드를 실행 Non-blocking I/O는 스레드가 입력/출력을 기다리지 않고 코드를 계속 실행 순차적으로 실행되다가 기다려야 할 상황이 오면 코드 실행을 멈추고 그 상황이 완료된 이후에 코드를 실행하지만, 어떤 프로그래밍 언어나 기술들은 코드가 기다려야 하는 상황이 왔을 때, 그에 대한 신호만 주고 다음 코드를 계속 실행한다. 이전 코드가 완료되기를 기다렸다가 실행하는 것이 blocking I/O라고 하며 기다리지 않고 계속 실행하는 것을 non-blocking I/O라고 한다. non-blocking의 단점은 코드가 복잡해질 수 있다는 점이다. (이러한 복잡함을 해결해주는 도구가 promise이다.) I/O 성능 향상 &amp; 복잡한 코드 Node.js Module123456789101112131415// name.js// `module.exports`에 저장한 값은 다른 모듈에서 불러올 수 있음module.exports = &#123; familyName: '김', givenName: '승하', fullName: function() &#123; return this.familyName + this.givenName &#125;&#125;// calc.js// `exports`로도 참조 가능exports.add = (x, y) =&gt; x + yexports.sub = (x, y) =&gt; x - y REPL에서 불러오기12345678910111213// Node.js 내장 모듈과는 다르게 경로를 지정해야 함&gt; const name = require(&apos;./name&apos;)undefined&gt; name&#123; familyName: &apos;김&apos;, givenName: &apos;승하&apos;, fullName: [Function: fullName] &#125;&gt; name.familyName&apos;김&apos;&gt; name.fullName()&apos;김승하&apos;&gt; require(&apos;./calc&apos;).add(1, 2)3 브라우저에서는 전역변수를 쓰면 위험하다script1.js 파일에 var evil = 1; 이라는 전역 변수를 선언하면 script2.js 파일에서도 evil을 참조할 수 있게 된다.하지만 nodejs는 조금 다르다. nodejs 모듈은 각각의 스코프(scope)가 따로 존재한다. 따라서 module1.js에서 var evil = 1;이라고 선언하더라도 전역에 선언되는 것이 아닌, module1이라는 모듈 내의 스코프에서만 존재하기 때문에 다른 모듈에서 접근할 수 없다. 따라서 export하지 않으면 다른 모듈에서 해당 변수에 접근할 수 없다. NPMNode.js 패키지 관리 도구 + 클라우드 패키지 저장소 의존 패키지 관리 스크립트 실행 패키지 설정 NPM에 패키지 배포 Node.js 종합 작업 도구 1234567891011121314151617$ mkdir hello-npm$ cd hello-npm$ npm init -y$ code .// package.json&#123; \"name\": \"hello-npm\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\"&#125; package.json패키지 정보를 담고 있는 파일 dependenciesnpm install --save 명령으로 설치한 패키지가 기록됨 scripts원래 목적은 패키지 생명주기마다 자동으로 실행되는 명령을 등록하기 위함이나, 개발자 편의를 위해 자주 사용되는 명령을 등록하는 용도로 더 많이 사용됨 1$ npm install --save randomstring # node_modules에 저장됨 123// index.jsconst randomstring = require('randomstring')console.log(randomstring.generate()) 123456// package.json... \"scripts\": &#123; \"start\": \"node index.js\" &#125;... 1$ npm start Concurrency Model(동시성 모델)프로그램이 생애 주기가 겹치는 여러 실행 과정을 통해 실행된다 하더라도 프로그램의 결과에는 영향을 미치지 않는 성질 생애 주기가 겹치는 여러 실행 과정이 자원을 공유할 때 어떻게 충돌이 생기지 않도록 할 것인가? Resources CPU 메모리 네트워크 … Thread코드 실행의 가장 작은 단위 프로그램은 하나 이상의 스레드로 이루어짐 CPU 코어 하나는 한 번에 하나의 스레드를 실행 1234$ sysctl -n hw.ncpu # OSX$ nproc # linux$ mmc devmgmt.msc # Windows$ top -H # Shows the total number of threads 동시성을 위한 도구자원의 공유를 위해 프로그래밍 언어는 언어들만이 가지고 있는 동시성을 위한 도구를 가지고 있는 경우가 많다. 1) 운영체제 차원의 도구 Process Thread Mutex (Mutual Exclusion) 2) 언어 차원의 도구 Python - asyncio Go - goroutine Erlang - actor JavaScript - …? 자바스크립트의 동시성Single-Threaded Event Loop자바스크립트를 실행시키는 스레드가 하나 뿐이다.실행 과정(보통 콜백 연쇄)의 생애 주기가 겹칠 수는 있지만 어떤 경우에도 두 자바스크립트 실행과정이 동시에 실행되는 경우는 없음. 내부적으로 메시지 큐를 활용하고 있으나, 모든 처리가 자동으로 이루어짐 !MDN[https://developer.mozilla.org/ko/docs/Web/JavaScript/EventLoop] 1) 장점 프로그래머가 동시성에 대해 신경쓸 필요가 없어짐 프로그램 작성이 쉬워짐 2) 단점 CPU를 많이 쓰는 작업에 부적절 오래 걸리는 자바스크립트 코드가 실행되면 전체 프로그램에 영향을 미침 3) 전략브라우저는 API가 있다면 API에 위임, 노드js는 c/c++로 만들어진 모듈을 가져와서 사용할 수 있는 방법이 있다. 오래 걸리는 일은 외부에 위임하고 넘어간 뒤, 나중에 결과를 받아 처리하기 Database Node.js - External libraries Web browser - WebAssembly 긴 실행과정을 여러 개의 함수로 쪼개서 한 번의 함수 실행이 금방 끝나게 만들기 Asynchronous JavaScriptnon-blocking과 asynchronous는 비슷한 맥락이다. 다만, non-blocking은 코드의 실행 순서에 대한 개념이고, asynchronous는 코드 작성 방식에 대한 개념이다. 함수를 호출할 때, 콜백까지 같이 인자에 넣어서 호출하는 비동기 프로그래밍 양식 콜백에서 에러 인자를 받는 방식으로 에러 처리를 함 Node.js 내장 모듈 전체가 이 방식을 사용하도록 만들어져 있음 주의! 모든 콜백이 비동기인 것은 아님 비동기식 코드의 에러처리: 관습try-catch는 동기식 에러처리 시에만 사용한다. 비동기식 에러 처리는 관습적으로 아래 방식을 사용한다. 1234567891011//readFile.jsconst fs = require('fs'); // Node.js 내장 모듈fs.readFile('./calc.js', 'utf8', (err, data) =&gt; &#123; // 에러처리 if(err) &#123; //error가 있으면 console.error(err); &#125;else &#123; //errro가 없으면 console.data(data); &#125;&#125;);console.log('done!'); 동기식 코드의 에러 처리: 일반적인 방식으로 처리123456789//readFileSync.jsconst fs = require('fs'); // Node.js 내장 모듈try &#123; const data = fs.readFileSync('./calc.js', 'utf8'); console.log(data);&#125; catch (err) &#123; console.log(err);&#125;console.log('done!'); 위 예제에서 readFile.js는 비동기 방식이며 readFileSync는 동기 방식으로 동작하는 코드이다. 코드를 실행 한 후 결과를 보면, readFile.js 12done!&#123; Error: ENOENT: no such file or directory, open './calc.js' errno: -2, code: 'ENOENT', syscall: 'open', path: './calc.js' &#125; 비동기 방식에서는 마지막 줄의 console.log(&#39;done!&#39;)코드가 이전 코드의 실행이 완료될 때까지 기다리지 않고 먼저 실행된다. readFileSync.js 123456789101112&#123; Error: ENOENT: no such file or directory, open './calc.js' at Object.fs.openSync (fs.js:652:18) at Object.fs.readFileSync (fs.js:553:33) at Object.&lt;anonymous&gt; (/Users/ihyeseung/projectfolder/fastcam/frontstudy/nodejs/practice/readFileSync.js:4:19) at Module._compile (module.js:573:30) at Object.Module._extensions..js (module.js:584:10) at Module.load (module.js:507:32) at tryModuleLoad (module.js:470:12) at Function.Module._load (module.js:462:3) at Function.Module.runMain (module.js:609:10) at startup (bootstrap_node.js:158:16) errno: -2, code: 'ENOENT', syscall: 'open', path: './calc.js' &#125;done! 동기 방식에서는 console.log(&#39;done!&#39;)이 이전 코드의 실행이 완료될때까지 기다린 후 실행되었다. Github REST API 호출1234567891011121314151617181920212223242526272829303132333435//request.js// 유저 이름, 저장소, 할당된 이슈 갯수 출력하기const request = require('request')const apiUrl = 'https://api.github.com'const option = &#123; json: true, auth: &#123; 'user': 'username', // github 유저네임 'pass': 'password', // github 비밀번호 &#125;, headers: &#123; 'User-Agent': 'request' &#125;&#125;request.get(`$&#123;apiUrl&#125;/user`, option, function (error, response, body) &#123; const name = body.name if (error) console.error(error) // 콜백 안에 콜백 request.get(`$&#123;apiUrl&#125;/user/repos`, option, function (error, response, body) &#123; if (error) console.error(error) const repoNames = body.map(item =&gt; item.name) // 콜백 안에 콜백 안에 콜백 request.get(`$&#123;apiUrl&#125;/issues`, option, function (error, response, body) &#123; if (error) console.error(error) const issueNum = body.length console.log(`name: $&#123;name&#125;`) console.log('repos:') repoNames.forEach(name =&gt; &#123; console.log(name) &#125;) console.log(`num of assigned issues: $&#123;issueNum&#125;`) &#125;) &#125;)&#125;) 1$ node request.js Callback Hell Promise비동기 작업의 결과를 담는 객체정확히 언제가 될지 모르지만, 결국 성공 또는 실패의 상태를 갖게 되며 이 상태가 되었을 때 비로소 콜백을 실행하라는 명령을 갖게 된다. 12345678910// tenSec.js// 10초 뒤에 콜백(promise 객체를 새로 만들어서 리턴)을 실행하는 함수module.exports = function tenSec(value) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(value) &#125;, 10000) &#125;)&#125; 12345678910&gt; const tenSec = require(&apos;./tenSec&apos;)&gt; const p = tenSec(1) // p에 Promise 저장&gt; p // 만든지 10초가 지나기 전Promise &#123; [pending], //pending: 아직 결과가 나오지 않음. ...&gt; p // 만든지 10초가 지난 후Promise &#123; 1, ... 1) promise의 상태(state) pending아직 수행 중인 상태 (fulfilled 혹은 rejected 되기 전) fulfilledpromise가 지켜진(수행된) 상태 rejectedpromise가 지켜지지 못한(거부된) 상태 settledfulfilled이든 rejected이든 결론이 난 상태 2) .thenpromise 객체의 메서드 12345678&gt; tenSec(&apos;hello promise&apos;).then(value =&gt; &#123;... console.log(value)... &#125;)Promise &#123; // `then`은 Promise를 반환 [pending], ...&gt; // 10초 후&apos;hello promise&apos; new Promise ()의 결과는 promise이다..then 메소드에서 반환된 값도 promise이다.따라서 .then 메소드를 계속 사용할 수 있다..then 메소드를 쓰면 들여쓰기를 하지 않아도 된다.따라서 Callback Hell을 피할 수 있다. return은 바로 실행되는 동기식 작업이다. 비동기 작업을 하려면 콜백을 통해서 해야 했다. 1234567new Promise().then(value =&gt; &#123; request.get( function()&#123; &#125;)return // 콜백은 함수 밖에서 리턴이 불가하다&#125;) promise는 함수 밖에서 리턴해야 하는데 위와 같은 콜백 방식에서는 함수 밖에서 리턴이 불가하다. 1234567new Promise().then(value =&gt; &#123; &#125;).then(value =&gt; &#123;&#125;) 3) Promise chaining1234567891011121314151617181920212223// chaining.jsconst tenSec = require('./tenSec')tenSec('hello promise') .then(value =&gt; &#123; console.log(value) return 1 // 위 `.then`은 값이 1인 Promise를 반환함 &#125;) .then(value =&gt; &#123; console.log(value) // value = 1 return tenSec('new promise') // Promise도 반환할 수 있음 &#125;) // 안에 들어 있는 값이 value(=1)인 Promise 생성 .then(value =&gt; &#123; // tenSec이 실행되고 10초 후 실행됨 console.log(value) &#125;) .then(() =&gt; &#123; //promise 안에서 에러가 나면 throw new Error('error in promise') &#125;) .catch(err =&gt; &#123; // 에러가 나면 catch 내부 코드 실행, 안나면 통과 console.error(err) &#125;) .then(() =&gt; &#123; // 에러 처리 이후에도 코드 실행 가능 console.log('done') &#125;) 기타 메소드 Promise.all(Arr): 모든 프라미스가 성공해야 성공하는 promise 12pa = Promise.all([p1, p2])// pa는 p1, p2가 모두 성공해야 성공하는 Promise이다. Promise.race(Arr): 가장 빨리 성공하는 promise를 반환 1pr = Promise.race([p1, pw]) promisify 함수 1234567891011// readfilePromise.jsconst &#123;promisify&#125; = require('util') // Node.js 8.0.0부터 추가됨const fs = require('fs')const readFile = promisify(fs.readFile)readFile('./calc.js', 'utf8') .then(data =&gt; &#123; console.log(data) &#125;) .catch(err =&gt; &#123; console.error(err) &#125;) 1&#123; Error: ENOENT: no such file or directory, open &apos;./calc.js&apos; errno: -2, code: &apos;ENOENT&apos;, syscall: &apos;open&apos;, path: &apos;./calc.js&apos; &#125; 4) Promise의 특징1) 이미 resolve 된 Promise에도 콜백을 실행할 수 있음 12&gt; const resolved = Promise.resolve(1)&gt; resolved.then(v =&gt; console.log(v)) 2) .then에 넘겨진 콜백은 (비동기가 아니라 바로 성공하도록 만들어진 동기식 promise라 하더라도)무조건 다음 루프에 실행됨 12345678&gt; (function() &#123;... Promise.resolve(1).then(v =&gt; console.log(v))... console.log('done!')... &#125;)()/* 출력:done! -&gt; 먼저 출력된다.1*/ Promise.all1234567891011121314151617181920212223242526272829// npm install --save request-promiseconst rp = require('request-promise')const apiUrl = 'https://api.github.com'const option = &#123; json: true, auth: &#123; 'user': 'username', 'pass': 'password', &#125;, headers: &#123; 'User-Agent': 'request' &#125;&#125;const userPromise = rp.get(`$&#123;apiUrl&#125;/user`, option)const reposPromise = rp.get(`$&#123;apiUrl&#125;/user/repos`, option)const issuesPromise = rp.get(`$&#123;apiUrl&#125;/issues`, option)// 배열 내의 모든 Promise 객체가 완료되었을 때// resolve 되는 Promise를 만든다.Promise.all([userPromise, reposPromise, issuesPromise]) .then(([user, repos, issues]) =&gt; &#123; console.log(`name: $&#123;user.name&#125;`) console.log('repos:') repos.forEach(repo =&gt; &#123; console.log(repo.name) &#125;) console.log(`num of assigned issues: $&#123;issues.length&#125;`) &#125;) 비동기 코드와 동일한 일을 promise로 할 수 있으며 promise를 이용하면 좀 더 깔끔하게 코드를 짤 수 있다. Fetch API window.fetch polyfill: Fetch API를 IE에서도 사용할 수 있게 해준다. Async/Await ES2017에서 도입되어, 비동기식 코드를 동기식 코드처럼 쓸 수 있는 문법 제공 Chrome 55, Node.js 8.0.0 부터 사용가능(아주 최근에 나온 문법이므로, 아직까지는 비동기식 코드에 promise가 더 널리 쓰인다.) async function 안에서 반환된 값은 최종적으로 Promise 객체로 변환되어 반환된다. async function 안에서 쓸 수 있는 await 키워드는 현재 함수를 중단시키고 Promise 객체가 충족될 때까지 기다리지만, 스레드를 block 하지 않는다. 에러 처리는 동기식 코드처럼 try, catch 블록을 통해서 한다. 1234567891011const tenSec = require('./tenSec')//await는 async 함수 안에서만 사용할 수 있다.async function resolveAfterTenSec() &#123; await tenSec() return 1&#125;resolveAfterTenSec().then(value =&gt; &#123; console.log(value)&#125;) 1) readFile - async/await123456789101112131415// readfileAsync.jsconst &#123;promisify&#125; = require('util') // Node.js 8.0.0부터 추가됨const fs = require('fs')const readFile = promisify(fs.readFile)async function readFileAsync() &#123; try &#123; const data = await readFile('./calc.js', 'utf8') console.log(data) &#125; catch (e) &#123; console.error(e) &#125;&#125;readFileAsync() 1&#123; Error: ENOENT: no such file or directory, open &apos;./calc.js&apos; errno: -2, code: &apos;ENOENT&apos;, syscall: &apos;open&apos;, path: &apos;./calc.js&apos; &#125;","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://huusz.github.io/categories/Nodejs/"}],"tags":[{"name":"nvm","slug":"nvm","permalink":"http://huusz.github.io/tags/nvm/"}]},{"title":"[JS] 비동기모델과 이벤트루프","slug":"Javascript/Javascript-Async,EventLoop","date":"2017-08-29T15:35:42.000Z","updated":"2017-08-29T15:43:40.000Z","comments":true,"path":"2017/Javascript/Javascript/Javascript-Async,EventLoop/","link":"","permalink":"http://huusz.github.io/2017/Javascript/Javascript/Javascript-Async,EventLoop/","excerpt":"","text":"비동기식 처리 모델과 이벤트 루프1. 브라우저 동작 원리1) 브라우저의 주요 기능브라우저의 주요 기능은 사용자가 참조하고자 하는 자원을 (또는 웹페이지를) 서버에 요청(Request)하고 응답(Response)을 받아 브라우저에 표시하는 것이다. 브라우저가 서버로부터 받는 자원은 보통 HTML 문서이지만, PDF나 이미지 또는 다른 형태일 수 있다. 일반적으로 브라우저는 서버로부터 HTML, CSS, Javascript 파일을 응답받는다. (자원의 주소는 URI에 의해 정해진다.)브라우저는 W3C(웹 표준화 기구)에서 정한 HTML과 CSS 표준 명세에 따라 HTML 파일을 해석해서 표시한다. 2) 브라우저의 기본 구조 사용자 인터페이스: 주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등. 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분이다. 브라우저 엔진: 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어. 렌더링 엔진: 요청한 콘텐츠를 표시한다. 예를 들어 HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시한다. 통신: HTTP 요청과 같은 네트워크 호출에 사용된다. 플랫폼 독립적인 인터페이스이고 각 플랫폼 하부에서 실행된다. UI 백엔드: 콤보 박스와 창 같은 기본적인 장치를 그린다. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, OS 사용자 인터페이스 체계를 사용한다. 자바스크립트 해석: 자바스크립트 코드를 해석하고 실행한다. 자료 저장소: 자료를 저장하는 계층이다. 쿠키를 저장하는 것과 같이 모든 종류의 자원을 하드 디스크에 저장할 필요가 있다. HTML5 명세에는 브라우저가 지원하는 웹 데이터베이스가 정의되어 있다. 크롬 브라우저는 각 탭마다 별도의 렌더링 엔진 인스턴스를 유지한다. 따라서 각 탭은 독립된 프로세스로 처리된다. 3) 렌더링 엔진렌더링 엔진의 역할은 요청 받은 콘텐츠를 브라우저에 표시하는 일이다. HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시한다. HTML, CSS 파일은 렌더링 엔진의 HTML 파서와 CSS 파서에 의해 파싱되어 DOM, CSSOM 트리로 변환되고 렌더 트리로 결합된다. 렌더링 엔진은 XML 문서와 이미지도 표시할 수 있다. 물론 플러그인이나 브라우저 확장 기능을 이용해 PDF 같은 다른 유형도 표시할 수 있다. 여기서는 HTML과 이미지를 CSS로 표시하는 주된 사용 패턴에 초점을 둘 것이다. 렌더링 엔진은 브라우저마다 다르다. 파이어폭스는 게코(Gecko) 엔진을 사용하며 사파리와 크롬은 웹킷(Webkit) 엔진을 사용한다. 렌더링 엔진 동작 과정렌더링 엔진은 통신으로부터 요청한 문서의 콘텐츠를 얻는 것으로 시작한다. 문서 내용은 보통 8KB 단위로 전송된다. 렌더링 엔진은 HTML 문서를 파싱하고, 콘텐츠 트리 내부에서 태그를 DOM 노드로 변환한다. 그다음 외부 CSS 파일과 함께 포함된 스타일 요소도 파싱한다. 파싱된 스타일 정보는 CSSOM 노드로 변환한다. 스타일 정보(CSSOM)와 HTML 표시 규칙(DOM)으로 렌더 트리라는 또 다른 트리를 생성한다. 렌더트리는 색상이나 면적같은 시각적 속성이 있는 박스를 포함하고 있는데, 정해진 순서대로 화면에 표시된다. 렌더 트리의 각 노드가 화면의 정확한 위치에 배치되어 표시된다. 다음은 UI 백엔드에서 렌더 트리의 각 노드를 가로지르며 형상을 만들어내는 그리기 과정이다. 일련의 과정들이 점진적으로 진행된다는 것을 아는 것이 중요하다. 렌더링 엔진은 좀 더 나은 사용자 경험을 위해 가능하면 빠르게 내용을 표시하는데 모든 HTML을 파싱할 때까지 기다리지 않고 배치와 그리기 과정을 시작한다. 네트워크로부터 나머지 내용이 전송되기를 기다리는 동시에 받은 내용의 일부를 먼저 화면에 표시하는 것이다. [참고] 브라우저는 어떻게 동작하는가, Poiema web HTML 파서는 script 태그를 만나면 DOM 생성 프로세스를 중지하고 자바스크립트 엔진에 제어 권한을 넘긴다. 자바스크립트 엔진의 실행이 완료된 후 브라우저가 중지했던 시점부터 DOM 생성을 재개한다. 이것은 script 태그의 위치에 의해 DOM의 생성이 지연될 수 있음을 의미한다. 2. Ajax브라우저에서 웹페이지를 요청하거나 링크를 클릭하면 화면 전환이 발생한다. 이것은 브라우저와 서버와의 통신에 의한 것이다. 서버는 요청받은 페이지(HTML)를 반환하는데 이때 HTML에서 로드하는 CSS나 JavaScript 파일들도 같이 반환된다. 클라이언트의 요청에 따라 서버는 정적인 파일을 반환할 수도 있고 서버 사이드 프로그램이 만들어낸 파일이나 데이터를 반환할 수도 있다. 서버로부터 웹페이지가 반환되면 클라이언트(브라우저)는 이를 렌더링하여 화면에 표시한다. Ajax(Asynchronous JavaScript and XML)는 자바스크립트를 이용해서 비동기적(Asynchronous)으로 서버와 브라우저가 데이터를 교환할 수 있는 통신 방식을 의미한다.서버로부터 웹페이지가 반환되면 화면 전체를 갱신해야 하는데, AJAX는 페이지 일부만을 갱신하고도 동일한 효과를 볼 수 있도록 한다. 페이지 전체를 로드하여 렌더링할 필요가 없고 갱신이 필요한 일부만 로드하여 갱신하면 되므로 빠른 퍼포먼스와 부드러운 화면 표시 효과를 기대할 수 있다. 서버는 HTML, XML, JSON등을 반환하는데, Ajax을 위한 데이터 형식은 JSON(JavaScript Object Notation) 을 사용하는 것이 일반적이다. 3. 동기식 처리 모델 VS 비동기식 처리 모델동기식 처리 모델(Synchronous processing model)작업이 순차적으로 실행된다. 어떤 작업이 수행 중이면 다음 작업은 대기한다. 예를 들어 서버에서 데이터를 가져와 화면에 표시하는 작업을 수행할 경우 서버에 데이터를 요청하고 데이터가 전달될 때까지 이후 작업들은 중단(Blocking)된다. 비동기식 처리 모델(Asynchronous processing model or Non-Blocking processing model)작업이 종료되지 않은 상태라도 대기하지 않고 다음 작업을 실행한다. 예를 들어 서버에서 데이터를 가져와 화면에 표시하는 작업을 수행할 경우 서버에 데이터를 요청한 이후 서버로부터 데이터가 전달될 때까지 대기하지 않고(Non-Blocking) 즉시 다음 작업을 수행한다. 이후 서버로부터 데이터가 전달되면 이벤트가 발생되고 이벤트 핸들러가 데이터를 가지고 수행할 작업을 계속하여 수행한다. 자바스크립트의 대부분의 DOM 이벤트와 Timer 함수(setTimeout, setInterval), Ajax 요청은 비동기적으로 동작한다. 4. 이벤트 루프와 동시성(Concurrency)브라우저는 단일 쓰레드(single-thread)에서 이벤트 드리븐(event-driven) 방식으로 동작한다. 자바스크립트는 본래 단일스레드 기반의 언어이다. 한번에 하나의 작업(task)만을 처리할 수 있다는 의미이다. 하지만 실제 웹 애플리케이션들을 보면 여러 task가 동시에 처리되는 것처럼 보인다. 이는 자바스크립트가 이벤트 루프를 이용해서 비동기 방식으로 동시성을 지원하기 때문이다. 브라우저 환경 자바스크립트 엔진은 크게 콜 스택 영역과 힙 영역으로 나뉜다. 흔히 비동기 호출을 위해 사용하는 setTimeout이나 XMLHttpRequest와 같은 함수들은 자바스크립트 엔진이 아닌 Web API 영역에 따로 정의되어 있음을 확인할 수 있다. 비동기 방식을 가능하게 하는 이벤트 루프와 태스트 큐(이벤트 큐) 또한 자바스크립트 엔진 외부에 구현되어있다. 1. Call Stack(호출 스택)작업이 요청되면(함수가 실행되면) 요청된 작업은 순차적으로 Call Stack에 쌓이게 되고 순차적으로 실행된다. 자바스크립트는 단 하나의 Call Stack을 사용하기 때문에 해당 task가 종료하기 전까지는 다른 어떤 task도 수행될 수 없다. 2. Heap힙은 동적으로 생성된 객체 인스턴스가 할당되는 영역이다. 이와 같이 자바스크립트 엔진은 단순히 작업이 요청되면 요청된 작업을 Call Stack을 사용하여 순차적으로 실행할 뿐이다. 앞에서 언급한 동시성(Concurrency)을 지원하기 위해 필요한 비동기 요청(이벤트를 포함) 처리는 자바스크립트 엔진을 구동하는 환경, 즉 브라우저(또는 Node.js)가 담당한다. 3. Event Queue(Task Queue)비동기 처리 함수의 콜백 함수, 비동기식 이벤트 핸들러, Timer 함수(setTimeout(), setInterval())가 보관되는 영역이다. 이벤트 루프(Event Loop)에 의해 특정 시점(Call Stack이 비어졌을 때)에 순차적으로 Call Stack으로 이동되어 실행된다. 4. Event Loop(이벤트 루프)Call Stack내에서 1) 현재 실행중인 task가 있는지, 그리고 2) Event Queue에 task가 있는지 반복하여 확인한다. 아래의 예제가 어떻게 동작할지 살펴보자. 123456789101112131415161718function func1() &#123; console.log('func1'); func2();&#125;function func2() &#123; setTimeout(function() &#123; console.log('func2'); &#125;, 0); func3();&#125;function func3() &#123; console.log('func3');&#125;func1(); 함수 func1이 호출되면 함수 func1은 Call Stack에 쌓인다. 그리고 함수 func1은 함수 func2을 호출하므로 함수 func2가 Call Stack에 쌓이고 setTimeout가 호출된다. setTimeout의 핸들러는 즉시 실행되지 않고 지정 대기 시간만큼 기다리다가 이벤트 큐로 이동한 후 Call Stack이 비어졌을 때 Call Stack으로 이동되어 실행된다. DOM 이벤트도 이와 같이 동작한다. 12345678910111213141516171819202122function func1() &#123; console.log('func1'); func2();&#125;function func2() &#123; // &lt;button id=\"foo\"&gt;foo&lt;/button&gt; var elem = document.getElementById('foo'); elem.addEventListener('click', function () &#123; this.style.backgroundColor = 'indigo'; console.log('func2'); &#125;); func3();&#125;function func3() &#123; console.log('func3');&#125;func1(); 함수 func1이 호출되면 함수 func1은 Call Stack에 쌓인다. 그리고 함수 func1은 함수 func2을 호출하므로 함수 func2가 Call Stack에 쌓이고 addEventListener가 호출된다. addEventListener의 콜백함수는 foo 버튼이 클릭되어 “onclick” 이벤트가 발생하면 이벤트 큐로 이동한 후 Call Stack이 비어졌을 때 Call Stack으로 이동되어 실행된다. Nodejs 환경 Node.js는 비동기 IO를 지원하기 위해 libuv 라이브러리를 사용하며, 이 libuv가 이벤트 루프를 제공한다. 자바스크립트 엔진은 비동기 작업을 위해 Node.js의 API를 호출하며, 이때 넘겨진 콜백은 libuv의 이벤트 루프를 통해 스케쥴되고 실행된다. 결론적으로, 자바스크립트가 단일 스레드 기반의 언어라는 말은 자바스크립트 엔진이 단일 호출 스택을 사용한다는 관점에서만 사실이다. 실제 자바스크립트가 구동되는 환경(브라우저, nodejs 등)에서는 주로 여러개의 스레드가 사용되며 이러한 구동 환경이 단일 호출 스택을 사용하는 자바스크립트 엔진과 상호 연동하기 위해 사용하는 장치가 바로 이벤트 루프이다. Reference Poiemaweb nhnent/github","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://huusz.github.io/categories/Javascript/"}],"tags":[{"name":"asynchronous","slug":"asynchronous","permalink":"http://huusz.github.io/tags/asynchronous/"}]},{"title":"[JS] 클로져 Closure","slug":"Javascript/Javascript-Closure","date":"2017-08-07T15:35:42.000Z","updated":"2017-08-28T14:13:02.000Z","comments":true,"path":"2017/Javascript/Javascript/Javascript-Closure/","link":"","permalink":"http://huusz.github.io/2017/Javascript/Javascript/Javascript-Closure/","excerpt":"","text":"클로저1. 클로저의 개념클로저는 자바스크립트에서 중요한 개념 중 하나이다. 클로저는 자바스크립트 고유의 개념이 아니라 함수를 일급 객체로 취급하는 함수형 언어에서 사용되는 중요한 속성이다. 클로저란, 이미 생명 주기가 끝난 외부 함수의 변수를 참조하는 함수이다. 12345678function outerFunc() &#123; //...(1) var x = 10; var innerFunc = function() &#123; //...(2) console.log(x); //...(3) &#125;; innerFunc();&#125;outerFunc(); 위 예제를 통해 살펴보면, outerFunc 함수가 선언되었고 …(1)그 내부 함수로 innerFunc가 선언되었다. …(2)innerFunc는 자신을 포함하고 있는 outerFunc의 지역 변수 x에 접근할 수 있다. …(3) 자바스크립트 엔진은 Scope-chain을 통해 중첩된 함수의 scope 레퍼런스를 차례대로 검색한다. innerFunc 함수 내에서 변수 x를 검색한다. x가 존재하지 않는다. 검색 실패. innerFunc 함수의 외부 함수 outerFunc 함수에서 변수 x를 검색한다. x가 존재한다. 검색 성공! 이번에는 innerFunc를 outerFunc에서 반환하는 코드로 변경해보자. 12345678910function outerFunc()&#123; // ...(1) var x = 10; var innerFunc = function () &#123; //...(2) console.log(x); &#125;; return innerFunc; //...(3)&#125;var inner = outerFunc(); // ...(4)inner(); //...(5) (1), (2) 과정은 위와 동일하고, innerFunc를 반환하는 outerFunc를 정의하였다. …(3)inner 변수에 outerFunc() 함수의 실행 결과를 저장한다. outerFunc의 실행 결과로 innerFunc의 참조가 반환된다. 결론적으로 innerFunc 함수의 참조가 변수 inner에 할당된다. 그리고 이때, outerFunc 함수가 종료되면서 life-cycle이 종료된다. …(4)변수 inner에 할당된 참조값을 통해 innerFunc 함수를 실행한다….(5)즉 outerFunc는 실행된 이후 콜스택(call stack)에서 제거되었으므로 함수 outerFunc의 지역변수 x 또한 더이상 유효하지 않게 되어 변수 x에 접근할 수 있는 방법이 없어 보인다. 하지만 위 코드의 실행 결과는 변수 x의 값인 10이다. 원래대로라면 외부 함수 내에 있는 지역 변수는 외부함수의 실행 컨텍스트에 구속되어 있는 존재이기 때문에 외부함수가 사라지면 함께 사라져야 한다. 하지만 지역 변수가 외부 함수 내부에, 같은 유효범위 내에 선안된 내부 함수에 의해 참조되면, 그 변수의 life cycle은 외부 함수보다 길어진다. 외부 함수의 참조는 끊어지지만, 외부 함수의 지역 변수는 내부 함수가 호출되면서 함께 계속 참조되므로 1)가비지 컬렉션의 수집 대상에서 벗어난다. 그리고 지역 변수의 라이프 사이클은 내부 함수와 함께 가게 된다. 즉, 내부 함수가 종료될 때 까지 살아있는 변수로 남게 되는 것이다. 1) 가비지컬렉션: 자바스크립트는 변수나 함수를 선언할 때 메모리를 할당한다. 그리고 할당된 메모리가 필요하지 않게 되면, 즉 어떤 변수나 함수에서도 더이상 참조하지 않게 되면 자바스크립트의 가비지 컬렉션이 메모리를 해제한다. 내부 함수가 외부 함수의 지역변수에 접근할 수 있다. 외부 함수는 외부 함수의 지역변수를 사용하는 내부 함수가 소멸될 때까지 소멸되지 못하고 상태가 유지되며, 내부 함수에 의해 소멸하게 된다. 위와 같은 특성을 클로저(Closure)라고 부른다. 외부 함수 내에서 내부 함수를 선언할 때, 함수만 정의되는 것이 아니라, 그 시점에 같은 유효 범위에 있는 모든 변수를 포함하는 클로저도 생성된다. 그 다음, 내부 함수를 실행하면 함수가 속해있던 유효 범위가 사라진 후에 실행됨에도 클로저를 통해 정의된 원래 유효범위에 접근하게 된다. 이것이 클로저의 핵심이다. 클로저는 보호막을 만든다. 보호막은 함수가 선언된 시점의 유효범위 내에 있는 모든 함수와 변수를 가지고 있으며 필요할 때 그것들을 사용할 수 있다. 이 보호막은 함수가 동작하는 한 관련 정보를 유지한다. &lt;자바스크립트 닌자 비급, p.118, 인사이트, 2014&gt; 1) 자유변수(Free variable)클로저에 의해 참조되는 외부 함수의 변수 12345678910function outerFunc()&#123; var x = 10; // 자유변수 var innerFunc = function () &#123; console.log(x); &#125;; return innerFunc;&#125;var inner = outerFunc();inner(); 예제의 outerFunc 함수의 지역 변수 x가 자유변수에 해당한다. 클로저라는 이름은 ‘자유변수에 함수가 닫혀있다(closed)’라는 의미로, 의역하자면 자유변수에 엮여있는 함수라는 뜻이다. 실행컨텍스트의 관점에서, 내부 함수가 유효한 상태에서 외부 함수가 종료된 경우를 생각해보자. 외부 함수의 실행 컨텍스트가 반환되어도, 그 내부의 Activation object(AO)는 유효하다. 다시 말해, 내부 함수가 Scope-chain을 통해 AO를 참조할 수 있다. 즉 외부함수가 이미 반환되었어도 외부함수 내의 변수는 자신을 필요로 하는 내부 함수가 하나 이상 존재하는 경우 계속 유지될 수 있다는 것이다. 이때 내부 함수가 외부 함수에 있는 변수의 복사본이 아니라 실제 변수에 접근한다는 것에 주의해야 한다. 2. 클로저의 활용그렇다면 클로저는 언제 사용하는가? 클로저 정보를 저장하고 참조하는 데는 직접적인 비용이 발생한다. 클로저 정보를 따로 보관해두는 명시적인 “closure”객체 같은 것은 존재하지 않기 때문에 클로저를 이용해 정보에 접근하는 함수는 계속해서 관련된 정보를 가지고 다녀야 한다. 클로저는 정말 유용하지만, 오버헤드에서 자유롭다고 할 수 없다. 클로저에 관한 모든 정보는 더이상 사용하는 곳이 없을 때, 혹은 페이지가 언로드 될 때까지 메모리에 남아있는다. 따라서 클로저가 의도되지 않은 상황이었다면 이는 리소스 낭비일 뿐이다. 클로저는 의도된 상황에서 활용되어야 한다. 1) 전역 변수의 사용 억제클로저의 필요성을 이해하기 위해, 버튼이 클릭될 때마다 클릭 횟수가 누적되어 화면에 표시되는 코드를 만들어보자. 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;p&gt;전역 변수를 사용한 Counting&lt;/p&gt; &lt;button type=\"button\" onclick=\"myFunction()\"&gt;Count!&lt;/button&gt; &lt;p id=\"demo\"&gt;0&lt;/p&gt; &lt;script&gt; var counter = 0; // 전역변수의 사용은 그다지 좋지 못하다. 전역 변수를 쓰지 않는 방법을 찾아야 한다. function add() &#123; return counter += 1; &#125; function myFunction()&#123; document.getElementById('demo').innerHTML = add(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 위 코드는 동작에는 전혀 무리가 없다. 다만 add 함수만을 위한 전역 변수를 사용하고 있다. 전역 변수는 어디서나 접근할 수 있어 의도치 않게 변수명이 중복되거나 값이 변경되었을 때 문제가 발생할 소지가 다분하다. 따라서 전역 변수를 쓰지 않는 방법을 강구해야 한다. 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;p&gt;지역 변수를 사용한 Counting&lt;/p&gt; &lt;button type=\"button\" onclick=\"myFunction()\"&gt;Count!&lt;/button&gt; &lt;p id=\"demo\"&gt;0&lt;/p&gt; &lt;script&gt; function add() &#123; var counter = 0; // 전역 변수에서 add 함수 내부의 지역 변수로 이동시켰다. return counter += 1; &#125; function myFunction()&#123; document.getElementById('demo').innerHTML = add(); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 전역 변수를 피하기 위해 add 함수 내부로 이동시켜, 지역 변수로 다시 선언하였다. 그런데 이번엔 함수의 작동 방식에서 문제가 발생하였다. counter가 함수가 호출될 때마다 0으로 리셋되어 0 -&gt; 1 -&gt; 함수호출 -&gt; 0 -&gt; 1 을 반복하게 되어, 화면 상에는 1만 표시된다. 처음 의도했던 동작을 수행하지 못하여, 결국 이 방법도 해결책이 되지 못한다. 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;p&gt;클로저를 사용한 Counting&lt;/p&gt; &lt;button type=\"button\" onclick=\"myFunction()\"&gt;Count!&lt;/button&gt; &lt;p id=\"demo\"&gt;0&lt;/p&gt; &lt;script&gt; var add = (function () &#123; // 외부 함수 ...(1) var counter = 0; // 외부 함수의 지역 변수 ...(2) return function () &#123; // 내부 함수 ...(3) return counter += 1; // 외부 함수의 지역 변수 참조 &#125; &#125;)(); // 즉시 실행 함수 function myFunction()&#123; document.getElementById('demo').innerHTML = add(); //...(4) &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 위 예제에서는 클로저를 활용하였다. 변수 add에 즉시실행함수가 외부함수로 호출되었다…(1)add()를 실행하면 변수 add에 담긴 즉시실행함수가 실행되어…(4)무명함수 function () { return counter +=1; }가 반환(return)된다…(3) 즉시실행함수는 단 한번만 실행된다. 따라서 add에 담긴 함수가 호출될 때마다 변수 counter가 초기화되는 일은 없을 것이다. 중요한 것은 add에 담겨 있는 내부 함수(3)는 변수 counter(2)에 접근할 수 있고 변수 counter는 add에 담겨 있는 내부 함수(3)가 소멸될 때까지 유지된다는 것이다. 이것이 클로저이다. 변수 counter는 외부에서 직접 접근할 수 없는 private변수이므로 전역 변수를 사용했을 때와 같이 의도되지 않은 변경을 걱정할 필요도 없다. 2) setTimeout()의 콜백 함수12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;p&gt;새로고침으로 다시 실행해 보세요&lt;/p&gt; &lt;script&gt; var fade = function (node) &#123; // 자유변수 var level = 1; // ② var step = function() &#123; var hex = level.toString(16); // ④ // hex: '1' ~ 'f' node.style.backgroundColor = '#ff' + hex; // ⑤ if(level &lt; 15) &#123; // ⑥ level += 1; setTimeout(step, 100); // ⑦ &#125; &#125;; // setTimeout 호출 이후 fade 함수는 종료한다. 100ms 후 함수 step은 호출된다. // 즉 외부 함수 fade보다 내부 함수 step이 더 오래 유지된다. setTimeout(step, 100); // ③ &#125;; fade(document.body); // ① &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; setTimeout() 함수는 첫번째 파라미터에 콜백 함수를 전달하고, 파라미터에 ms(1/1000초)단위의 시간 간격을 지정한다. 즉 지정된 시간 간격으로 콜백 함수를 호출한다. ① 함수 fade는 document.body를 인자로 전달받아 호출된다.② 함수 fade의 지역변수 level은 1로 초기화되어 있다. 함수 step은 내부함수이며 외부함수 fade의 지역변수 level을 사용한다. level은 자유변수이다.③ setTimeout 호출 이후 fade 함수는 종료한다. 100ms 후 함수 step은 호출된다. 즉 외부 함수 fade보다 내부 함수 step이 더 오래 유지된다.④ 함수 step은 지역변수 hex을 갖는다. 이것은 16진수 문자열을 값으로 갖는다.⑤ 함수 fade의 매개변수 node(document.body)의 배경색을 변경한다.⑥ 변수 level이 15(f)보다 작은지 다시말해 16진수 범위 내(1~f)인지 확인한다.⑦ level을 1 증가시키고 다시 함수 step을 호출하여 같은 작업을 반복한다. 이때 fade 함수는 이미 반환되었지만 외부함수 fade 내의 변수는 이를 필요로 하는 내부함수가 하나 이상 존재하는 경우 계속 유지된다. 이때 내부함수가 외부함수에 있는 변수의 복사본이 아니라 실제 변수에 접근한다는 것에 주의하여야 한다. 3) 자주 발생하는 실수아래 예제는 클로저 사용시 자주 발생하는 실수에 관한 예제이다. 1234567891011var arr = [];for (var i = 0; i &lt; 5; i++) &#123; arr[i] = function () &#123; return i; &#125;;&#125;for (var index = 0; index &lt; arr.length; index++) &#123; console.log(arr[index]());&#125; 배열 arr에 5개의 함수가 할당되고 각각의 함수는 순차적으로 0, 1, 2, 3, 4를 반환할 것으로 기대하겠지만 결과는 그렇지않다. 이유는 변수 i는 외부함수의 변수가 아닌 전역 변수이기 때문이다. 바르게 동작하는 코드는 아래와 같다. 12345678910111213var arr = [];for (var i = 0; i &lt; 5; i++)&#123; arr[i] = (function (id) &#123; // ② return function () &#123; return id; // ③ &#125;; &#125;)(i); // ①&#125;for (var index = 0; index &lt; arr.length; index++) &#123; console.log(arr[index]());&#125; ① 배열 arr에는 즉시실행함수에 의해 함수가 반환된다. ② 이때 즉시실행함수는 i를 인자로 전달받고 매개변수 id에 할당한 후 내부 함수를 반환하고 life-cycle이 종료된다. 매개변수 id는 자유변수가 된다. ③ 배열 arr에 할당된 함수는 id를 반환한다. 이때 id는 상위 스코프의 자유변수이므로 그 값이 유지된다. 위 예제는 자바스크립트의 함수 레벨 스코프 특성으로 인해 for 루프의 초기문에서 사용된 변수의 스코프가 전역이 되기 때문에 발생하는 현상이다. ES6의 let 키워드를 사용하면 이와 같은 문제는 말끔히 해결된다. 1234567891011const arr = [];for (let i = 0; i &lt; 5; i++) &#123; arr[i] = function () &#123; return i; &#125;;&#125;for (let i = 0; i &lt; arr.length; i++) &#123; console.log(arr[i]());&#125; Reference Poiema WebMDNblog","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://huusz.github.io/categories/Javascript/"}],"tags":[{"name":"closure","slug":"closure","permalink":"http://huusz.github.io/tags/closure/"}]},{"title":"[SASS] Extensions","slug":"SCSS/SASS-Extensions","date":"2017-08-07T05:03:41.000Z","updated":"2017-08-28T14:12:48.000Z","comments":true,"path":"2017/Sass/SCSS/SASS-Extensions/","link":"","permalink":"http://huusz.github.io/2017/Sass/SCSS/SASS-Extensions/","excerpt":"","text":"Extensions1. NestingSass의 유용한 확장 기능으로 중첩(Nesting)이 있다. CSS는 후손 셀렉터의 경우 부모요소를 기술하여야 한다. 12345678910111213141516#navbar &#123; width: 80%; height: 23px;&#125;#navbar ul &#123; list-style-type: none;&#125;#navbar li &#123; float: left;&#125;#navbar li a &#123; font-weight: bold;&#125; Sass의 Nesting은 후손 셀렉터를 간단히 기술이 가능하다. 또한 HTML의 구조를 반영한 CSS를 기술할 수 있다. 1234567891011#navbar &#123; width: 80%; height: 23px; ul &#123; list-style-type: none; &#125; li &#123; float: left; a &#123; font-weight: bold; &#125; &#125;&#125; 너무 깊은 Nesting은 가독성을 나쁘게 하고 셀렉터를 복잡하게 만든다. 따라서 Nesting은 3단계 이상 들어가지 않도록 한다. 만약 3단계 이상 들어가야 할 경우에는, 네스팅 하지 않고 차라리 클래스로 꺼내두는게 낫다. 12345678910111213141516171819202122232425// Bad casediv#main &#123; #sidebar &#123; #navbar &#123; width: 80%; height: 23px; aside &#123; div &#123; ul &#123; list-style-type: none; li &#123; float: left; a &#123; font-weight: bold; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 부모요소의 참조가 필요한 경우 &amp;를 사용한다. 예를 들어 :hover 또는 :before 등의 가상 클래스 선택자(Pseudo-Class Selector)를 지정하는 경우 부모요소의 참조가 필요하다. 123456789a.myAnchor &#123; color: blue; &amp;:hover &#123; text-decoration: underline; &#125; &amp;:visited &#123; color: purple; &#125;&#125; Nesting은 프로퍼티에도 사용할 수 있다. 1234567.funky &#123; font: &#123; family: fantasy; size: 30em; weight: bold; &#125;&#125; 위 코드의 컴파일 결과는 아래와 같다. 12345.funky &#123; font-family: fantasy; font-size: 30em; font-weight: bold;&#125; 2. @-Rules and Directives1) @import1개의 CSS파일에 모든 스타일을 기술하는 것은 가독성을 나쁘게 한다. 또한 기능에따라 CSS파일을 분리하면 재사용 및 유지보수 측면에서 유리하다. 따라서 룰을 정하여 파일을 분리하여 개발하는 것은 효과적인 방법이다. Sass는 @import directive를 사용하여 분리된 stylesheet 파일을 import할 수 있다. 기존의 CSS @import보다 편리한 기능을 제공한다. 12345678910@import \"foo.scss\";//확장자는 생략 가능하다.@import \"foo\";//import multiple files@import \"rounded-corners\", \"text-shadow\";$family: unquote(\"Droid+Sans\");@import url(\"https://fonts.googleapis.com/css?family=#&#123;$family&#125;\") 여러개의 파일로 분할하는 것 또는 분할된 파일을 partial이라 하며 partial된 Sass 파일명의 선두에는 underscore(_)를 붙인다. (_reset.scss, _module.scss, _print.scss) 예를 들어 “foo.scss”라는 partial된 Sass 파일이 있고 이 파일을 import 하는 경우 아래와 같이 기술한다. 파일명 선두의 와 확장자는 생략할 수 있다. 1@import &quot;foo&quot;; partial된 Sass 파일명 선두에 붙인 _의 의미는 import는 수행하되 CSS로의 컴파일은 수행하지 말라는 의미를 갖는다. 따라서 partial은 import시에는 CSS파일로 컴파일되지 않기 때문에 최종적으로 CSS로 컴파일을 수행할 Sass 파일에서 import한다. @import는 top-level에서 사용하는 것이 일반적이지만 CSS rule 또는 @media rule 내에 포함시키는 것도 가능하다. 1234//_example.scss.example &#123; color: red;&#125; 123#main &#123; @import \"example\";&#125; 위 코드는 컴파일 결과는 아래와 같다. 123#main .example &#123; color: red;&#125; 2) @extend기존 스타일을 상속하고자 경우 @extend를 사용한다. 123&lt;div class=\"error seriousError\"&gt; Oh no! You've been hacked!&lt;/div&gt; 기존에 선언되어 있는 error class를 사용하면서 일부 rule set에 대해서는 다른 선언이 필요한 경우 자주 사용하는 방법이다. 이러한 경우 사용할 수 있는 방법이 상속이다. 상속되는 rule set을 그대로 상속받아 다른 부분만 별도 선언하면 된다. 12345678910.error &#123; border: 1px #f00;&#125;.seriousError &#123; @extend .error; border-width: 3px; border-color: darkblue;&#125; 위 코드의 컴파일 결과는 아래와 같다. .error과 .seriousError가 공통으로 사용하는 프로퍼티를 묶어 나름 합리적인 룰셋을 생성한다. 123456789.error, .serousError &#123; border: 1px #f00; background-color: blue;&#125;.seriousError &#123; border-width: 3px; border-color: darkblue;&#125; 이제 하나의 클래스만 적용시키면 된다. 123&lt;div calss=\"seriousError\"&gt; Oh no! You've been hacked!&lt;/div&gt; @extend를 @media블록과 같이 사용하는 경우, 제대로 작동하지 않는다. 다시말해 @media 안에서 외부 선택자를 @extend할 수 없다. 12345678910.foo &#123; color: red;&#125;@media print &#123; .bar &#123; //ERROR @extend .foo; &#125;&#125; 컴파일 후 자신의 셀렉터가 어디에 첨부될 것인지 예상하기 어렵고, 예상치 못했던 부작용이 발생할 수 있다. 따라서 @Extend의 사용은 가급적 자제하고 Mixin을 사용하는 것을 추천한다. @extend의 부작용 3) Placeholder SelectorsPlaceholder Selector는 Sass3.2부터 제공되는 기능으로 재이용 가능한 Rule set을 %키워드로 지정하는 @extend 전용 Selector이다. (그러니, extend를 사용하지 않는다면 별로 기억하지 않아도 된다.) Placeholder Selector는 상속만을 위한 rule set으로 자신은 컴파일되지 않는다. 123456789101112131415%input-style &#123; font-size: 14px;&#125;.input-black &#123; @extend %input-style; colr: black;&#125;.input-red &#123; @extend %input-style; color: red;&#125; 컴파일 결과는 아래와 같다. 1234567891011.input-black, .input-red &#123; font-size: 14px;&#125;.input-black &#123; color: black;&#125;.input-red &#123; color: red;&#125; 3. 조건과 반복Sass는 Javascript 같은 프로그래밍 언어와 같이 제어문(Control flow statement)을 사용할 수 있는 기능을 제공한다. 1) if()built-in if()함수는 주어진 조건읊 판단하여 결과를 리턴한다. Javascript의 삼항 연산자와 유사하게 동작한다. 1if(condition, if_true, if_false) condition이 true이면 if_true를, false이면 if_false를 반환한다. 12345$type: ocean;p &#123; color: if($type == ocean, blue, black); // color: blue;&#125; 2) @if@if를 사용하면 조건분기가 가능하다. 12345678910111213$type: monster;p &#123; @if $type == ocean &#123; color: blue; &#125; @else if $type == matador &#123; color: red; &#125; @else if $type == monster &#123; color: green; &#125; @else &#123; color: black; &#125;&#125; 컴파일 결과는 아래와 같다. 123p &#123; color: green;&#125; 3) @for@for으로 반복문을 사용할 수 있다. 123@for $i from 1 though 3 &#123; .item-#&#123;$1&#125; &#123; width: 2em * $i; &#125;&#125; 컴파일 결과는 아래와 같다. 123456789.item-1 &#123; width: 2em;&#125;.item-2 &#123; width: 4em;&#125;.item-3 &#123; width: 6em;&#125; 4) @each@each와 list 또는 map의 요소에 대해 반복을 실시한다. 1234567891011121314151617//List@each $animal in puma, sea-slug, egret, salamander &#123; .#&#123;$animal&#125;-icon &#123; background-image: url('/image/#&#123;$animal&#125;.png'); &#125;&#125;// Map// $header; h1, $size: 2em// $header; h2, $size: 1.5em// $header; h3, $size: 1.2em@each $header, $size in (h1: 2em, h2: 1.5em, h3: 1.2em) &#123; #&#123;$header&#125; &#123; font-size: $size; &#125;&#125; 컴파일 결과는 아래와 같다. 1234567891011121314151617181920212223.puma-icon &#123; background-image: url(\"/image/puma.png\");&#125;.sea-slug-icon &#123; background-image: url(\"/images/sea-slug.png\");&#125;.salamander-icon &#123; background-image: url(\"/image/salamander.png\");&#125;h1 &#123; font-size: 2em;&#125;h2 &#123; font-size: 1.5em;&#125;h3 &#123; font-size: 1.2em;&#125; 5) @while@while로 반복문을 사용할 수 있다. 123456789101112131415161718192021$i: 6;@while $i &gt; 0 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125; $i: $i - 2;&#125;컴파일 결과는 아래와 같다.```css.item-6&#123; width: 12em;&#125;.item-4 &#123; width: 8em;&#125;.item-2 &#123; width: 4em;&#125; 4. MixinMixin은 Sass의 매우 유용한 기능으로 중복 기술을 방직하기 위해 사용 빈도가 높은 마크업을 사전에 정의하여 필요할 때 불러 사용하는 방법이다. @extend와 유사하나 프로그래밍 언어의 함수와 같이 argument를 받을 수 있다. 사용법은 매우 간단하다. @mixin 선언하고 @include로 불러들인다. 12345678910111213//지름이 50px인 원@mixin circle &#123; width: 50px; height: 50px; border-radius: 50%;&#125;//지름이 50px인 원을 위한 mixin을 include한 후, 배경을 추가 지정.box &#123; @include circle; background: #f00;&#125; 컴파일 결과는 아래와 같다. 배경이 red이고 지름이 50px인 원을 표시한다. 123456.box &#123; width: 50px; height: 50px; border-radius: 50%; background: #f00;&#125; @extend와 차이가 없어 보이나 Mixin은 함수처럼 argument를 사용할 수 있다. 1234567891011@mixin circle($size) &#123; width: $size; height: $size; border-radius: 50%;&#125;.box &#123; @include circle(100px); background: #f00;&#125; 컴파일 결과는 아래와 같다. 123456.box&#123; width: 100px; height: 100px; border-radius: 50%; background: #f00;&#125;","categories":[{"name":"Sass","slug":"Sass","permalink":"http://huusz.github.io/categories/Sass/"}],"tags":[{"name":"nesting","slug":"nesting","permalink":"http://huusz.github.io/tags/nesting/"}]},{"title":"[SASS] Sass Script","slug":"SCSS/SASS-SassScript","date":"2017-08-06T07:56:57.000Z","updated":"2017-08-08T14:56:13.000Z","comments":true,"path":"2017/Sass/SCSS/SASS-SassScript/","link":"","permalink":"http://huusz.github.io/2017/Sass/SCSS/SASS-SassScript/","excerpt":"","text":"Sass Script1. Data Type프로퍼티값으로 사용할 수 있는 값에는 각각의 자료형(Data Type)이 존재한다. SassScript가 제공하는 자료형은 7가지가 있다. 숫자형e.g) 1.2, 13, 10px 문자열CSS는 2종류의 문자열을 사용할 수 있다. 따옴표를 사용하는 경우(“Lucida Grande”, ‘http://sass-lang.com’)와 사용하지 않는 경우(bold, sans-serif)가 있다. Sass는 2종류의 문자열 모두를 인식할 수 있으며 컴파일 후의 CSS에는 Sass에서 사용한 문자열이 그대로 출력된다.e.g. “Lucida Grande”, ‘http://sass-lang.com’, sans-serif 컬러e.g. blue, #04a3f9, rgba(255, 0, 0, 0.5) booleane.g. true, false null listmargin과 padding 프로퍼티값 지정에 사용되는 0 auto와 font-family 프로퍼티값 지정에 사용되는 Helvetica, Arial, sans-serif 등은 공백 또는 콤마 구분된 값의 list이다.e.g. 1.5em 1em 0 2em, Helvetica, Arial, sans-serif mapJSON과 유사한 방식으로 map-get 함수를 사용하여 원하는 값은 추출할 수 있다.e.g. (key1: value1, key2: value2) 12345678910111213// map$foundation-palette: ( primary: #E44347, mars: #D7525C, saturn: #E4B884, neptune: #5147D7);.mars &#123; color: map-get($foundation-palette, mars); &#125;// =&gt; .mars &#123; color: #D7525C; &#125; 2. 변수Sass에서는 변수를 사용할 수 있다. 문자열, 숫자, 컬러(#aa443f) 등을 사전에 변수에 저장하고 필요할 때 불러 사용할 수 있다. 변수명은 $로 시작한다. 12345678910111213141516$width: 960px;header &#123; width: $width; margin: 0 auto;&#125;#main &#123; width: $width; margin: 20px auto;&#125;footer &#123; width: $width; margin: 0 auto;&#125; 어떤 것을 변수명으로 설정할지에 대한 설계가 필요하다. 변수명은 대체로 파일의 앞 쪽에 몰아서 선언해둔다. 3. 변수의 스코프123456789101112131415161718192021222324252627$width: 960px; // global variableheader &#123; width: $width; margin: 0 auto;&#125;#main &#123; $color: #333; // local variable width: $width; margin: 20px auto; section &#123; p &#123; color: $color; a:link &#123; color: $color; &#125; &#125; &#125;&#125;footer &#123; width: $width; margin: 0 auto; color: $color;&#125; 위 코드를 컴파일하면 Undefined variable: “$color”라는 에러가 발생한다. 이는 #main에서 선언한 $color는 #main 내에서만 유효한 지역변수이기 때문이다. 코드블럭 내에서 선언한 지역변수를 전역변수화하는 방법은 아래와 같다. 1234#main &#123; $color: #333 !global; // global variable width: $width; ... 4. 연산자(Operation)1) 숫자 연산자 Operator Description + 덧셈 - 뺄셈 * 곱셈 / 나눗셈 % 나머지 == 동등 != 부등 123456789$width: 100px;#foo &#123; width: $width + 10; //110px&#125;#bar &#123; width: $width + 10in; //1060px&#125; 변수 $width의 값 100px에 10 또는 10em과 같이 다른 단위의 값을 연산하여도 에러없이 연산이 수행된다. 이때 연산자의 왼쪽 값을 기준으로 단위가 설정된다. $width에 10em을 더하면 어떻게 될까? 12345$width: 100px;#foo &#123; width: $width + 10em; //NG: 100px + 10em&#125; 컴파일 결과 Incompatible units: ‘em’ and ‘px’.이라는 에러를 출력한다. Scss 연산은 대상을 변환하여 연산할 수 없는 경우, 에러를 출력한다. %,em,rem,vh,vw,vmin,vmax와 같이 상대적인 값을 Sass는 알지 못한다. 상대적인 값의 결과값은 브라우저만이 알 수 있기 때문이다. (sass는 단지 css로 변환하기만 할 뿐, em 등등의 값은 알 수 없다.) 따라서 상대적 값을 갖는 단위의 연산은 동일한 단위를 갖는 값과의 연산만이 유효하다. %는 부모를 기준으로, rem은 html을 기준으로 (기본적으로 16px), vw는 뷰포트를 기준으로, 1vw = viewport를 기준으로 1/100. CSS3의 calc함수(IE9 이상에서만 사용할 수 있다.)는 이런 문제를 해결할 수 있다. (calc는 브라우저에서 수행하기 때문에 상대값과 절댓값 사이 계산이 가능한 것이다.) 123#foo &#123; width: calc(25% - 5px);&#125; CSS에서의 /는 나눗셈이 아니라 값을 분리하는 의미를 갖는다. 따라서 Sass의 / 연산자를 사용하기 위해서는 몇가지 조건이 필요하다. 이외의 조건에서는 나눗셈을 하지 않는다. 변수에 대해 사용 괄호 내에서 사용 다른 연산의 일부로서 사용 1234567891011p &#123; // font와 border-radius의 '/'는 CSS문법에 맞는 표현이므로 연산되지 않는다. font: italic bold 12px/30px Georgia, serif; // 타원형 둥근 모서리 border-radius: 10px 20px / 20px; $width: 1000px; width: $width / 2; // 변수에 대해 사용 → width: 500px; height: (500px / 2); // 괄호 내에서 사용 → height: 250px; margin-left: 5px + 8px / 2px; // 다른 연산의 일부로서 사용 → margin-left: 9px;&#125; 변수를 CSS의 /와 함께 사용하고자 하는 경우 #{}(Interpolation)를 사용한다.#{}를 사용하면 변수를 문자열로 인식하게 한다. 따라서 연산을 하지 않는다. 12345p&#123; $font-size: 12px; $line-height: 30px; font: #&#123;$font-size&#125; / #&#123;$line-height&#125;; // 12px/30px&#125; #{}를 좌항에만 사용해주어도 같은 효과가 난다. (좌항을 기준으로 하며, 둘 다 변수일 때만 연산을 하기 때문이다.)하지만 양 쪽 모두 #{}를 사용해주는 것이 더 좋다. 2) 컬러 연산자컬러 값에도 모든 산술 연산자를 적용할 수 있다. 컬러 값은 R은 R끼리, G는 G끼리, B는 B끼리 연산한다.(#RRBBGG 표기법의 숫자는 16진수로 표기한다. 16진수에서는 10부터 A로 시작하는 알파벳이다. 05 + 05 = A) 123456789101112131415161718192021222324p &#123; color: #010203 + #040506; // R: 01 + 04 = 05 // G: 02 + 05 = 07 // B: 03 + 06 = 09 // =&gt; #050709&#125;p &#123; color: #010203 * 2; // R: 01 * 2 = 02 // G: 02 * 2 = 04 // B: x03 * 2 = 06 // =&gt; #020406&#125;p &#123; color: rgba(255, 0, 0, 0.75) + rgba(0, 255, 0, 0.75); /* alpha 값은 연산되지 않는다 / color: rgba(255, 255, 0, 0.75); / alpha 값이 서로 다르면, e.g. rgba(0, 0, 0, 0.7) + rgba(100, 120, 255, 0.5); 이 경우 error가 발생한다. */&#125; alpha값은 연산되지 않는다. 서로 다른 alpha값을 연산하려 하는 경우 error가 발생한다. 서로 같은 alpha값을 연산하려 하는 경우, error는 발생하지 않지만 연산을 하지 않고 값을 그대로 반환한다. 위 예제에서도 연산 결과로 0.75를 그대로 반환하였다. alpha 값을 연산하려면 opacify 함수 또는 transparentize 함수를 사용해야 한다. opacify(불투명화) 함수: + 연산, 첫번째 argument의 alpha값에 두번째 argument를 더해 불투명도를 증가시킨다. transparentize(투명화) 함수: - 연산, 첫번째 argument의 alpha값에 두번째 argument의 alpha값을 빼서 불투명도를 감소시킨다. 1234567$translucent-red: rgba(255, 0, 0, 0.5);p &#123; color: opacify($translucent-red, 0.3); // =&gt; color: rgba(255, 0, 0, 0.8) background-color: transparentize($translucent-red, 0.25); // =&gt; color: rgba(255, 0, 0, 0.25);&#125; 3) 문자열 연산자+ 연산자는 자바스크립트와 같이 문자열을 연결할 수 있다. 123p &#123; cursor: e + -resize; // e-resize&#125; 따옴표가 있는 문자열과 없는 문자열을 함께 사용하는 경우, 좌향의 문자열을 기준으로 따옴표를 처리한다. 하이픈(-) 기호가 사용될 경우, 하이픈 기호를 포함해서 붙인다. 12345678910111213141516p:before &#123; content: \"Foo \" + Bar; //Foo Bar font-family: sans- + \"serif\"; //sans-serif;&#125;.btn &#123; cursor: p + inter; font-family: sans- + 'serif'; &amp;:after &#123; content: \"Hello \" + world; &#125; $value: 100; &amp;:before &#123; content: \"I'm #&#123;$value&#125; years old!\"; &#125;&#125; 12345678910111213/* compiled */p:before&#123; content: \"Foo Bar\"; font-family: sans-serif;&#125;.btn &#123; cursor: pinter; font-family: sans-serif;&#125;.btn:after &#123; content: \"Hello world\"; &#125;.btn:before &#123; content: \"I'm 100 years old!\"; &#125; 4) boolean 연산자 &amp;&amp; (and) || (or) ! (not) 5) list 연산자리스트를 위한 별도의 연산자는 제공되지 않지만, 리스트 함수를 사용하여 필요한 처리를 수행할 수 있다. 5. 함수(Function)Built-in Function 6. Interpolation: #{}인터폴레이션은 변수의 값을 문자열 그대로 삽입한다. 인터폴레이션에 의해 삽입된 문자열은 연산 대상으로 취급되지 않는다. 변수는 프로퍼티값으로만 사용할 수 있으나 #{}을 사용하면 셀렉터와 프로퍼티명에도 사용할 수 있다. 123456789101112131415$name: foo;$attr: border;p.#&#123;$name&#125; &#123; //p.foo #&#123;$attr&#125;-color: blue; //border-color: blue;&#125;.someclass &#123; $font-size: 12px; $line-height: 30px; //연산의 대상으로 취급되지 않게 한다. font: #&#123;$font-size&#125; / #&#123;$line-height&#125;; // 12px / 30px&#125; 7. Ampersand(&amp;)&amp;는 부모요소를 참조하는 셀렉터이다.&amp;는 Sass와 Less에서 아주 유용한 기능으로 주로 중첩(nesting)시에 사용된다. 사용법만 알면, css로 동일한 코드를 작성할 때보다 훨씬 많은 시간을 절약할 수 있다. Nesting1234//scss.parent &#123; .child &#123;&#125;&#125; 12/* compiles to css */.parent .child &#123;&#125; 원하는 만큼 깊게 중첩시킬 수 있지만 지나치게 특수한 셀렉터(덜 유용하고 재정의하기 어려운)가 되는 것을 막기 위해 1 ~ 2단계의 중첩만 유지하는 게 좋다. Adding another class&amp;는 이러한 중첩(네스팅, nesting)에 편리하다. 다음과 같이 둘 이상의 클래스를 사용해서 특수한(구체적인) 선택자(selector)를 만들고자 할 때 특히 그렇다. 12/* css */.some-class.anoter-class &#123;&#125; 위와 같은 css코드는 sass로는 아래처럼 작성할 수 있다. 1234//scss.some-class &#123; &amp;.anoter-class&#123;&#125;&#125; &amp;는 네스팅시 항상 상위 선택자를 탐조한다. &amp;를 제거하고 부모 선택자로 대체한 것으로 생각할 수 있다. 위에서 예시로 들었던 코드를 다시 살펴보면, 1234//scss.parent &#123; .child &#123;&#125;&#125; 이 코드는 사실 &amp;로 네스팅하는 것의 short-hand이다. 123456//scss.parent &#123; &amp; .child&#123; &#125;&#125; 따라서 이 두 예시는 모두 아래처럼 동일하게 컴파일된다. 12/* compiles to css */.parent .child &#123;&#125; &amp;는 자식 선택자에 필요할 때마다 부모 선택자를 배치할 수 있게 하는 매커니즘 정도로 생각할 수 있다. 그러면 &amp;를 어떻게 더 다양하게 활용할 수 있을지 예제를 통해 알아보자. Using the &amp; with pseudo classes&amp;를 이용하면 가상클래스(pseudo class)를 작성할 때 코드의 반복을 현저하게 줄일 수 있다. 12345.button &#123; &amp;:visited &#123;&#125; &amp;:hover &#123;&#125; &amp;:active&#123;&#125;&#125; 1234/*compiles to css*/.button:visited &#123;&#125;.buttom:hover &#123;&#125;.button:active &#123;&#125; 이 경우 &amp;를 사용함으로써 .button을 반복적으로 작성하지 않고도 가상클래스 바로 옆에 .button를 배치할 수 있다. 만약 이때 &amp;를 생략하면, 기본 중첩(nesting)은 다음과 같이 둘 사이에 공백을 넣는다. 123456//scss.button &#123; :visited &#123;&#125; :hover &#123;&#125; :active &#123;&#125;&#125; 12/*css*/.button :hover 주의하자. 공백이 있는 것과 없는 것은 절대 같지 않다. Using the &amp; with &gt;, +, and ~&amp;를 부모-자식 관계를 나타내는 combinator인 &gt;, 인접 형제 관계임을 나타내는 combinator인 +, 그리고 일반적인 형제 관계임을 나타내는 combinator인 ~와 함께 사용하면 아주 용이하다. 코드를 작성할 때, &amp;를 함께 작성해야한다 생각하겠지만, 사실 그렇지 않다. 12345.button &#123; &amp; &gt; span &#123;&#125; &amp; + span &#123;&#125; &amp; ~ span &#123;&#125;&#125; 선택자에서 &amp;를 떼어내서 아래처럼 작성할 수도 있는데, 두 코드는 동일하게 컴파일 된다. 123456// 이렇게 작성해도 똑같다..button &#123; &gt; span &#123;&#125; + span &#123;&#125; ~ span &#123;&#125; &#125; 1234/*compiles to css*/.button &gt; span &#123;&#125;.button + span &#123;&#125;.button ~ span&#123;&#125; Qualifying based on context네스팅된 셀렉터에 &amp;가 반드시 앞에 붙을 필요는 없다. 끝에 &amp;를 붙이면 선택자를 한정할 수 있다. 1234//scss.button &#123; body.page-about &amp; &#123;&#125;&#125; &amp; 자리는 본래 부모 선택자의 자리이다. 만약 필요한 부모 선택자가 있다면 그 자리에 부모 선택자를 기재한다. &amp;는 마지막에 붙인다. 이 방식은 다른 부모를 기반으로 셀렉터를 한정하는데 아주 유용하다. 이 코드는 아래와 같이 컴파일 된다. 1body.page-about .button&#123;&#125; 해석해보자면, page-about이 body클래스의 자식클래스로 있을 때에만 (다르게 말하면, 다른 클래스의 자식클래스로 있을 때는 적용하지 않는다.) button 클래스에 {내용}의 css를 정의한다 그 외 더 많은 예시 8. !default!default flag는 할당되지 않은 변수의 초기값을 설정한다. 123456$content: null; //값이 할당되지 않았다.$content: \"Non-null content\" !default;#main &#123; content: $content; //\"Non-null content\"&#125; 이미 값이 할당되어 있는 변수에 !default flag를 사용하면 적용되지 않는다. 12345678$content: \"First content\";$content: \"Second content?\" !default;$new_content: \"First time reference\" !default;#main &#123; content: $content; //\"First content\" new_content: $new_content; //\"First time reference\"&#125; 이러한 특성은 partial에 매우 유용하다.2개의 font.scss와 main.scss파일을 생성해보자. 12345678//font.scss$font-size: 16px !default;$line-height: 1.5 !default;$font-family: \"Helvetica Neue\", \"Helverica\", \"Arial\", sans-serif !default;body &#123; font: #&#123;$font-size&#125;/$line-height $font-family;&#125; main.scss는 내부에서 font.scss를 import한다. 1234//main.scss$font-family: \"Lucida Grande\", \"Lucida Sans Unicode\", sans-serif;@import \"font\"; 위 코드의 컴파일 결과는 아래와 같다. 123body &#123; font: 16px/1.5 \"Lucida Grande\", \"Lucida Sans Unicode\", sans-serif;&#125; !default는 변수에 값이 할당되지 않았을 때 사용할 기본 값을 지정할 때 사용한다. 위 예제의 경우 main.scss에서 변수에 값을 할당하였기 때문에 !default와 같이 사용한 변수값은 무력화된다. 만일 font.scss의 $font-family 변수에 !default설정이 없었다면 후위에 선언된 font.scss의 $font-family 변수값이 적용되어 아래와 같은 결과가 생성되었을 것이다. 123body &#123; font: 16px/1.5 \"Helvetica Neue\", \"Helvetica\", \"Arial\", sans-serif;&#125;","categories":[{"name":"Sass","slug":"Sass","permalink":"http://huusz.github.io/categories/Sass/"}],"tags":[{"name":"sass syntax","slug":"sass-syntax","permalink":"http://huusz.github.io/tags/sass-syntax/"}]},{"title":"[JS] 프로토타입 Prototype","slug":"Javascript/Javascript-Prototype","date":"2017-08-06T01:53:50.000Z","updated":"2017-08-28T14:13:25.000Z","comments":true,"path":"2017/Javascript/Javascript/Javascript-Prototype/","link":"","permalink":"http://huusz.github.io/2017/Javascript/Javascript/Javascript-Prototype/","excerpt":"","text":"Prototype 프로토타입과 객체지향객체(Object)자바스크립트에서는 객체를 만드는 방법으로 객체리터럴 방식과 생성자(Object() 함수, 일반 생성자 함수)를 이용한 방식이 있다. 12var objectMadeByLiteral = &#123;&#125;;var objectMadeByConstructor = new Object(); 리터럴은 Object 타입의 객체를 만들어내는 일종의 숏컷이고 두 번째 라인의 생성자를 이용한 코드 역시 Object 생성자이기 때문에 사실 위 예제는 구조면에서 동일한 객체를 만든다. 둘 다 Object타입을 갖는 객체로 Object타입의 메서드들을 사용할 수 있다. Object타입은 모든 객체의 최상위 타입이다. 사실 다른 객체지향언어의 관점에서 보면 위 코드는 Object객체의 인스턴스를 만든 것에 불과하니 상속받았다고 표현하기 어렵다. 하지만 자바스크립트에서는 조금 다른 개념으로 생각해야 한다. 지금 만들어진 객체가 Object 타입의 인스턴스 객체인 것도 맞지만 프로토 타입을 이용한 상속받은 객체라고 표현하는게 더 정확한 표현이다. 사실 상속이라는 표현도 OOP의 관점에서 사용하는 단어로 표현하고자 한 것일 뿐 실제로는 링크드 리스트 형태의 창조를 통한 객체끼리의 연결에 가깝고 클래스 매커니즘처럼 정적이지 않고 매우 동적이다. 1. 프로토타입 객체자바스크립트의 모든 객체는 부모가 존재한다. 그런데 객체가 생성자 함수를 통해 생성되었다고 하여 객체의 부모가 생성자함수인 것은 아니다. 모든 객체의 부모는 prototype 객체이다. 함수도 객체이다. 다만 함수 객체는 일반 객체와 달리 prototype이라는 프로퍼티를 특별히 가지고 있다. 생성자 함수는 함수 객체이다. 따라서 prototype 프로퍼티가 존재한다. 생성자 함수의 prototype 프로퍼티는 생성자 함수가 생산한 객체의 부모가 되는 prototype 객체를 가리킨다. 프로토타입은 자바의 객체지향의 상속 개념과 유사하다. 자바스크립트는 프로토타입 기반 객체지향언어이며 자바는 클래스 기반 객체지향언어이다. 따라서 둘은 같지 않다. 자바스크립트의 모든 객체는 자신의 부모 역할을 담당하는 객체와 연결되어 있다. 그리고 이것은 마치 객체 지향의 상속 개념과 같이 부모 객체의 프로퍼티 또는 메소드를 상속받아 사용할 수 있게 한다. 이러한 부모 객체를 Prototype(프로토타입) 객체 또는 줄여서 프로토타입이라 한다. 프로토타입을 이용하면 객체와 객체를 연결하고 한쪽 방향으로 상속을 받는 형태를 만들 수가 있다. 자바스크립트에서 객체와 객체를 연결해서 상속 받는다는 것은 다른 말로 객체와 객체를 연결해 멤버 함수나 멤버 변수를 공유 한다는 뜻이다. 이런 점을 이용해 자바스크립트에서는 상속과 비슷한 효과를 얻는 것이다. 123456789var student = &#123; name: 'Lee', score: 90&#125;;// student에는 hasOwnProperty 메서드가 없지만 아래 구문은 동작한다.console.log(student.hasOwnProperty('name')); // trueconsole.dir(student); 객체를 생성할 때 프로토타입은 결정된다. 결정된 프로토타입 객체는 다른 임의의 객체로 변경할 수 있다. 이것은 부모 객체인 프로토타입을 동적으로 변경할 수 있다는 것을 의미한다. 이러한 특징을 활용하여 객체의 상속을 구현할 수 있다. 2. [[Prototype]] 프로퍼티 VS prototype 프로퍼티[함수 객체와 일반 객체의 차이] 함수 객체는 prototype 프로퍼티를 가지고 있다.(prototype 프로퍼티는 prototype Object를 가리키고 있다.) 함수 객체는 호출될 수 있다. 자바스크립트 엔진은 객체를 일종의 키와 값을 가진 해쉬맵처럼 다룬다. 값에는 데이터나 함수가 들어갈 수 있으며 엔진 내부에 필요한 데이터를 임의로 만들어 넣기도 한다. 물론 그게 자바스크립트 단으로 노출이 될 수도, 안될 수도 있다. 프로토타입 체인의 핵심은 엔진이 사용하는 __proto__라는 속성이다. __proto__ 속성은 ECMAScript의 스펙 [[prototype]] 이 자바스크립트로 노출된 것인데 예전 스펙이 legacy처럼 남아있는 것이다. 모던 브라우저 개발자 도구에서도 디버깅 편의상 노출하고 있으나 코드에서 직접 접근하는 것은 피해야 한다. 클래스를 통한 상속의 경우 클래스 상속 정보를 이용해 상속 구조의 모습을 가진 새로운 객체를 찍어내는 반면 프로토타입을 통한 상속구조는 존재하는 객체와 객체의 동적인 연결로 풀어낸다. 그렇다보니 이미 객체가 만들어진 상태라도 상속된 내용의 변경/추가/삭제가 가능하며 아예 상속 구조를 바꿀 수도 있게 된다. 이렇게 객체와 객체의 연결을 통한 단방향 공유 관계를 프로토타입 체인이라고 한다. 3. constructor 프로퍼티프로토타입 객체는 constructor 프로퍼티를 갖는다. 이 constructor 프로퍼티는 객체의 입장에서 자신을 생성한 객체를 가리킨다. Person() 생성자 함수에 의해 생성된 객체를 생성한 객체는 Person() 생성자 함수이다. 따라서 prototype 객체의 constructor 프로퍼티는 객체를 생성하는 생성자 함수 객체를 가리킨다. 1234567891011121314function Person(name) &#123; this.name = name;&#125;var foo = new Person('Lee');// Person() 생성자 함수에 의해 생성된 객체를 생성한 객체는 Person() 생성자 함수이다.console.log(Person.prototype.constructor === Person);// foo 객체를 생성한 객체는 Person() 생성자 함수이다.console.log(foo.constructor === Person);// Person() 생성자 함수를 생성한 객체는 Function() 생성자 함수이다.console.log(Person.constructor === Function); 4. Prototype chain자바스크립트는 특정 객체의 프로퍼티나 메소드에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티 또는 메소드가 없다면 [[Prototype]] 프로퍼티가 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티나 메소드를 차례대로 검색한다. 이것을 프로토타입 체인이라 한다. 1234567var student = &#123; name: 'Lee', score: 90&#125;// Object.prototype.hasOwnProperty()console.log(student.hasOwnProperty('name')); // true 1) 객체 리터럴 방식으로 생성된 객체의 프로토타입 체인객체 생성 방법은 3가지가 있다. 객체 리터럴 생성자 함수 Object() 생성자 함수 객체 리터럴 방식으로 생성된 객체는 결국 내장 함수(Built-in)인 Object() 생성자 함수로 객체를 생성하는 것을 단순화시킨 것이다. 자바스크립트 엔진은 객체 리터럴로 객체를 생성하는 코드를 만나면 내부적으로 Object() 생성자 함수를 사용하여 객체를 생성한다. Object() 생성자 함수는 물론 함수이다. 따라서 함수 객체인 Object() 생성자 함수는 일반 객체와 달리 prototype 프로퍼티가 있다. prototype 프로퍼티는 함수 객체가 생성자로 사용될 때 이 함수를 통해 생성된 객체의 부모 역할을 하는 객체를 가리킨다. [[Prototype]] 프로퍼티는 객체의 입장에서 자신의 부모 역할을 하는 프로토타입 객체을 가리킨다. 1234567891011121314var person = &#123; name: 'Lee', gender: 'male', sayHello: function()&#123; console.log('Hi! my name is ' + this.name); &#125;&#125;;console.dir(person);console.log(person.__proto__ === Object.prototype); // ① trueconsole.log(Object.prototype.constructor === Object); // ② trueconsole.log(Object.__proto__ === Function.prototype); // ③ trueconsole.log(Function.prototype.__proto__ === Object.prototype); // ④ true 결론적으로 객체 리터럴을 사용하여 객체를 생성한 경우, 그 객체의 프로토타입 객체는 Object.prototype이다. 2) 생성자 함수로 생성된 객체의 프로토타입 체인생성자 함수로 객체를 생성하기 위해서는 우선 생성자 함수를 정의하여야 한다. 함수를 정의하는 방식은 3가지가 있다. 함수선언식(Function declaration) 함수표현식(Function expression) Function() 생성자 함수 함수표현식으로 함수를 정의할 때 함수 리터럴 방식을 사용한다. 3가지 함수 정의 방식은 결국 Function() 생성자 함수를 통해 함수 객체를 생성한다, 따라서 어떠한 방식으로 함수 객체를 생성하여도 모든 함수 객체의 prototype 객체는 Function.prototype이다. 생성자 함수도 함수 객체이므로 생성자 함수의 prototype 객체는 Function.prototype이다. 이제 객체의 관점에서 prototype 객체를 살펴보자. 객체를 생성하는 방식은 3가지가 있다. 3가지 객체 생성 방식에 의해 생성된 객체의 prototype 객체를 정리해 보면 아래와 같다. 123456789101112131415161718192021function Person(name, gender) &#123; this.name = name; this.gender = gender; &lt;!-- this.sayHello = function()&#123; console.log('Hi! my name is ' + this.name); --&gt; &#125;;&#125;Person.prototype = function sayHello()&#123; console.log('Hi! my name is ' + this.name);var foo = new Person('Lee', 'male');console.dir(Person);console.dir(foo);console.log(foo.__proto__ === Person.prototype); // ① trueconsole.log(Person.prototype.__proto__ === Object.prototype); // ② trueconsole.log(Person.prototype.constructor === Person); // ③ trueconsole.log(Person.__proto__ === Function.prototype); // ④ trueconsole.log(Function.prototype.__proto__ === Object.prototype); // ⑤ true foo 객체의 프로토타입 객체 Person.prototype 객체와 Person() 생성자 함수의 프로토타입 객체인 Function.prototype의 프로토타입 객체는 Object.prototype 객체이다. 이는 객체 리터럴 방식이나 생성자 함수 방식이나 결국은 모든 객체의 부모 객체인 Object.prototype 객체에서 프로토타입 체인이 끝나기 때문이다. 이때 Object.prototype 객체를 프로토타입 체인의 종점(End of prototype chain)이라 한다. 5. 프로토타입 객체의 확장프로토타입 객체도 객체이므로 일반 객체와 같이 프로퍼티를 추가/삭제할 수 있다. 그리고 이렇게 추가/삭제된 프로퍼티는 즉시 프로토타입 체인에 반영된다. 1234567891011function Person(name) &#123; this.name = name;&#125;var foo = new Person('Lee');Person.prototype.sayHello = function()&#123; console.log('Hi! my name is ' + this.name);&#125;;foo.sayHello(); 생성자 함수 Person은 prototype 프로퍼티에 연결된 프로토타입 객체 Person.prototype를 갖는다. Person.prototype 객체는 일반 객체와 같이 프로퍼티를 추가/삭제가 가능하다. 위의 예에서는 Person.prototype 객체에 메소드 sayHello를 추가하였다. 이때 sayHello 메소드는 프로토타입 체인에 반영된다. 따라서 생성자 함수 Person에 의해 생성된 모든 객체는 프로토타입 체인에 의해 부모객체인 Person.prototype의 메소드를 사용할 수 있게 되었다. 6. 기본자료형(Primitive data type)의 확장자바스크립트에서 기본자료형(숫자, 문자열, boolean, null, undefined)을 제외한 모든것은 객체이다. 그런데 아래 예제를 살펴보면 기본자료형인 문자열이 흡사 객체와 같이 동작한다. 12345678910111213var str = 'test'; //리터럴 방식으로 객체 선언console.log(typeof str); // stringconsole.log(str.constructor === String); // trueconsole.dir(str);var strObj = new String('test');//객체인 문자열을 생성한다.console.log(typeof strObj); // objectconsole.log(strObj.constructor === String); // trueconsole.dir(strObj);console.log(str.toUpperCase()); // TESTconsole.log(strObj.toUpperCase()); // TEST 기본자료형과 객체의 차이:기본자료형은 상속, 프로퍼티, 메서드 개념이 없다. 그저 데이터(값)그 자체이다. 12345678var str = 'test';// 에러가 발생하지 않는다.str.myMethod = function () &#123; console.log('str.myMethod');&#125;;str.myMethod(); // Uncaught TypeError: str.myMethod is not a function String은 래퍼객체이다. 문자열을 String의 객체로 선언하면 String 객체 내부의 메소드를 사용할 수 있다. 그런데 모든 문자열을 다룰 때, 항상 객체로 다시 선언해주기에는 큰 번거로움이 따른다. 따라서 문자열 기본자료형에 .을 붙이면 자동으로 자바스크립트 엔진이 래퍼 객체를 통해 일시적으로 문자열 객체로 변환해준다. 따라서 리터럴 방식으로 선언한 기본자료형 문자열도 String객체의 메소드를 사용할 수 있게 된다. 123456789var str = 'test';String.prototype.myMethod = function () &#123; return 'myMethod';&#125;;console.log(str.myMethod()); // myMethodconsole.log('string'.myMethod()); // myMethodconsole.dir(String.prototype); 기본자료형 문자열과 String() 생성자 함수로 생성한 문자열 객체의 타입은 분명이 다르다. 기본 자료형은 객체가 아니므로 프로퍼티나 메소드를 가질수 없다. 하지만 기본자료형으로 프로퍼티나 메소드를 호출할 때 기본자료형과 연관된 객체로 일시적으로 변환되어 프로토타입 객체를 공유하게 된다. 기본자료형은 객체가 아니므로 .을 통해 바로 프로퍼티나 메소드를 직접 추가할 수 없다. 기본자료형은 오직 참조만 할 수 있다. 만약 기본자료형으로 메소드를 추가하고자 한다면, String 객체의 프로토타입 객체 String.prototype에 메소드를 추가하는 방법이 있다. 하지만 이는 위험 부담이 따른다. 앞선 방법으로 메소드를 추가하는 것은 Built-in 객체인 String 객체의 메소드들(표준)과 섞이거나 변수명의 중복으로 인해 기존 메소드가 지워지는 문제가 있을 수 있기 때문에 좋은 방식은 아니다. 이처럼 표준 이외의 메소드를 추가하는 것이 일종의 라이브러리인데, 라이브러리를 만들고자 할 때는 차라리 커스텀 객체를 따로 생성하는 것이 좋다. 앞서 살펴본 바와 같이 모든 객체는 프로토타입 체인에 의해 Object.prototype 객체의 메소드를 사용할 수 있었다. Object.prototype 객체는 프로토타입 체인의 종점으로 모든 객체가 사용할 수 있는 메소드를 갖는다. 이후 살펴보게 될 Built-in object(내장 객체)의 Global objects (Standard Built-in Objects)인 String, Number, Array 객체 등이 가지고 있는 표준 메소드는 프로토타입 객체인 String.prototype, Number.prototype, Array.prototype 등에 정의되어 있다. 이들 프로토타입 객체 또한 Object.prototype를 프로토타입 체인에 의해 자신의 프로토타입 객체로 연결한다. 자바스크립트는 표준 내장 객체의 프로토타입 객체에 개발자가 정의한 메소드의 추가를 허용한다. 1234567891011121314var str = 'test';String.prototype.myMethod = function() &#123; return 'myMethod';&#125;console.log(str.myMethod());console.dir(String.prototype);console.log(str.__proto__ === String.prototype); // ① trueconsole.log(String.prototype.__proto__ === Object.prototype); // ② trueconsole.log(String.prototype.constructor === String); // ③ trueconsole.log(String.__proto__ === Function.prototype); // ④ trueconsole.log(Function.prototype.__proto__ === Object.prototype); // ⑤ true 7. 프로토타입 객체의 변경객체를 생성할 때 프로토타입은 결정된다. 결정된 프로토타입 객체는 다른 임의의 객체로 변경할 수 있다. 이것은 부모 객체인 프로토타입을 동적으로 변경할 수 있다는 것을 의미한다. 이러한 특징을 활용하여 객체의 상속을 구현할 수 있다. 이때 주의할 것은 프로토타입 객체를 변경하면 프로토타입 객체 변경 시점 이전에 생성된 객체기존 프로토타입 객체를 [[Prototype]] 프로퍼티에 바인딩한다.프로토타입 객체 변경 시점 이후에 생성된 객체변경된 프로토타입 객체를 [[Prototype]] 프로퍼티에 바인딩한다. 12345678910111213141516function Person(name) &#123; this.name = name;&#125;var foo = new Person('Lee');// 프로토타입 객체의 변경Person.prototype = &#123; gender: 'male' &#125;;var bar = new Person('Kim');console.log(foo.gender); // undefinedconsole.log(bar.gender); // 'male'console.log(foo.constructor); // ① Person(name)console.log(bar.constructor); // ② Object() ① constructor 프로퍼티는 Person() 생성자 함수를 가리킨다. ② 프로토타입 객체 변경 후, Person() 생성자 함수의 Prototype 프로퍼티가 가리키는 프로토타입 객체를 일반 객체로 변경하면서 Person.prototype.constructor 프로퍼티도 삭제되었다. 따라서 프로토타입 체인에 의해 bar.constructor의 값은 프로토타입 체이닝에 의해 Object.prototype.constructor 즉 Object() 생성자 함수가 된다. 위 예제의 상속 방식은 물론 가능한 방식이지만, 문제점이 많기 때문에 사용하지 않는 방식이다. 8. 프로토타입 체인 동작기본적인 프로토타입 체인은 참조할 때 동작한다. 프로퍼티 동적 추가에서 객체에 프로퍼티가 존재하지 않으면 프로퍼티를 추가한다. 객체의 프로퍼티에 값을 할당하는 경우, 프로토타입 체인이 동작하지 않는다. 이는 객체에 해당 프로퍼티가 있는 경우, 값을 재할당하고 해당 프로퍼티가 없는 경우는 해당 객체에 프로퍼티를 동적으로 추가하기 때문이다. 123456789101112131415161718function Person(name) &#123; this.name = name;&#125;Person.prototype.gender = 'male'; // ①var foo = new Person('Lee');var bar = new Person('Kim');console.log(foo.gender); // ① 'male'console.log(bar.gender); // ① 'male'// 1. foo 객체에 gender 프로퍼티가 없으면 프로퍼티 동적 추가// 2. foo 객체에 gender 프로퍼티가 있으면 해당 프로퍼티에 값 할당foo.gender = 'female'; // ②console.log(foo.gender); // ② 'female'console.log(bar.gender); // ① 'male' 프로토 타입 체이닝은 참조할 때 위로 올라가는 것이다. 프로퍼티를 추가할 때는 자기 자신에게 추가한다. Reference Poiemaweb (서적)자바스크립트 닌자 비급, 인사이트, 2014 (서적) 인사이드 자바스크립트, 한빛, 2016","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://huusz.github.io/categories/Javascript/"}],"tags":[{"name":"prototype","slug":"prototype","permalink":"http://huusz.github.io/tags/prototype/"}]},{"title":"[JS] 객체 Object","slug":"Javascript/Javascript-Object","date":"2017-08-05T11:16:16.000Z","updated":"2017-08-28T14:13:20.000Z","comments":true,"path":"2017/Javascript/Javascript/Javascript-Object/","link":"","permalink":"http://huusz.github.io/2017/Javascript/Javascript/Javascript-Object/","excerpt":"","text":"Object1. 객체(Object)란?자바스크립트는 객체(Object)기반의 스크립트 언어이며 자바스크립트를 이루고 있는 거의 “모든 것”은 객체이다. 기본 자료형(primitives)을 제외한 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체이다. primitives프리미티브: 객체도 아니고 메소드도 아닌 데이터. string/number/boolean/null/undefined/symbol로 6개의 기본 데이터 타입이 있다.null과 undefined를 제외하고 모든 프리미티브 값은 래퍼 객체를 갖는다. string을 위한 String객체 number를 위한 Number객체 boolean을 위한 Boolean객체 Symbol을 위한 Symbol객체 모두 Bulit-in Object(자바스크립트 내장객체)이다. 객체는 데이터와 데이터 관련 동작을 모두 포함할 수 있는 개념적 존재이다. 이름(키)과 값으로 구성된 데이터를 의미하는 프로퍼티(property)와 동작을 나타내는 메서드(method)를 포함하고 있는 독립적 주체이다. 객체는 흩어져있는 것들을 모은다는 관점에서 매우 유용하다. 객체 하나는 다른 객체를 포함할 수 있기 때문에 그래프나 트리와 같은 자료구조를 쉽게 표현할 수 있다. 1) 프로퍼티(property)객체는 프로퍼티들을 포함하는 컨테이너라고 할 수 있다. 프로퍼티는 객체의 속성을 나타내는 접근 가능한 이름과 활용 가능한 값을 가지는 특별한 형태이다. 프로퍼티는 객체를 활용함에 있어 매우 유용한 존재이다. 특정 객체가 가진 정보에 직접적으로 접근할 수 있게 해주기 때문이다. 프로퍼티 이름 명명 규칙: 빈 문자열을 포함하는 문자열과 숫자 프로퍼티 값: undefined 제외, 모든 값 가능 프로퍼티는 기본적으로 이름과 값으로 구성된다. 프로퍼티에 대한 접근 연산자는 .이다. 이 연산자를 통해 프로퍼티에 접근할 수도 있고 프로퍼티를 추가할 수도 있다. Q. 만약 프로퍼티에 아무런 값도 할당하지 않으면 어떻게 될까?변수는 값을 할당하지 않고 선언만 할 경우 자바스크립트 엔진이 강제로 undefined 를 할당한다. 하지만 프로퍼티는 값이 할당되지 않는다면 존재 이유가 없다. 객체의 정보를 담고 있어야 하는 요소가 아무 정보도 갖지 않는다면 객체로써는 이 프로퍼티가 쓸모가 없기 때문이다. 그렇기 때문에 프로퍼티를 추가하면서 값을 할당하지 않으면 syntax error 가 발생한다. 만약 값을 비워둬야 한다면 빈문자열(&#39;&#39;)을 넣는 것이 바람직하다. 2) 메서드(Method)메서드는 객체에 제한되어 있는 함수를 의미한다. 따라서 메서드 함수의 호출은 객체에 의해서만 가능하다.(=메서드를 호출하는 주체가 해당 함수를 프로퍼티로 가지고 있는 객체이다.) 1)함수를 객체의 프로퍼티로 할당하고, 그 프로퍼티를 사용하여 참조에 의한 호출이 일어나면, 함수는 그 객체의 메서드로 호출된다. 즉 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메서드라 칭한다. 123var foo = &#123;&#125;; //Objectfoo.whatever = function()&#123;&#125;; //method of foo(Object)foo.whatever(); 2. 객체 생성 방법자바에서는 클래스를 사전에 정의하고 필요한 시점에 new 연산자를 사용하여 인스턴스를 생성하는 방식으로 객체를 생성한다. 하지만 자바스크립트는 클래스 개념이 없고 별도의 객체 생성 방법이 존재한다. 1) 객체 리터럴가장 일반적이며 간편한 자바스크립트 객체 생성 방식이다. 중괄호({})를 이용하여 객체를 생성하는데 {} 내에 아무것도 기술하지 않으면 빈 객체가 생성된다. {} 내에 프로퍼티이름: 프로퍼티값 을 기술하면 해당 프로퍼티가 추가된 객체를 생성할 수 있다. 객체 리터럴 방식의 특징은 new 연산자를 사용할 필요없이 선언과 동시에 인스턴스가 생성된다는 것이다. {name:value} 형태의 구성 방식을 JSON(javascript object notation) 방식이라고 한다. 12345678910111213141516var emptyObject = &#123;&#125;;console.log(typeof emptyObject); // objectvar person = &#123; name: 'Lee', gender: 'male', sayHello: function () &#123; console.log('Hi! My name is ' + this.name); &#125;&#125;;console.log(typeof person); // objectconsole.log(person); // &#123; name: 'Lee', gender: 'male', sayHello: [Function: sayHello] &#125;person.sayHello(); // Hi! My name is Lee` 2) Object() 생성자 함수object를 만드는 함수이다. new 연산자를 반드시 함께 사용해야 한다. new 연산자와 함께 사용하여 빈 객체를 생성할 수 있다. 우선 빈 객체를 생성하고, 이후에 프로퍼티와 메서드를 추가하여 객체를 완성하는 방법이다. 객체의 프로퍼티에 새로운 값을 할당하면, 프로퍼티 값은 갱신된다. 객체가 소유하고 있지 않은 프로퍼티에 값을 할당하면, 해당 객체에 프로퍼티 추가하고 값을 할당을 한다. 아래와 같은 방식으로 선언한다.1var obj = new Object(); 123456var person = new Object(); // obj에는 빈 객체가 들어온다.//프로퍼티 추가person.name = 'Lee'; //name 프로퍼티에 'Lee'값을 할당한다.person.gender = 'male';person.sayHello = 'Hello';... 이 방식은 별로 유용하지 않아 보인다.반드시 new 연산자와 Object() 생성자 함수를 사용하여 빈객체를 생성해야 하는 것은 아니다. 객체를 생성하는 방법은 객체 리터럴을 사용하는 것이 더 간편하다. 123456var person = &#123;&#125;;person.name = 'Lee';person.gender = 'male';person.sayHello = function () &#123; console.log('Hi! My name is ' + this.name);&#125;; 위와 같이 객체를 생성할 수도 있기 때문에다. 사실 이렇게 선언해도 자바스크립트 엔진은 Object 생성자를 불러서 객체를 만든다. 그러니 위와 같은 선언 방식은 shorthand인 셈이다. Object() 생성자는 사실 node에서 사용한다. 3) 생성자 함수객체 리터럴 방식과 Object() 생성자 함수 방식으로 객체를 생성하는 것은 프로퍼티 값만 다른 여러개의 객체 생성에 불편이 있다. 동일한 프로퍼티를 갖는 객체임에도 불구하고 매번 같은 프로퍼티를 기술해야한다.따라서, 유사 객체를 다량 생산 해야 할때, 생성자 함수가 매우 유용하게 쓰일 수 있다. 123456789101112131415var person1 = &#123; name: 'Lee', gender: 'male', sayHello: function () &#123; console.log('Hi! My name is ' + this.name); &#125;&#125;;var person2 = &#123; name: 'Kim', gender: 'female', sayHello: function () &#123; console.log('Hi! My name is ' + this.name); &#125;&#125;; 생성자 함수를 사용하면 마치 객체를 생성하기 위한 탬플릿(클래스)처럼 사용하여 구성이 동일한 객체 여러개를 간편하게 생성할 수 있다. 1234567891011121314151617181920// 생성자 함수function Person(name, gender) &#123; this.name = name; this.gender = gender; this.sayHello = function()&#123; console.log('Hi! My name is ' + this.name); &#125;;&#125;// 인스턴스의 생성var person1 = new Person('Lee', 'male');var person2 = new Person('Kim', 'female');console.log('person1: ', typeof person1);console.log('person2: ', typeof person2);console.log('person1: ', person1);console.log('person2: ', person2);person1.sayHello();person2.sayHello(); 생성자는 인스턴스를 찍어내는 공장이며, 인스턴스는 실제 객체이다. 생성자는 일반 함수로 사용하지 않고, 객체를 찍어낼 때만 사용해야 한다. 따라서 첫 문자를 대문자로 하는 관습이 있다. 생성자 함수임을 인식하는데 도움을 주기 위함이다. 따라서 생성자를 만들때는 이 관습을 지켜 네이밍하도록 한다. 프로퍼티 또는 메서드명 앞에 기술한 this는 생성자 함수로 생성될 인스턴스를 가리킨다. 따라서 this에 연결되어 있는 프로퍼티와 메서드는 public이다. 3. 객체 프로퍼티 접근1) 프로퍼티 이름프로퍼티 이름에는 문자열(빈 문자열 포함)과 숫자가 올 수 있다. 프로퍼티 값은 undefined을 제외한 모든 값과 표현식이 올 수 있으며 프로퍼티 값이 함수인 경우 이를 메서드라 한다. 프로퍼티 이름의 따옴표(‘’ 또는 ““)는 자바스크립트에서 사용할 수 있는 유효한 이름이고 예약어가 아닌 경우 생략할 수 있다. 반대로 말하면 자바스크립트에서 사용할 수 있는 유효한 이름이 아닌 경우 반드시 따옴표를 사용하여야 한다. 12345678var person = &#123; 'first-name': 'Ung-mo', /* 유효하지 않은 이름, 연산자가 있는 표현식 */ 'last-name': 'Lee', /* 프로퍼티 이름에 따옴표를 쓰지 않으면, 연산을 수행한다. last라는 변수를 찾으려고 할 것이다. 이로 인해 에러가 발생한다. */ gender: 'male', function: 1 /* OK. 하지만 예약어는 사용하지 말아야 한다. */&#125;;console.log(person.function); 명명 규칙 스네이크케이스: 공백(space) 대신 _(언더라인) 사용 (e.g. first_name) 케밥케이스: 공백 대신 - 사용 (e.g. first-name) 카멜케이스: 공백 대신 앞 문자를 대문자로 (e.g. firstName) 또한 예약어와 키워드는 사용하면 안 된다. 사용하여도 에러를 발생시키지는 않지만, 언제 에상치 못한 에러가 발생할지 모르기 때문이다. 2) 프로퍼티 값 읽기객체의 프로퍼티에 접근하려면 아래 두 방법을 사용한다. 마침표(.) 표기법 대괄호([])표기법 123456789101112131415var person = &#123; 'first-name': 'Ung-mo', 'last-name': 'Lee', gender: 'male',&#125;;console.log(person);console.log(person.first-name); // NaN: undefined-name, first-name은 마이너스 연산을 하려고 하기 때문에 프로퍼티에 접근하기도 전에 프로퍼티 명에서부터 NaN을 반환한다.console.log(person[first-name]); // ReferenceError: first is not definedconsole.log(person['first-name']); // 'Ung-mo'console.log(person.gender); // 'male'console.log(person[gender]); // ReferenceError: gender is not definedconsole.log(person['gender']); // 'male' 프로퍼티 이름이 유효한 자바스크립트 이름이고 예약어가 아닌 경우 프로퍼티 값은 마침표 표기법, 대괄호 표기법 모두 사용할 수 있다. 프로퍼티 이름이 유효한 자바스크립트 이름이 아니거나 예약어인 경우 프로퍼티 값은 대괄호 표기법으로 읽어야 한다. 대괄호([]) 표기법을 사용하는 경우, 대괄호 내에 들어가는 프로퍼티 이름은 반드시 문자열이어야 한다. 객체에 존재하지 않는 프로퍼티를 참조하면 undefined를 반환한다. 12345678var person = &#123; 'first-name': 'Ung-mo', 'last-name': 'Lee', gender: 'male',&#125;console.log(person.age); // undefined` 3) 프로퍼티 값 갱신객체가 소유하고 있는 프로퍼티에 새로운 값을 할당하면 프로퍼티 값은 새로운 값으로 갱신된다. 12345678var person = &#123; 'first-name': 'Ung-mo', 'last-name': 'Lee', gender: 'male',&#125;;person['first-name'] = 'Kim';console.log(person['first-name'] ); // 'Kim' 4) 프로퍼티 동적 생성객체가 소유하고 있지 않은 프로퍼티에 값을 할당하면 하면 해당 프로퍼티를 객체에 추가하고 값을 할당한다. 12345678var person = &#123; 'first-name': 'Ung-mo', 'last-name': 'Lee', gender: 'male',&#125;;person.age = 20;console.log(person.age); // 20 5) 프로퍼티 삭제delete 연산자를 사용하면 객체의 프로퍼티를 삭제할 수 있다. delete 연산자는 당연하게도, 객체가 소유하지 않는 프로퍼티에 적용할 수 없다. 1234567891011var person = &#123; 'first-name': 'Ung-mo', 'last-name': 'Lee', gender: 'male',&#125;;delete person.gender;console.log(person.gender); // undefineddelete person;console.log(person); // Object &#123;first-name: 'Ung-mo', last-name: 'Lee'&#125; 6) for-in문for-in문을 사용하면 객체에 포함된 모든 프로퍼티에 대해 루프를 수행할 수 있다. 123456789101112131415var person = &#123; 'first-name': 'Ung-mo', 'last-name': 'Lee', gender: 'male'&#125;;for(var prop in person) &#123; console.log(prop + ': ' + person[prop]);&#125;/*first-name: Ung-molast-name: Leegender: male*/ for-in문은 여러가지 이유로 사용하지 않는다. 일단, 순서가 보장되지 않는다. es6에서 이를 보완한 for ~ of문이 나와있다. 4. Pass-by-reference기본자료형 object를 객체형 또는 참조형이라 한다. 참조형이란 객체의 모든 연산이 실제값이 아닌 참조값으로 처리됨을 의미한다.이에 반해 기본자료형의 값은 값(value)으로 전달된다. 즉 복사되어 전달된다. 이를 pass-by-value라고 한다.기본자료형은 값이 한번 정해지면 변경할 수 없지만(immutable), 객체는 변경 가능한 프로퍼티들의 집합이라 할 수 있다. 참조값을 준다는 것은 단일 객체를 사용한다는 의미이다. immutable객체는 참조형이다. 객체에 객체를 할당했을 때, 결국 똑같은 객체를 가리킨다. 5. Pass-by-value6. 객체의 분류 Bulit-in Object(내장 객체) Standard Built-in Object(or Global Objects) Native Object BOM(Browser Object Model): 브라우저에 대한 것을 컨트롤하기 위한 객체 (e.g. 스크롤) DOM(Document Object Model): html과 css에 대한 정보를 담고 있는 객체 [참고]Poeima webMDN koblogblog - this","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://huusz.github.io/categories/Javascript/"}],"tags":[{"name":"object","slug":"object","permalink":"http://huusz.github.io/tags/object/"}]}]}