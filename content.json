{"meta":{"title":"휴지블로그","subtitle":null,"description":null,"author":"huusz","url":"http://huusz.github.io"},"pages":[{"title":"About","date":"2018-07-16T12:28:06.676Z","updated":"2018-07-16T12:28:06.676Z","comments":true,"path":"about/index.html","permalink":"http://huusz.github.io/about/index.html","excerpt":"","text":""},{"title":"Project","date":"2018-07-16T12:28:06.684Z","updated":"2018-07-16T12:28:06.684Z","comments":true,"path":"project/index.html","permalink":"http://huusz.github.io/project/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-07-16T12:28:06.685Z","updated":"2018-07-16T12:28:06.685Z","comments":true,"path":"tags/index.html","permalink":"http://huusz.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"테스트 하지 않던 코드 테스트 하기","slug":"how-to-test","date":"2018-07-02T14:04:53.000Z","updated":"2018-08-23T01:14:55.352Z","comments":true,"path":"2018/Test/how-to-test/","link":"","permalink":"http://huusz.github.io/2018/Test/how-to-test/","excerpt":"","text":"TDD 맛 테스트 연습하기내가 테스트 코드를 작성하기 시작한 것은 불과 2달 전이다. 그 전까지는 테스트 코드를 작성하지 않았다. 해본 적이 없었고, 어떻게 시작하는 지 몰라서였다. 어디서 부터 시작 해야 할 지 모르겠는 그 막막함 때문에 항상 시도만 하다가 테스트 파일을 지워버리곤 했었다. 구글에서 검색해서 나오는 블로그 글이나 아티클들은 아주 간단한 함수들을 예제로 하고 있어서 실무 코드에 활용하기가 쉽지 않았다. 이 글에서는 내가 테스트 코드 작성을 어떻게 시작했는 지와 기존에 테스트 코드 없이 이미 작성한 코드로 어떻게 (미약하게 나마) TDD를 했는 지를 이야기 하려고 한다. 참고로 예제 코드는 React로 작성되었고, 테스트 프레임 워크로는 Jest를 사용하였다.1. 함수로 추출하자.프로젝트의 전반적인 컴포넌트 구조는[부모] Redux와 API 요청 및 React 라이프 사이클 함수를 호출하는 Container 컴포넌트[자식] 실제 View를 반환하는 순수 함수로 작성된 Presentational 컴포넌트이렇게 두 컴포넌트가 중심이 된다.사이드 이펙트가 발생할 수 있는 모든 요소는 Container 컴포넌트에 있고, Presentational 컴포넌트는 최대한 순수하게 유지하고 있다. 그래서, Container 컴포넌트가 정말 길고 복잡하고, 가독성도 매우 떨어졌다. 내가 테스트를 위해 가장 먼저 한 일은 Container 컴포넌트에 숨어 있는 비즈니스 로직을 순수 함수로 추출하는 일이다. 비즈니스 로직은 DOM 조작이 필요하지 않기 때문에 순수 함수로 떼어낸다면 쉽게 테스트 할 수 있다. 어떤 식으로 함수를 추출할 수 있는지는, 먼저 아래 ‘테스트 없이 작성된 코드’ 예시를 보자. (이 코드는 예시만을 위한 것으로, 많은 부분이 생략되어 동작하지 않을 것이다.)1) 발견123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// RegisterFormContainer.jsclass RegisterFormContainer extends Component &#123; handleOpen = () =&gt; &#123; UserActions.openModal(); &#125; handleClose = () =&gt; &#123; UserActions.closeModal(); &#125; handleSubmit = async () =&gt; &#123; // ************* 함수로 추출할 부분은 바로 여기 이다!! ***************** const &#123; validateValues &#125; = this.props.form; if(!validateValues) &#123; throw Error(); &#125; const command = &#123; username: validateValues.username || validateValues.email, email: validateValues.email, tel: validateValues.tel || null, date: new Date(), &#125;; // ************************************************************ try &#123; await postRegisterRequest(command); this.handleClose(); &#125; catch(err) &#123; Modal.info(&#123; message: 'Register failed.' icon: true, &#125;) &#125; &#125; render() &#123; return( &lt;Modal visible=&#123;this.props.visible&#125; open=&#123;this.handleOpen&#125; close=&#123;this.handleClose&#125; &gt; &lt;RegisterForm submit=&#123;this.handleSubmit&#125;/&gt; &lt;/Modal&gt; ) &#125;&#125; export default connect((&#123;user&#125;) =&gt; (&#123; form: &#123; validateValues: user.form.validateValues, visible: user.form.isModalVisible, &#125;&#125;))(RegisterFormContainer)2) 추출processRegisterCommand 라는 이름의 함수를 외부 파일로 생성하고, 일단 발견한 부분을 무작정 추출해온다.당연히 코드는 정상적으로 돌아가지 않을 것이다. 아무것도 수정하지 않는다. 다만, 어떤 것을 리턴할 것인지만 정한다.1234567891011121314151617// processRegisterCommand.jsexport default processRegisterCommand() &#123; const &#123; validateValues &#125; = this.props.form; if(!validateValues) &#123; throw Error(); &#125; const command = &#123; username: validateValues.username || validateValues.email, email: validateValues.email, tel: validateValues.tel || null, date: new Date(), &#125;; return command;&#125;아까의 RegisterFormContainer 컴포넌트에서 새로 만든 함수를 불러와서 적용한다.123456789101112131415161718192021// RegisterFormContainer.jsclass RegisterFormContainer extends Component &#123; // (생략) handleSubmit = async () =&gt; &#123; // ************* 함수로 추출한 부분이다!! ***************** const command = processRegisterCommand(); // *************************************************** try &#123; await postRegisterRequest(command); this.handleClose(); &#125; catch(err) &#123; Modal.info(&#123; message: 'Register failed.' icon: true, &#125;) &#125; &#125; // (생략)&#125;2. 함수가 하는 일을 테스트 수트로 작성한다.이제 테스트 파일을 만든다. 그리고 아까 추출한 processRegisterCommand 함수를 불러온다. 테스트 수트는 describe 구문으로 작성할 수 있다. describe 구문에는 함수가 하는 일을, test 구문에는 그 일을 마치기 위해 필요한 단계들 혹은 확인해야 할 것들을 잘게 쪼갠다.유의할 점은, 처음부터 모든 시나리오를 빠짐없이 적으려 해서는 안 된다는 것이다. 오래 생각하지 않아도 바로 바로 눈에 띄는 것들 위주로 일단 작성하는 게 중요하다. 테스트를 처음 해보는 입장에서는 본격적으로 테스트 코드를 작성 해보기도 전에 힘이 빠져 버린다. 부족한 부분은 나중에 더 추가하면 그만이다.1234567891011121314151617// processRegisterCommand.jsexport default processRegisterCommand() &#123; const &#123; validateValues &#125; = this.props.form; if(!validateValues) &#123; throw Error(); &#125;; const command = &#123; username: validateValues.username || validateValues.email, email: validateValues.email, tel: validateValues.tel || null, date: new Date(), &#125;; return command;&#125;;12345678910// processRegisterCommand.test.jsimport processRegisterCommand from '../processRegisterCommand';describe('유효성 검사를 통과한 값들을 command 데이터 포맷으로 정제하여 반환한다.', () =&gt; &#123; test('validateValues 파라미터가 존재하면 예외를 발생시키지 않는다.'); test('validateValues 파라미터가 존재하지 않으면, 예외를 발생시킨다.'); test('validateValues 파라미터가 존재하면 command 객체를 반환한다.'); test('validateValues의 username 속성이 존재하지 않으면, email 속성으로 대체한다.'); test('validateValues의 tel 속성이 존재하지 않으면, null로 대체한다.');&#125;);사실 이렇게 여러 테스트 케이스를 미리 작성하지 않아도 된다. 하나씩 차례 차례 해 나가도 전혀 상관 없다. 다만, 이렇게 하고 나면 내가 추출한 함수가 어떤 일을 하고 그 일을 위해 어떤 것을 체크해야 하는 지가 한 눈에 보인다.3. TDD 맛 테스트 코드를 작성해보자!1) Red - 실패하는 테스트 코드 작성일단 처음에는 누가봐도 무조건 실패할 것 같은 구문부터 시작한다. 아래 테스트 코드는 실패할 수 밖에 없다. 애초에 함수 자체가 현재 오류 상태이기 때문이다.12345678910111213141516171819202122// processRegisterCommand.test.jsimport processRegisterCommand from '../processRegisterCommand';describe('유효성 검사를 통과한 값들을 command 데이터 포맷으로 정제하여 반환한다.', () =&gt; &#123; // ***************************** 첫번째 테스트 코드 ************************* test('validateValues 파라미터가 존재하면 예외를 발생시키지 않는다.', () =&gt; &#123; const param = &#123; username: 'user' email: 'user@email.com', tel: '01012345678', agreement: [true, true, true], &#125;; expect(() =&gt; processRegisterCommand(param)).not.toThrowError(); &#125;); // ******************************************************************** test('validateValues 파라미터가 존재하지 않으면, 예외를 발생시킨다.'); test('validateValues 파라미터가 존재하면 command 객체를 반환한다.'); test('validateValues의 username 속성이 존재하지 않으면, email 속성으로 대체한다.'); test('validateValues의 tel 속성이 존재하지 않으면, null로 대체한다.');&#125;)2) Green - 프로덕션 코드를 수정해서 테스트 성공시키기이제 테스트가 성공하도록 processRegisterCommand 함수를 수정해주면 된다. 오류가 생기는 부분은 분명 ‘this.props’ 일 것이다. 이 구문 자체가 리액트에 의존적인 코드이기 때문이다. 지금 함수는 리액트와 아무 상관 없는 일반 자바스크립트 함수이다. 그러니 this.props.form.validateValues 가 아니라, validateValues 값 자체를 파라미터로 받는다. 그러면 오류를 반환하지 않게 되므로, 테스트에 통과할 것이다.12345678910111213141516// processRegisterCommand.jsexport default processRegisterCommand(validateValues) &#123; // const &#123; validateValues &#125; = this.props.form; &lt;- 이 부분을 지우고, 파라미터로 받는다. if(!validateValues) &#123; throw Error(); &#125;; const command = &#123; username: validateValues.username || validateValues.email, email: validateValues.email, tel: validateValues.tel || null, date: new Date(), &#125;; return command;&#125;;두번째 테스트 코드를 작성해보자.12345678910111213141516// processRegisterCommand.test.jsimport processRegisterCommand from '../processRegisterCommand';describe('유효성 검사를 통과한 값들을 command 데이터 포맷으로 정제하여 반환한다.', () =&gt; &#123; // ... // ***************************** 두번째 테스트 코드 ************************* test('validateValues 파라미터가 존재하지 않으면, 예외를 발생시킨다.', () =&gt; &#123; expect(() =&gt; processRegisterCommand(undefined)).toThrowError(); &#125;); // ******************************************************************** test('validateValues 파라미터가 존재하면 command 객체를 반환한다.'); test('validateValues의 username 속성이 존재하지 않으면, email 속성으로 대체한다.'); test('validateValues의 tel 속성이 존재하지 않으면, null로 대체한다.');&#125;);이 코드는 성공할 것이다. 프로덕션 코드에 이미 에러 처리 구문이 포함되어 있기 때문이다.12345678910111213141516// processRegisterCommand.jsexport default processRegisterCommand(validateValues) &#123; if(!validateValues) &#123; // validateValues가 undefined이면 에러를 던진다. throw Error(); &#125;; const command = &#123; username: validateValues.username || validateValues.email, email: validateValues.email, tel: validateValues.tel || null, date: new Date(), &#125;; return command;&#125;;이미 작성된 코드에 테스트를 추가하는 일은 TDD처럼 항상 테스트 실패(Red) 단계로 시작할 수 없다. 이미 작성된 코드를 기반으로 테스트 시나리오를 만들기 때문에 이처럼 작성과 동시에 성공하는 테스트 위주로 만들어지게 된다. 앞에서 작성한 나머지 테스트들도 로직에 큰 문제가 없다면 대부분 성공할 것이다.123456789101112131415161718192021222324252627282930// processRegisterCommand.test.jsimport processRegisterCommand from '../processRegisterCommand';describe('유효성 검사를 통과한 값들을 command 데이터 포맷으로 정제하여 반환한다.', () =&gt; &#123; // ... // ***************************** 세번째 테스트 코드 ************************* test('validateValues 파라미터가 존재하면 command 객체를 반환한다.', () =&gt; &#123; const param = &#123; username: 'user' email: 'user@email.com', tel: '01012345678', agreement: [true, true, true], &#125;; const command = &#123; username: 'user', email: 'user@email.com', tel: '01012345678', date: new Date(), // 이 부분 때문에 이 함수는 아직 순수 함수가 아니다. 나중에 리팩터 할 것이다. &#125;; const actual = processRegisterCommand(param); expect(actual).toEqual(command); &#125;); // ******************************************************************** test('validateValues의 username 속성이 존재하지 않으면, email 속성으로 대체한다.'); test('validateValues의 tel 속성이 존재하지 않으면, null로 대체한다.');&#125;);3) Refactor - 테스트가 실패하지 않는 범위 내에서 코드 개선하기위에서 command 객체의 date 속성에 new Date() 값이 들어간다. 이 부분 때문에 processRegisterCommand 함수는 순수 함수가 아니다. 순수 함수는 input이 같으면 output도 항상 같아야 한다. 그런데 이 함수는 2018년 7월 2일에 실행하면 date 속성이 2018-07-02인 command 객체를 반환하고, 2018년 7월 3일에 실행하면 date 속성이 2018-07-03인 command 객체를 반환한다. 즉 input이 동일함에도, 함수를 실행하는 시점에 따라 output이 바뀐다. 이를 순수 함수로 만들어주는 리팩터링을 이 단계에서 시도할 수 있다.123456789101112131415// processRegisterCommand.jsexport default processRegisterCommand(validateValues, date) &#123; if(!validateValues) &#123; throw Error(); &#125;; const command = &#123; username: validateValues.username || validateValues.email, email: validateValues.email, tel: validateValues.tel || null, date, // date: date, 와 같다. &#125;; return command;&#125;;date를 파라미터로 받도록 리팩터 하였다. 이렇게 하면 비로소 processRegisterCommand 함수는 순수 함수가 된다. 앞서 수정해 준 것과 동일하게 테스트 코드도 약간 수정해준다.12345678910111213141516171819202122232425// processRegisterCommand.test.jsimport processRegisterCommand from '../processRegisterCommand';// ... // ***************************** 세번째 테스트 코드 ************************* test('validateValues 파라미터가 존재하면 command 객체를 반환한다.', () =&gt; &#123; const param = &#123; username: 'user' email: 'user@email.com', tel: '01012345678', agreement: [true, true, true], &#125;; const date = new Date(); const command = &#123; username: 'user', email: 'user@email.com', tel: '01012345678', date, &#125;; const actual = processRegisterCommand(param, date); expect(actual).toEqual(command); &#125;); // ********************************************************************단계는 여기서 끝이다! 이제 위 Red ~ Refactor까지를 반복하면 된다. 다만 앞서 말했듯 이미 작성된 코드에 테스트 코드를 추가하는 것이므로 Red 단계를 못 볼 가능성이 높다. 이제 나머지 테스트 코드들도 작성해보자.1234567891011121314151617181920212223242526272829303132333435363738394041424344 // ... // ***************************** 나머지 테스트 코드 ************************* test('validateValues의 username 속성이 존재하지 않으면, email 속성으로 대체한다.', () =&gt; &#123; const param = &#123; username: undefined, email: 'user@gamil.com', tel: '01012345678', agreement: [true, true, true], &#125;; const date = new Date(); const command = &#123; username: 'user@gamil.com', email: 'user@gamil.com', tel: '01012345678', date, &#125;; const actual = processRegisterCommand(param, date); expect(actual).toEqual(command); &#125;); test('validateValues의 tel 속성이 존재하지 않으면, null로 대체한다.', () =&gt; &#123; const param = &#123; username: 'user', email: 'user@gamil.com', tel: undefined, agreement: [true, true, true], &#125;; const date = new Date(); const command = &#123; username: 'user', email: 'user@gamil.com', tel: null, date, &#125;; const actual = processRegisterCommand(param, date); expect(actual).toEqual(command); &#125;);&#125;);모든 테스트 코드가 성공하는 것을 확인했으니, 간단한 리팩터링을 시도한다.123456789101112131415// processRegisterCommand.jsexport default processRegisterCommand(source, date) &#123; // 1. validateValues 파라미터 명을 source로 변경해주었다. if(!source) &#123; throw Error(); &#125;; // 2. command 변수를 굳이 선언하지 않고, 곧바로 리턴해주었다. return &#123; username: source.username || source.email, email: source.email, tel: source.tel || null, date, &#125;;&#125;;이렇게 하면 한결 깔끔해진 함수와 함께, 첫 번째 테스트 코드가 완성된다.++ 4. 스펙을 추가하자! (선택)테스트 코드 작성 중 추가적으로 필요한 스펙이 떠오른다거나, 새로운 비즈니스 요구 사항에 의해 기능을 추가해야 하는 상황이 올 수 있다. 이렇게 기존에 없던 새로운 로직이 들어가야 할 때가 바로 TDD를 연습해볼 수 있는 기회이다.만약 param 파라미터의 agreement 배열이 모두 true가 아니면 null을 반환하는 스펙을 추가한다고 해보자.먼저 테스트 코드부터 작성한다.1234567891011121314// ...test('agreement가 하나라도 false인 경우 null을 반환한다.', () =&gt; &#123; const param = &#123; username: 'user', email: 'user@gamil.com', tel: undefined, agreement: [true, true, false], &#125;; const date = new Date(); const actual = processRegisterCommand(param, date); expect(actual).toBeNull();&#125;)당연히 실패하는 테스트이다. (Red 단계)프로덕션 코드를 수정한다.1234567891011121314151617181920// processRegisterCommand.jsexport default processRegisterCommand(source, date) &#123; if(!source) &#123; throw Error(); &#125;; // ************************ 추가된 부분 ************************ // source의 agreement 속성에 false가 포함되어 있으면, null을 리턴한다. if(source.agreement.some(agree =&gt; !agree)) &#123; // (e =&gt; e === false) 와 같다. return null; &#125;; // ******************************************************** return &#123; username: source.username || source.email, email: source.email, tel: source.tel || null, date, &#125;;&#125;;테스트가 성공하게끔, 프로덕션 코드를 수정해준다. (Green 단계). 리팩터 단계는 딱히 떠오르지 않아 생략하였다.이 글을 통해 말하고자 했던 바는 TDD가 아니고 (나도 아직 아주 아주 허접이니까), 너무 어렵게 생각하지 말고 아주 작은 부분 부터 하나씩 뜯어서 테스트 해보자는 것이다. 작은 것 부터 하나씩 연습하다보면 뭐 부터, 어떻게 시작해야 할 지 모르겠는 그 막막함을 조금 덜어낼 수 있다. 계속 연습하다보면 어느 정도 테스트가 손에 익고, 어떻게 해야 할 지 약간 감이 오기 시작한다. 그 때 TDD도 연습해보고, 더 다양한 테스팅 툴도 사용해 보면 된다. 조급하게 생각하지 말자! 경력 30년 된 우리 회사 CTO님이 테스트 코드 만 개는 작성해 봐야 한다고 했다!","categories":[{"name":"Test","slug":"Test","permalink":"http://huusz.github.io/categories/Test/"}],"tags":[{"name":"Unit test","slug":"Unit-test","permalink":"http://huusz.github.io/tags/Unit-test/"},{"name":"React test","slug":"React-test","permalink":"http://huusz.github.io/tags/React-test/"},{"name":"Jest","slug":"Jest","permalink":"http://huusz.github.io/tags/Jest/"}]},{"title":"Enzyme - Cannot read property 'have' of undefined","slug":"멍청1","date":"2018-06-30T14:18:53.000Z","updated":"2018-07-16T12:28:06.675Z","comments":true,"path":"2018/멍청/멍청1/","link":"","permalink":"http://huusz.github.io/2018/멍청/멍청1/","excerpt":"","text":"리액트 컴포넌트 유닛테스트를 연습하려던 차에 시작부터 막힌 부분Cannot read property ‘have’ of undefined???????????공식 문서에서 이렇게 하라고 했는데 ??????결론부터 말하면 to.have.lengthOf() 는 테스트 프레임워크 chai의 문법이다.나는 jest를 사용하고 있기 때문에.. toHaveLength() 로 해줘야 한다.jest도, chai도 아닌 다른 테스트 프레임워크를 사용하고 있다면, 그 프레임워크의 길이 검사 문법을 사용해야 한다.나는 진짜 똥 멍청이다..","categories":[{"name":"멍청","slug":"멍청","permalink":"http://huusz.github.io/categories/멍청/"}],"tags":[{"name":"Jest","slug":"Jest","permalink":"http://huusz.github.io/tags/Jest/"},{"name":"Enzyme","slug":"Enzyme","permalink":"http://huusz.github.io/tags/Enzyme/"},{"name":"Test","slug":"Test","permalink":"http://huusz.github.io/tags/Test/"}]},{"title":"Unit test style","slug":"TIL180529-unit-test-pattern","date":"2018-05-29T14:18:53.000Z","updated":"2018-07-16T12:28:06.674Z","comments":true,"path":"2018/TIL/TIL180529-unit-test-pattern/","link":"","permalink":"http://huusz.github.io/2018/TIL/TIL180529-unit-test-pattern/","excerpt":"","text":"Test styleSetup, Exercise, Verify and Teardown (Four-phases test pattern)Given, When, Then (BDD)Arrange, Act, Assert(AAA)모두 기본적인 아이디어는 같다.[Setup/ Given/ Arrange] 테스트 할 대상에게, 테스트를 위해 사전에 필요한 조건들을 사전에 갖추게 하고 (기본 값, 파라미터, 선행 되어야 할 함수 실행 등)[Exercise/ When/ Act]테스트 대상 함수를 호출하고[Verify/ Then/ Assert]테스트 대상이 예상한 대로 작동하는지 확인한다.* Four-phases test pattern의 Teardown은 테스트에 의해 만들어진 fixture를 해제하는 단계로 필수는 아니다.ReferenceMeszaros - Four-phases test patternBill Wake - 3A(AAA)MS docs: AAA exampleBDD - Given When Thenmartinfowler.com: Given-When-Then","categories":[{"name":"TIL","slug":"TIL","permalink":"http://huusz.github.io/categories/TIL/"}],"tags":[{"name":"Unit test","slug":"Unit-test","permalink":"http://huusz.github.io/tags/Unit-test/"},{"name":"Test style","slug":"Test-style","permalink":"http://huusz.github.io/tags/Test-style/"},{"name":"AAA(3A)","slug":"AAA-3A","permalink":"http://huusz.github.io/tags/AAA-3A/"},{"name":"Arrange Act Assert","slug":"Arrange-Act-Assert","permalink":"http://huusz.github.io/tags/Arrange-Act-Assert/"},{"name":"Given When Then","slug":"Given-When-Then","permalink":"http://huusz.github.io/tags/Given-When-Then/"}]},{"title":"Semantic-ui-react와 css-module을 같이 사용할 수 없을까?","slug":"Log/01.dada-log-01","date":"2017-10-02T07:31:11.000Z","updated":"2018-07-16T12:28:06.674Z","comments":true,"path":"2017/Log/Log/01.dada-log-01/","link":"","permalink":"http://huusz.github.io/2017/Log/Log/01.dada-log-01/","excerpt":"","text":"삽질의 발단…팀 프로젝트를 시작하고 채택한 스타일링 방식은 CSS Framework인 semantic-ui-react로 큰 틀을 잡고, CSS로 세부적인 디자인을 하는 것이었다. 지금까지 css 작업을 누군가와 같이 해본 경험이 없었기 때문에, 몇 가지 우려되는 것이 있었다. 각각 다른 css파일에서 중복되는 클래스 네임이 존재하는 상황 같은 것 말이다 (…) 이런 상황을 사전에 방지하고자, className 앞에 파일명(컴포넌트 이름)을 붙이기로 하였다. 근데 … 너무 귀찮을 것 같았다. 모든 클래스네임을 수동으로 home-header home-header-search 이런 식으로 지정해 주는, 이런 걸 반복 해야 하다니?자동으로 해주는 게 없을까?css를 자동으로 모듈화 해주는 방법에 css-module이라는게 있다는 것을 알게 되었고, webpack에서 css-loader에 module: true 설정을 추가해주었다.CSS 프레임워크와는 공존할 수 없다.eject로 webpack config에 직접 설정을 추가하는 방식이었는데, semantic-ui-css가 적용되지 않는 문제가 생겼다.module: true 때문이다.How to use css-modules with other global css (discussion please don’t merge it)웹팩 설정에서 css-loader 설정을 module:true로 바꾸면, node-modules에 있는 semantic-ui-css(global css)도 component에 따라 class 이름을 변경하기 때문에 전혀 다른 클래스가 되어버리므로 (ex. .ui.icon-k1t4h#9) 결국 semantic-ui-css와의 연결이 끊긴다. 이 때문에 에러는 안 나지만, 전혀 다른 클래스를 적용한 꼴이 되어버리므로 시맨틱 스타일 적용한 것들이 없어져 버린 것..윗 글에서는 css-loader에 두 가지로 분류해서 로딩하는 방식으로 약간의 꼼수(?)를 사용했다. global로 쓸 css는 (내 경우 semantic-ui-css) 그대로 하되, local 한 모듈들에 쓸 css들은 app.module.css 와 같이 명명하여 별도로 처리하게 하는 방식이다.선택지는..1. Semantic-ui를 쓴다.semantic-ui + pure css를 쓴다. 클래스 네임을 직접. 수동으로. 명명해서 css를 모듈화 한다.semantic-ui + styled-components를 쓴다. (웹 팩 설정이 필요 없다.)위 방법 처럼 꼼수(?)를 써서 css-module + semantic-ui를 쓴다.2. Semnatic-ui를 안 쓴다.모든 것이 평화롭게 해결된다.사실 semantic-ui를 안 쓰고 싶지만, 당장 4일 내로 정적 페이지 제작이 끝나야 하므로 스타일링에 많은 시간을 쏟을 수 없었다. 프레임워크는 그대로 쓰기로 했다. 그러면 남은 선택지 중에서…2. styled-components?styled-components는 기존의 css문법과 약간 다르다. react와 css를 섞어 놓은 듯한 문법이라 학습+적응 시간이 필요할 것 같은데, 빠르게 페이지를 만들어야 하는 지금 상황에서 그다지 좋은 선택지는 아닌 것 같다. 게다가 시맨틱도 컴포넌트이고 styled-components도 컴포넌트라서 시맨틱 컴포넌트 내부에 스타일링을 적용해야 하는 경우에는 결국 인라인스타일을 쓰게 된다. 이런게 많아지면, styled-components를 적용하는 의미가 없어지는 것 같았다. 그럴바엔 그냥 전부 inline style로 하면 되는 것 아닌가? 라는 생각이 들었다.3. css-module + semantic-ui?어차피 css를 쓸거라면 위 방법을 써서 css-module을 사용하는 것도 좋겠지만, 사실 이것 하나 때문에 eject로 웹팩 config 파일 및 script 설정 파일 등등을 풀어헤친다는 게 석연치 않았다. (불안하기도 했고..)결국 처음 고민하던 시점으로 돌아가, pure css + css 프레임워크를 쓰기로 했다.프로젝트가 끝나가는 시점에서..위에서도 말했듯, 처음 고민하던 시점으로 돌아가서 pure css + css 프레임워크를 쓰려고 하였고 적용해보려는 시도도 했다. 그런데 결국 채택한 방식은 컴포넌트 인라인 스타일 + pure css + css 프레임워크 방식이다. styled 컴포넌츠를 약간 (정말 약간) 모방하여 Styled***.js라는 이름으로 인라인 스타일 객체만 모아둔 파일을 각 페이지 폴더 내부에 하나씩 두는 방식으로 하였다. 여기까지 오기까지 나름 치열한(?) 고민을 했기 때문에, 기록해두려고 한다.인라인 스타일 방식을 선택한 이유는,일단 className을 부여하는 방식으로는 semantic의 기본 스타일을 커스터마이징하는 데 한계가 있었다. semantic ui가 스타일링 하는 방식을 개발자 도구로 열어보면, 아래처럼 클래스 여러개를 중첩하여 선언하는 방식이다.12/* semantic-ui class(className) */.ui.icon.input input여기다가 직접 커스텀한 className을 부여하여도,1&lt;Input className = \"foodSearchInput\" ... /&gt;123456789/* custom class(className) 추가하는 경우 */.foodSearchInput &#123; border-radius: 100px; /* 이 코드는 무시된다. */&#125;/* 중첩 선언 방식이 명시도 면에서 더 우위를 가져간다. */.ui.icon.input input &#123; border-radius: .28571429rem; /* 이 코드가 적용된다. */&#125;결국 캐스캐이딩(cascading) 우선 순위에서 밀리기 때문에 (명시도 면에서 중첩 선언된 기존의 semantic 방식보다 더 하위가 된다.) 적용되지 않는 경우가 많았다.커스텀 css의 캐스캐이딩 우선 순위가 semantic-ui 프레임워크보다 항상 우위에 있도록 할 수 있는 방법은 없을까?일단 cascading의 명시도 면에서 !important &gt; 인라인 스타일 &gt; 아이디 선택자 &gt; 클래스/어트리뷰트/가상 선택자 &gt; 태그 선택자 &gt; 전체 선택자 &gt; 상위 요소에 의해 상속된 속성 순으로 우선 순위에서 우위를 가져간다. 여기서, !important를 사용하는 방법은 최대한 배제하기로 하였다. 그러면 남은 것은 인라인 스타일과 아이디 선택자를 사용하는 방법이 남는다.아이디 선택자 (X)id 선택자는 단 하나의 요소에만 부여할 수 있는 고유한 것이다.따라서 코드의 재사용이 불가함은 물론이고, 유사 스타일에 대한 확장 가능성이 전혀 없기 때문에 인라인 스타일에 비해 비효율적이다.프로젝트 내에서 예를 들면, 검색창과 같은 경우, 유사한 스타일 코드를 다른 페이지의 input 요소들과 공유하게 되는데, id선택자를 이용하면 같은 스타일을 여러번 반복해서 선언해주어야 한다.1234567891011121314151617/* 아이디 선택자를 사용할 경우 같은 혹은 유사 스타일 일지라도 반복해서 선언해주어야 한다. */#searchInput&#123; width: 400px; margin: 20px 10px; border-radius: 100px; position: absolute; left:300px;&#125;#searchResultInput&#123; width: 800px; margin: 20px 10px; border-radius: 100px; position: absolute; left: 100px; top: 400px;&#125;123456789101112131415// 인라인 스타일의 경우 spread 문법을 이용한 스타일의 확장이 가능하다.export const searchInput &#123; width: '400', margin: '20 10', borderRadius: '100', position: 'absolute', left: '300',&#125;export const searchResultInput &#123; ...searchInput, width: '800', left: '300', top: '400'&#125;인라인 스타일 (O)인라인 스타일은 캐스캐이딩에서 !important를 제외하고 두 번째 우선순위를 갖는다. 따라서 중첩된 클래스보다 항상 우위에 있을 것이고, 위 예제처럼 아이디 선택자에 비해 재사용 및 확장이 용이하기 때문에 효율적이고 문제가 없을 것이라 생각했다. 그런데 여기에도 문제가 있었다.대부분의 컴포넌트가 div로 실제 시맨틱 태그를 감싸고 있어 인라인 스타일을 주어도 적용되지 않는 경우가 많았다. 예를 들어 Input이나 Search 컴포넌트의 경우, &lt;input&gt; 태그를 &lt;div&gt;&lt;/div&gt;가 감싸고 있다.123&lt;div&gt; &lt;input type=\"text\"/&gt;&lt;/div&gt;이런 식이라 인라인으로 스타일을 부여하면 &lt;input&gt;이 아니라 가장 바깥의 &lt;div&gt;로 스타일 코드가 적용되었다.123&lt;div style=\"border: 1px solid blue;\"&gt; &lt;input type=\"text\"/&gt;&lt;/div&gt;따라서 상속이 되는 css 속성에 한해서만 (ex. font/color/text-align 등 비교적 레이아웃과 관련되지 않는 속성들) 적용이 되었고, 정작 필요한 border 속성이나 margin, padding, position과 같은 속성은 적용할 수 없었다.즉, 인라인 스타일이나 className 중 하나만 선택하는 방식으로는 발생하는 모든 문제를 해결할 수 없었다. 그래서, 그나마 문제가 거의 발생하지 않는 인라인 스타일을 주 스타일링 방식으로 채택하였다. 그리고 인라인으로 해결되지 않는 몇몇 문제들에 한해서만, semantic ui에서 정의한 클래스의 css를 아래와 같이 커스텀 css에서 재정의해주는 방식을 채택하였다.1234567891011/* search.css(custom css) */.ui.icon.input input&#123; border-radius: 100px /* 이 코드가 적용된다. */&#125;/* semantic.min.css */.ui.icon.input input &#123; padding-right: 2.67142857em!important; /* ... */ border-radius: .28571429rem /* 이 코드는 무시된다. */&#125;사실 Object 형태의 인라인 스타일 방식을 주 스타일링 방식으로 채택하게 되기까지 React.js + CSS라는 글이 꽤나 큰 동기 부여가 되기도 하였다. styled-components의 존재를 알게 된 시점부터 css-in-js 라는 스타일링 방식이 어떤 이유로 나오게 되었으며, 어떤 이점을 갖는 지에 대해 궁금했었고, 윗 글이 어느 정도 대답이 되었기 때문이다.이 방식을 채택함으로써 가장 큰 수혜(?)를 받은 부분이 Navigation 컴포넌트였다. 프로젝트의 디자인 시안 상으로, 페이지 상단 네비게이션(메뉴)바의 폰트와 보더(border) 색상을 적용함에 있어 두 가지 케이스가 있었다.흰 배경인 경우: #16325c사진이나 동영상이 배경인 경우: #fff1234567// components/Navigation/index.js// default Props: 컬러 반전이 없는 일반 페이지의 default color// props를 전달하지 않는 경우 color: '#16325c'Navigation.defaultProps = &#123; color: '#16325c'&#125;디자인 상 대부분의 화면이 흰 배경이므로, 이를 기본으로 설정하기 위해 위와 같이 defaultProps로 color 스타일을 지정하였다. 그리고 아래처럼 특정 조건에 따라 color와 borderColor를 다르게 적용하도록 하였다.12// pages/HomePage/index.js&lt;Navigation color=\"#fff\" /&gt;123456789101112131415161718192021222324// components/Navigation/RightMenu/index.js&lt;Menu.Item style=&#123; // active일때만 border-color 적용 isLinkMatched ? &#123; ...linkTagWrap, // linkTagWrap은 아래 참고 borderColor: this.props.color, //#fff &#125; : &#123; linkTagWrap &#125; active=&#123;isLinkMatched&#125;&gt; &lt;Link style=&#123;&#123; ..linkTag, color: this.props.color, // #fff &#125;&#125; to=&#123;route.linkTo&#125; &gt; &#123;route.linkLabel&#125; &lt;/Link&gt;&lt;/Menu.Item&gt;123456// components/Navigation/StyledNavigation.jsexport const linkTagWrap = &#123; padding: '7px', marginLeft: '37px', marginBottom: '6px',&#125;이렇게 css를 변수(또는 props)로 직접 이식하는 부분이 굉장히 매력적이었다. 그리고 이런 방식은 굳이 css-in-js방식의 라이브러리를 사용하지 않아도 가능하였고, 이보다 더 복잡하고 많은 스타일링이 필요할만큼 앱이 거대하지도 않았다. 어찌됐든, 이러한 고민들을 거쳐 최종적으로 인라인 스타일 + css 방식을 사용하였다.언젠간 css와 js 스타일링 방식의 차이에 대해서 나름대로 정리한 내용을 기록하려고 한다. (언제가 될지는 모르겠다..) css-in-js 방식을 차용한 스타일링 라이브러리들을 찾아보면서 Aphrodite, CSS in JS, Emotion.js 등등 다양한 라이브러리들을 알게 되었는데, 개인적으로 Emotion.js나 Styled-components를 꼭 한번 사용해보고 싶다.","categories":[{"name":"Log","slug":"Log","permalink":"http://huusz.github.io/categories/Log/"}],"tags":[{"name":"semantic-ui-react","slug":"semantic-ui-react","permalink":"http://huusz.github.io/tags/semantic-ui-react/"}]}]}