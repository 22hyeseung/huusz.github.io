---
title: '.git: git의 내부'
date: 2017-10-22 04:21:58
category: Git
tags: git
---

git 은 Content-addressable 파일 시스템이고 그 위에 VCS 사용자 인터페이스가 있는
구조입니다 .

1. Content-addressable 파일 시스템
2. 데이터 전송 원리
3. 저장소 관리법

<br>

---

# Git 의 내부

## 1. Plumbing 명령과 Porcelain 명령

git 은 본래 VCS 라기보다 , **VCS 를 위한 툴킷 (tool kit)**입니다 . 기본적으로 매
우 많은 저수준명령어로 구성되어 있습니다 . ( 저수준이란 사용자보다컴퓨터에게 더
친숙함을 의미합니다 .) 저수준 명령어들을 UNIX 스타일로 엮어 실행하거나 스크립트
로만들어 사용하도록 설계되어 있습니다 . Plumbing 명령어는 이러한 저수준 명령어를
일컫는 말이며 , Porcelain 명령은사용자에게 친숙한 명령어를 의미합니다 . 흔히 사
용하는 `git add`, `git commit`, `git push`, `git checkout` 등의 명령어들은 사용
자에게더친숙한 Porcelain 명령어 입니다 .

* **Plumbing** : 저수준의 명령어 .

* **Porcelain** : 사용자에게 친숙한 사용자용 명령어 . 일반적으로 사용하는 git 명
  령어들 (`add`, `commit`, `push`, `checkout` 등 ) 이 이에 해당합니다 .

### Git 의 내부 구조

Plumbing 명령을 사용하면 git 의 내부 구조에 접근할수 있습니다 . 그리고 git 이 왜
, 그렇게 작동하는지도확인할 수 있습니다 . Plumbing 명령어는 직접 커맨드라인에서
실행하기보다 새로운 도구를 만들거나 각자필요한 스크립트를 작성할 때 사용합니다 .

새로 만든 디렉토리나 이미 파일이 있는 디렉토리에서 `git init` 명령을 실행하면
git 은 데이터를 저장하고관리하는 `.git` 디렉토리가 생성됩니다 .

```
.git/
 HEAD
 config*
 description
 hooks/
 info/
 objects/
 refs/
```

위 파일 구조는 `git init` 명령 실행 직후 보이는 새저장소의 모습입니다 .

* `config` : 해당 프로젝트에만 적용되는 설정 옵션이 들어 있습니다 .

* `info/` : `.gitignore`처럼 무시할 파일의 패턴을적어 두는 곳 입니다 . 하지만
  `.gitignore`와 달리 git 으로 관리되지 않습니다 .

* `hooks/` : 클라이언트 훅이나 서버 훅이 위치합니다 .

<br>

이제 아래 4 가지 항목이 git 의 핵심입니다 .

<br>

* `objects/` : 모든 컨텐츠를 저장하는 데이터베이스입니다 .

* `refs/` : 커밋 개체의 포인터 (pointer) 를 저장합니다 .

* `HEAD` : 현재 checkout 한 브랜치를 가리킵니다 .

* `index` : Staging Area 의 정보를 저장합니다 .

<br>

## 2. Git 개체

Git 은 Content-addressable 파일시스템 입니다 . 즉 , 단순한 key-value 데이터 저장
소입니다 . 데이터가어떤 형식인가와 무관하게 key 를 통해 언제든 데이터를다시 가져
올 수 있습니다 . Plumbing 명령어 `hash-object`에 데이터를 주면 `.git`디렉토리에
저장하고 그 key 를 알려줍니다 .

테스트용 폴더를 만들어 내부를 실제로 확인해볼 수있습니다 .

```zsh
$ mkdir test
$ cd test
$ git init # 폴더 내부에 .git 디렉터리가 생성됨
$ find .git/objects
.git/objects
.git/objects/pack
.git/objects/info
$ find .git/objects -type f
$
```

위에서 `.git`의 하위 디렉터리로 `objects/` 디렉터리가 있습니다 . Git 은
`objects` 디렉터리 밑에 `pack`과 `info` 디렉터리를 만듭니다 . init 명령으로 초기
화된 지금 상태에서는 파일이 없는 빈 디렉터리로 존재합니다 . 이제 Git 데이터베이
스에 텍스트파일을 저장합니다 .

```zsh
# -w 옵션을 주어야 실제로 저장합니다.
# -w가 없으면 저장하지 않고 key만 보여줍니다.
# --stdin 옵션은 표준 입력으로 입력되는 데이터를 읽습니다. 이 옵션이 없으면 파일 경로를 알려주어야 합니다.
$ echo 'test' | git hash-object -w --stdin
9daeafb9864cf43055ae93beb0afd6c7d144bfa4
# 40자 길이의 체크섬 해시
```

이 명령은 표준 입력으로 들어오는 데이터를 저장합니다 . `hash-object` 명령이 출력
하는 것은 40 자 길이의 체크섬 해시입니다 . 이 해시는 헤더 정보와 데이터모두에 대
한 SHA-1 해시입니다 .

<br>

### 2.1) blob 개체

이제 Git 이 저장한 데이터를 알아봅니다 .

```zsh
$ find .git/objects -type f
.git/objects/9d/aeafb9864cf43055ae93beb0afd6c7d144bfa4
# 디렉터리 9d는 위 체크섬 해시의 앞 2글자 입니다.
# 디렉터리 아래 파일명은 해시의 나머지 38글자입니다.
# 이 파일에 데이터가 저장됩니다.
```

아까와 달리 obejct 디렉토리에 파일이 하나 생성되었습니다 . Git 은 데이터를 저장
할 때 해시의 처음 두글자를 디렉토리 이름으로 사용하고 나머지 38 글자를그아래 파
일 이름으로 사용합니다 . 데이터는 새로만든파일에 저장합니다 .

이제 `cat-file` 명령으로 저장한 데이터를 불러올 수있습니다 . 여기에 `-p` 옵션을
주면 파일 내용이 출력됩니다 . 이 명령은 Git 개체를 살펴보고 싶을 때언제든 사용할
수 있습니다 .

```zsh
$ git cat-file -p 9daeafb9864cf43055ae93beb0afd6c7d144bfa4
test
```

다시 한 번 데이터를 Git 저장소에 추가하고 불러와봅니다 . Git 이 파일 버전을 관리
하는 방식을 이해할수있도록 가상의 상황을 만들어보겠습니다 . 우선 새파일을 하나만
들고 Git 저장소에 저장합니다 .

```zsh
$ echo 'version1' > test.txt
$ git hash-object -w test.txt
83baae61804e65cc73a7201a7252750c76066a30
```

그리고 그 파일을 수정한 뒤 다시 저장합니다 .

```zsh
$ echo 'version2' > test.txt
$ git hash-object -w test.txt
1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
```

이제 데이터베이스에는 데이터가 두 가지 버전으로 저장되어 있습니다 .

```zsh
$ find .git/objects -type f
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
.git/objects/9d/aeafb9864cf43055ae93beb0afd6c7d144bfa4
```

파일의 내용을 첫 번째 버전으로 되돌려봅니다 .

```zsh
$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 > test.txt
$ cat test.txt
version 1
```

```zsh
$ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a > test.txt
$ cat test.txt
version 2
```

그런데 파일의 SHA-1 키를 외워서 사용하는 것은 너무어렵습니다 . 게다가 파일의 내
용만 저장했을 뿐 파일의 본래 이름은 저장하지도 않았습니다 . 이런 종류의개체를
Blob 개체라고 부릅니다 . `cat-file -t` 명령으로 해당 개체가 무슨 개체인지 확인할
수 있습니다 .

```zsh
$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
blob
```

### 2.2) tree 개체

그렇다면 파일 이름은 어디에 저장되는 것일까요 ? 바로 Tree 개체에 파일 이름을 저
장합니다 . ( 트리 개체에는 파일 여러 개를 한꺼번에 저장할 수도 있습니다 .) Git
은 모든 것을 Tree 와 Blob 개체로 저장합니다 . Tree 를 디렉토리 , Blob 은 일반 파
일에 대응하면쉽습니다 . Tree 개체 하나는 항목을 여러 개 가질 수있고 그 항목에는
Blob 개체나 하위 Tree 개체를가리키는 SHA-1 포인터 , 파일 모드 , 개체 타입 , 파일
이름이 들어있습니다 . 아래와 같은 Tree 개체가 있다고할 때 ,

```zsh
# master^{tree} 구문은 master 브랜치가 가리키는 tree개체를 말합니다.
$ git cat-file -p master^{tree}
100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README
100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile
040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib
# 디렉터리로, 또 다른 tree개체입니다.
```

Git 이 저장하는 데이터는 대략 아래와 같습니다 .

![단순화한 Git 데이터 모델](https://git-scm.com/figures/18333fig0901-tn.png)

<!-- 
직접 tree 개체를 만들어보겠습니다 . Git 은 일반적으로 Staging Area(Index) 의 상
태대로 Tree 개체를만들고 기록합니다 . 그래서 Tree 개체를 만들려면 일단 Staging
Area 에 파일을 추가해서 Index 를 만들어야합니다 . 우선 Plumbing 명령어
`update-index`로 test.txt 파일만 들어있는 Index 를 만듭니다 . 이 명령어는 파일을
인위적으로 Staging Area 에 추가하는명령입니다 . 아직 Staging Area 에 없는 파일이
므로 --add 옵션을 꼭 주어야 합니다 . 그리고 디렉토리에있는 파일이 아니라 데이터
베이스에 있는 파일을 추가하는 것이기 때문에 --casheinfo 옵션이 필요합니다 . 파일
모드 SHA-1 해시 , 파일 이름 정보도 입력합니다 .

```zsh
$ git update-index --add --cashinfo 100644 \
``` -->

---
