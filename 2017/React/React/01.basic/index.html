<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta name="description" content="마우스 누르는 게 세상에서 제일 귀찮은 휴지의 개발블로그"><meta name="keyword" content="huusz, frontend"><link rel="shortcut icon" type="image/ico" href="css/images/logo.png"><title>[React] 리액트 입문하기 | 휴지블로그</title><link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet"><link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/plugins/gitment.css"><script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script><script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script><script src="/js/qrious.js"></script><script src="/js/gitment.js"></script></head><div class="wechat-share"><img src="/css/images/logo.png"></div><body><header class="header fixed-header"><div class="header-container"><a class="home-link" href="/"><span>휴지블로그</span></a><ul class="right-list"><li class="list-item"><a href="/" class="item-link">Home</a></li><li class="list-item"><a href="/tags/" class="item-link">Tags</a></li><li class="list-item"><a href="/archives/" class="item-link">Archives</a></li><li class="list-item"><a href="/project/" class="item-link">Projects</a></li><li class="list-item"><a href="/about/" class="item-link">About</a></li></ul><div class="menu"><span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></div><div class="menu-mask"><ul class="menu-list"><li class="menu-item"><a href="/" class="menu-link">Home</a></li><li class="menu-item"><a href="/tags/" class="menu-link">Tags</a></li><li class="menu-item"><a href="/archives/" class="menu-link">Archives</a></li><li class="menu-item"><a href="/project/" class="menu-link">Projects</a></li><li class="menu-item"><a href="/about/" class="menu-link">About</a></li></ul></div></div></header><div id="article-banner"><h2>[React] 리액트 입문하기</h2><p class="post-date">2017-09-20</p><div class="arrow-down"><a href="javascript:;"></a></div></div><main class="app-body flex-box"><article class="post-article"><section class="markdown-content"><p><img src="https://cdn-images-1.medium.com/max/2000/1*HSisLuifMO6KbLfPOKtLow.jpeg" alt=""></p><h2 id="1-What-is-React"><a href="#1-What-is-React" class="headerlink" title="1. What is React?"></a>1. What is React?</h2><p>React는 페이스북에서 개발한 자바스크립트 라이브러리이다. 공식 문서에서는 <strong>사용자 인터페이스(User Interface)를 구축하기위한 선언적(declarative)이고 효율적(efficient)이며 유연한(flexible) JavaScript 라이브러리</strong>라고 설명하고있다. React는 ‘컴포넌트’단위로 재사용 가능한 UI 템플릿을 만든다. 현재 페이스북, 인스타그램, MS 등 대형 서비스에서도 사용되고있는 견고한 라이브러리이다.</p><p>React는 Virtual DOM이라는 개념을 사용하여 상태(state)의 변함(diff)에 따라 선택적으로 UI를 렌더링한다. 따라서 최소한의 DOM 처리로 컴포넌트 업데이트가 가능하다.</p><p><br></p><h2 id="2-Virtual-DOM"><a href="#2-Virtual-DOM" class="headerlink" title="2. Virtual DOM"></a>2. Virtual DOM</h2><h3 id="1-DOM-Document-Object-Model"><a href="#1-DOM-Document-Object-Model" class="headerlink" title="1) DOM(Document Object Model)"></a>1) DOM(Document Object Model)</h3><p>DOM이란 객체를 통해 구조화된 문서를 표현하는 방법을 말한다. XML또는 HTML로 작성된다. 웹 브라우저는 DOM을 이용해 객체에 자바스크립트와 CSS를 적용한다. DOM은 트리 형태로 되어있으며 특정 노드(node)의 서치(search)와 수정, 제거, 삽입이 가능하다.</p><p>DOM의 문제점은 동적 UI에 최적화되어 있지 않다는 것이다. HTML은 그 자체로 정적인 문서(document)이기 때문이다. 큰 규모의 웹 어플리케이션은 하나의 페이지에도 수 많은 요소들이 생기는데, 이 모든 요소들을 DOM에 직접 접근하여 조작하면서 변화룰 주다보면 속도 저하를 피할 수 없게 된다.</p><p>브라우저 단에서 DOM의 변화가 일어나면 브라우저는 CSS를 다시 연산하고 레이아웃을 새로 구성(=리플로우, reflow )하며 웹 페이지에서 레이아웃에 관계 없는 나머지(색상 변경 등)를 처리(=리페인트, repaint) 하는 데, 이 과정이 DOM에 접근하는 만큼 반복된다. 속도 저하는 바로 이 부분에서 발생한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> style = <span class="built_in">document</span>.body.style; <span class="comment">// 캐싱</span></div><div class="line">style.padding = <span class="string">"20px"</span>; <span class="comment">// reflow, repaint</span></div><div class="line">style.border = <span class="string">"10px solid red"</span>; <span class="comment">// reflow, repaint</span></div><div class="line"></div><div class="line">style.color = <span class="string">"blue"</span>; <span class="comment">// repaint</span></div><div class="line">style.backgroundColor = <span class="string">"#ffa"</span>; <span class="comment">// repaint</span></div><div class="line"></div><div class="line">style.fontSize = <span class="string">"1em"</span>; <span class="comment">// reflow, repaint</span></div><div class="line"></div><div class="line"><span class="comment">// reflow, repaint</span></div><div class="line"><span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'hello World'</span>));</div></pre></td></tr></table></figure><p>이렇게 코드가 실행될 때마다 reflow하는 것은 매우 비효율적이며 이에 따른 성능 저하를 우려하지 않을 수 없다. 브라우저는 성능 저하를 단축시키기 위해 짧은 시간 내에 여러 reflow가 발생하려 할 시 이 작업을 미루고 한번에 처리한다. (하지만, <code>offsetTop</code>, <code>scrollTop</code>, <code>getComputedStyle()</code> 등 코드 실행 당시 값을 가져오는 것이 중요한 일부 코드들은 reflow가 여러번 발생할 수 없으므로 브라우저에서 최적화하지 못한다.) 따라서 성능 개선을 위해서는 reflow 횟수를 줄이기 위해 코드를 최적화 해야 한다.</p><h3 id="2-Virtual-DOM-1"><a href="#2-Virtual-DOM-1" class="headerlink" title="2) Virtual DOM"></a>2) Virtual DOM</h3><p>HTML 마크업을 시각적 형태로 변환하는 것은 브라우저의 주 역할이다. 결국 DOM 조작을 아예 하지 않을 수는 없으니, 최소한의 조작만 하여 성능 저하 문제를 해결해보고자 하는 노력이 Virtual DOM을 탄생시켰다.</p><p>Virtual DOM은 언어 그대로 가상 DOM이다. DOM 작업을 가상화(추상화)하여 미리 처리한 다음, 실제 DOM에 한번에 적용하는 방식이다.</p><p>React의 실제 DOM 업데이트는 아래 3단계로 이루어진다.</p><ol><li>데이터가 업데이트되면, 전체 UI를 virtual DOM에 리렌더링한다.</li><li>이전 Virtual DOM에 있던 내용과 현재 내용을 비교한다.</li><li>바뀐 부분만 실제 DOM에 적용한다.</li></ol><p>결국 컴포넌트가 업데이트 될 때, 레이아웃 계산(reflow)이 한번만 이루어지므로 속도 저하 문제를 개선할 수 있게 되는 것이다.</p><p>하지만, Virtual DOM이 모든 경우에서 무조건 더 좋은 퍼포먼스를 내는 것은 아니다. 오히려 단순 라우팅만 있는 정적 웹페이지의 경우 React를 쓰지 않는 편이 더 낫기도 하다. (React는 지속적으로 데이터가 변화하는 대규모 애플리케이션 구축에 적절하다고 공식 매뉴얼에서 밝히고 있다.)</p><p>React와 Virtual DOM이 주는 최고의 편의성은 <strong>간결한 업데이트 처리</strong>이다. UI를 업데이트 하는 과정에서 발생하는 복잡함을 해소해줄 뿐 아니라, 업데이트에 쉽게 접근할 수 있게 해준다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// index.html</span></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=<span class="string">"en"</span>&gt;</div><div class="line">&lt;head&gt;</div><div class="line">  &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">  &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</div><div class="line">  &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span>&gt;</div><div class="line"></div><div class="line">  &lt;script src=<span class="string">"https://unpkg.com/react@latest/dist/react.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div><div class="line">  &lt;script src=<span class="string">"https://unpkg.com/react-dom@latest/dist/react-dom.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div><div class="line">  &lt;script src=<span class="string">"https://unpkg.com/babel-standalone@6.15.0/babel.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div><div class="line">&lt;<span class="regexp">/head&gt;</span></div><div class="line"><span class="regexp">&lt;body&gt;</span></div><div class="line"><span class="regexp">  &lt;h1&gt;Welcome to React&lt;/</span>h1&gt;</div><div class="line">  &lt;div id=<span class="string">"react-app"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">  &lt;script type=<span class="string">"text/babel"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">BlogPost</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">      <span class="keyword">return</span> (</div><div class="line">        &lt;div&gt;</div><div class="line">          This is a blog post</div><div class="line">        &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">      )</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">  reactDOM.render(</span></div><div class="line"><span class="regexp">  &lt;BlogPost/</span>&gt;,</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'react-app'</span>);</div><div class="line">  );</div><div class="line">&lt;<span class="regexp">/body&gt;</span></div><div class="line"><span class="regexp">&lt;/</span>html&gt;</div></pre></td></tr></table></figure><h2 id="create-react-app"><a href="#create-react-app" class="headerlink" title="create-react-app"></a><a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="external">create-react-app</a></h2><p>간편하게 React 앱을 만들수 있도록 자동으로 빌드해주는 도구이다. 이 패키지를 이용하면 Webpack이나 Babel을 설치하고 구성하는 복잡한 빌드 과정을 생략할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># npm으로 create-react-app 패키지 설치</span></div><div class="line">$ npm install -g create-react-app</div><div class="line"></div><div class="line"><span class="comment"># 패키지를 통해 react 프로젝트를 생성</span></div><div class="line">$ create-react-app my-app(프로젝트이름)</div></pre></td></tr></table></figure><p>명령을 통해 my-app 프로젝트 폴더가 생성된다. 폴더 구조는 아래와 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">my-app</div><div class="line">├── README.md</div><div class="line">├── node_modules</div><div class="line">├── package.json</div><div class="line">├── .gitignore</div><div class="line">├── public <span class="comment"># 서버 public path</span></div><div class="line">│   └── favicon.ico</div><div class="line">│   └── index.html <span class="comment"># 메인 페이지</span></div><div class="line">│   └── manifest.json</div><div class="line">└── src <span class="comment"># React.js 프로젝트 루트</span></div><div class="line">    └── App.css </div><div class="line">    └── App.js <span class="comment"># App 컴포넌트</span></div><div class="line">    └── App.test.js <span class="comment"># test file</span></div><div class="line">    └── index.css</div><div class="line">    └── index.js <span class="comment"># Webpack Entry point</span></div><div class="line">    └── logo.svg</div><div class="line">    └── registerServiceWorker.js</div></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 프로젝트 폴더로 이동</span></div><div class="line">$ <span class="built_in">cd</span> my-app</div><div class="line"></div><div class="line"><span class="comment"># 이후에는 아래 두 가지 방법 중 택1</span></div><div class="line"><span class="comment"># 1. yarn을 이용하는 방법</span></div><div class="line"></div><div class="line">$ npm install -g yarn <span class="comment"># yarn이 설치되어 있다면 생략 가능</span></div><div class="line"></div><div class="line">$ yarn start</div><div class="line"></div><div class="line"><span class="comment"># 2. npm을 이용하는 방법</span></div><div class="line"></div><div class="line">$ npm start</div><div class="line"></div><div class="line"><span class="comment"># 위 작업을 마치면 http://localhost:3000 서버로 React 앱을 열 수 있다.</span></div></pre></td></tr></table></figure><p>코드가 수정되면 자동으로 페이지가 로드되며 콘솔창을 통해 빌드 오류 및 lint 경고가 출력된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 아래 두 명령어 중 택 1로 앱을 번들링하여 배포할 수 있다.</span></div><div class="line"><span class="comment"># 프로덕션용 앱을 build 폴더에 빌드하며 최적의 성능을 위한 최적화(minify)를 진행한다. 빌드가 축소되며 파일이름에 해시가 포함된다. </span></div><div class="line"></div><div class="line">$ yarn build</div><div class="line"></div><div class="line">$ npm run build</div></pre></td></tr></table></figure><p>아래는 자동 생성된 app.js 파일이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// app.js</span></div><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> logo <span class="keyword">from</span> <span class="string">'./logo.svg'</span>;</div><div class="line"><span class="keyword">import</span> <span class="string">'./App.css'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div className=<span class="string">"App"</span>&gt;</div><div class="line">        &lt;div className=<span class="string">"App-header"</span>&gt;</div><div class="line">          &lt;img src=&#123;logo&#125; className=<span class="string">"App-logo"</span> alt=<span class="string">"logo"</span> /&gt;</div><div class="line">          &lt;h2&gt;Welcome to React&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">        &lt;/</span>div&gt;</div><div class="line">        &lt;p className=<span class="string">"App-intro"</span>&gt;</div><div class="line">          To get started, edit &lt;code&gt;src/App.js&lt;<span class="regexp">/code&gt; and save to reload.</span></div><div class="line"><span class="regexp">        &lt;/</span>p&gt;</div><div class="line">      &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">    );</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">export default App;</span></div></pre></td></tr></table></figure><p><br></p><h2 id="import-export"><a href="#import-export" class="headerlink" title="import, export"></a>import, export</h2><p>import는 ES6(ECMA Script 2016)의 문법이다. node의 require()와 동일한 의미이다. 이렇게 모듈을 require하는 방식은 서버단인 node의 방식이다. 클라이언트단에서는 <code>&lt;script&gt;</code>태그를 이용하여 파일을 로드해오는 것이 일반적이다. (require를 지원하지도 않는다.) 하지만 webpack으로 클라이언트에서도 node에서처럼 모듈을 불러올 수 있다. webpack은 import한 모듈을 한 파일로 합치는 번들링(bundling) 작업을 수행하는 모듈 번들러이다. <code>create-react-app</code>의 기본 구성도 webpack이다.</p><p>아래는 <code>create-react-app</code> 패키지의 구성 요소이다.</p><ul><li>webpack with webpack-dev-server, html-webpack-plugin and style-loader</li><li>Babel with ES6 and extensions used by Facebook (JSX, object spread, class properties)</li><li>Autoprefixer</li><li>ESLint</li><li>Jest</li><li>and others.</li></ul><p>기본 문법(syntax)은 <code>import 변수명 from 가져올 모듈의 경로</code>이다. 리액트의 모든 컴포넌트는 필수적으로 react모듈을 import해야 한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// es6</span></div><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span> <span class="comment">// (필수)</span></div><div class="line"><span class="keyword">import</span> <span class="string">'./App'</span></div><div class="line"><span class="comment">// require와 같은 의미이다.</span></div><div class="line"> <span class="comment">// node</span></div><div class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);</div><div class="line"><span class="keyword">var</span> App = <span class="built_in">require</span>(<span class="string">'./App'</span>);</div></pre></td></tr></table></figure><p>경로 작성시 주의할 것이 있다면, React는 경로 맨 앞에 <code>./</code>를 붙이지 않으면 <code>node_modules</code>에서 해당 파일을 찾는다는 점이다. 코드에서 <code>&#39;react&#39;</code>는 <code>node_modules</code>에 있는 리액트 모듈을 가리키며, <code>./App.css</code>는 개발자가 직접 정의한 컴포넌트인 App.js를 가리킨다.</p><p>위와 같이 import하기 위해서는 해당 컴포넌트에 export가 필수적으로 정의되어 있어야 한다. export 선언되지 않은 컴포넌트는 import도 할 수 없다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="keyword">import</span> <span class="string">'./App.css'</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  render()&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;h1&gt;Hello React&lt;<span class="regexp">/h1&gt;</span></div><div class="line"><span class="regexp">    );</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">export default App;</span></div></pre></td></tr></table></figure><p>default로 export되는 컴포넌트에 한해서 아래와 같이 표현할 수도 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="keyword">import</span> <span class="string">'./App.css'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br></p><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p><a href="https://www.webpackbin.com/bins/-KeVMcQWGocAn5VJL6XL" target="_blank" rel="external">webpackbin.com</a>을 통해 간단한 react project를 확인해 볼 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// HelloWorld.js</span></div><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="comment">// stateless Function</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloWorld</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;h1&gt;Hello <span class="keyword">from</span> React!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span> <span class="comment">// JSX 문법</span></div><div class="line">  );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> HelloWorld;</div></pre></td></tr></table></figure><p>React는 일반 js문법과는 다른 xml형태의 JSX 문법을 사용한다. JSX는 자바스크립트로 만든 xml로, HTML과 매우 유사한 모양을 하고 있다. 위 예제에서 자바스크립트 코드 내부에 <code>&quot;</code>나 <code>&#39;</code>없이 HTML 코드가 섞여있는 것을 볼 수 있다. 이와 같은 모양을 JSX라고 하며, React는 JSX문법을 사용하여 UI를 템플릿화한다. 이 코드는 webpack의 babel-loader를 통해 자바스크립트 코드로 번들링된다. 위 코드는 아래와 같이 변환된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">return React.createElement(</div><div class="line">  &quot;h1&quot;,</div><div class="line">  null,</div><div class="line">  &quot;Hello from React!&quot;</div><div class="line">);</div></pre></td></tr></table></figure><p>JSX 문법을 취함으로써 얻는 이점은 다음과 같다.</p><ul><li>JSX는 컴파일링 되면서 최적화되므로 빠른 속도를 자랑한다.</li><li>Type-safe하며 컴파일 과정에서 에러를 감지할 수 있다</li><li>HTML에 익숙하다면 더 쉽고 빠르게 템플릿을 작성할 수 있다.</li></ul><p><br></p><h2 id="컴포넌트-로드하기"><a href="#컴포넌트-로드하기" class="headerlink" title="컴포넌트 로드하기"></a>컴포넌트 로드하기</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123;render&#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"><span class="keyword">import</span> Hello <span class="keyword">from</span> <span class="string">'./HelloWorld.js'</span>;</div><div class="line"></div><div class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">HelloWorld</span>/&gt;</span></span>, <span class="built_in">document</span>.querySelector(<span class="string">'#app'</span>));</div></pre></td></tr></table></figure><p>main.js파일은 webpack의 entry 파일(진입점)으로 번들링 작업이 이루어지는 중심 지점이다. HelloWorld.js에서 만든 컴포넌트를 import하고, 기타 import한 파일들을 재귀적으로 불러와 하나의 파일로 합치는 작업을 수행한 후 페이지에 렌더링한다.</p><p>React 컴포넌트를 페이지에 렌더링할 때는 react-dom 모듈을 불러와 render 함수를 통해 처리한다. render 함수의 첫번째 파라미터는 렌더링할 JSX 형태의 코드로, 여기서는 HelloWorld 컴포넌트를 렌더링한다. 컴포넌트를 만들면 <code>&lt;컴포넌트이름 /&gt;</code>의 형태(HTML의 태그처럼)로 작성할 수 있다. 두번째 파라미터는 렌더링할 HTML 요소이다. 위에서는 <code>index.html</code>의 id값이 app인 요소에 렌더링하도록 설정되었다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- index.html --&gt;</span></div><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 여기에 렌더링한다. --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"main.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><p><br></p><h2 id="컴포넌트에-속성-부여하기"><a href="#컴포넌트에-속성-부여하기" class="headerlink" title="컴포넌트에 속성 부여하기"></a>컴포넌트에 속성 부여하기</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// HelloWorld.js</span></div><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloWorld</span> (<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;h1&gt;Hello &#123;props.name&#125;!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></div><div class="line">  );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> HelloWorld;</div></pre></td></tr></table></figure><p>위 코드는 함수 HelloWorld에 props 파라미터를 부여하고 props.name(props의 name 속성) 값을 JSX 안에서 렌더링하게 하였다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123;render&#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">'./HelloWorld.js'</span>;</div><div class="line"></div><div class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">HelloWorld</span> <span class="attr">name</span>=<span class="string">"World"</span>/&gt;</span>, document.querySelector('#app'));</span></div></pre></td></tr></table></figure><p>main.js에서 렌더링할 때 HelloWorld 컴포넌트에 name 값을 “World”로 설정해주었다. 출력은 아래와 같을 것이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello World!</div></pre></td></tr></table></figure><p><br></p><h2 id="prop-state"><a href="#prop-state" class="headerlink" title="prop, state"></a>prop, state</h2><h3 id="1-Components-and-Props"><a href="#1-Components-and-Props" class="headerlink" title="1) Components and Props"></a>1) Components and Props</h3><p>컴포넌트를 이용해 UI를 독립적이고 재사용 가능한 부분으로 분리할 수 있으며 분리된 각 부분들을 개별적인 것(isolation)으로 생각할 수 있다. component는 view를 생성하는 자바스크립트 함수이다. 컴포넌트는 props라 불리는 임의의 입력을 받고, (prop는 사전적 의미로 ‘소품’이다.) React 요소를 반환한다. 이 요소는 화면에 무엇이 나타나야 하는지(render)를 설명한다.</p><h3 id="2-Props-are-Read-Only"><a href="#2-Props-are-Read-Only" class="headerlink" title="2) Props are Read-Only"></a>2) Props are Read-Only</h3><p>Prop 값은 읽기만 가능한 값이다. 컴포넌트가 함수로 선언되었든, 클래스로 선언되었든 관계 없이 컴포넌트의 prop를 <strong>절대로 수정해서는 안 된다.</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> a + b ;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>위와 같은 함수들은 “pure”하다고 말한다. 입력값을 변경하지 않으며, 동일한 입력에 대해 항상 동일한 결과를 반환하기 때문이다. 위 예제는 a=2, b=3 일 때, 항상 5라는 값을 반환한다. 결과로서 a나 b를 변환하지 않는다. a는 항상 2이며 b도 항상 3이다.</p><p>반면, 아래와 같은 함수는 “impure”하다. 결과값을 반환하면서 input을 스스로 바꿔버리기 때문이다. 이러한 함수는 입력값이 계속 변화함에 따라 결과값도 변화하기 때문에 항상 동일한 결과가 보장되지 않는다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">withdraw</span>(<span class="params">accout, amount</span>) </span>&#123;</div><div class="line">  accout.total -= amount;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>리액트는 상당히 유연하지만 엄격한 규칙이 하나 있다.<br><strong>모든 React 컴포넌트는 props에 관해서는 반드시 pure함수처럼 동작해야 한다.</strong></p><p>물론 어플리케이션 UI는 동적이며 시간의 흐름에 따라 변화한다. state는 React 컴포넌트가 이 규칙을 위반하지 않으면서 (유저의 행동, 네트워크 응답, 그리고 그 외 여러가지 요인들에 대한 응답으로) 시간 경과에 따라 결과값을 변경할 수 있게 한다.</p><blockquote><p>this.prop는 변경할 수 없고 this.state는 변경이 가능하다. 단 setState로만 바꿀 수 있다. immutable은 강제되는 부분은 아니지만 (오류가 발생하지 않는다.) 의도한 대로 동작하게 하기 위해서는 immutable을 지켜주어야 한다.</p></blockquote><h3 id="3-State-and-Life-Cycle"><a href="#3-State-and-Life-Cycle" class="headerlink" title="3) State and Life-Cycle"></a>3) State and Life-Cycle</h3><p>지금까지 배운 바에 의하면, 렌더된 출력을 변경하기 위해 <code>ReactDOM.render()</code>를 호출할 수 있다. 아래는 Live 시계를 만드는 컴포넌트이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> element = (</div><div class="line">    &lt;div&gt;</div><div class="line">      &lt;h1&gt;Hello, World!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></div><div class="line">      &lt;h2&gt;It is &#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">    &lt;/</span>div&gt;</div><div class="line">  );</div><div class="line">  ReactDOM.render(</div><div class="line">    element,</div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</div><div class="line">  );</div><div class="line">&#125;</div><div class="line"></div><div class="line">setInterval(tick, <span class="number">1000</span>);</div></pre></td></tr></table></figure><p>위 <code>clock</code> 코드를 캡슐화하고 재사용하기 위해 컴포넌트화 할 수 있다. 먼저 위 함수는 크게 시계가 화면에 보이게 하는 것과 1초마다 시간이 갱신되게 하는 것으로 두 가지 일을 한다. 다음과 같이 분리할 수 있을 것이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Clock</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;div&gt;</div><div class="line">      &lt;h1&gt;Hello, World!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></div><div class="line">      &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">    &lt;/</span>div&gt;</div><div class="line">  )</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  ReactDOM.render(</div><div class="line">    &lt;Clock data=&#123;<span class="keyword">new</span> <span class="built_in">Date</span>()&#125; /&gt;,</div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</div><div class="line">  );</div><div class="line">&#125;</div><div class="line"></div><div class="line">setInterval(tick, <span class="number">1000</span>);</div></pre></td></tr></table></figure><p>사실 이렇게 분리하는 것은 별로 좋은 방법이 아니다. 위 코드에서는 Clock 함수를 매 초마다 불러내 매번 새로 UI를 업데이트한다. 이상적인 것은 Clock을 한번만 작성하는 것이다. 한번만 작성하면 Clock 함수가 스스로 업데이트 하도록 하는 것이 좋다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ReactDOM.render(</div><div class="line">  &lt;Clock /&gt;,</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</div><div class="line">);</div></pre></td></tr></table></figure><p>이를 구현하려면 clock 구성 요소에 <code>state</code>를 추가해야 한다. State는 props와 유사하지만 private하며 제어권이 완전히 컴포넌트에 있다. 클래스로 정의된 컴포넌트는 몇 가지 추가 기능을 가지고 있다고 하였다. <strong>로컬(Local) state는 클래스 안에서만 사용할 수 있는 기능이다.</strong></p><h3 id="4-Converting-a-Function-to-a-Class"><a href="#4-Converting-a-Function-to-a-Class" class="headerlink" title="4. Converting a Function to a Class"></a>4. Converting a Function to a Class</h3><p>앞에서 정의한 <code>Clock</code>과 같은 함수형 컴포넌트를 클래스 컴포넌트로 변환할 수 있다. 다음 5단계를 거친다.</p><ol><li>React.Component로부터 extends한 동일한 이름의 ES6 클래스를 만든다.</li><li><code>render()</code> 메서드를 추가한다.</li><li>함수 바디를 <code>render()</code> 메서드 내부로 옮긴다.</li><li><code>render()</code> 내부에 정의된 <code>props</code>를 <code>this.props</code>로 바꾼다.</li><li>나머지 빈 함수 선언문을 지운다.</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></div><div class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.props.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">      &lt;/</span>div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>Clock</code>함수가 class로 정의되었다. 이제 local state와 lifecycle hooks과 같은 추가 기능을 사용할 수 있다.</p><h3 id="5-Adding-Local-State-to-a-Class"><a href="#5-Adding-Local-State-to-a-Class" class="headerlink" title="(5) Adding Local State to a Class"></a>(5) Adding Local State to a Class</h3><p>이제 <code>date</code>를 props에서 state로 변환할 차례이다. 아래 3단계를 거친다.</p><p><strong>1.</strong> <code>render()</code>메서드 내부의 <code>this.props.date</code>를 <code>this.state.date</code>로 바꾼다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></div><div class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">      &lt;/</span>div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>2.</strong> <code>this.state</code>의 초기값을 할당하는 class constructor(생성자)를 추가한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></div><div class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">      &lt;/</span>div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>기본 생성자에 <code>props</code> 값을 전달하는 방법은 아래와 같음을 기억해두자.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constructor</span>(props) &#123;</div><div class="line">  <span class="keyword">super</span>(props);</div><div class="line">  <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>클래스 컴포넌트는 항상 <code>props</code>와 함께 기본 생성자(base constructor)를 호출해야 한다.</p><p><strong>3.</strong> <code>&lt;Clock /&gt;</code>요소에서 <code>date</code> prop를 제거한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ReactDOM.render(</div><div class="line">  &lt;Clock /&gt;,</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</div><div class="line">);</div></pre></td></tr></table></figure><p>타이머 코드는 나중에 컴포넌트에 다시 추가할 것이다.<br>지금까지의 결과는 아래와 같다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></div><div class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">      &lt;/</span>div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">  &lt;Clock /&gt;,</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</div><div class="line">);</div></pre></td></tr></table></figure><p><br></p><h3 id="6-Adding-Lifecycle-Methods-to-a-Class"><a href="#6-Adding-Lifecycle-Methods-to-a-Class" class="headerlink" title="(6) Adding Lifecycle Methods to a Class"></a>(6) Adding Lifecycle Methods to a Class</h3><p>위에서는 <code>Clock</code>이 DOM 위에 그려졌다가 사라지는 것을 1초마다 반복한다. <code>Clock</code>이 렌더될 때마다 DOM 위에 타이머를 셋업(set up)하는 것을 리액트에서는 마운팅(Mounting)이라고 한다. 또 DOM 위에서 타이머가 <code>clear</code>될 때마다 <code>Clock</code>을 DOM에서 지우는데, 이를 리액트에서는 unmounting이라고 한다.</p><p>class 컴포넌트에는 마운트 또는 언마운트될 때 특정 코드를 실행하는 메서드가 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">data</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</div><div class="line">  &#125;</div><div class="line">  componentDidMount() &#123;</div><div class="line">    <span class="comment">// 컴포넌트가 마운트 되었다는 의미의 메서드</span></div><div class="line">    <span class="comment">// 컴포넌트가 마운트된 후에 실행된다.</span></div><div class="line"></div><div class="line">  &#125;</div><div class="line">  componentWillMount() &#123;</div><div class="line">    <span class="comment">// 컴포넌트가 마운트 될 것이라는 의미의 메서드</span></div><div class="line">    <span class="comment">// 컴포넌트가 마운트되기 전에 실행된다.</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;h1&gt;Hello world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></div><div class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.data.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">      &lt;/</span>div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>위와 같은 방법을 ‘lifecycle hooks’라고 한다.</p><p><img src="https://velopert.com/wp-content/uploads/2016/03/Screenshot-from-2016-12-10-00-21-26-1-950x610.png" alt="출처: https://velopert.com/1130"></p><p>위 그림은 Lifecycle API를 표현한 것이다. 컴포넌트 생성은 <code>constructor</code> -&gt; <code>componentWillMount</code> -&gt; <code>render</code> 순으로 실행되며, <code>componentDidMount</code>가 가장 마지막에 위치하는 것을 확인할 수 있다.</p><p>다시 타이머로 돌아와서, <code>componentDidMount()</code> hook은 컴포넌트 출력이 DOM에 렌더된 이후에 실행된다. 따라서 이 메서드에 타이머를 넣는 것이 좋은 방법일 것 같다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">componentDidMount() &#123;</div><div class="line">  <span class="keyword">this</span>.timerID = setInterval(</div><div class="line">    () =&gt; <span class="keyword">this</span>.tick(),</div><div class="line">    <span class="number">1000</span></div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>timerID를 어떤 식으로 저장하는지 눈여겨 보자. <code>this.props</code>는 리액트가 자체적으로 설정하지만, <code>this.state</code>는 특별한 의미를 갖기 때문에, 자유롭게 부가적인 필드를 추가할 수 있다. 만약 state를 보이지 않게 하려는 경우라면, 클래스에 수동으로 아래와 같은 필드를 추가할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">componentWillUnmount() &#123;</div><div class="line">  clearInterval(<span class="keyword">this</span>.timerID);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>마지막으로, 1초마다 실행되는 tick() 메서드를 구현해본다.<br><code>this.setState()</code>를 사용하여 컴포넌트의 local state 값을 업데이트할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">data</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  componentDidMount() &#123;</div><div class="line">    <span class="keyword">this</span>.timerID = setInterval(</div><div class="line">      () =&gt; <span class="keyword">this</span>. tick(), <span class="number">1000</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  componentWillUnmount() &#123;</div><div class="line">    clearInterval(<span class="keyword">this</span>.timerID);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  tick() &#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123;</div><div class="line">      date: <span class="keyword">new</span> <span class="built_in">Date</span>()</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></div><div class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">      &lt;/</span>div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">  &lt;Clock /&gt;,</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>);</div><div class="line">);</div></pre></td></tr></table></figure><p>타이머가 완성되었다.</p><p>이제 진행중인 작업과 메서드가 호출되는 순서를 간단히 요약해보자.</p><p><strong>1)</strong> <code>&lt;Clock /&gt;</code>이 <code>ReactDOM.render()</code>에 전달되면 React가 <code>Clock</code> 구성 요소의 생성자를 호출한다. <code>Clock</code>은 현재 시간을 표시해야하므로 <code>this.state</code>를 현재 시간을 포함하는 객체로 초기화한다. 나중에 이 상태를 업데이트 할 것이다.</p><p><strong>2)</strong> 그런 다음 React는 Clock 구성 요소의 <code>render()</code> 메서드를 호출한다. 이 메서드를 통해 React는 화면에 무엇을 표시해야 하는지 알아낸다. 그런 다음 React가 <code>Clock</code>의 렌더링 결과와 일치하도록 DOM을 업데이트한다.</p><p><strong>3)</strong> <code>Clock</code> 출력이 DOM에 삽입되면 React는 <code>componentDidMount()</code> 라이프 사이클 후크를 호출한다. 내부에있는 Clock 컴포넌트는 브라우저에 <code>tick()</code>을 한 번씩 호출하는 타이머를 설정하도록 요청한다.</p><p><strong>4)</strong> 초마다 브라우저에서 <code>tick()</code> 메소드를 호출한다. 그 내부에서 Clock 구성 요소는 현재 시간을 포함하는 객체로 <code>setState()</code>를 호출하여 UI 업데이트를 예약한다. <code>setState()</code> 호출 덕분에 React는 상태가 변경된 것을 알아채고 <code>render()</code> 메서드를 다시 호출하여 화면에 무엇이 있어야 하는지를 파악한다. 이번에는 <code>render()</code> 메서드의 <code>this.state.date</code>가 달라 지므로 렌더 결과에 업데이트 된 시간이 포함된다. React는 그에 따라 DOM을 업데이트한다.</p><p><strong>5)</strong> <code>Clock</code> 컴포넌트가 DOM에서 제거되면 React가 <code>componentWillUnmount()</code> 라이프 사이클 후크를 호출하여 타이머가 중지된다.</p><p><br></p><hr><h3 id="What-is-“Mounting”-in-React-js"><a href="#What-is-“Mounting”-in-React-js" class="headerlink" title="++ What is “Mounting” in React js?"></a>++ What is “Mounting” in React js?</h3><p>React에서 작업하는 컴포넌트는 모두 React 노드와 DOM 노드로 나타낼 수 있다. React노드를 DOM노드로 표시하는 방식, 위치, 시기는 최상위 API에서 관리한다. 아래 예제를 통해 좀 더 쉽게 이해해보자.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> foo = React.createElement(FooComponent);</div></pre></td></tr></table></figure><p>foo는 무엇이고 저 객체로 무엇을 할 수 있는가? 지금 이 시점의 foo는 React 타입인 FooComponent의 인스턴스이다. 즉, 현 시점에서는 페이지 그 어디에도 존재하지 않는다. DOM 요소가 아니므로 DOM 트리 어디에도 존재하지 않는 (React 요소 노드를 제외하고) document 상에서 아무런 의미도 없는 객체이다.</p><p>이 상태에서 <code>React.findDOMNode(foo)</code>를 호출하면, falsy object를 반환할 것이다. 이유가 무엇일까? foo는 DOM 트리에 있을 필요가 없다. 따라서 DOM 표현(representation)을 가지고 있지 않다.</p><p>그러나 React 요소 노드를 document에 마운트(mount)하려고하면 DOM 노드를 만드는 컴포넌트 생명주기가 시작된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">React.render(foo, container);</div></pre></td></tr></table></figure><h2 id="이제-foo는-더이상-React-노드가-아니다-연관되는-DOM-노드가-있으며-현재-document에-속하게-된다-이제-실제-DOM-노드에서-어디서든지-foo를-찾을-수-있고-다른-DOM-요소들과-상호작용할-수-있으며-높이나-너비를-계산하거나-스타일을-적용하거나-jQuery로-전달하는-등-일반적인-DOM-요소처럼-취급할-수-있게-된다"><a href="#이제-foo는-더이상-React-노드가-아니다-연관되는-DOM-노드가-있으며-현재-document에-속하게-된다-이제-실제-DOM-노드에서-어디서든지-foo를-찾을-수-있고-다른-DOM-요소들과-상호작용할-수-있으며-높이나-너비를-계산하거나-스타일을-적용하거나-jQuery로-전달하는-등-일반적인-DOM-요소처럼-취급할-수-있게-된다" class="headerlink" title="이제 foo는 더이상 React 노드가 아니다. 연관되는 DOM 노드가 있으며 현재 document에 속하게 된다. 이제 실제 DOM 노드에서 어디서든지 foo를 찾을 수 있고 다른 DOM 요소들과 상호작용할 수 있으며, 높이나 너비를 계산하거나 스타일을 적용하거나, jQuery로 전달하는 등 일반적인 DOM 요소처럼 취급할 수 있게 된다."></a>이제 foo는 더이상 React 노드가 아니다. 연관되는 DOM 노드가 있으며 현재 document에 속하게 된다. 이제 실제 DOM 노드에서 어디서든지 foo를 찾을 수 있고 다른 DOM 요소들과 상호작용할 수 있으며, 높이나 너비를 계산하거나 스타일을 적용하거나, jQuery로 전달하는 등 일반적인 DOM 요소처럼 취급할 수 있게 된다.</h2><p><br></p><hr><hr><p><strong>Reference</strong></p><p><a href="https://facebook.github.io/react/tutorial/tutorial.html#what-is-react" target="_blank" rel="external">React Document</a></p><p><a href="https://velopert.com/867" target="_blank" rel="external">React Lecture Blog - Korean</a></p><p><a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="external">create-react-app github</a></p><p><a href="https://stackoverflow.com/questions/31556450/what-is-mounting-in-react-js" target="_blank" rel="external">stack overflow - What is “Mounting” in React js?</a></p></section><div class="tags"><span>Tags:</span> <a href="/tags#react"><span class="tag-code">react</span></a></div><div class="qrcode"><canvas id="share-qrcode"></canvas><p class="notice">QR코드를 스캔해서 공유하세요!</p></div></article><aside class="catalog-container"><div class="toc-main"><strong class="toc-title">Catalog</strong><ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-What-is-React"><span class="toc-nav-text">1. What is React?</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-Virtual-DOM"><span class="toc-nav-text">2. Virtual DOM</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-DOM-Document-Object-Model"><span class="toc-nav-text">1) DOM(Document Object Model)</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-Virtual-DOM-1"><span class="toc-nav-text">2) Virtual DOM</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#create-react-app"><span class="toc-nav-text">create-react-app</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#import-export"><span class="toc-nav-text">import, export</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#JSX"><span class="toc-nav-text">JSX</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#컴포넌트-로드하기"><span class="toc-nav-text">컴포넌트 로드하기</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#컴포넌트에-속성-부여하기"><span class="toc-nav-text">컴포넌트에 속성 부여하기</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#prop-state"><span class="toc-nav-text">prop, state</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-Components-and-Props"><span class="toc-nav-text">1) Components and Props</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-Props-are-Read-Only"><span class="toc-nav-text">2) Props are Read-Only</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-State-and-Life-Cycle"><span class="toc-nav-text">3) State and Life-Cycle</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-Converting-a-Function-to-a-Class"><span class="toc-nav-text">4. Converting a Function to a Class</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-Adding-Local-State-to-a-Class"><span class="toc-nav-text">(5) Adding Local State to a Class</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-Adding-Lifecycle-Methods-to-a-Class"><span class="toc-nav-text">(6) Adding Lifecycle Methods to a Class</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#What-is-“Mounting”-in-React-js"><span class="toc-nav-text">++ What is “Mounting” in React js?</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#이제-foo는-더이상-React-노드가-아니다-연관되는-DOM-노드가-있으며-현재-document에-속하게-된다-이제-실제-DOM-노드에서-어디서든지-foo를-찾을-수-있고-다른-DOM-요소들과-상호작용할-수-있으며-높이나-너비를-계산하거나-스타일을-적용하거나-jQuery로-전달하는-등-일반적인-DOM-요소처럼-취급할-수-있게-된다"><span class="toc-nav-text">이제 foo는 더이상 React 노드가 아니다. 연관되는 DOM 노드가 있으며 현재 document에 속하게 된다. 이제 실제 DOM 노드에서 어디서든지 foo를 찾을 수 있고 다른 DOM 요소들과 상호작용할 수 있으며, 높이나 너비를 계산하거나 스타일을 적용하거나, jQuery로 전달하는 등 일반적인 DOM 요소처럼 취급할 수 있게 된다.</span></a></li></ol></div></aside></main><script>(function () {
    var url = 'http://huusz.github.io/2017/React/React/01.basic/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "[React] 리액트 입문하기",
        owner: "",
        repo: "",
        oauth: {
          client_id: "",
          client_secret: ""
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();</script><div class="scroll-top"><span class="arrow-icon"></span></div><footer class="app-footer"><p class="copyright">&copy; 2017 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a><br>Theme by <a href="https://github.com/yanm1ng">yanm1ng</a></p></footer><script>function async(e,n){var t=document,a="script",r=t.createElement(a),c=t.getElementsByTagName(a)[0];r.src=e,n&&r.addEventListener("load",function(e){n(null,e)},!1),c.parentNode.insertBefore(r,c)}</script><script>async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js",function(){FastClick.attach(document.body)})</script><script>var hasLine="true";async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js",function(){$("figure pre").each(function(t,e){var a=$(this).parents("figure");"false"===hasLine&&a.find(".gutter").hide();var s=a.attr("class").split(" ")[1]||"code",i=$(this).html(),h=document.createElement("code");h.className=s,h.innerHTML=i,$(this).attr("class","").empty().html(h),a.attr("data-lang",s.toUpperCase()),hljs.highlightBlock(e)})})</script><script src="/js/script.js"></script></body></html>