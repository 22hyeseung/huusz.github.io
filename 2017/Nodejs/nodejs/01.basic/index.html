<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="마우스 누르는 게 세상에서 제일 귀찮은 휴지의 개발블로그">
  <meta name="keyword" content="huusz, frontend">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      [node] node 시작하기 | 휴지 개발 블로그
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>휴지 개발 블로그</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>[node] node 시작하기</h2>
  <p class="post-date">2017-08-30</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p><img src="http://allvectorlogo.com/img/2016/05/node-js-logo.png" alt=""></p>
<h1 id="nvm-node-version-manager"><a href="#nvm-node-version-manager" class="headerlink" title="nvm(node version manager)"></a>nvm(node version manager)</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 주석: `#`으로 시작하는 명령은 bash에서 무시됩니다.</span></div><div class="line"><span class="comment"># 아래 명령을 한 줄씩 차례대로 입력하세요</span></div><div class="line">$ nvm install 8.4</div><div class="line">$ nvm use 8.4</div><div class="line">$ nvm <span class="built_in">alias</span> default 8.4 <span class="comment"># nvm-windows는 필요없음</span></div></pre></td></tr></table></figure>
<h1 id="Node-js-REPL"><a href="#Node-js-REPL" class="headerlink" title="Node.js REPL"></a>Node.js REPL</h1><p>REPL(Read Eval Print Loop): 윈도우 커맨드, 혹은 UNIX/LINUX Shell처럼 사용자가 커맨드를 입력하면 시스템이 값을 반환하는 환경을 일컫는다. </p>
<p>Node.js는 REPL 환경과 함께 제공되며 다음과 같은 기능을 수행할 수 있다.</p>
<ul>
<li>Read: 유저의 값을 입력 받아 Javascript 데이터 구조로 메모리에 저장한다.</li>
<li>Eval: 데이터를 처리(Evaluate)한다.</li>
<li>Print: 결과값을 출력한다.</li>
<li>Loop: Read, Eval, Print를 유저가 Ctrl+C를 두 번 눌러 종료할 때까지 반복한다.</li>
</ul>
<p>Node.js 의 REPL 환경은 자바스크립트 코드의 테스팅 및 디버깅할 때 유용하게 사용된다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">// REPL 시작하기</div><div class="line">$ node</div><div class="line"></div><div class="line">// 한 줄 짜리 코드 입력하기</div><div class="line">&gt; <span class="string">'hello node'</span></div><div class="line"><span class="string">'hello node'</span></div><div class="line"></div><div class="line">// 위쪽 화살표 키를 입력해서 이전 명령 불러오기</div><div class="line">&gt; <span class="string">'hello node'</span></div><div class="line"><span class="string">'hello node'</span></div><div class="line"></div><div class="line">// Underscore(_) 변수</div><div class="line">밑줄 _변수는 최근 결과값을 지칭한다.</div><div class="line">&gt; var x = 10;</div><div class="line">undefined</div><div class="line">&gt; var y = 5;</div><div class="line">undefined</div><div class="line">&gt; x+y;</div><div class="line">15</div><div class="line">&gt; var sum = _</div><div class="line">undefined</div><div class="line">&gt;console.log(sum)</div><div class="line">15</div><div class="line">undefined</div><div class="line"></div><div class="line">// 변수 사용하기</div><div class="line">&gt; const factorial = n =&gt; n &lt; 1 ? 1 : n * factorial(n-1)</div><div class="line">undefined</div><div class="line"></div><div class="line">&gt; factorial(3)</div><div class="line">6</div><div class="line"></div><div class="line">// 여러 줄에 나눠서 입력하기</div><div class="line">&gt; <span class="keyword">function</span> factorial2(n) &#123;</div><div class="line">... <span class="built_in">return</span> n &lt; 1 ? 1 : n * factorial(n-1)</div><div class="line">... &#125;</div><div class="line">undefined</div><div class="line"></div><div class="line">&gt; factorial2(4)</div><div class="line">24</div><div class="line"></div><div class="line">// `.<span class="built_in">exit</span>`를 입력하거나 `Ctrl+C`를 두 번 입력해서 나가기</div><div class="line">&gt; .<span class="built_in">exit</span></div><div class="line"></div><div class="line">// Node.js module 사용하기</div><div class="line">&gt; const os = require(<span class="string">'os'</span>) // 급할땐 `os = ...`</div><div class="line">undefined</div><div class="line"></div><div class="line">&gt; os.platform()</div><div class="line"><span class="string">'linux'</span></div><div class="line"></div><div class="line">&gt; os.freemem()</div><div class="line">658300928</div></pre></td></tr></table></figure>
<h1 id="node-js로-파일-실행시키기"><a href="#node-js로-파일-실행시키기" class="headerlink" title="node.js로 파일 실행시키기"></a>node.js로 파일 실행시키기</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ node (파일 경로)</div></pre></td></tr></table></figure>
<h1 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h1><p>Node.js®은 chrome의 v8 자바스크립트 엔진에 기반한 자바스크립트 런타임이다.</p>
<p>Node.js는 가볍고 효율적인 event-driven, non-blocking I/O model을 사용한다. </p>
<p>Node.js의 패키지 에코 시스템인 npm은 전 세계 오픈 소스 라이브러리 중 가장 큰 생태계(ecosystem)이다.</p>
<h2 id="1-JavaScript-Runtime이란"><a href="#1-JavaScript-Runtime이란" class="headerlink" title="1) JavaScript Runtime이란?"></a>1) JavaScript Runtime이란?</h2><ul>
<li>JavaScript는 언어</li>
<li>JavaScript 런타임(runtime)은 JS를 구동하기 위해 필요한 실행 환경</li>
<li>프로그래머는 런타임이 제공하는 도구를 응용해서 프로그램을 개발</li>
<li>웹 브라우저나 Node.js도 JavaScript 런타임의 일종</li>
</ul>
<h2 id="2-JavaScript-Runtime-종류"><a href="#2-JavaScript-Runtime-종류" class="headerlink" title="2) JavaScript Runtime 종류"></a>2) JavaScript Runtime 종류</h2><ul>
<li>Chrome이 제공하는 웹 브라우저용 런타임</li>
<li>Node.js가 제공하는 서버용 런타임</li>
<li>MongoDB가 제공하는 데이터 처리용 런타임</li>
<li>Photoshop이 제공하는 전용 런타임<br>…</li>
</ul>
<h1 id="V8-JavaScript-Engine"><a href="#V8-JavaScript-Engine" class="headerlink" title="V8 JavaScript Engine"></a>V8 JavaScript Engine</h1><p>JIT(Just-In-Time) compilation<br>Code Optimization<br>Used in<br>Google Chrome<br>Node.js<br>MongoDB<br>…</p>
<h2 id="V8-엔진의-작동-방식"><a href="#V8-엔진의-작동-방식" class="headerlink" title="V8 엔진의 작동 방식?"></a>V8 엔진의 작동 방식?</h2><h3 id="1-Event-driven-Programming"><a href="#1-Event-driven-Programming" class="headerlink" title="1) Event-driven Programming"></a>1) Event-driven Programming</h3><p>프로그램의 흐름이 외부 요인에 의해 일어나는 사건에 의해 결정되는 프로그래밍 양식<br>약속된 방식으로 이벤트 핸들러를 작성함으로써 외부 이벤트가 일어났을 때 코드를 실행  </p>
<ul>
<li>마우스 입력</li>
<li>키보드 입력</li>
<li>다른 프로그램/컴퓨터로부터의 통신</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// DOM 이벤트 핸들러 등록 (웹 브라우저)</span></div><div class="line">domElement.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  e.stopPropagation()</div><div class="line">  alert(<span class="string">'hello'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 서버도 똑같이 합니다.</span></div><div class="line"><span class="comment">// (단, 프레임워크를 쓸 때는 직접 이벤트를 다룰 일이 별로 없음)</span></div><div class="line"><span class="comment">// HTTP 응답 이벤트 핸들러 등록 (Node.js)</span></div><div class="line">httpResponse.on(<span class="string">'data'</span>, data =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(data)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="2-Non-blocking-I-O"><a href="#2-Non-blocking-I-O" class="headerlink" title="2) Non-blocking I/O"></a>2) Non-blocking I/O</h3><p>Blocking I/O는 스레드가 입력/출력이 완료될 때까지 기다렸다가 다음 코드를 실행  </p>
<p>Non-blocking I/O는 스레드가 입력/출력을 기다리지 않고 코드를 계속 실행  </p>
<p>순차적으로 실행되다가 기다려야 할 상황이 오면 코드 실행을 멈추고 그 상황이 완료된 이후에 코드를 실행하지만, 어떤 프로그래밍 언어나 기술들은 코드가 기다려야 하는 상황이 왔을 때, 그에 대한 신호만 주고 다음 코드를 계속 실행한다. 이전 코드가 완료되기를 기다렸다가 실행하는 것이 blocking I/O라고 하며 기다리지 않고 계속 실행하는 것을 non-blocking I/O라고 한다.</p>
<p>non-blocking의 단점은 코드가 복잡해질 수 있다는 점이다. (이러한 복잡함을 해결해주는 도구가 promise이다.)</p>
<p><strong>I/O 성능 향상 &amp; 복잡한 코드</strong>  </p>
<h1 id="Node-js-Module"><a href="#Node-js-Module" class="headerlink" title="Node.js Module"></a>Node.js Module</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// name.js</span></div><div class="line"></div><div class="line"><span class="comment">// `module.exports`에 저장한 값은 다른 모듈에서 불러올 수 있음</span></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  familyName: <span class="string">'김'</span>,</div><div class="line">  givenName: <span class="string">'승하'</span>,</div><div class="line">  fullName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.familyName + <span class="keyword">this</span>.givenName</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// calc.js</span></div><div class="line"></div><div class="line"><span class="comment">// `exports`로도 참조 가능</span></div><div class="line">exports.add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y</div><div class="line">exports.sub = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x - y</div></pre></td></tr></table></figure>
<h1 id="REPL에서-불러오기"><a href="#REPL에서-불러오기" class="headerlink" title="REPL에서 불러오기"></a>REPL에서 불러오기</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// Node.js 내장 모듈과는 다르게 경로를 지정해야 함</div><div class="line">&gt; const name = require(&apos;./name&apos;)</div><div class="line">undefined</div><div class="line">&gt; name</div><div class="line">&#123; familyName: &apos;김&apos;,</div><div class="line">  givenName: &apos;승하&apos;,</div><div class="line">  fullName: [Function: fullName] &#125;</div><div class="line">&gt; name.familyName</div><div class="line">&apos;김&apos;</div><div class="line">&gt; name.fullName()</div><div class="line">&apos;김승하&apos;</div><div class="line">&gt; require(&apos;./calc&apos;).add(1, 2)</div><div class="line">3</div></pre></td></tr></table></figure>
<p><strong>브라우저에서는 전역변수를 쓰면 위험하다</strong><br>script1.js 파일에 var evil = 1; 이라는 전역 변수를 선언하면 script2.js 파일에서도 evil을 참조할 수 있게 된다.<br>하지만 nodejs는 조금 다르다. nodejs 모듈은 각각의 스코프(scope)가 따로 존재한다. 따라서 module1.js에서 var evil = 1;이라고 선언하더라도 전역에 선언되는 것이 아닌, module1이라는 모듈 내의 스코프에서만 존재하기 때문에 다른 모듈에서 접근할 수 없다. 따라서 export하지 않으면 다른 모듈에서 해당 변수에 접근할 수 없다.</p>
<h1 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h1><p>Node.js 패키지 관리 도구 + 클라우드 패키지 저장소</p>
<ul>
<li>의존 패키지 관리</li>
<li>스크립트 실행</li>
<li>패키지 설정</li>
<li>NPM에 패키지 배포</li>
<li>Node.js 종합 작업 도구</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$ mkdir hello-npm</div><div class="line">$ <span class="built_in">cd</span> hello-npm</div><div class="line">$ npm init -y</div><div class="line">$ code .</div><div class="line">// package.json</div><div class="line">&#123;</div><div class="line">  <span class="string">"name"</span>: <span class="string">"hello-npm"</span>,</div><div class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</div><div class="line">  <span class="string">"description"</span>: <span class="string">""</span>,</div><div class="line">  <span class="string">"main"</span>: <span class="string">"index.js"</span>,</div><div class="line">  <span class="string">"scripts"</span>: &#123;</div><div class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="string">"keywords"</span>: [],</div><div class="line">  <span class="string">"author"</span>: <span class="string">""</span>,</div><div class="line">  <span class="string">"license"</span>: <span class="string">"ISC"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h1><p>패키지 정보를 담고 있는 파일</p>
<p><strong>dependencies</strong><br><code>npm install --save</code> 명령으로 설치한 패키지가 기록됨  </p>
<p><strong>scripts</strong><br>원래 목적은 패키지 생명주기마다 자동으로 실행되는 명령을 등록하기 위함이나, 개발자 편의를 위해 자주 사용되는 명령을 등록하는 용도로 더 많이 사용됨  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save randomstring <span class="comment"># node_modules에 저장됨</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// index.js</span></div><div class="line"><span class="keyword">const</span> randomstring = <span class="built_in">require</span>(<span class="string">'randomstring'</span>)</div><div class="line"><span class="built_in">console</span>.log(randomstring.generate())</div></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// package.json</div><div class="line">...</div><div class="line">  "scripts": &#123;</div><div class="line">    "start": "node index.js"</div><div class="line">  &#125;</div><div class="line">...</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm start</div></pre></td></tr></table></figure>
<h1 id="Concurrency-Model-동시성-모델"><a href="#Concurrency-Model-동시성-모델" class="headerlink" title="Concurrency Model(동시성 모델)"></a>Concurrency Model(동시성 모델)</h1><p>프로그램이 생애 주기가 겹치는 여러 실행 과정을 통해 실행된다 하더라도 프로그램의 결과에는 영향을 미치지 않는 성질</p>
<p>생애 주기가 겹치는 여러 실행 과정이 자원을 공유할 때 어떻게 충돌이 생기지 않도록 할 것인가?</p>
<h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><ul>
<li>CPU</li>
<li>메모리</li>
<li>네트워크</li>
<li>…</li>
</ul>
<h1 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h1><p>코드 실행의 가장 작은 단위</p>
<p>프로그램은 하나 이상의 스레드로 이루어짐</p>
<p>CPU 코어 하나는 한 번에 하나의 스레드를 실행</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ sysctl -n hw.ncpu <span class="comment"># OSX</span></div><div class="line">$ nproc <span class="comment"># linux</span></div><div class="line">$ mmc devmgmt.msc <span class="comment"># Windows</span></div><div class="line">$ top -H <span class="comment"># Shows the total number of threads</span></div></pre></td></tr></table></figure>
<h1 id="동시성을-위한-도구"><a href="#동시성을-위한-도구" class="headerlink" title="동시성을 위한 도구"></a>동시성을 위한 도구</h1><p>자원의 공유를 위해 프로그래밍 언어는 언어들만이 가지고 있는 동시성을 위한 도구를 가지고 있는 경우가 많다.</p>
<h2 id="1-운영체제-차원의-도구"><a href="#1-운영체제-차원의-도구" class="headerlink" title="1) 운영체제 차원의 도구"></a>1) 운영체제 차원의 도구</h2><ul>
<li>Process</li>
<li>Thread</li>
<li>Mutex (Mutual Exclusion)</li>
</ul>
<h2 id="2-언어-차원의-도구"><a href="#2-언어-차원의-도구" class="headerlink" title="2) 언어 차원의 도구"></a>2) 언어 차원의 도구</h2><ul>
<li>Python - asyncio</li>
<li>Go - goroutine</li>
<li>Erlang - actor</li>
<li>JavaScript - …?</li>
</ul>
<p><br></p>
<h1 id="자바스크립트의-동시성"><a href="#자바스크립트의-동시성" class="headerlink" title="자바스크립트의 동시성"></a>자바스크립트의 동시성</h1><h2 id="Single-Threaded-Event-Loop"><a href="#Single-Threaded-Event-Loop" class="headerlink" title="Single-Threaded Event Loop"></a>Single-Threaded Event Loop</h2><p><strong>자바스크립트를 실행시키는 스레드가 하나 뿐이다.</strong><br>실행 과정(보통 콜백 연쇄)의 생애 주기가 겹칠 수는 있지만 어떤 경우에도 두 자바스크립트 실행과정이 동시에 실행되는 경우는 없음. 내부적으로 메시지 큐를 활용하고 있으나, 모든 처리가 자동으로 이루어짐</p>
<p>!MDN[<a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/EventLoop" target="_blank" rel="external">https://developer.mozilla.org/ko/docs/Web/JavaScript/EventLoop</a>]</p>
<h2 id="1-장점"><a href="#1-장점" class="headerlink" title="1) 장점"></a>1) 장점</h2><ul>
<li>프로그래머가 동시성에 대해 신경쓸 필요가 없어짐</li>
<li>프로그램 작성이 쉬워짐</li>
</ul>
<h2 id="2-단점"><a href="#2-단점" class="headerlink" title="2) 단점"></a>2) 단점</h2><ul>
<li>CPU를 많이 쓰는 작업에 부적절</li>
<li>오래 걸리는 자바스크립트 코드가 실행되면 전체 프로그램에 영향을 미침</li>
</ul>
<h2 id="3-전략"><a href="#3-전략" class="headerlink" title="3) 전략"></a>3) 전략</h2><p>브라우저는 API가 있다면 API에 위임, 노드js는 c/c++로 만들어진 모듈을 가져와서 사용할 수 있는 방법이 있다.</p>
<ul>
<li>오래 걸리는 일은 외부에 위임하고 넘어간 뒤, 나중에 결과를 받아 처리하기<ul>
<li>Database</li>
<li>Node.js - External libraries</li>
<li>Web browser - WebAssembly</li>
</ul>
</li>
<li>긴 실행과정을 <strong>여러 개의 함수로 쪼개서</strong> 한 번의 함수 실행이 금방 끝나게 만들기</li>
</ul>
<p><br></p>
<h1 id="Asynchronous-JavaScript"><a href="#Asynchronous-JavaScript" class="headerlink" title="Asynchronous JavaScript"></a>Asynchronous JavaScript</h1><p>non-blocking과 asynchronous는 비슷한 맥락이다. 다만, non-blocking은 코드의 실행 순서에 대한 개념이고, asynchronous는 코드 작성 방식에 대한 개념이다.</p>
<ul>
<li>함수를 호출할 때, 콜백까지 같이 인자에 넣어서 호출하는 비동기 프로그래밍 양식</li>
<li>콜백에서 에러 인자를 받는 방식으로 에러 처리를 함</li>
<li>Node.js 내장 모듈 전체가 이 방식을 사용하도록 만들어져 있음</li>
<li>주의! 모든 콜백이 비동기인 것은 아님</li>
</ul>
<hr>
<h1 id="비동기식-코드의-에러처리-관습"><a href="#비동기식-코드의-에러처리-관습" class="headerlink" title="비동기식 코드의 에러처리: 관습"></a>비동기식 코드의 에러처리: 관습</h1><p>try-catch는 동기식 에러처리 시에만 사용한다. 비동기식 에러 처리는 관습적으로 아래 방식을 사용한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//readFile.js</span></div><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>); <span class="comment">// Node.js 내장 모듈</span></div><div class="line">fs.readFile(<span class="string">'./calc.js'</span>, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</div><div class="line">  <span class="comment">// 에러처리</span></div><div class="line">  <span class="keyword">if</span>(err) &#123; <span class="comment">//error가 있으면</span></div><div class="line">    <span class="built_in">console</span>.error(err);</div><div class="line">  &#125;<span class="keyword">else</span> &#123; <span class="comment">//errro가 없으면 </span></div><div class="line">    <span class="built_in">console</span>.data(data);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'done!'</span>);</div></pre></td></tr></table></figure>
<h1 id="동기식-코드의-에러-처리-일반적인-방식으로-처리"><a href="#동기식-코드의-에러-처리-일반적인-방식으로-처리" class="headerlink" title="동기식 코드의 에러 처리: 일반적인 방식으로 처리"></a>동기식 코드의 에러 처리: 일반적인 방식으로 처리</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//readFileSync.js</span></div><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>); <span class="comment">// Node.js 내장 모듈</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">const</span> data = fs.readFileSync(<span class="string">'./calc.js'</span>, <span class="string">'utf8'</span>);</div><div class="line">  <span class="built_in">console</span>.log(data);</div><div class="line">&#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">  <span class="built_in">console</span>.log(err);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'done!'</span>);</div></pre></td></tr></table></figure>
<hr>
<p>위 예제에서 readFile.js는 비동기 방식이며 readFileSync는 동기 방식으로 동작하는 코드이다. 코드를 실행 한 후 결과를 보면, </p>
<ul>
<li>readFile.js</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">done</span>!</div><div class="line">&#123; Error: ENOENT: no such file or directory, open <span class="string">'./calc.js'</span> errno: -2, code: <span class="string">'ENOENT'</span>, syscall: <span class="string">'open'</span>, path: <span class="string">'./calc.js'</span> &#125;</div></pre></td></tr></table></figure>
<p>비동기 방식에서는 마지막 줄의 <code>console.log(&#39;done!&#39;)</code>코드가 이전 코드의 실행이 완료될 때까지 기다리지 않고 먼저 실행된다.</p>
<ul>
<li>readFileSync.js</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123; Error: ENOENT: no such file or directory, open <span class="string">'./calc.js'</span></div><div class="line">    at Object.fs.openSync (fs.js:652:18)</div><div class="line">    at Object.fs.readFileSync (fs.js:553:33)</div><div class="line">    at Object.&lt;anonymous&gt; (/Users/ihyeseung/projectfolder/fastcam/frontstudy/nodejs/practice/readFileSync.js:4:19)</div><div class="line">    at Module._compile (module.js:573:30)</div><div class="line">    at Object.Module._extensions..js (module.js:584:10)</div><div class="line">    at Module.load (module.js:507:32)</div><div class="line">    at tryModuleLoad (module.js:470:12)</div><div class="line">    at Function.Module._load (module.js:462:3)</div><div class="line">    at Function.Module.runMain (module.js:609:10)</div><div class="line">    at startup (bootstrap_node.js:158:16) errno: -2, code: <span class="string">'ENOENT'</span>, syscall: <span class="string">'open'</span>, path: <span class="string">'./calc.js'</span> &#125;</div><div class="line"><span class="keyword">done</span>!</div></pre></td></tr></table></figure>
<p>동기 방식에서는 <code>console.log(&#39;done!&#39;)</code>이 이전 코드의 실행이 완료될때까지 기다린 후 실행되었다.</p>
<p><br></p>
<h1 id="Github-REST-API-호출"><a href="#Github-REST-API-호출" class="headerlink" title="Github REST API 호출"></a>Github REST API 호출</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//request.js</span></div><div class="line"></div><div class="line"><span class="comment">// 유저 이름, 저장소, 할당된 이슈 갯수 출력하기</span></div><div class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>)</div><div class="line"><span class="keyword">const</span> apiUrl = <span class="string">'https://api.github.com'</span></div><div class="line"><span class="keyword">const</span> option = &#123;</div><div class="line">  json: <span class="literal">true</span>,</div><div class="line">  auth: &#123;</div><div class="line">    <span class="string">'user'</span>: <span class="string">'username'</span>, <span class="comment">// github 유저네임</span></div><div class="line">    <span class="string">'pass'</span>: <span class="string">'password'</span>, <span class="comment">// github 비밀번호</span></div><div class="line">  &#125;,</div><div class="line">  headers: &#123;</div><div class="line">    <span class="string">'User-Agent'</span>: <span class="string">'request'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">request.get(<span class="string">`<span class="subst">$&#123;apiUrl&#125;</span>/user`</span>, option, <span class="function"><span class="keyword">function</span> (<span class="params">error, response, body</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> name = body.name</div><div class="line">  <span class="keyword">if</span> (error) <span class="built_in">console</span>.error(error)</div><div class="line">  <span class="comment">// 콜백 안에 콜백</span></div><div class="line">  request.get(<span class="string">`<span class="subst">$&#123;apiUrl&#125;</span>/user/repos`</span>, option, <span class="function"><span class="keyword">function</span> (<span class="params">error, response, body</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (error) <span class="built_in">console</span>.error(error)</div><div class="line">    <span class="keyword">const</span> repoNames = body.map(<span class="function"><span class="params">item</span> =&gt;</span> item.name)</div><div class="line">    <span class="comment">// 콜백 안에 콜백 안에 콜백</span></div><div class="line">    request.get(<span class="string">`<span class="subst">$&#123;apiUrl&#125;</span>/issues`</span>, option, <span class="function"><span class="keyword">function</span> (<span class="params">error, response, body</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (error) <span class="built_in">console</span>.error(error)</div><div class="line">      <span class="keyword">const</span> issueNum = body.length</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">`name: <span class="subst">$&#123;name&#125;</span>`</span>)</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'repos:'</span>)</div><div class="line">      repoNames.forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(name)</div><div class="line">      &#125;)</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">`num of assigned issues: <span class="subst">$&#123;issueNum&#125;</span>`</span>)</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ node request.js</div></pre></td></tr></table></figure>
<h2 id="Callback-Hell"><a href="#Callback-Hell" class="headerlink" title="Callback Hell"></a>Callback Hell</h2><p><img src="https://image.slidesharecdn.com/promisesandchaininginangularjs-141027044455-conversion-gate02/95/promises-and-chaining-in-angularjs-into-callback-hell-and-back-again-17-638.jpg?cb=1414385382" alt="callback hell"></p>
<p><br></p>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>비동기 작업의 결과를 담는 객체<br>정확히 언제가 될지 모르지만, 결국 성공 또는 실패의 상태를 갖게 되며 이 상태가 되었을 때 비로소 콜백을 실행하라는 명령을 갖게 된다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tenSec.js</span></div><div class="line"></div><div class="line"><span class="comment">// 10초 뒤에 콜백(promise 객체를 새로 만들어서 리턴)을 실행하는 함수</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">tenSec</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      resolve(value)</div><div class="line">    &#125;, <span class="number">10000</span>)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; const tenSec = require(&apos;./tenSec&apos;)</div><div class="line">&gt; const p = tenSec(1) // p에 Promise 저장</div><div class="line">&gt; p // 만든지 10초가 지나기 전</div><div class="line">Promise &#123;</div><div class="line">  [pending], //pending: 아직 결과가 나오지 않음.</div><div class="line">  ...</div><div class="line">&gt; p // 만든지 10초가 지난 후</div><div class="line">Promise &#123;</div><div class="line">  1,</div><div class="line">  ...</div></pre></td></tr></table></figure>
<h2 id="1-promise의-상태-state"><a href="#1-promise의-상태-state" class="headerlink" title="1) promise의 상태(state)"></a>1) promise의 상태(state)</h2><ul>
<li><p>pending<br>아직 수행 중인 상태 (fulfilled 혹은 rejected 되기 전)</p>
</li>
<li><p>fulfilled<br>promise가 지켜진(수행된) 상태</p>
</li>
<li><p>rejected<br>promise가 지켜지지 못한(거부된) 상태</p>
</li>
<li><p>settled<br>fulfilled이든 rejected이든 결론이 난 상태</p>
</li>
</ul>
<h2 id="2-then"><a href="#2-then" class="headerlink" title="2) .then"></a>2) .then</h2><p>promise 객체의 메서드</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; tenSec(&apos;hello promise&apos;).then(value =&gt; &#123;</div><div class="line">... console.log(value)</div><div class="line">... &#125;)</div><div class="line">Promise &#123; // `then`은 Promise를 반환</div><div class="line">  [pending],</div><div class="line">  ...</div><div class="line">&gt; // 10초 후</div><div class="line">&apos;hello promise&apos;</div></pre></td></tr></table></figure>
<p>new Promise ()의 결과는 promise이다.<br>.then 메소드에서 반환된 값도 promise이다.<br>따라서 .then 메소드를 계속 사용할 수 있다.<br>.then 메소드를 쓰면 들여쓰기를 하지 않아도 된다.<br>따라서 Callback Hell을 피할 수 있다.</p>
<p>return은 바로 실행되는 동기식 작업이다. </p>
<p>비동기 작업을 하려면 콜백을 통해서 해야 했다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>()</div><div class="line">.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line">  request.get( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">  &#125;)</div><div class="line"><span class="keyword">return</span> <span class="comment">// 콜백은 함수 밖에서 리턴이 불가하다</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>promise는 함수 밖에서 리턴해야 하는데 위와 같은 콜백 방식에서는 함수 밖에서 리턴이 불가하다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>()</div><div class="line">.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line">  </div><div class="line">&#125;)</div><div class="line">.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line"></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="3-Promise-chaining"><a href="#3-Promise-chaining" class="headerlink" title="3) Promise chaining"></a>3) Promise chaining</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// chaining.js</span></div><div class="line"><span class="keyword">const</span> tenSec = <span class="built_in">require</span>(<span class="string">'./tenSec'</span>)</div><div class="line">tenSec(<span class="string">'hello promise'</span>)</div><div class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(value)</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="comment">// 위 `.then`은 값이 1인 Promise를 반환함</span></div><div class="line">  &#125;)</div><div class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(value) <span class="comment">// value = 1</span></div><div class="line">    <span class="keyword">return</span> tenSec(<span class="string">'new promise'</span>) <span class="comment">// Promise도 반환할 수 있음</span></div><div class="line">  &#125;) <span class="comment">// 안에 들어 있는 값이 value(=1)인 Promise 생성</span></div><div class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="comment">// tenSec이 실행되고 10초 후 실행됨</span></div><div class="line">    <span class="built_in">console</span>.log(value)</div><div class="line">  &#125;)</div><div class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">//promise 안에서 에러가 나면</span></div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error in promise'</span>)</div><div class="line">  &#125;)</div><div class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="comment">// 에러가 나면 catch 내부 코드 실행, 안나면 통과</span></div><div class="line">    <span class="built_in">console</span>.error(err)</div><div class="line">  &#125;)</div><div class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 에러 처리 이후에도 코드 실행 가능</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'done'</span>)</div><div class="line">  &#125;)</div></pre></td></tr></table></figure>
<hr>
<h3 id="기타-메소드"><a href="#기타-메소드" class="headerlink" title="기타 메소드"></a>기타 메소드</h3><ul>
<li>Promise.all(Arr): 모든 프라미스가 성공해야 성공하는 promise</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pa = <span class="built_in">Promise</span>.all([p1, p2])</div><div class="line"><span class="comment">// pa는 p1, p2가 모두 성공해야 성공하는 Promise이다.</span></div></pre></td></tr></table></figure>
<ul>
<li>Promise.race(Arr): 가장 빨리 성공하는 promise를 반환</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pr = <span class="built_in">Promise</span>.race([p1, pw])</div></pre></td></tr></table></figure>
<ul>
<li>promisify 함수</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// readfilePromise.js</span></div><div class="line"><span class="keyword">const</span> &#123;promisify&#125; = <span class="built_in">require</span>(<span class="string">'util'</span>) <span class="comment">// Node.js 8.0.0부터 추가됨</span></div><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="keyword">const</span> readFile = promisify(fs.readFile)</div><div class="line">readFile(<span class="string">'./calc.js'</span>, <span class="string">'utf8'</span>)</div><div class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(data)</div><div class="line">  &#125;)</div><div class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.error(err)</div><div class="line">  &#125;)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; Error: ENOENT: no such file or directory, open &apos;./calc.js&apos; errno: -2, code: &apos;ENOENT&apos;, syscall: &apos;open&apos;, path: &apos;./calc.js&apos; &#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="4-Promise의-특징"><a href="#4-Promise의-특징" class="headerlink" title="4) Promise의 특징"></a>4) Promise의 특징</h2><p>1) 이미 resolve 된 Promise에도 콜백을 실행할 수 있음</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">const</span> resolved = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</div><div class="line">&gt; resolved.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</div></pre></td></tr></table></figure>
<p>2) <code>.then</code>에 넘겨진 콜백은 (비동기가 아니라 바로 성공하도록 만들어진 동기식 promise라 하더라도)무조건 다음 루프에 실행됨</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">... Promise.resolve(<span class="number">1</span>).then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</div><div class="line">... console.log(<span class="string">'done!'</span>)</div><div class="line">... &#125;)()</div><div class="line"><span class="comment">/* 출력:</span></div><div class="line"><span class="comment">done! -&gt; 먼저 출력된다.</span></div><div class="line"><span class="comment">1</span></div><div class="line"><span class="comment">*/</span></div></pre></td></tr></table></figure>
<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// npm install --save request-promise</span></div><div class="line"><span class="keyword">const</span> rp = <span class="built_in">require</span>(<span class="string">'request-promise'</span>)</div><div class="line"><span class="keyword">const</span> apiUrl = <span class="string">'https://api.github.com'</span></div><div class="line"><span class="keyword">const</span> option = &#123;</div><div class="line">  json: <span class="literal">true</span>,</div><div class="line">  auth: &#123;</div><div class="line">    <span class="string">'user'</span>: <span class="string">'username'</span>,</div><div class="line">    <span class="string">'pass'</span>: <span class="string">'password'</span>,</div><div class="line">  &#125;,</div><div class="line">  headers: &#123;</div><div class="line">    <span class="string">'User-Agent'</span>: <span class="string">'request'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> userPromise = rp.get(<span class="string">`<span class="subst">$&#123;apiUrl&#125;</span>/user`</span>, option)</div><div class="line"><span class="keyword">const</span> reposPromise = rp.get(<span class="string">`<span class="subst">$&#123;apiUrl&#125;</span>/user/repos`</span>, option)</div><div class="line"><span class="keyword">const</span> issuesPromise = rp.get(<span class="string">`<span class="subst">$&#123;apiUrl&#125;</span>/issues`</span>, option)</div><div class="line"></div><div class="line"><span class="comment">// 배열 내의 모든 Promise 객체가 완료되었을 때</span></div><div class="line"><span class="comment">// resolve 되는 Promise를 만든다.</span></div><div class="line"><span class="built_in">Promise</span>.all([userPromise, reposPromise, issuesPromise])</div><div class="line">  .then(<span class="function">(<span class="params">[user, repos, issues]</span>) =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`name: <span class="subst">$&#123;user.name&#125;</span>`</span>)</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'repos:'</span>)</div><div class="line">    repos.forEach(<span class="function"><span class="params">repo</span> =&gt;</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(repo.name)</div><div class="line">    &#125;)</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`num of assigned issues: <span class="subst">$&#123;issues.length&#125;</span>`</span>)</div><div class="line">  &#125;)</div></pre></td></tr></table></figure>
<p>비동기 코드와 동일한 일을 promise로 할 수 있으며 promise를 이용하면 좀 더 깔끔하게 코드를 짤 수 있다.</p>
<blockquote>
<ul>
<li><a href="http://hacks.mozilla.or.kr/2015/05/this-api-is-so-fetching/" target="_blank" rel="external">Fetch API</a><ul>
<li>window.fetch polyfill: Fetch API를 IE에서도 사용할 수 있게 해준다.</li>
</ul>
</li>
</ul>
</blockquote>
<p><br></p>
<h1 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async/Await"></a>Async/Await</h1><ul>
<li>ES2017에서 도입되어, 비동기식 코드를 동기식 코드처럼 쓸 수 있는 문법 제공</li>
<li>Chrome 55, Node.js 8.0.0 부터 사용가능<br>(아주 최근에 나온 문법이므로, 아직까지는 비동기식 코드에 promise가 더 널리 쓰인다.)</li>
<li>async function 안에서 반환된 값은 최종적으로 Promise 객체로 변환되어 반환된다.</li>
<li>async function 안에서 쓸 수 있는 await 키워드는 현재 함수를 중단시키고 Promise 객체가 충족될 때까지 기다리지만, 스레드를 block 하지 않는다.</li>
<li>에러 처리는 동기식 코드처럼 try, catch 블록을 통해서 한다.</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> tenSec = <span class="built_in">require</span>(<span class="string">'./tenSec'</span>)</div><div class="line"></div><div class="line"><span class="comment">//await는 async 함수 안에서만 사용할 수 있다.</span></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveAfterTenSec</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">await</span> tenSec()</div><div class="line">  <span class="keyword">return</span> <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">resolveAfterTenSec().then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(value)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="1-readFile-async-await"><a href="#1-readFile-async-await" class="headerlink" title="1) readFile - async/await"></a>1) readFile - async/await</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// readfileAsync.js</span></div><div class="line"><span class="keyword">const</span> &#123;promisify&#125; = <span class="built_in">require</span>(<span class="string">'util'</span>) <span class="comment">// Node.js 8.0.0부터 추가됨</span></div><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="keyword">const</span> readFile = promisify(fs.readFile)</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">readFileAsync</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> readFile(<span class="string">'./calc.js'</span>, <span class="string">'utf8'</span>)</div><div class="line">    <span class="built_in">console</span>.log(data)</div><div class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    <span class="built_in">console</span>.error(e)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">readFileAsync()</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; Error: ENOENT: no such file or directory, open &apos;./calc.js&apos; errno: -2, code: &apos;ENOENT&apos;, syscall: &apos;open&apos;, path: &apos;./calc.js&apos; &#125;</div></pre></td></tr></table></figure>
<hr>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#nvm" >
    <span class="tag-code">nvm</span>
  </a>

      </div>
    
    <!-- QR code START -->
    <div class="qrcode">
      <canvas id="share-qrcode"></canvas>
      <p class="notice">QR코드를 스캔해서 공유하세요!</p>
    </div>
    <!-- QR code END -->
    
      <!-- Gitment START -->
      <div id="comments"></div>
      <!-- Gitment END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#nvm-node-version-manager"><span class="toc-nav-text">nvm(node version manager)</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Node-js-REPL"><span class="toc-nav-text">Node.js REPL</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#node-js로-파일-실행시키기"><span class="toc-nav-text">node.js로 파일 실행시키기</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#node-js"><span class="toc-nav-text">node.js</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-JavaScript-Runtime이란"><span class="toc-nav-text">1) JavaScript Runtime이란?</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-JavaScript-Runtime-종류"><span class="toc-nav-text">2) JavaScript Runtime 종류</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#V8-JavaScript-Engine"><span class="toc-nav-text">V8 JavaScript Engine</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#V8-엔진의-작동-방식"><span class="toc-nav-text">V8 엔진의 작동 방식?</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-Event-driven-Programming"><span class="toc-nav-text">1) Event-driven Programming</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-Non-blocking-I-O"><span class="toc-nav-text">2) Non-blocking I/O</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Node-js-Module"><span class="toc-nav-text">Node.js Module</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#REPL에서-불러오기"><span class="toc-nav-text">REPL에서 불러오기</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#NPM"><span class="toc-nav-text">NPM</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#package-json"><span class="toc-nav-text">package.json</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Concurrency-Model-동시성-모델"><span class="toc-nav-text">Concurrency Model(동시성 모델)</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Resources"><span class="toc-nav-text">Resources</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Thread"><span class="toc-nav-text">Thread</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#동시성을-위한-도구"><span class="toc-nav-text">동시성을 위한 도구</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-운영체제-차원의-도구"><span class="toc-nav-text">1) 운영체제 차원의 도구</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-언어-차원의-도구"><span class="toc-nav-text">2) 언어 차원의 도구</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#자바스크립트의-동시성"><span class="toc-nav-text">자바스크립트의 동시성</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Single-Threaded-Event-Loop"><span class="toc-nav-text">Single-Threaded Event Loop</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-장점"><span class="toc-nav-text">1) 장점</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-단점"><span class="toc-nav-text">2) 단점</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-전략"><span class="toc-nav-text">3) 전략</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Asynchronous-JavaScript"><span class="toc-nav-text">Asynchronous JavaScript</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#비동기식-코드의-에러처리-관습"><span class="toc-nav-text">비동기식 코드의 에러처리: 관습</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#동기식-코드의-에러-처리-일반적인-방식으로-처리"><span class="toc-nav-text">동기식 코드의 에러 처리: 일반적인 방식으로 처리</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Github-REST-API-호출"><span class="toc-nav-text">Github REST API 호출</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Callback-Hell"><span class="toc-nav-text">Callback Hell</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Promise"><span class="toc-nav-text">Promise</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-promise의-상태-state"><span class="toc-nav-text">1) promise의 상태(state)</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-then"><span class="toc-nav-text">2) .then</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-Promise-chaining"><span class="toc-nav-text">3) Promise chaining</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#기타-메소드"><span class="toc-nav-text">기타 메소드</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-Promise의-특징"><span class="toc-nav-text">4) Promise의 특징</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Promise-all"><span class="toc-nav-text">Promise.all</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Async-Await"><span class="toc-nav-text">Async/Await</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-readFile-async-await"><span class="toc-nav-text">1) readFile - async/await</span></a></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://huusz.github.io/2017/Nodejs/nodejs/01.basic/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "huusz";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "[node] node 시작하기",
        owner: "huusz",
        repo: "huusz.github.io",
        oauth: {
          client_id: "d3a0f59f7ed9d7912d34",
          client_secret: "1e6eda5594a1d8399f6da40da0582ba24fc74bb3"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2017 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>