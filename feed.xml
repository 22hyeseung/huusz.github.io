<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Huusz&#39;s Log</title>
  
  <link href="/feed.xml" rel="self"/>
  
  <link href="http://huusz.github.io/"/>
  <updated>2017-08-29T15:43:15.000Z</updated>
  <id>http://huusz.github.io/</id>
  
  <author>
    <name>huusz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[node] 템플릿 언어 ejs</title>
    <link href="http://huusz.github.io/2017/Nodejs/nodejs/4.%20Template%20Language/"/>
    <id>http://huusz.github.io/2017/Nodejs/nodejs/4. Template Language/</id>
    <published>2017-08-29T15:42:01.000Z</published>
    <updated>2017-08-29T15:43:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Template-Language"><a href="#Template-Language" class="headerlink" title="Template Language"></a>Template Language</h1><h2 id="Web-Page"><a href="#Web-Page" class="headerlink" title="Web Page"></a>Web Page</h2><h3 id="1-Static-Web-Page"><a href="#1-Static-Web-Page" class="headerlink" title="1) Static Web Page"></a>1) Static Web Page</h3><p>누가 어떻게 요청하든 미리 저장되어 있던 HTML 파일을 그대로 응답</p>
<h3 id="2-Dynamic-Web-Page"><a href="#2-Dynamic-Web-Page" class="headerlink" title="2) Dynamic Web Page"></a>2) Dynamic Web Page</h3><p>요청한 사람과 요청한 내용에 따라 <strong>각각 다른 내용으로 편집한 HTML을 응답</strong></p>
<h2 id="Template-Engine"><a href="#Template-Engine" class="headerlink" title="Template Engine"></a>Template Engine</h2><p>템플릿과 데이터를 결합해 문서를 생성하는 프로그램, 혹은 라이브러리. 템플릿을 작성할 때 사용하는 언어를 템플릿 언어라고 한다.</p>
<h2 id="EJS-Embedded-JavaScript-Template"><a href="#EJS-Embedded-JavaScript-Template" class="headerlink" title="EJS: Embedded JavaScript Template"></a><a href="http://ejs.co/" target="_blank" rel="external">EJS: Embedded JavaScript Template</a></h2><ul>
<li>Node.js 생태계에서 가장 많이 사용되는 템플릿 엔진</li>
<li>문법이 단순하다.</li>
<li>JavaScript 코드를 템플릿 안에서 그대로 쓸 수 있음</li>
<li>.ejs VSCode Extension</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;%# index.ejs %&gt;</div><div class="line">&lt;html&gt;</div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;title&gt;<span class="xml"><span class="tag">&lt;<span class="name">%=</span> <span class="attr">title</span> %&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></div><div class="line">  &lt;<span class="regexp">/head&gt;</span></div><div class="line"><span class="regexp">  &lt;body&gt;</span></div><div class="line"><span class="regexp">    &lt;div class="message"&gt;</span></div><div class="line"><span class="regexp">      &lt;%= message %&gt;</span></div><div class="line"><span class="regexp">    &lt;/</span>div&gt;</div><div class="line">    &lt;% <span class="keyword">if</span> (showSecret) &#123; %&gt;</div><div class="line">      &lt;div&gt;my secret&lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">    &lt;% &#125; %&gt;</span></div><div class="line"><span class="regexp">  &lt;/</span>body&gt;</div><div class="line">&lt;<span class="regexp">/html&gt;</span></div></pre></td></tr></table></figure>
<h2 id="Express에서-EJS-사용하기"><a href="#Express에서-EJS-사용하기" class="headerlink" title="Express에서 EJS 사용하기"></a>Express에서 EJS 사용하기</h2><ul>
<li>ejs 설치</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save ejs</div></pre></td></tr></table></figure>
<ul>
<li>template engine 설정</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'ejs'</span>)</div></pre></td></tr></table></figure>
<ul>
<li>res.render()<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> data = &#123;</div><div class="line">  title: <span class="string">'Template Language'</span>,</div><div class="line">  message: <span class="string">'Hello EJS!'</span>,</div><div class="line">  showSecret: <span class="literal">true</span></div><div class="line">&#125;</div><div class="line">res.render(<span class="string">'index.ejs'</span>, data)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="템플릿-태그"><a href="#템플릿-태그" class="headerlink" title="템플릿 태그"></a>템플릿 태그</h3><ul>
<li><p><code>&lt;% ... %&gt;</code>: 템플릿의 구조를 제어하기 위해 사용하며, 문자열을 내놓지 않는다.</p>
</li>
<li><p><code>&lt;%= ... %&gt;</code>: 내부의 식을 문자열로 변환해 HTML 문서 안에 삽입한다.</p>
</li>
<li><p><code>&lt;%# ... %&gt;</code>: EJS 주석입니다. HTML 주석과는 다르게 아예 HTML 문서에 포함되지 않는다. 일반 HTML 주석보다는 EJS 주석을 사용하는 것이 좋다.</p>
</li>
</ul>
<h3 id="HTML-escape"><a href="#HTML-escape" class="headerlink" title="HTML escape"></a>HTML escape</h3><p>데이터를 HTML에 삽입하는 <code>&lt;%= ... %&gt;</code> 템플릿 태그는 &lt;, &gt; 두 문자를 각각 <code>&amp;lt;</code>, <code>&amp;gt;</code>로 변환하여 HTML에 삽입합니다. 결과적으로 HTML 태그를 직접 템플릿에 삽입하지 못하게 막습니다. 이렇게 하는 이유는 보안 때문으로, XSS(Cross-site Scripting)를 당할 위험을 줄여줍니다. XSS에 대해서는 추후 자세히 배울 것입니다.</p>
<p><code>&lt;%- ... %&gt;</code> 템플릿 태그를 이용하면 HTML escape를 생략할 수 있으나, 아주 특별한 경우가 아니면 <code>&lt;%= ... %&gt;</code> 태그를 사용하기를 권장합니다.</p>
<p><a href="https://glitch.com/edit/#!/married-wing" target="_blank" rel="external">example code</a></p>
<h3 id="Serving-Static-Files"><a href="#Serving-Static-Files" class="headerlink" title="Serving Static Files"></a>Serving Static Files</h3><p>static 파일 (변하지 않는 파일)은 static 경로를 사용해 주는 것이 좋다. EX. <code>/static/index.css</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// `public` 폴더에 있는 파일을 `/static` 경로 아래에서 제공</span></div><div class="line">app.use(<span class="string">'/static'</span>, express.static(<span class="string">'public'</span>))</div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 템플릿 파일에서 참조할 수 있음 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/static/index.css"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/static/index.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="실습"><a href="#실습" class="headerlink" title="실습"></a>실습</h3><ul>
<li><p><code>:slug</code> : 긴 영문 제목을 url에서 쓰기 위해 짧게 만든 것.</p>
</li>
<li><p>Array.find(): 콜백 함수는 foreach나 map과 비슷한 모양을 하고 있다. true인 첫번째 요소 반환  </p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line">arr.map(<span class="function"><span class="params">item</span> =&gt;</span> item*<span class="number">2</span>) <span class="comment">// [2, 4, 6]</span></div><div class="line">arr.find(<span class="function"><span class="params">item</span> =&gt;</span> item === <span class="number">2</span>) <span class="comment">// 2</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> item = [&#123;<span class="attr">value</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">value</span>: <span class="number">2</span>&#125;, &#123;<span class="attr">value</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'second'</span>&#125;]</div><div class="line"></div><div class="line"></div><div class="line">item.find(<span class="function"><span class="params">item</span> =&gt;</span> item.value === <span class="number">2</span>) <span class="comment">// &#123;value: 2&#125;</span></div><div class="line"></div><div class="line">item.find(<span class="function"><span class="params">item</span> =&gt;</span> item.value === <span class="number">1</span>) <span class="comment">// &#123;value: 1&#125;</span></div></pre></td></tr></table></figure>
<ul>
<li>Array. filter(): true인 것을 모두 반환</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">items.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.value === <span class="number">2</span>) <span class="comment">// [&#123;value:2&#125;]</span></div><div class="line"></div><div class="line">items.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.value === <span class="number">1</span>) <span class="comment">// [&#123;value: 1&#125;, &#123;value: 1, name: "second"&#125;]</span></div></pre></td></tr></table></figure>
<hr>
<h1 id="Another-template-Language"><a href="#Another-template-Language" class="headerlink" title="# Another template Language"></a># Another template Language</h1><h2 id="Pug-jade"><a href="#Pug-jade" class="headerlink" title="Pug(=jade)"></a><a href="https://pugjs.org/api/getting-started.html" target="_blank" rel="external">Pug(=jade)</a></h2><ul>
<li><p>코드가 ejs보다 깔끔하다.</p>
</li>
<li><p>pug은 닫는 태그가 없다. 닫는 태그에 의한 에러를 걱정할 필요가 없다.</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Template-Language&quot;&gt;&lt;a href=&quot;#Template-Language&quot; class=&quot;headerlink&quot; title=&quot;Template Language&quot;&gt;&lt;/a&gt;Template Language&lt;/h1&gt;&lt;h2 id=&quot;Web-P
    
    </summary>
    
      <category term="Nodejs" scheme="http://huusz.github.io/categories/Nodejs/"/>
    
    
      <category term="ejs" scheme="http://huusz.github.io/tags/ejs/"/>
    
  </entry>
  
  <entry>
    <title>[node] 미들웨어 express</title>
    <link href="http://huusz.github.io/2017/Nodejs/nodejs/3.%20Middleware/"/>
    <id>http://huusz.github.io/2017/Nodejs/nodejs/3. Middleware/</id>
    <published>2017-08-29T15:40:50.000Z</published>
    <updated>2017-08-29T15:43:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Middleware"><a href="#Middleware" class="headerlink" title="Middleware"></a>Middleware</h1><h2 id="1-Express"><a href="#1-Express" class="headerlink" title="1. Express"></a>1. <a href="https://expressjs.com/ko/" target="_blank" rel="external">Express</a></h2><ul>
<li>Node.js 생태계에서 가장 널리 쓰이는 웹 프레임워크</li>
<li>내장하고 있는 기능은 매우 적으나, 미들웨어를 주입하는 방식으로 기능을 확장하는 생태계를 가지고 있음</li>
</ul>
<h2 id="2-Express-앱의-기본-구조"><a href="#2-Express-앱의-기본-구조" class="headerlink" title="2. Express 앱의 기본 구조"></a>2. Express 앱의 기본 구조</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Express 인스턴스 생성</span></div><div class="line"><span class="keyword">const</span> app = express()</div><div class="line"></div><div class="line"><span class="comment">// 미들웨어 주입</span></div><div class="line">app.use(sessionMiddleware()) <span class="comment">// 세션미들웨어</span></div><div class="line">app.use(authenticationMiddleware()) <span class="comment">// 인증미들웨어</span></div><div class="line"></div><div class="line"><span class="comment">// 라우트 핸들러 등록</span></div><div class="line"><span class="comment">// 루트 경로('/')로 요청이 들어왔을 때, Hello express! 라는 응답을 한다.</span></div><div class="line">app.get(<span class="string">'/'</span>, (request, response) =&gt; &#123;</div><div class="line">  response.send(<span class="string">'Hello express!'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 서버 구동</span></div><div class="line"><span class="comment">// 3000번 포트에서 서버 요청을 기다릴 것이고, 서버 구동에 성공하면 아래 콜백(console.log('Example app listening on port 3000!'))을 실행시켜라.</span></div><div class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Example app listening on port 3000!'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="1-Routing"><a href="#1-Routing" class="headerlink" title="1) Routing"></a>1) Routing</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// HTTP 요청 메소드(GET, POST, ...)와 같은 이름의 메소드를 사용</span></div><div class="line">app.get(<span class="string">'/articles'</span>, (req, res) =&gt; &#123;</div><div class="line">  res.send(<span class="string">'Hello Routing!'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 특정 경로('/articles')에만 미들웨어를 주입하는 것도 가능</span></div><div class="line">app.post(<span class="string">'/articles'</span>, bodyParserMiddleware(), (req, res) =&gt; &#123;</div><div class="line">  database.articles.create(req.body)</div><div class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      res.send(&#123;<span class="attr">ok</span>: <span class="literal">true</span>&#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 경로의 특정 부분을 함수의 인자처럼 입력받을 수 있음</span></div><div class="line"><span class="comment">// ':id' 위치에 오는 값이 req.params.id에 저장된다.</span></div><div class="line">app.get(<span class="string">'/articles/:id'</span>, (req, res) =&gt; &#123;</div><div class="line">  database.articles.find(req.params.id) <span class="comment">// `req.params`에 저장됨</span></div><div class="line">    .then(<span class="function"><span class="params">article</span> =&gt;</span> &#123;</div><div class="line">      res.send(article)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="2-Request-객체"><a href="#2-Request-객체" class="headerlink" title="2) Request 객체"></a>2) Request 객체</h3><ul>
<li><strong>req.body</strong><br>요청 바디를 적절한 형태의 자바스크립트 객체로 변환하여 이곳에 저장 (body-parser 미들웨어에 의해 처리됨)</li>
<li><strong>req.ip</strong><br>요청한 쪽의 IP</li>
<li><strong>req.params</strong><br>route parameter</li>
<li><strong>req.query</strong><br>query string이 객체로 저장됨</li>
</ul>
<h3 id="3-실습"><a href="#3-실습" class="headerlink" title="3) 실습"></a>3) 실습</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</div><div class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>)</div><div class="line"></div><div class="line"><span class="keyword">const</span> app = express()</div><div class="line"></div><div class="line"><span class="comment">// GET method</span></div><div class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</div><div class="line">  res.send(<span class="string">'Hello, Express!'</span>);</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// POST method</span></div><div class="line">app.post(<span class="string">'/'</span>, bodyParser.json(), (req, res) =&gt; &#123;</div><div class="line">  <span class="comment">/*</span></div><div class="line"><span class="comment">  Mission:</span></div><div class="line"><span class="comment">  요청의 바디에 실려 온 JSON에 name이라는 속성이 있으면 해당 값을 이용해 응답하고, 없으면 400 Bad Request를 응답한다.</span></div><div class="line"><span class="comment">  응답 형태는 'Hello, &lt;name&gt;!' 으로 한다. </span></div><div class="line"><span class="comment">  */</span></div><div class="line">  <span class="keyword">if</span> (req.body.name) &#123; <span class="comment">// 포함되어 있으면(String) true, 없으면(undefined) false</span></div><div class="line">    res.send(<span class="string">`Hello, <span class="subst">$&#123;req.body.name&#125;</span>!`</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    res.status(<span class="number">400</span>);</div><div class="line">    res.send(<span class="string">`400 Bad Request`</span>)</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// query parameter, res.status</span></div><div class="line">app.get(<span class="string">'/add'</span>, (req, res) =&gt; &#123;</div><div class="line">  <span class="comment">/* </span></div><div class="line"><span class="comment">  Mission: </span></div><div class="line"><span class="comment">  query parameter에 x와 y라는 이름을 가진 두 값을 정수로 바꾸어서 더한 후 응답한다.</span></div><div class="line"><span class="comment">  값을 정수로 바꿀 수 없다면 400 Bad Request로 응답한다.</span></div><div class="line"><span class="comment">  */</span></div><div class="line">  </div><div class="line">  <span class="comment">//parseInt 사용 시에는 무조건 try-catch를 써주어야 한다.</span></div><div class="line">  </div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">const</span> x = <span class="built_in">parseInt</span>(req.query.x);</div><div class="line">    <span class="keyword">const</span> y = <span class="built_in">parseInt</span>(req.query.y);</div><div class="line">    <span class="keyword">const</span> result = (x + y).toString();</div><div class="line">    res.send(result)</div><div class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    res.status(<span class="number">400</span>)</div><div class="line">    res.send(<span class="string">`400 Bad Request`</span>)</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// req.ip</span></div><div class="line">app.get(<span class="string">'/ip'</span>, (req, res) =&gt; &#123;</div><div class="line">  <span class="comment">/*</span></div><div class="line"><span class="comment">  Mission: </span></div><div class="line"><span class="comment">  요청한 쪽의 ip를 응답한다.</span></div><div class="line"><span class="comment">  */</span></div><div class="line">  res.send(req.ip);</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// req.get, res.set, res.end</span></div><div class="line">app.get(<span class="string">'/header'</span>, (req, res) =&gt; &#123;</div><div class="line">  <span class="comment">/*</span></div><div class="line"><span class="comment">  Mission:</span></div><div class="line"><span class="comment">  요청의 X-Custom-Header 헤더를 그대로 응답에 포함시켜 응답한다.</span></div><div class="line"><span class="comment">  응답에는 바디를 포함시키지 않도록 한다.</span></div><div class="line"><span class="comment">  </span></div><div class="line"><span class="comment">  hint 1: res.set 메소드는 응답에 새로운 헤더를 지정한다.</span></div><div class="line"><span class="comment">  예) res.set('X-Custom-Header', value)</span></div><div class="line"><span class="comment">  </span></div><div class="line"><span class="comment">  hint 2: res.end 메소드는 응답을 보낸다. res.send와 비슷하지만, 바디를 인자로 받지 않는다.</span></div><div class="line"><span class="comment">  */</span></div><div class="line">    <span class="keyword">const</span> value = req.get(<span class="string">"X-Custom-Header"</span>)</div><div class="line">  <span class="comment">// 표준이 아닌 헤더를 만들 때, 이름 앞에 X를 붙이는 것이 관례이다.</span></div><div class="line">  res.append(<span class="string">'X-Custom.Header'</span>, value)</div><div class="line">  res.end() <span class="comment">// send()</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">const</span> listener = app.listen(process.env.PORT, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'listening on port '</span> + listener.address().port)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Middleware&quot;&gt;&lt;a href=&quot;#Middleware&quot; class=&quot;headerlink&quot; title=&quot;Middleware&quot;&gt;&lt;/a&gt;Middleware&lt;/h1&gt;&lt;h2 id=&quot;1-Express&quot;&gt;&lt;a href=&quot;#1-Express&quot; c
    
    </summary>
    
      <category term="Nodejs" scheme="http://huusz.github.io/categories/Nodejs/"/>
    
    
      <category term="express" scheme="http://huusz.github.io/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>[node] HTTP</title>
    <link href="http://huusz.github.io/2017/Nodejs/nodejs/2.%20http/"/>
    <id>http://huusz.github.io/2017/Nodejs/nodejs/2. http/</id>
    <published>2017-08-29T15:40:30.000Z</published>
    <updated>2017-08-29T16:12:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="네트워크-확인하기"><a href="#네트워크-확인하기" class="headerlink" title="네트워크 확인하기"></a>네트워크 확인하기</h2><h3 id="1-wireshark"><a href="#1-wireshark" class="headerlink" title="1) wireshark"></a>1) wireshark</h3><p><img src="https://github.com/huusz/huusz.github.io/blob/master/source/_posts/images/WIRESHARK.png?raw=true" alt="WIRESHARK"></p>
<p><img src="https://github.com/huusz/huusz.github.io/blob/master/source/_posts/images/WIRESHARK2.png?raw=true" alt="WIRESHARK"></p>
<h3 id="2-크롬-개발자도구"><a href="#2-크롬-개발자도구" class="headerlink" title="2) 크롬 개발자도구"></a>2) 크롬 개발자도구</h3><p><img src="https://github.com/huusz/huusz.github.io/blob/master/source/_posts/images/chromeDevTools.png?raw=true" alt="크롬 개발자도구"></p>
<p><br></p>
<h2 id="HTTP-1"><a href="#HTTP-1" class="headerlink" title="HTTP"></a>HTTP</h2><p><img src="https://github.com/huusz/huusz.github.io/blob/master/source/_posts/images/http.png?raw=true" alt=""></p>
<ul>
<li>웹 브라우저와 웹 서버 간의 통신을 위해 개발된 통신규약</li>
<li>최근에는 REST API의 부상와 함께 다른 용도로도 널리 사용된다.<ul>
<li>모바일 앱 - 서버 간 통신</li>
<li>서버 - 서버 간 통신</li>
</ul>
</li>
<li>80번 포트를 기본으로 사용</li>
<li>클라이언트의 요청(request)과 서버의 응답(response)으로 이루어진다.</li>
</ul>
<h3 id="1-http의-역사"><a href="#1-http의-역사" class="headerlink" title="1) http의 역사"></a>1) http의 역사</h3><p><strong>1991</strong><br>HTTP 초기버전 발표. 텍스트만 전송할 수 있는 극도로 단순한 프로토콜. 1990년대 초 인터넷 붐을 일으킴</p>
<p><strong>1996</strong><br>여러 인터넷 서비스 업체들이 자체적으로 사용하던 HTTP 구현들을 모아 HTTP 1.0 발표</p>
<p><strong>1999</strong><br>1.0의 문제를 해결하고 여러가지 기능을 추가한 HTTP 1.1을 발표. 지금까지 사용되고 있는 버전</p>
<p><br></p>
<h3 id="2-HTTPS"><a href="#2-HTTPS" class="headerlink" title="2) HTTPS"></a>2) HTTPS</h3><p><img src="https://github.com/huusz/huusz.github.io/blob/master/source/_posts/images/https.png?raw=true" alt=""></p>
<ul>
<li>HTTP over SSL</li>
<li>HTTP 통신을 암호화해 주고 받는 내용을 중간에서 가로챌 수 없도록 한다.</li>
<li>443번 포트를 기본으로 사용한다.</li>
</ul>
<h3 id="3-HTTP-2"><a href="#3-HTTP-2" class="headerlink" title="3) HTTP/2"></a>3) HTTP/2</h3><ul>
<li>구글의 <a href="http://d2.naver.com/helloworld/140351" target="_blank" rel="external">SPDY</a> 프로토콜을 기반으로 2015년에 확정된 새로운 HTTP 표준</li>
<li>0,1만으로 통신하는 프로토콜로 더이상 텍스트 기반이 아님</li>
<li>오로지 <strong>속도 개선</strong>에 중점을 두고 개발됨</li>
<li>반드시 HTTPS를 사용해야 함</li>
<li><a href="https://w3techs.com/technologies/details/ce-http2/all/all" target="_blank" rel="external">현재 전체 웹사이트 중 16% 이상이 사용중</a></li>
</ul>
<h2 id="HTTP-작동방식"><a href="#HTTP-작동방식" class="headerlink" title="HTTP 작동방식"></a>HTTP 작동방식</h2><h3 id="1-Request-amp-Response"><a href="#1-Request-amp-Response" class="headerlink" title="1) Request &amp; Response"></a>1) Request &amp; Response</h3><ul>
<li>요청 Request: 웹 브라우저(또는 다른 클라이언트)는 웹 서버에 요청(request)를 보냄</li>
<li>응답 Response: 그에 따라 서버는 클라이언트에 응답(response)를 보냄</li>
<li>웹 브라우저의 경우, HTML 문서 형태의 응답이 오면 해당 문서를 분석한 후, 문서에 포함된 모든 자원에 대한 요청을 각각 추가로 보냄 (이미지, 동영상, 오디오, CSS, JS, 폰트, …)</li>
</ul>
<h3 id="2-Request-Methods"><a href="#2-Request-Methods" class="headerlink" title="2) Request Methods"></a>2) Request Methods</h3><ul>
<li><a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Methods" target="_blank" rel="external">HTTP 명세</a>에는 8 종류가 등록되어 있고, 각각의 역할과 충족해야 하는 성질이 명시되어 있음</li>
<li>웹 브라우저는 <strong>특정 상황에서 특정 메소드로 요청을 보내도록</strong> 만들어져 있음</li>
<li>Ajax와 같이 <strong>요청을 보내는 코드를 직접 짤 때</strong>는 요청 메소드를 선택할 수 있음</li>
<li><strong>자료의 본문을 요청하는 GET 메소드</strong>와, 새로운 <strong>자료를 등록하는 POST 메소드</strong>가 가장 많이 쓰임</li>
</ul>
<p>웹 브라우저는 순수 HTML만으로는 GET과 POST 메소드만 사용할 수 있도록 강제하고 있다. AJAX등으로 코드를 직접 작성할 때에는 메소드를 자유롭게 선택하여 사용할 수 있다.</p>
<h3 id="서버가-충족시켜야하는-메소드의-성질"><a href="#서버가-충족시켜야하는-메소드의-성질" class="headerlink" title="서버가 충족시켜야하는 메소드의 성질"></a>서버가 충족시켜야하는 메소드의 성질</h3><ul>
<li>Safe  </li>
</ul>
<p>요청이 서버의 상태에 영향을 미치지 않아야 함. 즉, <strong>읽기 전용</strong>이어야 함이 표준에 명시되어 있다.</p>
<ul>
<li>Idempotent  </li>
</ul>
<p>여러 번 같은 요청을 해도 한 번 요청한 것과 같은 효과여야 함. <strong>네트워크가 불안정해도 안전하게 요청을 보낼 수 있음</strong></p>
<blockquote>
<p>DELETE, GET은 Idempotent을 만족해야 한다. 게시글의 삭제 요청을 여러번 보내도 한 번의 삭제 작업이 이루어져야 한다. GET도 마찬가지로, 여러번 요청이 가도 한 번만 GET 작업을 해야한다.</p>
<p>POST는 데이터를 서버로 보내는 방법이다. 자료를 새로 만들 때 사용된다. 게시물을 만드는 요청을 서버에 보내다가 네트워크가 끊어진 상황을 가정했을 때, 서버에는 이미 해당 데이터가 만들어졌으므로 이후 같은 요청을 보내면 에러가 나야 한다. 따라서 POST는 Idempotent를 만족시켜서는 안 된다.</p>
</blockquote>
<ul>
<li>Cacheable  </li>
</ul>
<p>(특정 조건을 만족하면) 응답을 클라이언트에 저장해두었다가 다음 번 요청 때 <strong>다시 쓸 수 있음</strong>  </p>
<p><br></p>
<h3 id="3-URL"><a href="#3-URL" class="headerlink" title="3) URL"></a>3) URL</h3><p><img src="https://cascadingmedia.com/assets/images/insites/2015/02/url-anatomy/url-anatomy-55598c24.png" alt="URL"></p>
<hr>
<p>&lt;서버의 위치&gt;</p>
<ol>
<li><p>스키마</p>
</li>
<li><p>서브 도메인</p>
</li>
<li><p>도메인</p>
</li>
<li><p>탑레벨 도메인</p>
</li>
<li><p>포트</p>
</li>
</ol>
<hr>
<p>&lt;서버에서 얻고자 하는 자원의 위치&gt;</p>
<ol>
<li><p>경로(path)</p>
</li>
<li><p>쿼리 스트링 </p>
</li>
<li><p>해시 (fragment identifier)</p>
</li>
</ol>
<h3 id="4-Percent-Encoding"><a href="#4-Percent-Encoding" class="headerlink" title="4) Percent Encoding"></a>4) Percent Encoding</h3><ul>
<li><p>URL은 ASCII 문자(128개의 영문자+특수문자+제어문자)밖에 사용하지 못하기 때문에, non-ASCII 문자를 위한 표현방법이 필요함 #</p>
</li>
<li><p>Percent encoding은 non-ASCII 문자를 위한 웹 표준 인코딩 방법으로, JavaScript에 관련 기능이 포함되어 있음</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; encodeURIComponent(&quot;한글&quot;)</div><div class="line">&quot;%ED%95%9C%EA%B8%80&quot;</div><div class="line">&gt; decodeURIComponent(&quot;%ED%95%9C%EA%B8%80&quot;)</div><div class="line">&quot;한글&quot;</div></pre></td></tr></table></figure>
<p><img src="https://github.com/huusz/huusz.github.io/blob/master/source/_posts/images/%ED%8D%BC%EC%84%BC%ED%8A%B8%EC%9D%B8%EC%BD%94%EB%94%A9.png?raw=true" alt="퍼센트인코딩"></p>
<h3 id="5-Request-Target"><a href="#5-Request-Target" class="headerlink" title="5) Request Target"></a>5) Request Target</h3><p>일반적인 경우 아래와 같은 구조가 사용됨  </p>
<p><code>absolute path + query string + fragment id</code></p>
<p>절대 경로 + 쿼리스트링 + 해시  </p>
<p><code>GET /path/to/resource?foo=bar&amp;spam=hoge#fragid HTTP/1.1</code></p>
<h3 id="6-Response-Status"><a href="#6-Response-Status" class="headerlink" title="6) Response Status"></a>6) Response Status</h3><p>응답의 성공, 실패 여부와 종류를 나타내며, <a href="https://httpstatuses.com/" target="_blank" rel="external">상태 코드</a> + 상태 메시지의 형태로 응답에 포함됨</p>
<p><code>HTTP/1.1 200 OK</code></p>
<h3 id="Status-Category"><a href="#Status-Category" class="headerlink" title="[Status Category]"></a>[Status Category]</h3><p><strong>2xx</strong> 성공</p>
<ul>
<li>200 OK - 성공</li>
<li>201 Created - 자료가 성공적으로 생성되었다.</li>
</ul>
<p><strong>3xx</strong> 추가 작업이 필요하다.</p>
<ul>
<li>301 Moved Permanently (Redirection) - 자료가 완전히 다른 곳으로 이동했다.</li>
<li>302 Found (Redirection) - 자료가 일시적으로 다른 곳에 있다.</li>
<li>304 Not Modified (Cache) - 클라이언트가 이미 가지고 있던 자료가 수정되지 않았다. (그대로 사용하면 된다.) CSS나 Javascript에 대한 응답인 경우가 많다.</li>
</ul>
<p><strong>4xx</strong> 실패 - 클라이언트 책임</p>
<ul>
<li>400 Bad Request - 요청의 형태가 잘못되어 응답할 수 없다.</li>
<li>403 Forbidden - 요청한 자료에 접근할 권한이 없다.</li>
<li>404 Not Found - 요청한 자료가 없다.</li>
</ul>
<p><strong>5xx</strong> 실패 - 서버 책임</p>
<ul>
<li>500 Internal Server Error - 요청을 처리하던 중에 예상치 못한 요류가 발생했다.</li>
<li>503 Service Unavailable - 서버가 일시적으로 응답을 할 수 없다.</li>
</ul>
<h3 id="7-Header"><a href="#7-Header" class="headerlink" title="7) Header"></a>7) Header</h3><ul>
<li>요청과 응답에 대한 추가 정보를 표현하는 데 사용</li>
<li><p>인증, 캐싱, 쿠키, 보안, 내용협상, 프록시 등 웹 표준에 정의된 많은 기능을 제어하는 데 사용됨</p>
</li>
<li><p><strong>Authorization</strong><br>요청의 인증 정보</p>
</li>
<li><strong>User-Agent</strong><br>요청 중인 클라이언트의 정보</li>
<li><strong>Location</strong><br>301, 302 응답에서 자료의 위치</li>
<li><strong>Accept</strong><br>요청이 어떤 형태의 자료를 원하는지 나타냄</li>
<li><strong>Content-Type</strong><br>요청 혹은 응답이 어떤 형태의 자료인지 나타냄</li>
</ul>
<h3 id="8-Content-Negotiation"><a href="#8-Content-Negotiation" class="headerlink" title="8) Content Negotiation"></a>8) Content Negotiation</h3><p>요청의 Accept, Accept-Language 등의 헤더를 보고 서버가 그에 맞는 형태의 자료를 응답하는 절차를 content negotiation(내용 협상)이라고 함</p>
<p><img src="https://www.codeproject.com/KB/aspnet/1163143/Fig01-ContentNegotiation.png" alt=""></p>
<p>클라이언트가 JSON이 필요하다는 요청을 보내면, 서버가 JSON포맷의 데이터를 보내준다. 만약 없다면 XML 또는 기타 다른 포맷의 데이터를 대신 보내주는데, 이 과정을 content negotiation: 내용 협상이라고 한다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h1&gt;&lt;h2 id=&quot;네트워크-확인하기&quot;&gt;&lt;a href=&quot;#네트워크-확인하기&quot; class=&quot;headerlink&quot; title=
    
    </summary>
    
      <category term="Nodejs" scheme="http://huusz.github.io/categories/Nodejs/"/>
    
    
      <category term="http" scheme="http://huusz.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>[node] node 시작하기</title>
    <link href="http://huusz.github.io/2017/Nodejs/nodejs/1.%20basic/"/>
    <id>http://huusz.github.io/2017/Nodejs/nodejs/1. basic/</id>
    <published>2017-08-29T15:40:12.000Z</published>
    <updated>2017-08-29T15:43:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nvm-node-version-manager"><a href="#nvm-node-version-manager" class="headerlink" title="nvm(node version manager)"></a>nvm(node version manager)</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 주석: `#`으로 시작하는 명령은 bash에서 무시됩니다.</span></div><div class="line"><span class="comment"># 아래 명령을 한 줄씩 차례대로 입력하세요</span></div><div class="line">$ nvm install 8.4</div><div class="line">$ nvm use 8.4</div><div class="line">$ nvm <span class="built_in">alias</span> default 8.4 <span class="comment"># nvm-windows는 필요없음</span></div></pre></td></tr></table></figure>
<h1 id="Node-js-REPL"><a href="#Node-js-REPL" class="headerlink" title="Node.js REPL"></a>Node.js REPL</h1><p>REPL(Read Eval Print Loop): 윈도우 커맨드, 혹은 UNIX/LINUX Shell처럼 사용자가 커맨드를 입력하면 시스템이 값을 반환하는 환경을 일컫는다. </p>
<p>Node.js는 REPL 환경과 함께 제공되며 다음과 같은 기능을 수행할 수 있다.</p>
<ul>
<li>Read: 유저의 값을 입력 받아 Javascript 데이터 구조로 메모리에 저장한다.</li>
<li>Eval: 데이터를 처리(Evaluate)한다.</li>
<li>Print: 결과값을 출력한다.</li>
<li>Loop: Read, Eval, Print를 유저가 Ctrl+C를 두 번 눌러 종료할 때까지 반복한다.</li>
</ul>
<p>Node.js 의 REPL 환경은 자바스크립트 코드의 테스팅 및 디버깅할 때 유용하게 사용된다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">// REPL 시작하기</div><div class="line">$ node</div><div class="line"></div><div class="line">// 한 줄 짜리 코드 입력하기</div><div class="line">&gt; <span class="string">'hello node'</span></div><div class="line"><span class="string">'hello node'</span></div><div class="line"></div><div class="line">// 위쪽 화살표 키를 입력해서 이전 명령 불러오기</div><div class="line">&gt; <span class="string">'hello node'</span></div><div class="line"><span class="string">'hello node'</span></div><div class="line"></div><div class="line">// Underscore(_) 변수</div><div class="line">밑줄 _변수는 최근 결과값을 지칭한다.</div><div class="line">&gt; var x = 10;</div><div class="line">undefined</div><div class="line">&gt; var y = 5;</div><div class="line">undefined</div><div class="line">&gt; x+y;</div><div class="line">15</div><div class="line">&gt; var sum = _</div><div class="line">undefined</div><div class="line">&gt;console.log(sum)</div><div class="line">15</div><div class="line">undefined</div><div class="line"></div><div class="line">// 변수 사용하기</div><div class="line">&gt; const factorial = n =&gt; n &lt; 1 ? 1 : n * factorial(n-1)</div><div class="line">undefined</div><div class="line"></div><div class="line">&gt; factorial(3)</div><div class="line">6</div><div class="line"></div><div class="line">// 여러 줄에 나눠서 입력하기</div><div class="line">&gt; <span class="keyword">function</span> factorial2(n) &#123;</div><div class="line">... <span class="built_in">return</span> n &lt; 1 ? 1 : n * factorial(n-1)</div><div class="line">... &#125;</div><div class="line">undefined</div><div class="line"></div><div class="line">&gt; factorial2(4)</div><div class="line">24</div><div class="line"></div><div class="line">// `.<span class="built_in">exit</span>`를 입력하거나 `Ctrl+C`를 두 번 입력해서 나가기</div><div class="line">&gt; .<span class="built_in">exit</span></div><div class="line"></div><div class="line">// Node.js module 사용하기</div><div class="line">&gt; const os = require(<span class="string">'os'</span>) // 급할땐 `os = ...`</div><div class="line">undefined</div><div class="line"></div><div class="line">&gt; os.platform()</div><div class="line"><span class="string">'linux'</span></div><div class="line"></div><div class="line">&gt; os.freemem()</div><div class="line">658300928</div></pre></td></tr></table></figure>
<h1 id="node-js로-파일-실행시키기"><a href="#node-js로-파일-실행시키기" class="headerlink" title="node.js로 파일 실행시키기"></a>node.js로 파일 실행시키기</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ node (파일 경로)</div></pre></td></tr></table></figure>
<h1 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h1><p>Node.js®은 chrome의 v8 자바스크립트 엔진에 기반한 자바스크립트 런타임이다.</p>
<p>Node.js는 가볍고 효율적인 event-driven, non-blocking I/O model을 사용한다. </p>
<p>Node.js의 패키지 에코 시스템인 npm은 전 세계 오픈 소스 라이브러리 중 가장 큰 생태계(ecosystem)이다.</p>
<h2 id="1-JavaScript-Runtime이란"><a href="#1-JavaScript-Runtime이란" class="headerlink" title="1) JavaScript Runtime이란?"></a>1) JavaScript Runtime이란?</h2><ul>
<li>JavaScript는 언어</li>
<li>JavaScript 런타임(runtime)은 JS를 구동하기 위해 필요한 실행 환경</li>
<li>프로그래머는 런타임이 제공하는 도구를 응용해서 프로그램을 개발</li>
<li>웹 브라우저나 Node.js도 JavaScript 런타임의 일종</li>
</ul>
<h2 id="2-JavaScript-Runtime-종류"><a href="#2-JavaScript-Runtime-종류" class="headerlink" title="2) JavaScript Runtime 종류"></a>2) JavaScript Runtime 종류</h2><ul>
<li>Chrome이 제공하는 웹 브라우저용 런타임</li>
<li>Node.js가 제공하는 서버용 런타임</li>
<li>MongoDB가 제공하는 데이터 처리용 런타임</li>
<li>Photoshop이 제공하는 전용 런타임<br>…</li>
</ul>
<h1 id="V8-JavaScript-Engine"><a href="#V8-JavaScript-Engine" class="headerlink" title="V8 JavaScript Engine"></a>V8 JavaScript Engine</h1><p>JIT(Just-In-Time) compilation<br>Code Optimization<br>Used in<br>Google Chrome<br>Node.js<br>MongoDB<br>…</p>
<h2 id="V8-엔진의-작동-방식"><a href="#V8-엔진의-작동-방식" class="headerlink" title="V8 엔진의 작동 방식?"></a>V8 엔진의 작동 방식?</h2><h3 id="1-Event-driven-Programming"><a href="#1-Event-driven-Programming" class="headerlink" title="1) Event-driven Programming"></a>1) Event-driven Programming</h3><p>프로그램의 흐름이 외부 요인에 의해 일어나는 사건에 의해 결정되는 프로그래밍 양식<br>약속된 방식으로 이벤트 핸들러를 작성함으로써 외부 이벤트가 일어났을 때 코드를 실행  </p>
<ul>
<li>마우스 입력</li>
<li>키보드 입력</li>
<li>다른 프로그램/컴퓨터로부터의 통신</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// DOM 이벤트 핸들러 등록 (웹 브라우저)</span></div><div class="line">domElement.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  e.stopPropagation()</div><div class="line">  alert(<span class="string">'hello'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 서버도 똑같이 합니다.</span></div><div class="line"><span class="comment">// (단, 프레임워크를 쓸 때는 직접 이벤트를 다룰 일이 별로 없음)</span></div><div class="line"><span class="comment">// HTTP 응답 이벤트 핸들러 등록 (Node.js)</span></div><div class="line">httpResponse.on(<span class="string">'data'</span>, data =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(data)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="2-Non-blocking-I-O"><a href="#2-Non-blocking-I-O" class="headerlink" title="2) Non-blocking I/O"></a>2) Non-blocking I/O</h3><p>Blocking I/O는 스레드가 입력/출력이 완료될 때까지 기다렸다가 다음 코드를 실행  </p>
<p>Non-blocking I/O는 스레드가 입력/출력을 기다리지 않고 코드를 계속 실행  </p>
<p>순차적으로 실행되다가 기다려야 할 상황이 오면 코드 실행을 멈추고 그 상황이 완료된 이후에 코드를 실행하지만, 어떤 프로그래밍 언어나 기술들은 코드가 기다려야 하는 상황이 왔을 때, 그에 대한 신호만 주고 다음 코드를 계속 실행한다. 이전 코드가 완료되기를 기다렸다가 실행하는 것이 blocking I/O라고 하며 기다리지 않고 계속 실행하는 것을 non-blocking I/O라고 한다.</p>
<p>non-blocking의 단점은 코드가 복잡해질 수 있다는 점이다. (이러한 복잡함을 해결해주는 도구가 promise이다.)</p>
<p><strong>I/O 성능 향상 &amp; 복잡한 코드</strong>  </p>
<h1 id="Node-js-Module"><a href="#Node-js-Module" class="headerlink" title="Node.js Module"></a>Node.js Module</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// name.js</span></div><div class="line"></div><div class="line"><span class="comment">// `module.exports`에 저장한 값은 다른 모듈에서 불러올 수 있음</span></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  familyName: <span class="string">'김'</span>,</div><div class="line">  givenName: <span class="string">'승하'</span>,</div><div class="line">  fullName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.familyName + <span class="keyword">this</span>.givenName</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// calc.js</span></div><div class="line"></div><div class="line"><span class="comment">// `exports`로도 참조 가능</span></div><div class="line">exports.add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y</div><div class="line">exports.sub = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x - y</div></pre></td></tr></table></figure>
<h1 id="REPL에서-불러오기"><a href="#REPL에서-불러오기" class="headerlink" title="REPL에서 불러오기"></a>REPL에서 불러오기</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// Node.js 내장 모듈과는 다르게 경로를 지정해야 함</div><div class="line">&gt; const name = require(&apos;./name&apos;)</div><div class="line">undefined</div><div class="line">&gt; name</div><div class="line">&#123; familyName: &apos;김&apos;,</div><div class="line">  givenName: &apos;승하&apos;,</div><div class="line">  fullName: [Function: fullName] &#125;</div><div class="line">&gt; name.familyName</div><div class="line">&apos;김&apos;</div><div class="line">&gt; name.fullName()</div><div class="line">&apos;김승하&apos;</div><div class="line">&gt; require(&apos;./calc&apos;).add(1, 2)</div><div class="line">3</div></pre></td></tr></table></figure>
<p><strong>브라우저에서는 전역변수를 쓰면 위험하다</strong><br>script1.js 파일에 var evil = 1; 이라는 전역 변수를 선언하면 script2.js 파일에서도 evil을 참조할 수 있게 된다.<br>하지만 nodejs는 조금 다르다. nodejs 모듈은 각각의 스코프(scope)가 따로 존재한다. 따라서 module1.js에서 var evil = 1;이라고 선언하더라도 전역에 선언되는 것이 아닌, module1이라는 모듈 내의 스코프에서만 존재하기 때문에 다른 모듈에서 접근할 수 없다. 따라서 export하지 않으면 다른 모듈에서 해당 변수에 접근할 수 없다.</p>
<h1 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h1><p>Node.js 패키지 관리 도구 + 클라우드 패키지 저장소</p>
<ul>
<li>의존 패키지 관리</li>
<li>스크립트 실행</li>
<li>패키지 설정</li>
<li>NPM에 패키지 배포</li>
<li>Node.js 종합 작업 도구</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$ mkdir hello-npm</div><div class="line">$ <span class="built_in">cd</span> hello-npm</div><div class="line">$ npm init -y</div><div class="line">$ code .</div><div class="line">// package.json</div><div class="line">&#123;</div><div class="line">  <span class="string">"name"</span>: <span class="string">"hello-npm"</span>,</div><div class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</div><div class="line">  <span class="string">"description"</span>: <span class="string">""</span>,</div><div class="line">  <span class="string">"main"</span>: <span class="string">"index.js"</span>,</div><div class="line">  <span class="string">"scripts"</span>: &#123;</div><div class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="string">"keywords"</span>: [],</div><div class="line">  <span class="string">"author"</span>: <span class="string">""</span>,</div><div class="line">  <span class="string">"license"</span>: <span class="string">"ISC"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h1><p>패키지 정보를 담고 있는 파일</p>
<p><strong>dependencies</strong><br><code>npm install --save</code> 명령으로 설치한 패키지가 기록됨  </p>
<p><strong>scripts</strong><br>원래 목적은 패키지 생명주기마다 자동으로 실행되는 명령을 등록하기 위함이나, 개발자 편의를 위해 자주 사용되는 명령을 등록하는 용도로 더 많이 사용됨  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save randomstring <span class="comment"># node_modules에 저장됨</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// index.js</span></div><div class="line"><span class="keyword">const</span> randomstring = <span class="built_in">require</span>(<span class="string">'randomstring'</span>)</div><div class="line"><span class="built_in">console</span>.log(randomstring.generate())</div></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// package.json</div><div class="line">...</div><div class="line">  "scripts": &#123;</div><div class="line">    "start": "node index.js"</div><div class="line">  &#125;</div><div class="line">...</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm start</div></pre></td></tr></table></figure>
<h1 id="Concurrency-Model-동시성-모델"><a href="#Concurrency-Model-동시성-모델" class="headerlink" title="Concurrency Model(동시성 모델)"></a>Concurrency Model(동시성 모델)</h1><p>프로그램이 생애 주기가 겹치는 여러 실행 과정을 통해 실행된다 하더라도 프로그램의 결과에는 영향을 미치지 않는 성질</p>
<p>생애 주기가 겹치는 여러 실행 과정이 자원을 공유할 때 어떻게 충돌이 생기지 않도록 할 것인가?</p>
<h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><ul>
<li>CPU</li>
<li>메모리</li>
<li>네트워크</li>
<li>…</li>
</ul>
<h1 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h1><p>코드 실행의 가장 작은 단위</p>
<p>프로그램은 하나 이상의 스레드로 이루어짐</p>
<p>CPU 코어 하나는 한 번에 하나의 스레드를 실행</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ sysctl -n hw.ncpu <span class="comment"># OSX</span></div><div class="line">$ nproc <span class="comment"># linux</span></div><div class="line">$ mmc devmgmt.msc <span class="comment"># Windows</span></div><div class="line">$ top -H <span class="comment"># Shows the total number of threads</span></div></pre></td></tr></table></figure>
<h1 id="동시성을-위한-도구"><a href="#동시성을-위한-도구" class="headerlink" title="동시성을 위한 도구"></a>동시성을 위한 도구</h1><p>자원의 공유를 위해 프로그래밍 언어는 언어들만이 가지고 있는 동시성을 위한 도구를 가지고 있는 경우가 많다.</p>
<h2 id="1-운영체제-차원의-도구"><a href="#1-운영체제-차원의-도구" class="headerlink" title="1) 운영체제 차원의 도구"></a>1) 운영체제 차원의 도구</h2><ul>
<li>Process</li>
<li>Thread</li>
<li>Mutex (Mutual Exclusion)</li>
</ul>
<h2 id="2-언어-차원의-도구"><a href="#2-언어-차원의-도구" class="headerlink" title="2) 언어 차원의 도구"></a>2) 언어 차원의 도구</h2><ul>
<li>Python - asyncio</li>
<li>Go - goroutine</li>
<li>Erlang - actor</li>
<li>JavaScript - …?</li>
</ul>
<p><br></p>
<h1 id="자바스크립트의-동시성"><a href="#자바스크립트의-동시성" class="headerlink" title="자바스크립트의 동시성"></a>자바스크립트의 동시성</h1><h2 id="Single-Threaded-Event-Loop"><a href="#Single-Threaded-Event-Loop" class="headerlink" title="Single-Threaded Event Loop"></a>Single-Threaded Event Loop</h2><p><strong>자바스크립트를 실행시키는 스레드가 하나 뿐이다.</strong><br>실행 과정(보통 콜백 연쇄)의 생애 주기가 겹칠 수는 있지만 어떤 경우에도 두 자바스크립트 실행과정이 동시에 실행되는 경우는 없음. 내부적으로 메시지 큐를 활용하고 있으나, 모든 처리가 자동으로 이루어짐</p>
<p>!MDN[<a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/EventLoop" target="_blank" rel="external">https://developer.mozilla.org/ko/docs/Web/JavaScript/EventLoop</a>]</p>
<h2 id="1-장점"><a href="#1-장점" class="headerlink" title="1) 장점"></a>1) 장점</h2><ul>
<li>프로그래머가 동시성에 대해 신경쓸 필요가 없어짐</li>
<li>프로그램 작성이 쉬워짐</li>
</ul>
<h2 id="2-단점"><a href="#2-단점" class="headerlink" title="2) 단점"></a>2) 단점</h2><ul>
<li>CPU를 많이 쓰는 작업에 부적절</li>
<li>오래 걸리는 자바스크립트 코드가 실행되면 전체 프로그램에 영향을 미침</li>
</ul>
<h2 id="3-전략"><a href="#3-전략" class="headerlink" title="3) 전략"></a>3) 전략</h2><p>브라우저는 API가 있다면 API에 위임, 노드js는 c/c++로 만들어진 모듈을 가져와서 사용할 수 있는 방법이 있다.</p>
<ul>
<li>오래 걸리는 일은 외부에 위임하고 넘어간 뒤, 나중에 결과를 받아 처리하기<ul>
<li>Database</li>
<li>Node.js - External libraries</li>
<li>Web browser - WebAssembly</li>
</ul>
</li>
<li>긴 실행과정을 <strong>여러 개의 함수로 쪼개서</strong> 한 번의 함수 실행이 금방 끝나게 만들기</li>
</ul>
<p><br></p>
<h1 id="Asynchronous-JavaScript"><a href="#Asynchronous-JavaScript" class="headerlink" title="Asynchronous JavaScript"></a>Asynchronous JavaScript</h1><p>non-blocking과 asynchronous는 비슷한 맥락이다. 다만, non-blocking은 코드의 실행 순서에 대한 개념이고, asynchronous는 코드 작성 방식에 대한 개념이다.</p>
<ul>
<li>함수를 호출할 때, 콜백까지 같이 인자에 넣어서 호출하는 비동기 프로그래밍 양식</li>
<li>콜백에서 에러 인자를 받는 방식으로 에러 처리를 함</li>
<li>Node.js 내장 모듈 전체가 이 방식을 사용하도록 만들어져 있음</li>
<li>주의! 모든 콜백이 비동기인 것은 아님</li>
</ul>
<hr>
<h1 id="비동기식-코드의-에러처리-관습"><a href="#비동기식-코드의-에러처리-관습" class="headerlink" title="비동기식 코드의 에러처리: 관습"></a>비동기식 코드의 에러처리: 관습</h1><p>try-catch는 동기식 에러처리 시에만 사용한다. 비동기식 에러 처리는 관습적으로 아래 방식을 사용한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//readFile.js</span></div><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>); <span class="comment">// Node.js 내장 모듈</span></div><div class="line">fs.readFile(<span class="string">'./calc.js'</span>, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</div><div class="line">  <span class="comment">// 에러처리</span></div><div class="line">  <span class="keyword">if</span>(err) &#123; <span class="comment">//error가 있으면</span></div><div class="line">    <span class="built_in">console</span>.error(err);</div><div class="line">  &#125;<span class="keyword">else</span> &#123; <span class="comment">//errro가 없으면 </span></div><div class="line">    <span class="built_in">console</span>.data(data);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'done!'</span>);</div></pre></td></tr></table></figure>
<h1 id="동기식-코드의-에러-처리-일반적인-방식으로-처리"><a href="#동기식-코드의-에러-처리-일반적인-방식으로-처리" class="headerlink" title="동기식 코드의 에러 처리: 일반적인 방식으로 처리"></a>동기식 코드의 에러 처리: 일반적인 방식으로 처리</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//readFileSync.js</span></div><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>); <span class="comment">// Node.js 내장 모듈</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">const</span> data = fs.readFileSync(<span class="string">'./calc.js'</span>, <span class="string">'utf8'</span>);</div><div class="line">  <span class="built_in">console</span>.log(data);</div><div class="line">&#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">  <span class="built_in">console</span>.log(err);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'done!'</span>);</div></pre></td></tr></table></figure>
<hr>
<p>위 예제에서 readFile.js는 비동기 방식이며 readFileSync는 동기 방식으로 동작하는 코드이다. 코드를 실행 한 후 결과를 보면, </p>
<ul>
<li>readFile.js</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">done</span>!</div><div class="line">&#123; Error: ENOENT: no such file or directory, open <span class="string">'./calc.js'</span> errno: -2, code: <span class="string">'ENOENT'</span>, syscall: <span class="string">'open'</span>, path: <span class="string">'./calc.js'</span> &#125;</div></pre></td></tr></table></figure>
<p>비동기 방식에서는 마지막 줄의 <code>console.log(&#39;done!&#39;)</code>코드가 이전 코드의 실행이 완료될 때까지 기다리지 않고 먼저 실행된다.</p>
<ul>
<li>readFileSync.js</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123; Error: ENOENT: no such file or directory, open <span class="string">'./calc.js'</span></div><div class="line">    at Object.fs.openSync (fs.js:652:18)</div><div class="line">    at Object.fs.readFileSync (fs.js:553:33)</div><div class="line">    at Object.&lt;anonymous&gt; (/Users/ihyeseung/projectfolder/fastcam/frontstudy/nodejs/practice/readFileSync.js:4:19)</div><div class="line">    at Module._compile (module.js:573:30)</div><div class="line">    at Object.Module._extensions..js (module.js:584:10)</div><div class="line">    at Module.load (module.js:507:32)</div><div class="line">    at tryModuleLoad (module.js:470:12)</div><div class="line">    at Function.Module._load (module.js:462:3)</div><div class="line">    at Function.Module.runMain (module.js:609:10)</div><div class="line">    at startup (bootstrap_node.js:158:16) errno: -2, code: <span class="string">'ENOENT'</span>, syscall: <span class="string">'open'</span>, path: <span class="string">'./calc.js'</span> &#125;</div><div class="line"><span class="keyword">done</span>!</div></pre></td></tr></table></figure>
<p>동기 방식에서는 <code>console.log(&#39;done!&#39;)</code>이 이전 코드의 실행이 완료될때까지 기다린 후 실행되었다.</p>
<p><br></p>
<h1 id="Github-REST-API-호출"><a href="#Github-REST-API-호출" class="headerlink" title="Github REST API 호출"></a>Github REST API 호출</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//request.js</span></div><div class="line"></div><div class="line"><span class="comment">// 유저 이름, 저장소, 할당된 이슈 갯수 출력하기</span></div><div class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>)</div><div class="line"><span class="keyword">const</span> apiUrl = <span class="string">'https://api.github.com'</span></div><div class="line"><span class="keyword">const</span> option = &#123;</div><div class="line">  json: <span class="literal">true</span>,</div><div class="line">  auth: &#123;</div><div class="line">    <span class="string">'user'</span>: <span class="string">'username'</span>, <span class="comment">// github 유저네임</span></div><div class="line">    <span class="string">'pass'</span>: <span class="string">'password'</span>, <span class="comment">// github 비밀번호</span></div><div class="line">  &#125;,</div><div class="line">  headers: &#123;</div><div class="line">    <span class="string">'User-Agent'</span>: <span class="string">'request'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">request.get(<span class="string">`<span class="subst">$&#123;apiUrl&#125;</span>/user`</span>, option, <span class="function"><span class="keyword">function</span> (<span class="params">error, response, body</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> name = body.name</div><div class="line">  <span class="keyword">if</span> (error) <span class="built_in">console</span>.error(error)</div><div class="line">  <span class="comment">// 콜백 안에 콜백</span></div><div class="line">  request.get(<span class="string">`<span class="subst">$&#123;apiUrl&#125;</span>/user/repos`</span>, option, <span class="function"><span class="keyword">function</span> (<span class="params">error, response, body</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (error) <span class="built_in">console</span>.error(error)</div><div class="line">    <span class="keyword">const</span> repoNames = body.map(<span class="function"><span class="params">item</span> =&gt;</span> item.name)</div><div class="line">    <span class="comment">// 콜백 안에 콜백 안에 콜백</span></div><div class="line">    request.get(<span class="string">`<span class="subst">$&#123;apiUrl&#125;</span>/issues`</span>, option, <span class="function"><span class="keyword">function</span> (<span class="params">error, response, body</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (error) <span class="built_in">console</span>.error(error)</div><div class="line">      <span class="keyword">const</span> issueNum = body.length</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">`name: <span class="subst">$&#123;name&#125;</span>`</span>)</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'repos:'</span>)</div><div class="line">      repoNames.forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(name)</div><div class="line">      &#125;)</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">`num of assigned issues: <span class="subst">$&#123;issueNum&#125;</span>`</span>)</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ node request.js</div></pre></td></tr></table></figure>
<h2 id="Callback-Hell"><a href="#Callback-Hell" class="headerlink" title="Callback Hell"></a>Callback Hell</h2><p><img src="https://image.slidesharecdn.com/promisesandchaininginangularjs-141027044455-conversion-gate02/95/promises-and-chaining-in-angularjs-into-callback-hell-and-back-again-17-638.jpg?cb=1414385382" alt="callback hell"></p>
<p><br></p>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>비동기 작업의 결과를 담는 객체<br>정확히 언제가 될지 모르지만, 결국 성공 또는 실패의 상태를 갖게 되며 이 상태가 되었을 때 비로소 콜백을 실행하라는 명령을 갖게 된다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tenSec.js</span></div><div class="line"></div><div class="line"><span class="comment">// 10초 뒤에 콜백(promise 객체를 새로 만들어서 리턴)을 실행하는 함수</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">tenSec</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      resolve(value)</div><div class="line">    &#125;, <span class="number">10000</span>)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; const tenSec = require(&apos;./tenSec&apos;)</div><div class="line">&gt; const p = tenSec(1) // p에 Promise 저장</div><div class="line">&gt; p // 만든지 10초가 지나기 전</div><div class="line">Promise &#123;</div><div class="line">  [pending], //pending: 아직 결과가 나오지 않음.</div><div class="line">  ...</div><div class="line">&gt; p // 만든지 10초가 지난 후</div><div class="line">Promise &#123;</div><div class="line">  1,</div><div class="line">  ...</div></pre></td></tr></table></figure>
<h2 id="1-promise의-상태-state"><a href="#1-promise의-상태-state" class="headerlink" title="1) promise의 상태(state)"></a>1) promise의 상태(state)</h2><ul>
<li><p>pending<br>아직 수행 중인 상태 (fulfilled 혹은 rejected 되기 전)</p>
</li>
<li><p>fulfilled<br>promise가 지켜진(수행된) 상태</p>
</li>
<li><p>rejected<br>promise가 지켜지지 못한(거부된) 상태</p>
</li>
<li><p>settled<br>fulfilled이든 rejected이든 결론이 난 상태</p>
</li>
</ul>
<h2 id="2-then"><a href="#2-then" class="headerlink" title="2) .then"></a>2) .then</h2><p>promise 객체의 메서드</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; tenSec(&apos;hello promise&apos;).then(value =&gt; &#123;</div><div class="line">... console.log(value)</div><div class="line">... &#125;)</div><div class="line">Promise &#123; // `then`은 Promise를 반환</div><div class="line">  [pending],</div><div class="line">  ...</div><div class="line">&gt; // 10초 후</div><div class="line">&apos;hello promise&apos;</div></pre></td></tr></table></figure>
<p>new Promise ()의 결과는 promise이다.<br>.then 메소드에서 반환된 값도 promise이다.<br>따라서 .then 메소드를 계속 사용할 수 있다.<br>.then 메소드를 쓰면 들여쓰기를 하지 않아도 된다.<br>따라서 Callback Hell을 피할 수 있다.</p>
<p>return은 바로 실행되는 동기식 작업이다. </p>
<p>비동기 작업을 하려면 콜백을 통해서 해야 했다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>()</div><div class="line">.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line">  request.get( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">  &#125;)</div><div class="line"><span class="keyword">return</span> <span class="comment">// 콜백은 함수 밖에서 리턴이 불가하다</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>promise는 함수 밖에서 리턴해야 하는데 위와 같은 콜백 방식에서는 함수 밖에서 리턴이 불가하다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>()</div><div class="line">.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line">  </div><div class="line">&#125;)</div><div class="line">.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line"></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="3-Promise-chaining"><a href="#3-Promise-chaining" class="headerlink" title="3) Promise chaining"></a>3) Promise chaining</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// chaining.js</span></div><div class="line"><span class="keyword">const</span> tenSec = <span class="built_in">require</span>(<span class="string">'./tenSec'</span>)</div><div class="line">tenSec(<span class="string">'hello promise'</span>)</div><div class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(value)</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="comment">// 위 `.then`은 값이 1인 Promise를 반환함</span></div><div class="line">  &#125;)</div><div class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(value) <span class="comment">// value = 1</span></div><div class="line">    <span class="keyword">return</span> tenSec(<span class="string">'new promise'</span>) <span class="comment">// Promise도 반환할 수 있음</span></div><div class="line">  &#125;) <span class="comment">// 안에 들어 있는 값이 value(=1)인 Promise 생성</span></div><div class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="comment">// tenSec이 실행되고 10초 후 실행됨</span></div><div class="line">    <span class="built_in">console</span>.log(value)</div><div class="line">  &#125;)</div><div class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">//promise 안에서 에러가 나면</span></div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error in promise'</span>)</div><div class="line">  &#125;)</div><div class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="comment">// 에러가 나면 catch 내부 코드 실행, 안나면 통과</span></div><div class="line">    <span class="built_in">console</span>.error(err)</div><div class="line">  &#125;)</div><div class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 에러 처리 이후에도 코드 실행 가능</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'done'</span>)</div><div class="line">  &#125;)</div></pre></td></tr></table></figure>
<hr>
<h3 id="기타-메소드"><a href="#기타-메소드" class="headerlink" title="기타 메소드"></a>기타 메소드</h3><ul>
<li>Promise.all(Arr): 모든 프라미스가 성공해야 성공하는 promise</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pa = <span class="built_in">Promise</span>.all([p1, p2])</div><div class="line"><span class="comment">// pa는 p1, p2가 모두 성공해야 성공하는 Promise이다.</span></div></pre></td></tr></table></figure>
<ul>
<li>Promise.race(Arr): 가장 빨리 성공하는 promise를 반환</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pr = <span class="built_in">Promise</span>.race([p1, pw])</div></pre></td></tr></table></figure>
<ul>
<li>promisify 함수</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// readfilePromise.js</span></div><div class="line"><span class="keyword">const</span> &#123;promisify&#125; = <span class="built_in">require</span>(<span class="string">'util'</span>) <span class="comment">// Node.js 8.0.0부터 추가됨</span></div><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="keyword">const</span> readFile = promisify(fs.readFile)</div><div class="line">readFile(<span class="string">'./calc.js'</span>, <span class="string">'utf8'</span>)</div><div class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(data)</div><div class="line">  &#125;)</div><div class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.error(err)</div><div class="line">  &#125;)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; Error: ENOENT: no such file or directory, open &apos;./calc.js&apos; errno: -2, code: &apos;ENOENT&apos;, syscall: &apos;open&apos;, path: &apos;./calc.js&apos; &#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="4-Promise의-특징"><a href="#4-Promise의-특징" class="headerlink" title="4) Promise의 특징"></a>4) Promise의 특징</h2><p>1) 이미 resolve 된 Promise에도 콜백을 실행할 수 있음</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">const</span> resolved = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</div><div class="line">&gt; resolved.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</div></pre></td></tr></table></figure>
<p>2) <code>.then</code>에 넘겨진 콜백은 (비동기가 아니라 바로 성공하도록 만들어진 동기식 promise라 하더라도)무조건 다음 루프에 실행됨</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">... Promise.resolve(<span class="number">1</span>).then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</div><div class="line">... console.log(<span class="string">'done!'</span>)</div><div class="line">... &#125;)()</div><div class="line"><span class="comment">/* 출력:</span></div><div class="line"><span class="comment">done! -&gt; 먼저 출력된다.</span></div><div class="line"><span class="comment">1</span></div><div class="line"><span class="comment">*/</span></div></pre></td></tr></table></figure>
<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// npm install --save request-promise</span></div><div class="line"><span class="keyword">const</span> rp = <span class="built_in">require</span>(<span class="string">'request-promise'</span>)</div><div class="line"><span class="keyword">const</span> apiUrl = <span class="string">'https://api.github.com'</span></div><div class="line"><span class="keyword">const</span> option = &#123;</div><div class="line">  json: <span class="literal">true</span>,</div><div class="line">  auth: &#123;</div><div class="line">    <span class="string">'user'</span>: <span class="string">'username'</span>,</div><div class="line">    <span class="string">'pass'</span>: <span class="string">'password'</span>,</div><div class="line">  &#125;,</div><div class="line">  headers: &#123;</div><div class="line">    <span class="string">'User-Agent'</span>: <span class="string">'request'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> userPromise = rp.get(<span class="string">`<span class="subst">$&#123;apiUrl&#125;</span>/user`</span>, option)</div><div class="line"><span class="keyword">const</span> reposPromise = rp.get(<span class="string">`<span class="subst">$&#123;apiUrl&#125;</span>/user/repos`</span>, option)</div><div class="line"><span class="keyword">const</span> issuesPromise = rp.get(<span class="string">`<span class="subst">$&#123;apiUrl&#125;</span>/issues`</span>, option)</div><div class="line"></div><div class="line"><span class="comment">// 배열 내의 모든 Promise 객체가 완료되었을 때</span></div><div class="line"><span class="comment">// resolve 되는 Promise를 만든다.</span></div><div class="line"><span class="built_in">Promise</span>.all([userPromise, reposPromise, issuesPromise])</div><div class="line">  .then(<span class="function">(<span class="params">[user, repos, issues]</span>) =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`name: <span class="subst">$&#123;user.name&#125;</span>`</span>)</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'repos:'</span>)</div><div class="line">    repos.forEach(<span class="function"><span class="params">repo</span> =&gt;</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(repo.name)</div><div class="line">    &#125;)</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`num of assigned issues: <span class="subst">$&#123;issues.length&#125;</span>`</span>)</div><div class="line">  &#125;)</div></pre></td></tr></table></figure>
<p>비동기 코드와 동일한 일을 promise로 할 수 있으며 promise를 이용하면 좀 더 깔끔하게 코드를 짤 수 있다.</p>
<blockquote>
<ul>
<li><a href="http://hacks.mozilla.or.kr/2015/05/this-api-is-so-fetching/" target="_blank" rel="external">Fetch API</a><ul>
<li>window.fetch polyfill: Fetch API를 IE에서도 사용할 수 있게 해준다.</li>
</ul>
</li>
</ul>
</blockquote>
<p><br></p>
<h1 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async/Await"></a>Async/Await</h1><ul>
<li>ES2017에서 도입되어, 비동기식 코드를 동기식 코드처럼 쓸 수 있는 문법 제공</li>
<li>Chrome 55, Node.js 8.0.0 부터 사용가능<br>(아주 최근에 나온 문법이므로, 아직까지는 비동기식 코드에 promise가 더 널리 쓰인다.)</li>
<li>async function 안에서 반환된 값은 최종적으로 Promise 객체로 변환되어 반환된다.</li>
<li>async function 안에서 쓸 수 있는 await 키워드는 현재 함수를 중단시키고 Promise 객체가 충족될 때까지 기다리지만, 스레드를 block 하지 않는다.</li>
<li>에러 처리는 동기식 코드처럼 try, catch 블록을 통해서 한다.</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> tenSec = <span class="built_in">require</span>(<span class="string">'./tenSec'</span>)</div><div class="line"></div><div class="line"><span class="comment">//await는 async 함수 안에서만 사용할 수 있다.</span></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveAfterTenSec</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">await</span> tenSec()</div><div class="line">  <span class="keyword">return</span> <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">resolveAfterTenSec().then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(value)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="1-readFile-async-await"><a href="#1-readFile-async-await" class="headerlink" title="1) readFile - async/await"></a>1) readFile - async/await</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// readfileAsync.js</span></div><div class="line"><span class="keyword">const</span> &#123;promisify&#125; = <span class="built_in">require</span>(<span class="string">'util'</span>) <span class="comment">// Node.js 8.0.0부터 추가됨</span></div><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="keyword">const</span> readFile = promisify(fs.readFile)</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">readFileAsync</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> readFile(<span class="string">'./calc.js'</span>, <span class="string">'utf8'</span>)</div><div class="line">    <span class="built_in">console</span>.log(data)</div><div class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    <span class="built_in">console</span>.error(e)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">readFileAsync()</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; Error: ENOENT: no such file or directory, open &apos;./calc.js&apos; errno: -2, code: &apos;ENOENT&apos;, syscall: &apos;open&apos;, path: &apos;./calc.js&apos; &#125;</div></pre></td></tr></table></figure>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;nvm-node-version-manager&quot;&gt;&lt;a href=&quot;#nvm-node-version-manager&quot; class=&quot;headerlink&quot; title=&quot;nvm(node version manager)&quot;&gt;&lt;/a&gt;nvm(node vers
    
    </summary>
    
      <category term="Nodejs" scheme="http://huusz.github.io/categories/Nodejs/"/>
    
    
      <category term="nvm" scheme="http://huusz.github.io/tags/nvm/"/>
    
  </entry>
  
  <entry>
    <title>[JS] 비동기모델과 이벤트루프</title>
    <link href="http://huusz.github.io/2017/Javascript/Javascript/Javascript-Async,EventLoop/"/>
    <id>http://huusz.github.io/2017/Javascript/Javascript/Javascript-Async,EventLoop/</id>
    <published>2017-08-29T15:35:42.000Z</published>
    <updated>2017-08-29T15:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="비동기식-처리-모델과-이벤트-루프"><a href="#비동기식-처리-모델과-이벤트-루프" class="headerlink" title="비동기식 처리 모델과 이벤트 루프"></a>비동기식 처리 모델과 이벤트 루프</h1><h2 id="1-브라우저-동작-원리"><a href="#1-브라우저-동작-원리" class="headerlink" title="1. 브라우저 동작 원리"></a>1. 브라우저 동작 원리</h2><h3 id="1-브라우저의-주요-기능"><a href="#1-브라우저의-주요-기능" class="headerlink" title="1) 브라우저의 주요 기능"></a>1) 브라우저의 주요 기능</h3><p>브라우저의 주요 기능은 사용자가 참조하고자 하는 자원을 (또는 웹페이지를) 서버에 요청(Request)하고 응답(Response)을 받아 브라우저에 표시하는 것이다. 브라우저가 서버로부터 받는 자원은 보통 HTML 문서이지만, PDF나 이미지 또는 다른 형태일 수 있다. 일반적으로 브라우저는 서버로부터 HTML, CSS, Javascript 파일을 응답받는다. (자원의 주소는 URI에 의해 정해진다.)<br>브라우저는 W3C(웹 표준화 기구)에서 정한 HTML과 CSS 표준 명세에 따라 HTML 파일을 해석해서 표시한다.</p>
<p><br></p>
<h3 id="2-브라우저의-기본-구조"><a href="#2-브라우저의-기본-구조" class="headerlink" title="2) 브라우저의 기본 구조"></a>2) 브라우저의 기본 구조</h3><p><img src="http://d2.naver.com/content/images/2015/06/helloworld-59361-1.png" alt="브라우저의 구성 요소"></p>
<ol>
<li><p>사용자 인터페이스: 주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등. 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분이다.</p>
</li>
<li><p>브라우저 엔진: 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어.</p>
</li>
<li><p>렌더링 엔진: 요청한 콘텐츠를 표시한다. 예를 들어 HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시한다.</p>
</li>
<li><p>통신: HTTP 요청과 같은 네트워크 호출에 사용된다. 플랫폼 독립적인 인터페이스이고 각 플랫폼 하부에서 실행된다.</p>
</li>
<li><p>UI 백엔드: 콤보 박스와 창 같은 기본적인 장치를 그린다. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, OS 사용자 인터페이스 체계를 사용한다.</p>
</li>
<li><p>자바스크립트 해석: 자바스크립트 코드를 해석하고 실행한다.</p>
</li>
<li><p>자료 저장소: 자료를 저장하는 계층이다. 쿠키를 저장하는 것과 같이 모든 종류의 자원을 하드 디스크에 저장할 필요가 있다. HTML5 명세에는 브라우저가 지원하는 <a href="http://www.html5rocks.com/en/features/storage" target="_blank" rel="external">웹 데이터베이스</a>가 정의되어 있다.</p>
</li>
</ol>
<p>크롬 브라우저는 각 탭마다 별도의 렌더링 엔진 인스턴스를 유지한다. 따라서 각 탭은 독립된 프로세스로 처리된다.</p>
<p><br></p>
<h3 id="3-렌더링-엔진"><a href="#3-렌더링-엔진" class="headerlink" title="3) 렌더링 엔진"></a>3) 렌더링 엔진</h3><p>렌더링 엔진의 역할은 요청 받은 콘텐츠를 브라우저에 표시하는 일이다. HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시한다. HTML, CSS 파일은 렌더링 엔진의 HTML 파서와 CSS 파서에 의해 파싱되어 DOM, CSSOM 트리로 변환되고 렌더 트리로 결합된다.</p>
<p>렌더링 엔진은 XML 문서와 이미지도 표시할 수 있다. 물론 플러그인이나 브라우저 확장 기능을 이용해 PDF 같은 다른 유형도 표시할 수 있다. 여기서는 HTML과 이미지를 CSS로 표시하는 주된 사용 패턴에 초점을 둘 것이다.</p>
<blockquote>
<p>렌더링 엔진은 브라우저마다 다르다. 파이어폭스는 게코(Gecko) 엔진을 사용하며 사파리와 크롬은 웹킷(Webkit) 엔진을 사용한다.</p>
</blockquote>
<h3 id="렌더링-엔진-동작-과정"><a href="#렌더링-엔진-동작-과정" class="headerlink" title="렌더링 엔진 동작 과정"></a>렌더링 엔진 동작 과정</h3><p>렌더링 엔진은 통신으로부터 요청한 문서의 콘텐츠를 얻는 것으로 시작한다. 문서 내용은 보통 8KB 단위로 전송된다.</p>
<p><img src="http://d2.naver.com/content/images/2015/06/helloworld-59361-2.png" alt="렌더링 엔진 동작 과정"></p>
<p><img src="http://poiemaweb.com/img/client-server.png" alt="브라우저 동작 원리"></p>
<ul>
<li><p>렌더링 엔진은 HTML 문서를 파싱하고, 콘텐츠 트리 내부에서 태그를 DOM 노드로 변환한다. 그다음 외부 CSS 파일과 함께 포함된 스타일 요소도 파싱한다. 파싱된 스타일 정보는 CSSOM 노드로 변환한다.  </p>
</li>
<li><p>스타일 정보(CSSOM)와 HTML 표시 규칙(DOM)으로 <strong>렌더 트리</strong>라는 또 다른 트리를 생성한다. 렌더트리는 색상이나 면적같은 시각적 속성이 있는 박스를 포함하고 있는데, 정해진 순서대로 화면에 표시된다.</p>
</li>
<li><p>렌더 트리의 각 노드가 화면의 정확한 위치에 배치되어 표시된다. 다음은 UI 백엔드에서 렌더 트리의 각 노드를 가로지르며 형상을 만들어내는 그리기 과정이다.</p>
</li>
</ul>
<p>일련의 과정들이 점진적으로 진행된다는 것을 아는 것이 중요하다. 렌더링 엔진은 좀 더 나은 사용자 경험을 위해 가능하면 빠르게 내용을 표시하는데 <strong>모든 HTML을 파싱할 때까지 기다리지 않고 배치와 그리기 과정을 시작한다.</strong> 네트워크로부터 나머지 내용이 전송되기를 기다리는 동시에 받은 내용의 일부를 먼저 화면에 표시하는 것이다.</p>
<p><img src="http://d2.naver.com/content/images/2015/06/helloworld-59361-3.png" alt="웹킷 렌더링 엔진"></p>
<p><img src="http://d2.naver.com/content/images/2015/06/helloworld-59361-4.png" alt="게코 렌더링 엔진"></p>
<hr>
<p><strong>[참고]</strong> <a href="http://d2.naver.com/helloworld/59361" target="_blank" rel="external">브라우저는 어떻게 동작하는가</a>, <a href="http://poiemaweb.com/js-async" target="_blank" rel="external">Poiema web</a>  </p>
<p>HTML 파서는 script 태그를 만나면 DOM 생성 프로세스를 중지하고 자바스크립트 엔진에 제어 권한을 넘긴다. 자바스크립트 엔진의 실행이 완료된 후 브라우저가 중지했던 시점부터 DOM 생성을 재개한다. 이것은 script 태그의 위치에 의해 DOM의 생성이 지연될 수 있음을 의미한다.</p>
<p><br></p>
<h2 id="2-Ajax"><a href="#2-Ajax" class="headerlink" title="2. Ajax"></a>2. Ajax</h2><p>브라우저에서 웹페이지를 요청하거나 링크를 클릭하면 화면 전환이 발생한다. 이것은 브라우저와 서버와의 통신에 의한 것이다.</p>
<p><img src="http://poiemaweb.com/img/req_res.png" alt=""></p>
<p>서버는 요청받은 페이지(HTML)를 반환하는데 이때 HTML에서 로드하는 CSS나 JavaScript 파일들도 같이 반환된다. 클라이언트의 요청에 따라 서버는 정적인 파일을 반환할 수도 있고 서버 사이드 프로그램이 만들어낸 파일이나 데이터를 반환할 수도 있다. 서버로부터 웹페이지가 반환되면 클라이언트(브라우저)는 이를 렌더링하여 화면에 표시한다.</p>
<p><img src="http://poiemaweb.com/img/traditional-webpage-lifecycle.png" alt="Traditional Web Page Lifecycle"></p>
<h3 id="Ajax-Asynchronous-JavaScript-and-XML-는-자바스크립트를-이용해서-비동기적-Asynchronous-으로-서버와-브라우저가-데이터를-교환할-수-있는-통신-방식을-의미한다"><a href="#Ajax-Asynchronous-JavaScript-and-XML-는-자바스크립트를-이용해서-비동기적-Asynchronous-으로-서버와-브라우저가-데이터를-교환할-수-있는-통신-방식을-의미한다" class="headerlink" title="Ajax(Asynchronous JavaScript and XML)는 자바스크립트를 이용해서 비동기적(Asynchronous)으로 서버와 브라우저가 데이터를 교환할 수 있는 통신 방식을 의미한다."></a>Ajax(Asynchronous JavaScript and XML)는 자바스크립트를 이용해서 비동기적(Asynchronous)으로 서버와 브라우저가 데이터를 교환할 수 있는 통신 방식을 의미한다.</h3><p>서버로부터 웹페이지가 반환되면 화면 전체를 갱신해야 하는데, AJAX는 페이지 일부만을 갱신하고도 동일한 효과를 볼 수 있도록 한다. 페이지 전체를 로드하여 렌더링할 필요가 없고 갱신이 필요한 일부만 로드하여 갱신하면 되므로 <strong>빠른 퍼포먼스와 부드러운 화면 표시 효과</strong>를 기대할 수 있다.</p>
<p><img src="http://poiemaweb.com/img/ajax-webpage-lifecycle.png" alt="AJAX Lifecycle"></p>
<p>서버는 HTML, XML, JSON등을 반환하는데, Ajax을 위한 데이터 형식은 <strong>JSON(JavaScript Object Notation)</strong> 을 사용하는 것이 일반적이다.</p>
<p><br></p>
<h2 id="3-동기식-처리-모델-VS-비동기식-처리-모델"><a href="#3-동기식-처리-모델-VS-비동기식-처리-모델" class="headerlink" title="3. 동기식 처리 모델 VS 비동기식 처리 모델"></a>3. 동기식 처리 모델 VS 비동기식 처리 모델</h2><h3 id="동기식-처리-모델-Synchronous-processing-model"><a href="#동기식-처리-모델-Synchronous-processing-model" class="headerlink" title="동기식 처리 모델(Synchronous processing model)"></a>동기식 처리 모델(Synchronous processing model)</h3><p>작업이 순차적으로 실행된다. 어떤 작업이 수행 중이면 다음 작업은 대기한다. 예를 들어 서버에서 데이터를 가져와 화면에 표시하는 작업을 수행할 경우 서버에 데이터를 요청하고 데이터가 전달될 때까지 이후 작업들은 중단(Blocking)된다.<br><img src="http://poiemaweb.com/img/synchronous.png" alt="동기식 처리 모델"> </p>
<h3 id="비동기식-처리-모델-Asynchronous-processing-model-or-Non-Blocking-processing-model"><a href="#비동기식-처리-모델-Asynchronous-processing-model-or-Non-Blocking-processing-model" class="headerlink" title="비동기식 처리 모델(Asynchronous processing model or Non-Blocking processing model)"></a>비동기식 처리 모델(Asynchronous processing model or Non-Blocking processing model)</h3><p>작업이 종료되지 않은 상태라도 대기하지 않고 다음 작업을 실행한다. 예를 들어 서버에서 데이터를 가져와 화면에 표시하는 작업을 수행할 경우 서버에 데이터를 요청한 이후 서버로부터 데이터가 전달될 때까지 <strong>대기하지 않고(Non-Blocking) 즉시 다음 작업을 수행한다.</strong> 이후 서버로부터 데이터가 전달되면 이벤트가 발생되고 이벤트 핸들러가 데이터를 가지고 수행할 작업을 계속하여 수행한다.</p>
<p><strong>자바스크립트의 대부분의 DOM 이벤트와 Timer 함수(setTimeout, setInterval), Ajax 요청은 비동기적으로 동작한다.</strong></p>
<p><img src="http://poiemaweb.com/img/asynchronous.png" alt="비동기적 처리 모델"></p>
<p><br></p>
<h2 id="4-이벤트-루프와-동시성-Concurrency"><a href="#4-이벤트-루프와-동시성-Concurrency" class="headerlink" title="4. 이벤트 루프와 동시성(Concurrency)"></a>4. 이벤트 루프와 동시성(Concurrency)</h2><p><strong><em>브라우저는 단일 쓰레드(single-thread)에서 이벤트 드리븐(event-driven) 방식으로 동작한다.</em></strong></p>
<p>자바스크립트는 본래 단일스레드 기반의 언어이다. 한번에 하나의 작업(task)만을 처리할 수 있다는 의미이다. 하지만 실제 웹 애플리케이션들을 보면 여러 task가 동시에 처리되는 것처럼 보인다. 이는 자바스크립트가 이벤트 루프를 이용해서 비동기 방식으로 동시성을 지원하기 때문이다.</p>
<h3 id="브라우저-환경"><a href="#브라우저-환경" class="headerlink" title="브라우저 환경"></a>브라우저 환경</h3><p><img src="http://poiemaweb.com/img/event-loop.png" alt="이벤트 루프(Event Loop)와 브라우저의 환경"></p>
<p>자바스크립트 엔진은 크게 콜 스택 영역과 힙 영역으로 나뉜다. 흔히 비동기 호출을 위해 사용하는 <code>setTimeout</code>이나 <code>XMLHttpRequest</code>와 같은 함수들은 자바스크립트 엔진이 아닌 Web API 영역에 따로 정의되어 있음을 확인할 수 있다. 비동기 방식을 가능하게 하는 이벤트 루프와 태스트 큐(이벤트 큐) 또한 자바스크립트 엔진 외부에 구현되어있다.</p>
<p><strong><em>1. Call Stack(호출 스택)</em></strong><br>작업이 요청되면(함수가 실행되면) 요청된 작업은 순차적으로 Call Stack에 쌓이게 되고 순차적으로 실행된다. 자바스크립트는 단 하나의 Call Stack을 사용하기 때문에 해당 task가 종료하기 전까지는 다른 어떤 task도 수행될 수 없다.</p>
<p><strong><em>2. Heap</em></strong><br>힙은 동적으로 생성된 객체 인스턴스가 할당되는 영역이다.</p>
<p>이와 같이 자바스크립트 엔진은 단순히 작업이 요청되면 요청된 작업을 Call Stack을 사용하여 순차적으로 실행할 뿐이다. 앞에서 언급한 동시성(Concurrency)을 지원하기 위해 필요한 <em>비동기 요청(이벤트를 포함) 처리는 자바스크립트 엔진을 구동하는 환경, 즉 브라우저(또는 Node.js)가 담당한다.</em></p>
<p><strong><em>3. Event Queue(Task Queue)</em></strong><br>비동기 처리 함수의 콜백 함수, 비동기식 이벤트 핸들러, Timer 함수(setTimeout(), setInterval())가 보관되는 영역이다. <strong>이벤트 루프(Event Loop)에 의해 특정 시점(Call Stack이 비어졌을 때)에 순차적으로 Call Stack으로 이동되어 실행된다.</strong></p>
<p><strong><em>4. Event Loop(이벤트 루프)</em></strong><br>Call Stack내에서 1) 현재 실행중인 task가 있는지, 그리고 2) Event Queue에 task가 있는지 반복하여 확인한다.</p>
<p>아래의 예제가 어떻게 동작할지 살펴보자.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'func1'</span>);</div><div class="line">  func2();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'func2'</span>);</div><div class="line">  &#125;, <span class="number">0</span>);</div><div class="line"></div><div class="line">  func3();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func3</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'func3'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">func1();</div></pre></td></tr></table></figure>
<p>함수 func1이 호출되면 함수 func1은 Call Stack에 쌓인다. 그리고 함수 func1은 함수 func2을 호출하므로 함수 func2가 Call Stack에 쌓이고 setTimeout가 호출된다. setTimeout의 핸들러는 즉시 실행되지 않고 지정 대기 시간만큼 기다리다가 이벤트 큐로 이동한 후 Call Stack이 비어졌을 때 Call Stack으로 이동되어 실행된다.</p>
<p><img src="http://poiemaweb.com/img/event-loop.gif" alt="이벤트 루프(Event Loop)에 의한 setTimeout 핸들러의 실행"></p>
<p>DOM 이벤트도 이와 같이 동작한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'func1'</span>);</div><div class="line">  func2();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// &lt;button id="foo"&gt;foo&lt;/button&gt;</span></div><div class="line">  <span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">'foo'</span>);</div><div class="line"></div><div class="line">  elem.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.style.backgroundColor = <span class="string">'indigo'</span>;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'func2'</span>);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  func3();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func3</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'func3'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">func1();</div></pre></td></tr></table></figure>
<p>함수 func1이 호출되면 함수 func1은 Call Stack에 쌓인다. 그리고 함수 func1은 함수 func2을 호출하므로 함수 func2가 Call Stack에 쌓이고 addEventListener가 호출된다. addEventListener의 콜백함수는 foo 버튼이 클릭되어 “onclick” 이벤트가 발생하면 이벤트 큐로 이동한 후 Call Stack이 비어졌을 때 Call Stack으로 이동되어 실행된다.</p>
<h3 id="Nodejs-환경"><a href="#Nodejs-환경" class="headerlink" title="Nodejs 환경"></a>Nodejs 환경</h3><p><img src="https://camo.githubusercontent.com/cb45689d053b03f76965aa02fff3b049ce79e533/68747470733a2f2f7062732e7477696d672e636f6d2f6d656469612f42743579774a72494541414b4a51742e6a7067" alt="nodejs 환경"></p>
<p>Node.js는 비동기 IO를 지원하기 위해 libuv 라이브러리를 사용하며, 이 libuv가 이벤트 루프를 제공한다. 자바스크립트 엔진은 비동기 작업을 위해 Node.js의 API를 호출하며, 이때 넘겨진 콜백은 libuv의 이벤트 루프를 통해 스케쥴되고 실행된다.</p>
<hr>
<p>결론적으로, 자바스크립트가 단일 스레드 기반의 언어라는 말은 <strong>자바스크립트 엔진이 단일 호출 스택을 사용한다</strong>는 관점에서만 사실이다. 실제 자바스크립트가 구동되는 환경(브라우저, nodejs 등)에서는 주로 여러개의 스레드가 사용되며 이러한 구동 환경이 단일 호출 스택을 사용하는 자바스크립트 엔진과 상호 연동하기 위해 사용하는 장치가 바로 이벤트 루프이다.</p>
<hr>
<p>Reference</p>
<p><a href="http://poiemaweb.com/js-async" target="_blank" rel="external">Poiemaweb</a>  </p>
<p><a href="https://github.com/nhnent/fe.javascript/wiki/June-13-June-17,-2016" target="_blank" rel="external">nhnent/github</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;비동기식-처리-모델과-이벤트-루프&quot;&gt;&lt;a href=&quot;#비동기식-처리-모델과-이벤트-루프&quot; class=&quot;headerlink&quot; title=&quot;비동기식 처리 모델과 이벤트 루프&quot;&gt;&lt;/a&gt;비동기식 처리 모델과 이벤트 루프&lt;/h1&gt;&lt;h2 id=&quot;1
    
    </summary>
    
      <category term="Javascript" scheme="http://huusz.github.io/categories/Javascript/"/>
    
    
      <category term="asynchronous" scheme="http://huusz.github.io/tags/asynchronous/"/>
    
  </entry>
  
  <entry>
    <title>[JS] 클로져 Closure</title>
    <link href="http://huusz.github.io/2017/Javascript/Javascript/Javascript-Closure/"/>
    <id>http://huusz.github.io/2017/Javascript/Javascript/Javascript-Closure/</id>
    <published>2017-08-07T15:35:42.000Z</published>
    <updated>2017-08-28T14:13:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="클로저"><a href="#클로저" class="headerlink" title="클로저"></a>클로저</h1><h2 id="1-클로저의-개념"><a href="#1-클로저의-개념" class="headerlink" title="1. 클로저의 개념"></a>1. 클로저의 개념</h2><p>클로저는 자바스크립트에서 중요한 개념 중 하나이다. 클로저는 자바스크립트 고유의 개념이 아니라 함수를 일급 객체로 취급하는 함수형 언어에서 사용되는 중요한 속성이다. 클로저란, 이미 생명 주기가 끝난 외부 함수의 변수를 참조하는 함수이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunc</span>(<span class="params"></span>) </span>&#123;  <span class="comment">//...(1)</span></div><div class="line">  <span class="keyword">var</span> x = <span class="number">10</span>; </div><div class="line">  <span class="keyword">var</span> innerFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//...(2)</span></div><div class="line">    <span class="built_in">console</span>.log(x); <span class="comment">//...(3)</span></div><div class="line">  &#125;;</div><div class="line">  innerFunc();</div><div class="line">&#125;</div><div class="line">outerFunc();</div></pre></td></tr></table></figure>
<p>위 예제를 통해 살펴보면, outerFunc 함수가 선언되었고 …(1)<br>그 내부 함수로 innerFunc가 선언되었다. …(2)<br>innerFunc는 자신을 포함하고 있는 outerFunc의 지역 변수 x에 접근할 수 있다. …(3)  </p>
<p>자바스크립트 엔진은 Scope-chain을 통해 중첩된 함수의 scope 레퍼런스를 차례대로 검색한다.  </p>
<ol>
<li>innerFunc 함수 내에서 변수 x를 검색한다. x가 존재하지 않는다. 검색 실패.</li>
<li>innerFunc 함수의 외부 함수 outerFunc 함수에서 변수 x를 검색한다. x가 존재한다. 검색 성공!</li>
</ol>
<p>이번에는 innerFunc를 outerFunc에서 반환하는 코드로 변경해보자.  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunc</span>(<span class="params"></span>)</span>&#123; <span class="comment">// ...(1)</span></div><div class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line">  <span class="keyword">var</span> innerFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//...(2)</span></div><div class="line">    <span class="built_in">console</span>.log(x);</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">return</span> innerFunc; <span class="comment">//...(3)</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> inner = outerFunc(); <span class="comment">// ...(4)</span></div><div class="line">inner(); <span class="comment">//...(5)</span></div></pre></td></tr></table></figure>
<p>(1), (2) 과정은 위와 동일하고, innerFunc를 반환하는 outerFunc를 정의하였다. …(3)<br>inner 변수에 outerFunc() 함수의 실행 결과를 저장한다. outerFunc의 실행 결과로 innerFunc의 참조가 반환된다. 결론적으로 innerFunc 함수의 참조가 변수 inner에 할당된다. 그리고 이때, outerFunc 함수가 종료되면서 life-cycle이 종료된다. …(4)<br>변수 inner에 할당된 참조값을 통해 innerFunc 함수를 실행한다….(5)<br>즉 outerFunc는 실행된 이후 콜스택(call stack)에서 제거되었으므로 함수 outerFunc의 지역변수 x 또한 더이상 유효하지 않게 되어 변수 x에 접근할 수 있는 방법이 없어 보인다. 하지만 위 코드의 실행 결과는 변수 x의 값인 10이다. </p>
<p>원래대로라면 외부 함수 내에 있는 지역 변수는 외부함수의 실행 컨텍스트에 구속되어 있는 존재이기 때문에 외부함수가 사라지면 함께 사라져야 한다. 하지만 지역 변수가 외부 함수 내부에, 같은 유효범위 내에 선안된 내부 함수에 의해 참조되면, 그 변수의 life cycle은 외부 함수보다 길어진다. 외부 함수의 참조는 끊어지지만, 외부 함수의 지역 변수는 내부 함수가 호출되면서 함께 계속 참조되므로 <sup>1)</sup>가비지 컬렉션의 수집 대상에서 벗어난다. 그리고 지역 변수의 라이프 사이클은 내부 함수와 함께 가게 된다. 즉, 내부 함수가 종료될 때 까지 살아있는 변수로 남게 되는 것이다.</p>
<blockquote>
<p><sup>1)</sup> 가비지컬렉션: 자바스크립트는 변수나 함수를 선언할 때 메모리를 할당한다. 그리고 할당된 메모리가 필요하지 않게 되면, 즉 어떤 변수나 함수에서도 더이상 참조하지 않게 되면 자바스크립트의 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management" target="_blank" rel="external">가비지 컬렉션</a>이 메모리를 해제한다.</p>
</blockquote>
<ul>
<li>내부 함수가 외부 함수의 지역변수에 접근할 수 있다.</li>
<li>외부 함수는 외부 함수의 지역변수를 사용하는 내부 함수가 소멸될 때까지 소멸되지 못하고 상태가 유지되며, 내부 함수에 의해 소멸하게 된다.</li>
</ul>
<h3 id="위와-같은-특성을-클로저-Closure-라고-부른다"><a href="#위와-같은-특성을-클로저-Closure-라고-부른다" class="headerlink" title="위와 같은 특성을 클로저(Closure)라고 부른다."></a>위와 같은 특성을 <strong>클로저(Closure)</strong>라고 부른다.</h3><blockquote>
<p>외부 함수 내에서 내부 함수를 선언할 때, 함수만 정의되는 것이 아니라, 그 시점에 같은 유효 범위에 있는 모든 변수를 포함하는 클로저도 생성된다. 그 다음, 내부 함수를 실행하면 함수가 속해있던 유효 범위가 사라진 후에 실행됨에도 클로저를 통해 정의된 원래 유효범위에 접근하게 된다. 이것이 클로저의 핵심이다. 클로저는 <strong>보호막</strong>을 만든다. 보호막은 함수가 선언된 시점의 유효범위 내에 있는 모든 함수와 변수를 가지고 있으며 필요할 때 그것들을 사용할 수 있다. 이 보호막은 함수가 동작하는 한 관련 정보를 유지한다. &lt;자바스크립트 닌자 비급, p.118, 인사이트, 2014&gt;</p>
</blockquote>
<h3 id="1-자유변수-Free-variable"><a href="#1-자유변수-Free-variable" class="headerlink" title="1) 자유변수(Free variable)"></a>1) 자유변수(Free variable)</h3><p>클로저에 의해 참조되는 외부 함수의 변수</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunc</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> x = <span class="number">10</span>; <span class="comment">// 자유변수</span></div><div class="line">  <span class="keyword">var</span> innerFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(x);</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">return</span> innerFunc;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> inner = outerFunc();</div><div class="line">inner();</div></pre></td></tr></table></figure>
<p>예제의 outerFunc 함수의 지역 변수 x가 자유변수에 해당한다. 클로저라는 이름은 ‘자유변수에 함수가 닫혀있다(closed)’라는 의미로, 의역하자면 자유변수에 엮여있는 함수라는 뜻이다.  </p>
<p>실행컨텍스트의 관점에서,  </p>
<p>내부 함수가 유효한 상태에서 외부 함수가 종료된 경우를 생각해보자. 외부 함수의 실행 컨텍스트가 반환되어도, 그 내부의 Activation object(AO)는 유효하다. 다시 말해, 내부 함수가 Scope-chain을 통해 AO를 참조할 수 있다. 즉 외부함수가 이미 반환되었어도 외부함수 내의 변수는 자신을 필요로 하는 내부 함수가 하나 이상 존재하는 경우 계속 유지될 수 있다는 것이다. 이때 내부 함수가 외부 함수에 있는 변수의 <strong>복사본이 아니라 실제</strong> 변수에 접근한다는 것에 주의해야 한다.  </p>
<p><img src="http://poiemaweb.com/img/closure.png" alt="실행 컨텍스트의 Activation object와 클로저"></p>
<p><br></p>
<h2 id="2-클로저의-활용"><a href="#2-클로저의-활용" class="headerlink" title="2. 클로저의 활용"></a>2. 클로저의 활용</h2><p>그렇다면 클로저는 언제 사용하는가?  </p>
<p>클로저 정보를 저장하고 참조하는 데는 직접적인 비용이 발생한다. 클로저 정보를 따로 보관해두는 명시적인 “closure”객체 같은 것은 존재하지 않기 때문에 클로저를 이용해 정보에 접근하는 함수는 계속해서 관련된 정보를 가지고 다녀야 한다. 클로저는 정말 유용하지만, 오버헤드에서 자유롭다고 할 수 없다. 클로저에 관한 모든 정보는 더이상 사용하는 곳이 없을 때, 혹은 페이지가 언로드 될 때까지 메모리에 남아있는다. 따라서 클로저가 의도되지 않은 상황이었다면 이는 리소스 낭비일 뿐이다. 클로저는 의도된 상황에서 활용되어야 한다.</p>
<h3 id="1-전역-변수의-사용-억제"><a href="#1-전역-변수의-사용-억제" class="headerlink" title="1) 전역 변수의 사용 억제"></a>1) 전역 변수의 사용 억제</h3><p>클로저의 필요성을 이해하기 위해, 버튼이 클릭될 때마다 클릭 횟수가 누적되어 화면에 표시되는 코드를 만들어보자.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>전역 변수를 사용한 Counting<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"myFunction()"</span>&gt;</span>Count!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">    <span class="keyword">var</span> counter = <span class="number">0</span>; </span></div><div class="line"><span class="javascript">    <span class="comment">// 전역변수의 사용은 그다지 좋지 못하다. 전역 변수를 쓰지 않는 방법을 찾아야 한다.</span></span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span></div><div class="line"><span class="javascript">      <span class="keyword">return</span> counter += <span class="number">1</span>;</span></div><div class="line"><span class="undefined">    &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>)</span>&#123;</span></div><div class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">'demo'</span>).innerHTML = add();</span></div><div class="line"><span class="undefined">    &#125;</span></div><div class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>위 코드는 동작에는 전혀 무리가 없다. 다만 add 함수만을 위한 전역 변수를 사용하고 있다. 전역 변수는 어디서나 접근할 수 있어 의도치 않게 변수명이 중복되거나 값이 변경되었을 때 문제가 발생할 소지가 다분하다. 따라서 전역 변수를 쓰지 않는 방법을 강구해야 한다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>지역 변수를 사용한 Counting<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"myFunction()"</span>&gt;</span>Count!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span></div><div class="line"><span class="javascript">      <span class="keyword">var</span> counter = <span class="number">0</span>; <span class="comment">// 전역 변수에서 add 함수 내부의 지역 변수로 이동시켰다.</span></span></div><div class="line"><span class="javascript">      <span class="keyword">return</span> counter += <span class="number">1</span>;</span></div><div class="line"><span class="undefined">    &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>)</span>&#123;</span></div><div class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">'demo'</span>).innerHTML = add();</span></div><div class="line"><span class="undefined">    &#125;</span></div><div class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>전역 변수를 피하기 위해 add 함수 내부로 이동시켜, 지역 변수로 다시 선언하였다. 그런데 이번엔 함수의 작동 방식에서 문제가 발생하였다. counter가 함수가 호출될 때마다 0으로 리셋되어 0 -&gt; 1 -&gt; 함수호출 -&gt; 0 -&gt; 1 을 반복하게 되어, 화면 상에는 1만 표시된다. 처음 의도했던 동작을 수행하지 못하여, 결국 이 방법도 해결책이 되지 못한다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>클로저를 사용한 Counting<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"myFunction()"</span>&gt;</span>Count!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">    <span class="keyword">var</span> add = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 외부 함수 ...(1)</span></span></div><div class="line"><span class="javascript">      <span class="keyword">var</span> counter = <span class="number">0</span>; <span class="comment">// 외부 함수의 지역 변수 ...(2)</span></span></div><div class="line"><span class="javascript">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 내부 함수 ...(3)</span></span></div><div class="line"><span class="javascript">        <span class="keyword">return</span> counter += <span class="number">1</span>; <span class="comment">// 외부 함수의 지역 변수 참조</span></span></div><div class="line"><span class="undefined">      &#125;</span></div><div class="line"><span class="javascript">    &#125;)(); <span class="comment">// 즉시 실행 함수</span></span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>)</span>&#123;</span></div><div class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">'demo'</span>).innerHTML = add(); <span class="comment">//...(4)</span></span></div><div class="line"><span class="undefined">    &#125;</span></div><div class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>위 예제에서는 클로저를 활용하였다. 변수 <code>add</code>에 즉시실행함수가 외부함수로 호출되었다…(1)<br><code>add()</code>를 실행하면 변수 <code>add</code>에 담긴 즉시실행함수가 실행되어…(4)<br>무명함수 <code>function () { return counter +=1; }</code>가 반환(return)된다…(3)  </p>
<p><em>즉시실행함수는 단 한번만 실행된다.</em> 따라서 <code>add</code>에 담긴 함수가 호출될 때마다 변수 <code>counter</code>가 초기화되는 일은 없을 것이다. 중요한 것은 <code>add</code>에 담겨 있는 내부 함수(3)는 변수 <code>counter</code>(2)에 접근할 수 있고 변수 <code>counter</code>는 <code>add</code>에 담겨 있는 내부 함수(3)가 소멸될 때까지 유지된다는 것이다. 이것이 클로저이다.</p>
<p>변수 <code>counter</code>는 외부에서 직접 접근할 수 없는 <code>private</code>변수이므로 전역 변수를 사용했을 때와 같이 의도되지 않은 변경을 걱정할 필요도 없다.</p>
<h3 id="2-setTimeout-의-콜백-함수"><a href="#2-setTimeout-의-콜백-함수" class="headerlink" title="2) setTimeout()의 콜백 함수"></a>2) setTimeout()의 콜백 함수</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>새로고침으로 다시 실행해 보세요<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">    <span class="keyword">var</span> fade = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</span></div><div class="line"><span class="javascript">      <span class="comment">// 자유변수</span></span></div><div class="line"><span class="javascript">      <span class="keyword">var</span> level = <span class="number">1</span>; <span class="comment">// ②</span></span></div><div class="line"><span class="javascript">      <span class="keyword">var</span> step = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></div><div class="line"><span class="javascript">        <span class="keyword">var</span> hex = level.toString(<span class="number">16</span>); <span class="comment">// ④</span></span></div><div class="line"><span class="undefined">        </span></div><div class="line"><span class="javascript">        <span class="comment">// hex: '1' ~ 'f'</span></span></div><div class="line"><span class="javascript">        node.style.backgroundColor = <span class="string">'#ff'</span> + hex; <span class="comment">// ⑤</span></span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">        <span class="keyword">if</span>(level &lt; <span class="number">15</span>) &#123; <span class="comment">// ⑥</span></span></div><div class="line"><span class="undefined">          level += 1;</span></div><div class="line"><span class="javascript">          setTimeout(step, <span class="number">100</span>); <span class="comment">// ⑦</span></span></div><div class="line"><span class="undefined">        &#125;</span></div><div class="line"><span class="undefined">      &#125;;</span></div><div class="line"><span class="javascript">      <span class="comment">// setTimeout 호출 이후 fade 함수는 종료한다. 100ms 후 함수 step은 호출된다.</span></span></div><div class="line"><span class="javascript">      <span class="comment">// 즉 외부 함수 fade보다 내부 함수 step이 더 오래 유지된다.</span></span></div><div class="line"><span class="javascript">      setTimeout(step, <span class="number">100</span>); <span class="comment">// ③</span></span></div><div class="line"><span class="undefined">    &#125;;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">    fade(<span class="built_in">document</span>.body); <span class="comment">// ①</span></span></div><div class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>setTimeout() 함수는 첫번째 파라미터에 콜백 함수를 전달하고, 파라미터에 ms(1/1000초)단위의 시간 간격을 지정한다. 즉 지정된 시간 간격으로 콜백 함수를 호출한다.</p>
<p>① 함수 fade는 document.body를 인자로 전달받아 호출된다.<br>② 함수 fade의 지역변수 level은 1로 초기화되어 있다. 함수 step은 내부함수이며 외부함수 fade의 지역변수 level을 사용한다. level은 자유변수이다.<br>③ setTimeout 호출 이후 fade 함수는 종료한다. 100ms 후 함수 step은 호출된다. 즉 외부 함수 fade보다 내부 함수 step이 더 오래 유지된다.<br>④ 함수 step은 지역변수 hex을 갖는다. 이것은 16진수 문자열을 값으로 갖는다.<br>⑤ 함수 fade의 매개변수 node(document.body)의 배경색을 변경한다.<br>⑥ 변수 level이 15(f)보다 작은지 다시말해 16진수 범위 내(1~f)인지 확인한다.<br>⑦ level을 1 증가시키고 다시 함수 step을 호출하여 같은 작업을 반복한다.  </p>
<p>이때 fade 함수는 이미 반환되었지만 외부함수 fade 내의 변수는 이를 필요로 하는 내부함수가 하나 이상 존재하는 경우 계속 유지된다. 이때 내부함수가 외부함수에 있는 변수의 복사본이 아니라 실제 변수에 접근한다는 것에 주의하여야 한다.  </p>
<h3 id="3-자주-발생하는-실수"><a href="#3-자주-발생하는-실수" class="headerlink" title="3) 자주 발생하는 실수"></a>3) 자주 발생하는 실수</h3><p>아래 예제는 클로저 사용시 자주 발생하는 실수에 관한 예제이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">  arr[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> i;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; arr.length; index++) &#123;</div><div class="line">  <span class="built_in">console</span>.log(arr[index]());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>배열 arr에 5개의 함수가 할당되고 각각의 함수는 순차적으로 0, 1, 2, 3, 4를 반환할 것으로 기대하겠지만 결과는 그렇지않다. 이유는 변수 i는 외부함수의 변수가 아닌 전역 변수이기 때문이다. 바르게 동작하는 코드는 아래와 같다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</div><div class="line">  arr[i] = (<span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123; <span class="comment">// ②</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> id; <span class="comment">// ③</span></div><div class="line">    &#125;;</div><div class="line">  &#125;)(i); <span class="comment">// ①</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; arr.length; index++) &#123;</div><div class="line">  <span class="built_in">console</span>.log(arr[index]());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>① 배열 arr에는 즉시실행함수에 의해 함수가 반환된다.</p>
<p>② 이때 즉시실행함수는 i를 인자로 전달받고 매개변수 id에 할당한 후 내부 함수를 반환하고 life-cycle이 종료된다. 매개변수 id는 자유변수가 된다.</p>
<p>③ 배열 arr에 할당된 함수는 id를 반환한다. 이때 id는 상위 스코프의 자유변수이므로 그 값이 유지된다.</p>
<p>위 예제는 자바스크립트의 함수 레벨 스코프 특성으로 인해 for 루프의 초기문에서 사용된 변수의 스코프가 전역이 되기 때문에 발생하는 현상이다. ES6의 let 키워드를 사용하면 이와 같은 문제는 말끔히 해결된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> arr = [];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">  arr[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> i;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">  <span class="built_in">console</span>.log(arr[i]());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>Reference</p>
<p><a href="http://poiemaweb.com/js-closure" target="_blank" rel="external">Poiema Web</a><br><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management" target="_blank" rel="external">MDN</a><br><a href="http://chanlee.github.io/2013/12/10/understand-javascript-closure/" target="_blank" rel="external">blog</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;클로저&quot;&gt;&lt;a href=&quot;#클로저&quot; class=&quot;headerlink&quot; title=&quot;클로저&quot;&gt;&lt;/a&gt;클로저&lt;/h1&gt;&lt;h2 id=&quot;1-클로저의-개념&quot;&gt;&lt;a href=&quot;#1-클로저의-개념&quot; class=&quot;headerlink&quot; title=&quot;1. 
    
    </summary>
    
      <category term="Javascript" scheme="http://huusz.github.io/categories/Javascript/"/>
    
    
      <category term="closure" scheme="http://huusz.github.io/tags/closure/"/>
    
  </entry>
  
  <entry>
    <title>[SASS] Extensions</title>
    <link href="http://huusz.github.io/2017/Sass/SCSS/SASS-Extensions/"/>
    <id>http://huusz.github.io/2017/Sass/SCSS/SASS-Extensions/</id>
    <published>2017-08-07T05:03:41.000Z</published>
    <updated>2017-08-28T14:12:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h1><h2 id="1-Nesting"><a href="#1-Nesting" class="headerlink" title="1. Nesting"></a>1. Nesting</h2><p>Sass의 유용한 확장 기능으로 중첩(Nesting)이 있다. CSS는 후손 셀렉터의 경우 부모요소를 기술하여야 한다.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#navbar</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">80%</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">23px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-id">#navbar</span> <span class="selector-tag">ul</span> &#123;</div><div class="line">  <span class="attribute">list-style-type</span>: none;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-id">#navbar</span> <span class="selector-tag">li</span> &#123;</div><div class="line">  <span class="attribute">float</span>: left;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-id">#navbar</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</div><div class="line">  <span class="attribute">font-weight</span>: bold;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Sass의 Nesting은 후손 셀렉터를 간단히 기술이 가능하다. <strong><em>또한 HTML의 구조를 반영한 CSS를 기술할 수 있다.</em></strong></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#navbar</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">80%</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">23px</span>;</div><div class="line"></div><div class="line">  <span class="selector-tag">ul</span> &#123; <span class="attribute">list-style-type</span>: none; &#125;</div><div class="line"></div><div class="line">  <span class="selector-tag">li</span> &#123;</div><div class="line">    <span class="attribute">float</span>: left;</div><div class="line">    <span class="selector-tag">a</span> &#123; <span class="attribute">font-weight</span>: bold; &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>너무 깊은 Nesting은 가독성을 나쁘게 하고 셀렉터를 복잡하게 만든다. 따라서 Nesting은 3단계 이상 들어가지 않도록 한다. 만약 3단계 이상 들어가야 할 경우에는, 네스팅 하지 않고 차라리 클래스로 꺼내두는게 낫다.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Bad case</span></div><div class="line"><span class="selector-tag">div</span><span class="selector-id">#main</span> &#123;</div><div class="line">  <span class="selector-id">#sidebar</span> &#123;</div><div class="line">    <span class="selector-id">#navbar</span> &#123;</div><div class="line">      <span class="attribute">width</span>: <span class="number">80%</span>;</div><div class="line">      <span class="attribute">height</span>: <span class="number">23px</span>;</div><div class="line"></div><div class="line">      <span class="selector-tag">aside</span> &#123;</div><div class="line">        <span class="selector-tag">div</span> &#123;</div><div class="line">          <span class="selector-tag">ul</span> &#123;</div><div class="line">            <span class="attribute">list-style-type</span>: none;</div><div class="line"></div><div class="line">            <span class="selector-tag">li</span> &#123;</div><div class="line">              <span class="attribute">float</span>: left;</div><div class="line"></div><div class="line">              <span class="selector-tag">a</span> &#123;</div><div class="line">                <span class="attribute">font-weight</span>: bold;</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>부모요소의 참조가 필요한 경우 <code>&amp;</code>를 사용한다. 예를 들어 <code>:hover</code> 또는 <code>:before</code> 등의 가상 클래스 선택자(Pseudo-Class Selector)를 지정하는 경우 부모요소의 참조가 필요하다.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-class">.myAnchor</span> &#123;</div><div class="line">  <span class="attribute">color</span>: blue;</div><div class="line">  &amp;:hover &#123;</div><div class="line">    <span class="attribute">text-decoration</span>: underline;</div><div class="line">  &#125;</div><div class="line">  &amp;:visited &#123;</div><div class="line">    <span class="attribute">color</span>: purple;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Nesting은 프로퍼티에도 사용할 수 있다.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.funky</span> &#123;</div><div class="line">  <span class="attribute">font</span>: &#123;</div><div class="line">    family: fantasy;</div><div class="line">    size: <span class="number">30em</span>;</div><div class="line">    weight: bold;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위 코드의 컴파일 결과는 아래와 같다.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.funky</span> &#123;</div><div class="line">  <span class="attribute">font-family</span>: fantasy;</div><div class="line">  <span class="attribute">font-size</span>: <span class="number">30em</span>;</div><div class="line">  <span class="attribute">font-weight</span>: bold;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="2-Rules-and-Directives"><a href="#2-Rules-and-Directives" class="headerlink" title="2. @-Rules and Directives"></a>2. @-Rules and Directives</h2><h3 id="1-import"><a href="#1-import" class="headerlink" title="1) @import"></a>1) @import</h3><p>1개의 CSS파일에 모든 스타일을 기술하는 것은 가독성을 나쁘게 한다. 또한 기능에따라 CSS파일을 분리하면 재사용 및 유지보수 측면에서 유리하다. 따라서 룰을 정하여 파일을 분리하여 개발하는 것은 효과적인 방법이다.</p>
<p>Sass는 @import directive를 사용하여 분리된 stylesheet 파일을 import할 수 있다. 기존의 CSS @import보다 편리한 기능을 제공한다.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">import</span> <span class="string">"foo.scss"</span>;</div><div class="line"></div><div class="line"><span class="comment">//확장자는 생략 가능하다.</span></div><div class="line">@<span class="keyword">import</span> <span class="string">"foo"</span>;</div><div class="line"></div><div class="line"><span class="comment">//import multiple files</span></div><div class="line">@<span class="keyword">import</span> <span class="string">"rounded-corners"</span>, <span class="string">"text-shadow"</span>;</div><div class="line"></div><div class="line"><span class="variable">$family</span>: unquote(<span class="string">"Droid+Sans"</span>);</div><div class="line">@<span class="keyword">import</span> url(<span class="string">"https://fonts.googleapis.com/css?family=#&#123;$family&#125;"</span>)</div></pre></td></tr></table></figure>
<p>여러개의 파일로 분할하는 것 또는 분할된 파일을 <strong>partial</strong>이라 하며 partial된 Sass 파일명의 선두에는 underscore(_)를 붙인다. (_reset.scss, _module.scss, _print.scss)</p>
<p>예를 들어 “<em>foo.scss”라는 partial된 Sass 파일이 있고 이 파일을 import 하는 경우 아래와 같이 기술한다. 파일명 선두의 </em>와 확장자는 생략할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@import &quot;foo&quot;;</div></pre></td></tr></table></figure>
<p>partial된 Sass 파일명 선두에 붙인 _의 의미는 import는 수행하되 CSS로의 컴파일은 수행하지 말라는 의미를 갖는다. 따라서 partial은 import시에는 CSS파일로 컴파일되지 않기 때문에 최종적으로 CSS로 컴파일을 수행할 Sass 파일에서 import한다. </p>
<p><img src="http://poiemaweb.com/img/partial.png" alt="partial">  </p>
<p>@import는 top-level에서 사용하는 것이 일반적이지만 CSS rule 또는 @media rule 내에 포함시키는 것도 가능하다.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//_example.scss</span></div><div class="line"><span class="selector-class">.example</span> &#123;</div><div class="line">  <span class="attribute">color</span>: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#main</span> &#123;</div><div class="line">  @<span class="keyword">import</span> <span class="string">"example"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위 코드는 컴파일 결과는 아래와 같다.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#main</span> <span class="selector-class">.example</span> &#123;</div><div class="line">  <span class="attribute">color</span>: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="2-extend"><a href="#2-extend" class="headerlink" title="2) @extend"></a>2) @extend</h3><p>기존 스타일을 상속하고자 경우 @extend를 사용한다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"error seriousError"</span>&gt;</span></div><div class="line">  Oh no! You've been hacked!</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>기존에 선언되어 있는 error class를 사용하면서 일부 rule set에 대해서는 다른 선언이 필요한 경우 자주 사용하는 방법이다.</p>
<p>이러한 경우 사용할 수 있는 방법이 상속이다. 상속되는 rule set을 그대로 상속받아 다른 부분만 별도 선언하면 된다.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.error</span> &#123;</div><div class="line">  <span class="attribute">border</span>: <span class="number">1px</span> <span class="number">#f00</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.seriousError</span> &#123;</div><div class="line">  @<span class="keyword">extend</span> .error;</div><div class="line"></div><div class="line">  <span class="attribute">border-width</span>: <span class="number">3px</span>;</div><div class="line">  <span class="attribute">border-color</span>: darkblue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위 코드의 컴파일 결과는 아래와 같다. <code>.error</code>과 <code>.seriousError</code>가 공통으로 사용하는 프로퍼티를 묶어 <em>나름 합리적인</em> 룰셋을 생성한다.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.error</span>, <span class="selector-class">.serousError</span> &#123;</div><div class="line">  <span class="attribute">border</span>: <span class="number">1px</span> <span class="number">#f00</span>;</div><div class="line">  <span class="attribute">background-color</span>: blue;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.seriousError</span> &#123;</div><div class="line">  <span class="attribute">border-width</span>: <span class="number">3px</span>;</div><div class="line">  <span class="attribute">border-color</span>: darkblue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이제 하나의 클래스만 적용시키면 된다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">calss</span>=<span class="string">"seriousError"</span>&gt;</span></div><div class="line">  Oh no! You've been hacked!</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>@extend를 @media블록과 같이 사용하는 경우, 제대로 작동하지 않는다. 다시말해 @media 안에서 외부 선택자를 @extend할 수 없다.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.foo</span> &#123;</div><div class="line">  <span class="attribute">color</span>: red;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@<span class="keyword">media</span> print &#123;</div><div class="line">  <span class="selector-class">.bar</span> &#123;</div><div class="line">    <span class="comment">//ERROR</span></div><div class="line">    @<span class="keyword">extend</span> .foo;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>컴파일 후 자신의 셀렉터가 어디에 첨부될 것인지 <strong>예상하기 어렵고, 예상치 못했던 부작용이 발생할 수 있다.</strong> 따라서 @Extend의 사용은 <strong>가급적 자제</strong>하고 Mixin을 사용하는 것을 추천한다.  </p>
</blockquote>
<p><a href="https://sass-guidelin.es/ko/#extend" target="_blank" rel="external">@extend의 부작용</a></p>
<p><br></p>
<h3 id="3-Placeholder-Selectors"><a href="#3-Placeholder-Selectors" class="headerlink" title="3) Placeholder Selectors"></a>3) Placeholder Selectors</h3><p>Placeholder Selector는 Sass3.2부터 제공되는 기능으로 재이용 가능한 Rule set을 %키워드로 지정하는 <strong>@extend 전용 Selector</strong>이다. (그러니, extend를 사용하지 않는다면 별로 기억하지 않아도 된다.)</p>
<p>Placeholder Selector는 상속만을 위한 rule set으로 자신은 컴파일되지 않는다.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">%<span class="selector-tag">input</span>-<span class="selector-tag">style</span> &#123;</div><div class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.input-black</span> &#123;</div><div class="line">  @<span class="keyword">extend</span> %input-style;</div><div class="line"></div><div class="line">  colr: black;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.input-red</span> &#123;</div><div class="line">  @<span class="keyword">extend</span> %input-style;</div><div class="line"></div><div class="line">  <span class="attribute">color</span>: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>컴파일 결과는 아래와 같다.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.input-black</span>, <span class="selector-class">.input-red</span> &#123;</div><div class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.input-black</span> &#123;</div><div class="line">  <span class="attribute">color</span>: black;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.input-red</span> &#123;</div><div class="line">  <span class="attribute">color</span>: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="3-조건과-반복"><a href="#3-조건과-반복" class="headerlink" title="3. 조건과 반복"></a>3. 조건과 반복</h2><p>Sass는 Javascript 같은 프로그래밍 언어와 같이 제어문(Control flow statement)을 사용할 수 있는 기능을 제공한다.</p>
<p><br></p>
<h3 id="1-if"><a href="#1-if" class="headerlink" title="1) if()"></a>1) if()</h3><p>built-in if()함수는 주어진 조건읊 판단하여 결과를 리턴한다. Javascript의 삼항 연산자와 유사하게 동작한다.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if(condition, if_true, if_false)</div></pre></td></tr></table></figure>
<p>condition이 true이면 if_true를, false이면 if_false를 반환한다.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$type</span>: ocean;</div><div class="line"></div><div class="line"><span class="selector-tag">p</span> &#123;</div><div class="line">  <span class="attribute">color</span>: if(<span class="variable">$type</span> == ocean, blue, black); <span class="comment">// color: blue;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="2-if"><a href="#2-if" class="headerlink" title="2) @if"></a>2) @if</h3><p>@if를 사용하면 조건분기가 가능하다.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$type</span>: monster;</div><div class="line"></div><div class="line"><span class="selector-tag">p</span> &#123;</div><div class="line">  @<span class="keyword">if</span> <span class="variable">$type</span> == ocean &#123;</div><div class="line">    <span class="attribute">color</span>: blue;</div><div class="line">  &#125; @<span class="keyword">else</span> if <span class="variable">$type</span> == matador &#123;</div><div class="line">    <span class="attribute">color</span>: red;</div><div class="line">  &#125; @<span class="keyword">else</span> if <span class="variable">$type</span> == monster &#123;</div><div class="line">    <span class="attribute">color</span>: green;</div><div class="line">  &#125; @<span class="keyword">else</span> &#123;</div><div class="line">    <span class="attribute">color</span>: black;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>컴파일 결과는 아래와 같다.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> &#123;</div><div class="line">  <span class="attribute">color</span>: green;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="3-for"><a href="#3-for" class="headerlink" title="3) @for"></a>3) @for</h3><p>@for으로 반복문을 사용할 수 있다.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">for</span> <span class="variable">$i</span> from 1 though 3 &#123;</div><div class="line">  <span class="selector-class">.item-</span>#&#123;$1&#125; &#123; <span class="attribute">width</span>: <span class="number">2em</span> * <span class="variable">$i</span>; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>컴파일 결과는 아래와 같다.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.item-1</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">2em</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.item-2</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">4em</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.item-3</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">6em</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="4-each"><a href="#4-each" class="headerlink" title="4) @each"></a>4) @each</h3><p>@each와 list 또는 map의 요소에 대해 반복을 실시한다.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//List</span></div><div class="line">@<span class="keyword">each</span> <span class="variable">$animal</span> in puma, sea-slug, egret, salamander &#123;</div><div class="line"></div><div class="line">  .#&#123;<span class="variable">$animal</span>&#125;-<span class="attribute">icon</span> &#123;</div><div class="line">    <span class="attribute">background-image</span>: url(<span class="string">'/image/#&#123;$animal&#125;.png'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Map</span></div><div class="line"><span class="comment">// $header; h1, $size: 2em</span></div><div class="line"><span class="comment">// $header; h2, $size: 1.5em</span></div><div class="line"><span class="comment">// $header; h3, $size: 1.2em</span></div><div class="line">@<span class="keyword">each</span> <span class="variable">$header</span>, <span class="variable">$size</span> in (h1: 2em, h2: 1.5em, h3: 1.2em) &#123;</div><div class="line">  #&#123;<span class="variable">$header</span>&#125; &#123;</div><div class="line">    <span class="attribute">font-size</span>: <span class="variable">$size</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>컴파일 결과는 아래와 같다.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.puma-icon</span> &#123;</div><div class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">"/image/puma.png"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.sea-slug-icon</span> &#123;</div><div class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">"/images/sea-slug.png"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.salamander-icon</span> &#123;</div><div class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">"/image/salamander.png"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">h1</span> &#123;</div><div class="line">  <span class="attribute">font-size</span>: <span class="number">2em</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">h2</span> &#123;</div><div class="line">  <span class="attribute">font-size</span>: <span class="number">1.5em</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">h3</span> &#123;</div><div class="line">  <span class="attribute">font-size</span>: <span class="number">1.2em</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="5-while"><a href="#5-while" class="headerlink" title="5) @while"></a>5) @while</h3><p>@while로 반복문을 사용할 수 있다.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$i</span>: <span class="number">6</span>;</div><div class="line">@<span class="keyword">while</span> <span class="variable">$i</span> &gt; 0 &#123;</div><div class="line">  <span class="selector-class">.item-</span>#&#123;<span class="variable">$i</span>&#125; &#123; <span class="attribute">width</span>: <span class="number">2em</span> * <span class="variable">$i</span>; &#125;</div><div class="line">  <span class="variable">$i</span>: <span class="variable">$i</span> - <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">컴파일 결과는 아래와 같다.</div><div class="line"></div><div class="line">```css</div><div class="line"></div><div class="line"><span class="selector-class">.item-6</span>&#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">12em</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.item-4</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">8em</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.item-2</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">4em</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="4-Mixin"><a href="#4-Mixin" class="headerlink" title="4. Mixin"></a>4. Mixin</h2><p>Mixin은 Sass의 매우 유용한 기능으로 중복 기술을 방직하기 위해 사용 빈도가 높은 마크업을 사전에 정의하여 필요할 때 불러 사용하는 방법이다.</p>
<p>@extend와 유사하나 프로그래밍 언어의 함수와 같이 argument를 받을 수 있다. 사용법은 매우 간단하다. <code>@mixin</code> 선언하고 <code>@include</code>로 불러들인다.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//지름이 50px인 원</span></div><div class="line">@<span class="keyword">mixin</span> circle &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</div><div class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//지름이 50px인 원을 위한 mixin을 include한 후, 배경을 추가 지정</span></div><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">  @<span class="keyword">include</span> circle;</div><div class="line"></div><div class="line">  <span class="attribute">background</span>: <span class="number">#f00</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>컴파일 결과는 아래와 같다. 배경이 red이고 지름이 50px인 원을 표시한다.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</div><div class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</div><div class="line">  <span class="attribute">background</span>: <span class="number">#f00</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>@extend와 차이가 없어 보이나 Mixin은 함수처럼 argument를 사용할 수 있다.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">mixin</span> circle(<span class="variable">$size</span>) &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="variable">$size</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="variable">$size</span>;</div><div class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">  @<span class="keyword">include</span> circle(<span class="number">100px</span>);</div><div class="line"></div><div class="line">  <span class="attribute">background</span>: <span class="number">#f00</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>컴파일 결과는 아래와 같다.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span>&#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</div><div class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</div><div class="line">  <span class="attribute">background</span>: <span class="number">#f00</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Extensions&quot;&gt;&lt;a href=&quot;#Extensions&quot; class=&quot;headerlink&quot; title=&quot;Extensions&quot;&gt;&lt;/a&gt;Extensions&lt;/h1&gt;&lt;h2 id=&quot;1-Nesting&quot;&gt;&lt;a href=&quot;#1-Nesting&quot; c
    
    </summary>
    
      <category term="Sass" scheme="http://huusz.github.io/categories/Sass/"/>
    
    
      <category term="nesting" scheme="http://huusz.github.io/tags/nesting/"/>
    
  </entry>
  
  <entry>
    <title>[SASS] Sass Script</title>
    <link href="http://huusz.github.io/2017/Sass/SCSS/SASS-SassScript/"/>
    <id>http://huusz.github.io/2017/Sass/SCSS/SASS-SassScript/</id>
    <published>2017-08-06T07:56:57.000Z</published>
    <updated>2017-08-08T14:56:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sass-Script"><a href="#Sass-Script" class="headerlink" title="Sass Script"></a>Sass Script</h1><h2 id="1-Data-Type"><a href="#1-Data-Type" class="headerlink" title="1. Data Type"></a>1. Data Type</h2><p>프로퍼티값으로 사용할 수 있는 값에는 각각의 자료형(Data Type)이 존재한다. SassScript가 제공하는 자료형은 7가지가 있다.</p>
<ul>
<li><p><strong>숫자형</strong><br>e.g) 1.2, 13, 10px</p>
</li>
<li><p><strong>문자열</strong><br>CSS는 2종류의 문자열을 사용할 수 있다. 따옴표를 사용하는 경우(“Lucida Grande”, ‘<a href="http://sass-lang.com’)와" target="_blank" rel="external">http://sass-lang.com’)와</a> 사용하지 않는 경우(bold, sans-serif)가 있다. Sass는 2종류의 문자열 모두를 인식할 수 있으며 컴파일 후의 CSS에는 Sass에서 사용한 문자열이 그대로 출력된다.<br>e.g. “Lucida Grande”, ‘<a href="http://sass-lang.com’" target="_blank" rel="external">http://sass-lang.com’</a>, sans-serif</p>
</li>
<li><p><strong>컬러</strong><br>e.g. blue, #04a3f9, rgba(255, 0, 0, 0.5)</p>
</li>
<li><p><strong>boolean</strong><br>e.g. true, false  </p>
</li>
<li><p><strong>null</strong></p>
</li>
<li><p><strong>list</strong><br>margin과 padding 프로퍼티값 지정에 사용되는 0 auto와 font-family 프로퍼티값 지정에 사용되는 Helvetica, Arial, sans-serif 등은 공백 또는 콤마 구분된 값의 list이다.<br>e.g. 1.5em 1em 0 2em, Helvetica, Arial, sans-serif</p>
</li>
<li><p><strong>map</strong><br>JSON과 유사한 방식으로 map-get 함수를 사용하여 원하는 값은 추출할 수 있다.<br>e.g. (key1: value1, key2: value2)</p>
</li>
</ul>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// map</span></div><div class="line"><span class="variable">$foundation-palette</span>: (</div><div class="line">  primary: <span class="number">#E44347</span>,</div><div class="line">  mars: <span class="number">#D7525C</span>,</div><div class="line">  saturn: <span class="number">#E4B884</span>,</div><div class="line">  neptune: <span class="number">#5147D7</span></div><div class="line">);</div><div class="line"></div><div class="line"><span class="selector-class">.mars</span> &#123;</div><div class="line">  <span class="attribute">color</span>: map-get(<span class="variable">$foundation-palette</span>, mars); </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// =&gt; .mars &#123; color: #D7525C; &#125;</span></div></pre></td></tr></table></figure>
<h2 id="2-변수"><a href="#2-변수" class="headerlink" title="2. 변수"></a>2. 변수</h2><p>Sass에서는 변수를 사용할 수 있다. 문자열, 숫자, 컬러(<code>#aa443f</code>) 등을 사전에 변수에 저장하고 필요할 때 불러 사용할 수 있다.</p>
<p>변수명은 <code>$</code>로 시작한다.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$width</span>: <span class="number">960px</span>;</div><div class="line"></div><div class="line"><span class="selector-tag">header</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="variable">$width</span>;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-id">#main</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="variable">$width</span>;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> auto;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">footer</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="variable">$width</span>;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>어떤 것을 변수명으로 설정할지에 대한 설계가 필요하다. 변수명은 대체로 파일의 앞 쪽에 몰아서 선언해둔다.</p>
<h2 id="3-변수의-스코프"><a href="#3-변수의-스코프" class="headerlink" title="3. 변수의 스코프"></a>3. 변수의 스코프</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$width</span>: <span class="number">960px</span>; <span class="comment">// global variable</span></div><div class="line"></div><div class="line"><span class="selector-tag">header</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="variable">$width</span>;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-id">#main</span> &#123;</div><div class="line">  <span class="variable">$color</span>: <span class="number">#333</span>; <span class="comment">// local variable</span></div><div class="line">  <span class="attribute">width</span>: <span class="variable">$width</span>;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> auto;</div><div class="line">  <span class="selector-tag">section</span> &#123;</div><div class="line">    <span class="selector-tag">p</span> &#123;</div><div class="line">      <span class="attribute">color</span>: <span class="variable">$color</span>;</div><div class="line"></div><div class="line">      <span class="selector-tag">a</span>:link &#123;</div><div class="line">        <span class="attribute">color</span>: <span class="variable">$color</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">footer</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="variable">$width</span>;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</div><div class="line">  <span class="attribute">color</span>: <span class="variable">$color</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위 코드를 컴파일하면 <code>Undefined variable: “$color”</code>라는 에러가 발생한다. 이는 <code>#main</code>에서 선언한 <code>$color</code>는 <code>#main</code> 내에서만 유효한 지역변수이기 때문이다.</p>
<p>코드블럭 내에서 선언한 지역변수를 전역변수화하는 방법은 아래와 같다.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#main</span> &#123;</div><div class="line">  <span class="variable">$color</span>: <span class="number">#333</span> !global; <span class="comment">// global variable</span></div><div class="line">  <span class="attribute">width</span>: <span class="variable">$width</span>;</div><div class="line">  ...</div></pre></td></tr></table></figure>
<h2 id="4-연산자-Operation"><a href="#4-연산자-Operation" class="headerlink" title="4. 연산자(Operation)"></a>4. 연산자(Operation)</h2><h3 id="1-숫자-연산자"><a href="#1-숫자-연산자" class="headerlink" title="1) 숫자 연산자"></a>1) 숫자 연산자</h3><table>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>덧셈</td>
</tr>
<tr>
<td>-</td>
<td>뺄셈</td>
</tr>
<tr>
<td>*</td>
<td>곱셈</td>
</tr>
<tr>
<td>/</td>
<td>나눗셈</td>
</tr>
<tr>
<td>%</td>
<td>나머지</td>
</tr>
<tr>
<td>==</td>
<td>동등</td>
</tr>
<tr>
<td>!=</td>
<td>부등</td>
</tr>
</tbody>
</table>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$width</span>: <span class="number">100px</span>;</div><div class="line"></div><div class="line"><span class="selector-id">#foo</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="variable">$width</span> + <span class="number">10</span>; <span class="comment">//110px</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-id">#bar</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="variable">$width</span> + <span class="number">10in</span>; <span class="comment">//1060px</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>변수 $width의 값 100px에 10 또는 10em과 같이 다른 단위의 값을 연산하여도 에러없이 연산이 수행된다. 이때 연산자의 왼쪽 값을 기준으로 단위가 설정된다.</p>
<p>$width에 10em을 더하면 어떻게 될까?</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$width</span>: <span class="number">100px</span>;</div><div class="line"></div><div class="line"><span class="selector-id">#foo</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="variable">$width</span> + <span class="number">10em</span>; <span class="comment">//NG: 100px + 10em</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>컴파일 결과 Incompatible units: ‘em’ and ‘px’.이라는 에러를 출력한다. Scss 연산은 대상을 변환하여 연산할 수 없는 경우, 에러를 출력한다.</p>
<p>%,em,rem,vh,vw,vmin,vmax와 같이 상대적인 값을 Sass는 알지 못한다. 상대적인 값의 결과값은 브라우저만이 알 수 있기 때문이다. (sass는 단지 css로 변환하기만 할 뿐, em 등등의 값은 알 수 없다.) 따라서 <strong>상대적 값을 갖는 단위의 연산은 동일한 단위를 갖는 값과의 연산만이 유효하다.</strong></p>
<blockquote>
<p>%는 부모를 기준으로, rem은 html을 기준으로 (기본적으로 16px), vw는 뷰포트를 기준으로, 1vw = viewport를 기준으로 1/100. </p>
</blockquote>
<p>CSS3의 calc함수(IE9 이상에서만 사용할 수 있다.)는 이런 문제를 해결할 수 있다. (calc는 브라우저에서 수행하기 때문에 상대값과 절댓값 사이 계산이 가능한 것이다.)</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#foo</span> &#123;</div><div class="line">  <span class="attribute">width</span>: calc(<span class="number">25%</span> - <span class="number">5px</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CSS에서의 <code>/</code>는 나눗셈이 아니라 값을 분리하는 의미를 갖는다. 따라서 Sass의 <code>/</code> 연산자를 사용하기 위해서는 몇가지 조건이 필요하다. 이외의 조건에서는 나눗셈을 하지 않는다.</p>
<ul>
<li>변수에 대해 사용</li>
<li>괄호 내에서 사용</li>
<li>다른 연산의 일부로서 사용</li>
</ul>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> &#123;</div><div class="line">  <span class="comment">// font와 border-radius의 '/'는 CSS문법에 맞는 표현이므로 연산되지 않는다.</span></div><div class="line">  <span class="attribute">font</span>: italic bold <span class="number">12px</span>/<span class="number">30px</span> Georgia, serif;</div><div class="line">  <span class="comment">// 타원형 둥근 모서리</span></div><div class="line">  <span class="attribute">border-radius</span>: <span class="number">10px</span> <span class="number">20px</span> / <span class="number">20px</span>;</div><div class="line"></div><div class="line">  <span class="variable">$width</span>: <span class="number">1000px</span>;</div><div class="line">  <span class="attribute">width</span>: <span class="variable">$width</span> / <span class="number">2</span>;            <span class="comment">// 변수에 대해 사용 →　width: 500px;</span></div><div class="line">  <span class="attribute">height</span>: (<span class="number">500px</span> / <span class="number">2</span>);          <span class="comment">// 괄호 내에서 사용 →　height: 250px;</span></div><div class="line">  <span class="attribute">margin-left</span>: <span class="number">5px</span> + <span class="number">8px</span> / <span class="number">2px</span>; <span class="comment">// 다른 연산의 일부로서 사용 →　margin-left: 9px;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>변수를 CSS의 /와 함께 사용하고자 하는 경우 <code>#{}</code>(Interpolation)를 사용한다.<br><code>#{}</code>를 사용하면 변수를 문자열로 인식하게 한다. 따라서 연산을 하지 않는다.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span>&#123;</div><div class="line">  <span class="variable">$font-size</span>: <span class="number">12px</span>;</div><div class="line">  <span class="variable">$line-height</span>: <span class="number">30px</span>;</div><div class="line">  <span class="attribute">font</span>: #&#123;<span class="variable">$font-size</span>&#125; / #&#123;<span class="variable">$line-height</span>&#125;; <span class="comment">// 12px/30px</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>#{}</code>를 좌항에만 사용해주어도 같은 효과가 난다. (좌항을 기준으로 하며, 둘 다 변수일 때만 연산을 하기 때문이다.)<br>하지만 양 쪽 모두 <code>#{}</code>를 사용해주는 것이 더 좋다.</p>
<h3 id="2-컬러-연산자"><a href="#2-컬러-연산자" class="headerlink" title="2) 컬러 연산자"></a>2) 컬러 연산자</h3><p>컬러 값에도 모든 산술 연산자를 적용할 수 있다. 컬러 값은 R은 R끼리, G는 G끼리, B는 B끼리 연산한다.<br>(#RRBBGG 표기법의 숫자는 16진수로 표기한다. 16진수에서는 10부터 A로 시작하는 알파벳이다. 05 + 05 = A)</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> &#123;</div><div class="line">  <span class="attribute">color</span>: <span class="number">#010203</span> + <span class="number">#040506</span>;</div><div class="line">  <span class="comment">// R: 01 + 04 = 05</span></div><div class="line">  <span class="comment">// G: 02 + 05 = 07</span></div><div class="line">  <span class="comment">// B: 03 + 06 = 09</span></div><div class="line">  <span class="comment">// =&gt; #050709</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">p</span> &#123;</div><div class="line">  <span class="attribute">color</span>: <span class="number">#010203</span> * <span class="number">2</span>;</div><div class="line">  <span class="comment">// R: 01 * 2 = 02</span></div><div class="line">  <span class="comment">// G: 02 * 2 = 04</span></div><div class="line">  <span class="comment">// B: x03 * 2 = 06</span></div><div class="line">  <span class="comment">// =&gt; #020406</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">p</span> &#123;</div><div class="line">  <span class="attribute">color</span>: rgba(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.75</span>) + rgba(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0.75</span>);</div><div class="line">  <span class="comment">/* alpha 값은 연산되지 않는다</span></div><div class="line"><span class="comment">  / color: rgba(255, 255, 0, 0.75);</span></div><div class="line"><span class="comment">  / alpha 값이 서로 다르면, e.g. rgba(0, 0, 0, 0.7) + rgba(100, 120, 255, 0.5);</span></div><div class="line"><span class="comment">  이 경우 error가 발생한다.</span></div><div class="line"><span class="comment">  */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>alpha값은 연산되지 않는다. 서로 다른 alpha값을 연산하려 하는 경우 error가 발생한다. 서로 같은 alpha값을 연산하려 하는 경우, error는 발생하지 않지만 연산을 하지 않고 값을 그대로 반환한다. 위 예제에서도 연산 결과로 0.75를 그대로 반환하였다.  </p>
<p>alpha 값을 연산하려면 <a href="http://poiemaweb.com/sass-built-in-function#65-alpha-연산" target="_blank" rel="external">opacify 함수 또는 transparentize 함수</a>를 사용해야 한다.</p>
<ul>
<li>opacify(불투명화) 함수: <code>+</code> 연산, 첫번째 argument의 alpha값에 두번째 argument를 더해 <strong>불투명도를 증가</strong>시킨다.</li>
<li>transparentize(투명화) 함수: <code>-</code> 연산, 첫번째 argument의 alpha값에 두번째 argument의 alpha값을 빼서 <strong>불투명도를 감소</strong>시킨다.</li>
</ul>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$translucent-red</span>: rgba(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</div><div class="line"><span class="selector-tag">p</span> &#123;</div><div class="line">  <span class="attribute">color</span>: opacify(<span class="variable">$translucent-red</span>, <span class="number">0.3</span>);</div><div class="line">  <span class="comment">// =&gt; color: rgba(255, 0, 0, 0.8)</span></div><div class="line">  <span class="attribute">background-color</span>: transparentize(<span class="variable">$translucent-red</span>, <span class="number">0.25</span>);</div><div class="line">  <span class="comment">// =&gt;  color: rgba(255, 0, 0, 0.25);</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-문자열-연산자"><a href="#3-문자열-연산자" class="headerlink" title="3) 문자열 연산자"></a>3) 문자열 연산자</h3><p><code>+</code> 연산자는 자바스크립트와 같이 문자열을 연결할 수 있다.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> &#123;</div><div class="line">  <span class="attribute">cursor</span>: e + -resize; <span class="comment">// e-resize</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>따옴표가 있는 문자열과 없는 문자열을 함께 사용하는 경우, 좌향의 문자열을 기준으로 따옴표를 처리한다. 하이픈(<code>-</code>) 기호가 사용될 경우, 하이픈 기호를 포함해서 붙인다.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span>:before &#123;</div><div class="line">  <span class="attribute">content</span>: <span class="string">"Foo "</span> + Bar; <span class="comment">//Foo Bar</span></div><div class="line">  <span class="attribute">font-family</span>: sans- + <span class="string">"serif"</span>; <span class="comment">//sans-serif;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.btn</span> &#123;</div><div class="line">  <span class="attribute">cursor</span>: p + inter;</div><div class="line">  <span class="attribute">font-family</span>: sans- + <span class="string">'serif'</span>;</div><div class="line">  &amp;:after &#123;</div><div class="line">    <span class="attribute">content</span>: <span class="string">"Hello "</span> + world;</div><div class="line">  &#125;</div><div class="line">  <span class="variable">$value</span>: <span class="number">100</span>;</div><div class="line">  &amp;:before &#123;</div><div class="line">    <span class="attribute">content</span>: <span class="string">"I'm #&#123;$value&#125; years old!"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* compiled */</span></div><div class="line"></div><div class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:before</span>&#123;</div><div class="line">  <span class="attribute">content</span>: <span class="string">"Foo Bar"</span>;</div><div class="line">  <span class="attribute">font-family</span>: sans-serif;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.btn</span> &#123;</div><div class="line">  <span class="attribute">cursor</span>: pinter;</div><div class="line">  <span class="attribute">font-family</span>: sans-serif;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.btn</span><span class="selector-pseudo">:after</span> &#123; <span class="attribute">content</span>: <span class="string">"Hello world"</span>; &#125;</div><div class="line"><span class="selector-class">.btn</span><span class="selector-pseudo">:before</span> &#123; <span class="attribute">content</span>: <span class="string">"I'm 100 years old!"</span>; &#125;</div></pre></td></tr></table></figure>
<h3 id="4-boolean-연산자"><a href="#4-boolean-연산자" class="headerlink" title="4) boolean 연산자"></a>4) boolean 연산자</h3><ul>
<li><strong>&amp;&amp;</strong> (and)</li>
<li><strong>||</strong> (or)</li>
<li><strong>!</strong> (not)</li>
</ul>
<h3 id="5-list-연산자"><a href="#5-list-연산자" class="headerlink" title="5) list 연산자"></a>5) list 연산자</h3><p>리스트를 위한 별도의 연산자는 제공되지 않지만, <a href="http://poiemaweb.com/sass-built-in-function#4-list-functions" target="_blank" rel="external">리스트 함수</a>를 사용하여 필요한 처리를 수행할 수 있다.</p>
<h2 id="5-함수-Function"><a href="#5-함수-Function" class="headerlink" title="5. 함수(Function)"></a>5. 함수(Function)</h2><p><a href="http://poiemaweb.com/sass-built-in-function" target="_blank" rel="external">Built-in Function</a></p>
<h2 id="6-Interpolation"><a href="#6-Interpolation" class="headerlink" title="6. Interpolation: #{}"></a>6. Interpolation: <code>#{}</code></h2><p>인터폴레이션은 변수의 값을 문자열 그대로 삽입한다. 인터폴레이션에 의해 삽입된 문자열은 연산 대상으로 취급되지 않는다. 변수는 프로퍼티값으로만 사용할 수 있으나 <code>#{}</code>을 사용하면 <strong>셀렉터와 프로퍼티명에도</strong> 사용할 수 있다.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$name</span>: foo;</div><div class="line"><span class="variable">$attr</span>: border;</div><div class="line"></div><div class="line"><span class="selector-tag">p</span>.#&#123;<span class="variable">$name</span>&#125; &#123; <span class="comment">//p.foo</span></div><div class="line">  #&#123;<span class="variable">$attr</span>&#125;-<span class="attribute">color</span>: blue; <span class="comment">//border-color: blue;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="selector-class">.someclass</span> &#123;</div><div class="line">  <span class="variable">$font-size</span>: <span class="number">12px</span>;</div><div class="line">  <span class="variable">$line-height</span>: <span class="number">30px</span>;</div><div class="line">  <span class="comment">//연산의 대상으로 취급되지 않게 한다.</span></div><div class="line">  <span class="attribute">font</span>: #&#123;<span class="variable">$font-size</span>&#125; / #&#123;<span class="variable">$line-height</span>&#125;;</div><div class="line">  <span class="comment">// 12px / 30px</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="7-Ampersand-amp"><a href="#7-Ampersand-amp" class="headerlink" title="7. Ampersand(&amp;)"></a>7. Ampersand(&amp;)</h2><p><code>&amp;</code>는 부모요소를 참조하는 셀렉터이다.<br><code>&amp;</code>는 Sass와 Less에서 아주 유용한 기능으로  주로 중첩(nesting)시에 사용된다. 사용법만 알면, css로 동일한 코드를 작성할 때보다 훨씬 많은 시간을 절약할 수 있다.</p>
<p><img src="https://cdn.css-tricks.com/wp-content/uploads/2016/01/scss-to-css.gif" alt="Ampersand in SASS"></p>
<hr>
<h3 id="Nesting"><a href="#Nesting" class="headerlink" title="Nesting"></a><strong>Nesting</strong></h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//scss</span></div><div class="line"><span class="selector-class">.parent</span> &#123;</div><div class="line">  <span class="selector-class">.child</span> &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* compiles to css */</span></div><div class="line"><span class="selector-class">.parent</span> <span class="selector-class">.child</span> &#123;&#125;</div></pre></td></tr></table></figure>
<p>원하는 만큼 깊게 중첩시킬 수 있지만 지나치게 특수한 셀렉터(덜 유용하고 재정의하기 어려운)가 되는 것을 막기 위해 1 ~ 2단계의 중첩만 유지하는 게 좋다.</p>
<h3 id="Adding-another-class"><a href="#Adding-another-class" class="headerlink" title="Adding another class"></a><strong>Adding another class</strong></h3><p><code>&amp;</code>는 이러한 중첩(네스팅, nesting)에 편리하다. 다음과 같이 둘 이상의 클래스를 사용해서 특수한(구체적인) 선택자(selector)를 만들고자 할 때 특히 그렇다.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* css */</span></div><div class="line"><span class="selector-class">.some-class</span><span class="selector-class">.anoter-class</span> &#123;&#125;</div></pre></td></tr></table></figure>
<p>위와 같은 css코드는 sass로는 아래처럼 작성할 수 있다.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//scss</span></div><div class="line"><span class="selector-class">.some-class</span> &#123;</div><div class="line">  &amp;<span class="selector-class">.anoter-class</span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>&amp;</code>는 네스팅시 항상 상위 선택자를 탐조한다. <code>&amp;</code>를 제거하고 부모 선택자로 대체한 것으로 생각할 수 있다.  </p>
<p>위에서 예시로 들었던 코드를 다시 살펴보면,</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//scss</span></div><div class="line"><span class="selector-class">.parent</span> &#123;</div><div class="line">  <span class="selector-class">.child</span> &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 코드는 사실 <code>&amp;</code>로 네스팅하는 것의 short-hand이다.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//scss</span></div><div class="line"><span class="selector-class">.parent</span> &#123;</div><div class="line">  &amp; <span class="selector-class">.child</span>&#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>따라서 이 두 예시는 모두 아래처럼 동일하게 컴파일된다.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* compiles to css */</span></div><div class="line"><span class="selector-class">.parent</span> <span class="selector-class">.child</span> &#123;&#125;</div></pre></td></tr></table></figure>
<p><code>&amp;</code>는 자식 선택자에 필요할 때마다 부모 선택자를 배치할 수 있게 하는 매커니즘 정도로 생각할 수 있다. 그러면 <code>&amp;</code>를 어떻게 더 다양하게 활용할 수 있을지 예제를 통해 알아보자.</p>
<h3 id="Using-the-amp-with-pseudo-classes"><a href="#Using-the-amp-with-pseudo-classes" class="headerlink" title="Using the &amp; with pseudo classes"></a><strong>Using the <code>&amp;</code> with pseudo classes</strong></h3><p><code>&amp;</code>를 이용하면 가상클래스(pseudo class)를 작성할 때 코드의 반복을 현저하게 줄일 수 있다.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.button</span> &#123;</div><div class="line">  &amp;:visited &#123;&#125;</div><div class="line">  &amp;:hover &#123;&#125;</div><div class="line">  &amp;:active&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*compiles to css*/</span></div><div class="line"><span class="selector-class">.button</span><span class="selector-pseudo">:visited</span> &#123;&#125;</div><div class="line"><span class="selector-class">.buttom</span><span class="selector-pseudo">:hover</span> &#123;&#125;</div><div class="line"><span class="selector-class">.button</span><span class="selector-pseudo">:active</span> &#123;&#125;</div></pre></td></tr></table></figure>
<p>이 경우 <code>&amp;</code>를 사용함으로써 <code>.button</code>을 반복적으로 작성하지 않고도 가상클래스 바로 옆에 <code>.button</code>를 배치할 수 있다. 만약 이때 <code>&amp;</code>를 생략하면, 기본 중첩(nesting)은 다음과 같이 둘 사이에 공백을 넣는다.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//scss</span></div><div class="line"><span class="selector-class">.button</span> &#123;</div><div class="line">  :visited &#123;&#125;</div><div class="line">  :hover &#123;&#125;</div><div class="line">  :active &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*css*/</span></div><div class="line"><span class="selector-class">.button</span> <span class="selector-pseudo">:hover</span></div></pre></td></tr></table></figure>
<p>주의하자. 공백이 있는 것과 없는 것은 절대 같지 않다.</p>
<h3 id="Using-the-amp-with-gt-and"><a href="#Using-the-amp-with-gt-and" class="headerlink" title="Using the &amp; with &gt;, +, and ~"></a><em>Using the <code>&amp;</code> with <code>&gt;</code>, <code>+</code>, and <code>~</code></em></h3><p><code>&amp;</code>를 부모-자식 관계를 나타내는 combinator인 <code>&gt;</code>, 인접 형제 관계임을 나타내는 combinator인 <code>+</code>, 그리고 일반적인 형제 관계임을 나타내는 combinator인 <code>~</code>와 함께 사용하면 아주 용이하다.  </p>
<p>코드를 작성할 때, <code>&amp;</code>를 함께 작성해야한다 생각하겠지만, 사실 그렇지 않다.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.button</span> &#123;</div><div class="line">  &amp; &gt; <span class="selector-tag">span</span> &#123;&#125;</div><div class="line">  &amp; + <span class="selector-tag">span</span> &#123;&#125;</div><div class="line">  &amp; ~ <span class="selector-tag">span</span> &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>선택자에서 <code>&amp;</code>를 떼어내서 아래처럼 작성할 수도 있는데, 두 코드는 동일하게 컴파일 된다.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 이렇게 작성해도 똑같다.</span></div><div class="line"><span class="selector-class">.button</span> &#123;</div><div class="line">  &gt; <span class="selector-tag">span</span> &#123;&#125;</div><div class="line">  + <span class="selector-tag">span</span> &#123;&#125;</div><div class="line">  ~ <span class="selector-tag">span</span> &#123;&#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*compiles to css*/</span></div><div class="line"><span class="selector-class">.button</span> &gt; <span class="selector-tag">span</span> &#123;&#125;</div><div class="line"><span class="selector-class">.button</span> + <span class="selector-tag">span</span> &#123;&#125;</div><div class="line"><span class="selector-class">.button</span> ~ <span class="selector-tag">span</span>&#123;&#125;</div></pre></td></tr></table></figure>
<h3 id="Qualifying-based-on-context"><a href="#Qualifying-based-on-context" class="headerlink" title="Qualifying based on context"></a><strong>Qualifying based on context</strong></h3><p>네스팅된 셀렉터에 <code>&amp;</code>가 반드시 앞에 붙을 필요는 없다. 끝에 <code>&amp;</code>를 붙이면 선택자를 한정할 수 있다.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//scss</span></div><div class="line"><span class="selector-class">.button</span> &#123;</div><div class="line">  <span class="selector-tag">body</span><span class="selector-class">.page-about</span> &amp; &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>&amp;</code> 자리는 본래 부모 선택자의 자리이다. 만약 필요한 부모 선택자가 있다면 그 자리에 부모 선택자를 기재한다. <code>&amp;</code>는 마지막에 붙인다. 이 방식은 다른 부모를 기반으로 셀렉터를 한정하는데 아주 유용하다. 이 코드는 아래와 같이 컴파일 된다.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span><span class="selector-class">.page-about</span> <span class="selector-class">.button</span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>해석해보자면, <code>page-about</code>이 <strong><code>body</code>클래스의 자식클래스로 있을 때에만</strong> (다르게 말하면, 다른 클래스의 자식클래스로 있을 때는 적용하지 않는다.) <code>button</code> 클래스에 {내용}의 css를 정의한다</p>
<p><a href="https://css-tricks.com/the-sass-ampersand/#article-header-id-9" target="_blank" rel="external">그 외 더 많은 예시</a></p>
<hr>
<h2 id="8-default"><a href="#8-default" class="headerlink" title="8. !default"></a>8. <code>!default</code></h2><p><code>!default</code> flag는 할당되지 않은 변수의 초기값을 설정한다.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$content</span>: null; <span class="comment">//값이 할당되지 않았다.</span></div><div class="line"><span class="variable">$content</span>: <span class="string">"Non-null content"</span> !default;</div><div class="line"></div><div class="line"><span class="selector-id">#main</span> &#123;</div><div class="line">  <span class="attribute">content</span>: <span class="variable">$content</span>; <span class="comment">//"Non-null content"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이미 값이 할당되어 있는 변수에 <code>!default</code> flag를 사용하면 적용되지 않는다.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$content</span>: <span class="string">"First content"</span>;</div><div class="line"><span class="variable">$content</span>: <span class="string">"Second content?"</span> !default;</div><div class="line"><span class="variable">$new_content</span>: <span class="string">"First time reference"</span> !default;</div><div class="line"></div><div class="line"><span class="selector-id">#main</span> &#123;</div><div class="line">  <span class="attribute">content</span>: <span class="variable">$content</span>; <span class="comment">//"First content"</span></div><div class="line">  new_content: <span class="variable">$new_content</span>; <span class="comment">//"First time reference"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이러한 특성은 <a href="http://sass-lang.com/documentation/file.SASS_REFERENCE.html#Partials__partials" target="_blank" rel="external">partial</a>에 매우 유용하다.<br>2개의 font.scss와 main.scss파일을 생성해보자.  </p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//font.scss</span></div><div class="line"><span class="variable">$font-size</span>: <span class="number">16px</span> !default;</div><div class="line"><span class="variable">$line-height</span>: <span class="number">1.5</span> !default;</div><div class="line"><span class="variable">$font-family</span>: <span class="string">"Helvetica Neue"</span>, <span class="string">"Helverica"</span>, <span class="string">"Arial"</span>, sans-serif !default;</div><div class="line"></div><div class="line"><span class="selector-tag">body</span> &#123;</div><div class="line">  <span class="attribute">font</span>: #&#123;<span class="variable">$font-size</span>&#125;/<span class="variable">$line-height</span> <span class="variable">$font-family</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>main.scss는 내부에서 font.scss를 import한다.</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//main.scss</span></div><div class="line"><span class="variable">$font-family</span>: <span class="string">"Lucida Grande"</span>, <span class="string">"Lucida Sans Unicode"</span>, sans-serif;</div><div class="line"></div><div class="line">@<span class="keyword">import</span> <span class="string">"font"</span>;</div></pre></td></tr></table></figure>
<p>위 코드의 컴파일 결과는 아래와 같다. </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span> &#123;</div><div class="line">  <span class="attribute">font</span>: <span class="number">16px</span>/<span class="number">1.5</span> <span class="string">"Lucida Grande"</span>, <span class="string">"Lucida Sans Unicode"</span>, sans-serif;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>!default</code>는 <strong>변수에 값이 할당되지 않았을 때</strong> 사용할 기본 값을 지정할 때 사용한다. 위 예제의 경우 <code>main.scss</code>에서 <strong>변수에 값을 할당하였기 때문에</strong> <code>!default</code>와 같이 사용한 변수값은 무력화된다.  </p>
<p>만일 <code>font.scss</code>의 <code>$font-family</code> 변수에 <code>!default</code>설정이 없었다면 후위에 선언된 <code>font.scss</code>의 <code>$font-family</code> 변수값이 적용되어 아래와 같은 결과가 생성되었을 것이다.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span> &#123;</div><div class="line">  <span class="attribute">font</span>: <span class="number">16px</span>/<span class="number">1.5</span> <span class="string">"Helvetica Neue"</span>, <span class="string">"Helvetica"</span>, <span class="string">"Arial"</span>, sans-serif;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Sass-Script&quot;&gt;&lt;a href=&quot;#Sass-Script&quot; class=&quot;headerlink&quot; title=&quot;Sass Script&quot;&gt;&lt;/a&gt;Sass Script&lt;/h1&gt;&lt;h2 id=&quot;1-Data-Type&quot;&gt;&lt;a href=&quot;#1-Data
    
    </summary>
    
      <category term="Sass" scheme="http://huusz.github.io/categories/Sass/"/>
    
    
      <category term="sass syntax" scheme="http://huusz.github.io/tags/sass-syntax/"/>
    
  </entry>
  
  <entry>
    <title>[JS] 프로토타입 Prototype</title>
    <link href="http://huusz.github.io/2017/Javascript/Javascript/Javascript-Prototype/"/>
    <id>http://huusz.github.io/2017/Javascript/Javascript/Javascript-Prototype/</id>
    <published>2017-08-06T01:53:50.000Z</published>
    <updated>2017-08-28T14:13:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Prototype-프로토타입과-객체지향"><a href="#Prototype-프로토타입과-객체지향" class="headerlink" title="Prototype 프로토타입과 객체지향"></a>Prototype 프로토타입과 객체지향</h1><h3 id="객체-Object"><a href="#객체-Object" class="headerlink" title="객체(Object)"></a><strong>객체(Object)</strong></h3><p>자바스크립트에서는 객체를 만드는 방법으로 객체리터럴 방식과 생성자(Object() 함수, 일반 생성자 함수)를 이용한 방식이 있다.  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> objectMadeByLiteral = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> objectMadeByConstructor = <span class="keyword">new</span> <span class="built_in">Object</span>();</div></pre></td></tr></table></figure>
<p>리터럴은 Object 타입의 객체를 만들어내는 일종의 숏컷이고 두 번째 라인의 생성자를 이용한 코드 역시 Object 생성자이기 때문에 사실 위 예제는 구조면에서 동일한 객체를 만든다. 둘 다 Object타입을 갖는 객체로 Object타입의 메서드들을 사용할 수 있다. Object타입은 모든 객체의 최상위 타입이다. 사실 다른 객체지향언어의 관점에서 보면 위 코드는 Object객체의 인스턴스를 만든 것에 불과하니 상속받았다고 표현하기 어렵다. 하지만 자바스크립트에서는 조금 다른 개념으로 생각해야 한다. 지금 만들어진 객체가 Object 타입의 인스턴스 객체인 것도 맞지만 프로토 타입을 이용한 상속받은 객체라고 표현하는게 더 정확한 표현이다. 사실 상속이라는 표현도 OOP의 관점에서 사용하는 단어로 표현하고자 한 것일 뿐 실제로는 링크드 리스트 형태의 창조를 통한 객체끼리의 연결에 가깝고 클래스 매커니즘처럼 정적이지 않고 매우 동적이다.</p>
<h2 id="1-프로토타입-객체"><a href="#1-프로토타입-객체" class="headerlink" title="1. 프로토타입 객체"></a>1. 프로토타입 객체</h2><p>자바스크립트의 모든 객체는 부모가 존재한다. 그런데 객체가 생성자 함수를 통해 생성되었다고 하여 객체의 부모가 생성자함수인 것은 아니다. 모든 객체의 부모는 prototype 객체이다. 함수도 객체이다. 다만 함수 객체는 일반 객체와 달리 prototype이라는 프로퍼티를 특별히 가지고 있다. 생성자 함수는 함수 객체이다. 따라서 prototype 프로퍼티가 존재한다. 생성자 함수의 prototype 프로퍼티는 생성자 함수가 생산한 객체의 부모가 되는 prototype 객체를 가리킨다.</p>
<p>프로토타입은 자바의 객체지향의 상속 개념과 유사하다. 자바스크립트는 프로토타입 기반 객체지향언어이며 자바는 클래스 기반 객체지향언어이다. 따라서 둘은 같지 않다. 자바스크립트의 모든 객체는 자신의 부모 역할을 담당하는 객체와 연결되어 있다. 그리고 이것은 마치 객체 지향의 상속 개념과 같이 부모 객체의 프로퍼티 또는 메소드를 상속받아 사용할 수 있게 한다. 이러한 부모 객체를 Prototype(프로토타입) 객체 또는 줄여서 프로토타입이라 한다.</p>
<p>프로토타입을 이용하면 객체와 객체를 연결하고 한쪽 방향으로 상속을 받는 형태를 만들 수가 있다. 자바스크립트에서 객체와 객체를 연결해서 상속 받는다는 것은 다른 말로 객체와 객체를 연결해 멤버 함수나 멤버 변수를 공유 한다는 뜻이다. 이런 점을 이용해 자바스크립트에서는 상속과 비슷한 효과를 얻는 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> student = &#123;</div><div class="line">  name: <span class="string">'Lee'</span>,</div><div class="line">  score: <span class="number">90</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// student에는 hasOwnProperty 메서드가 없지만 아래 구문은 동작한다.</span></div><div class="line"><span class="built_in">console</span>.log(student.hasOwnProperty(<span class="string">'name'</span>)); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.dir(student);</div></pre></td></tr></table></figure>
<p>객체를 생성할 때 프로토타입은 결정된다. 결정된 프로토타입 객체는 다른 임의의 객체로 변경할 수 있다. 이것은 부모 객체인 프로토타입을 동적으로 변경할 수 있다는 것을 의미한다. 이러한 특징을 활용하여 객체의 상속을 구현할 수 있다.</p>
<p><br></p>
<h2 id="2-Prototype-프로퍼티-VS-prototype-프로퍼티"><a href="#2-Prototype-프로퍼티-VS-prototype-프로퍼티" class="headerlink" title="2. [[Prototype]] 프로퍼티 VS prototype 프로퍼티"></a>2. [[Prototype]] 프로퍼티 VS prototype 프로퍼티</h2><p><strong><em>[함수 객체와 일반 객체의 차이]</em></strong>  </p>
<ol>
<li><p>함수 객체는 <code>prototype</code> 프로퍼티를 가지고 있다.<br>(prototype 프로퍼티는 prototype Object를 가리키고 있다.)</p>
</li>
<li><p>함수 객체는 호출될 수 있다.</p>
</li>
</ol>
<p>자바스크립트 엔진은 객체를 일종의 키와 값을 가진 해쉬맵처럼 다룬다. 값에는 데이터나 함수가 들어갈 수 있으며 엔진 내부에 필요한 데이터를 임의로 만들어 넣기도 한다. 물론 그게 자바스크립트 단으로 노출이 될 수도, 안될 수도 있다. 프로토타입 체인의 핵심은 엔진이 사용하는 <code>__proto__</code>라는 속성이다. </p>
<blockquote>
<p><code>__proto__</code> 속성은 ECMAScript의 스펙 <code>[[prototype]]</code> 이 자바스크립트로 노출된 것인데 예전 스펙이 legacy처럼 남아있는 것이다. 모던 브라우저 개발자 도구에서도 디버깅 편의상 노출하고 있으나 코드에서 직접 접근하는 것은 피해야 한다.</p>
</blockquote>
<p>클래스를 통한 상속의 경우 클래스 상속 정보를 이용해 상속 구조의 모습을 가진 새로운 객체를 찍어내는 반면 프로토타입을 통한 상속구조는 존재하는 객체와 객체의 동적인 연결로 풀어낸다. 그렇다보니 이미 객체가 만들어진 상태라도 상속된 내용의 변경/추가/삭제가 가능하며 아예 상속 구조를 바꿀 수도 있게 된다. 이렇게 객체와 객체의 연결을 통한 단방향 공유 관계를 프로토타입 체인이라고 한다.</p>
<h2 id="3-constructor-프로퍼티"><a href="#3-constructor-프로퍼티" class="headerlink" title="3. constructor 프로퍼티"></a>3. constructor 프로퍼티</h2><p>프로토타입 객체는 <code>constructor</code> 프로퍼티를 갖는다. 이 <strong><code>constructor</code> 프로퍼티는 객체의 입장에서 자신을 생성한 객체</strong>를 가리킨다. <code>Person()</code> 생성자 함수에 의해 생성된 객체를 생성한 객체는 <code>Person()</code> 생성자 함수이다. 따라서 <code>prototype</code> 객체의 <code>constructor</code> 프로퍼티는 객체를 생성하는 생성자 함수 객체를 가리킨다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Person(<span class="string">'Lee'</span>);</div><div class="line"></div><div class="line"><span class="comment">// Person() 생성자 함수에 의해 생성된 객체를 생성한 객체는 Person() 생성자 함수이다.</span></div><div class="line"><span class="built_in">console</span>.log(Person.prototype.constructor === Person);</div><div class="line"></div><div class="line"><span class="comment">// foo 객체를 생성한 객체는 Person() 생성자 함수이다.</span></div><div class="line"><span class="built_in">console</span>.log(foo.constructor === Person);</div><div class="line"></div><div class="line"><span class="comment">// Person() 생성자 함수를 생성한 객체는 Function() 생성자 함수이다.</span></div><div class="line"><span class="built_in">console</span>.log(Person.constructor === <span class="built_in">Function</span>);</div></pre></td></tr></table></figure>
<h2 id="4-Prototype-chain"><a href="#4-Prototype-chain" class="headerlink" title="4. Prototype chain"></a>4. Prototype chain</h2><p>자바스크립트는 특정 객체의 프로퍼티나 메소드에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티 또는 메소드가 없다면 <code>[[Prototype]]</code> 프로퍼티가 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티나 메소드를 차례대로 검색한다. 이것을 프로토타입 체인이라 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> student = &#123;</div><div class="line">  name: <span class="string">'Lee'</span>,</div><div class="line">  score: <span class="number">90</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Object.prototype.hasOwnProperty()</span></div><div class="line"><span class="built_in">console</span>.log(student.hasOwnProperty(<span class="string">'name'</span>)); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="1-객체-리터럴-방식으로-생성된-객체의-프로토타입-체인"><a href="#1-객체-리터럴-방식으로-생성된-객체의-프로토타입-체인" class="headerlink" title="1) 객체 리터럴 방식으로 생성된 객체의 프로토타입 체인"></a>1) 객체 리터럴 방식으로 생성된 객체의 프로토타입 체인</h3><p>객체 생성 방법은 3가지가 있다.</p>
<ul>
<li>객체 리터럴</li>
<li>생성자 함수</li>
<li><code>Object()</code> 생성자 함수</li>
</ul>
<p>객체 리터럴 방식으로 생성된 객체는 결국 내장 함수(Built-in)인 <code>Object()</code> 생성자 함수로 객체를 생성하는 것을 단순화시킨 것이다. 자바스크립트 엔진은 객체 리터럴로 객체를 생성하는 코드를 만나면 내부적으로 <code>Object()</code> 생성자 함수를 사용하여 객체를 생성한다.</p>
<p><code>Object()</code> 생성자 함수는 물론 함수이다. 따라서 함수 객체인 <code>Object()</code> 생성자 함수는 일반 객체와 달리 prototype 프로퍼티가 있다.</p>
<ul>
<li><code>prototype</code> 프로퍼티는 함수 객체가 생성자로 사용될 때 이 함수를 통해 생성된 객체의 부모 역할을 하는 객체를 가리킨다.</li>
<li><code>[[Prototype]]</code> 프로퍼티는 객체의 입장에서 자신의 부모 역할을 하는 프로토타입 객체을 가리킨다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">  name: <span class="string">'Lee'</span>,</div><div class="line">  gender: <span class="string">'male'</span>,</div><div class="line">  sayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Hi! my name is '</span> + <span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.dir(person);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.__proto__ === <span class="built_in">Object</span>.prototype);   <span class="comment">// ① true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.constructor === <span class="built_in">Object</span>); <span class="comment">// ② true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype); <span class="comment">// ③ true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// ④ true</span></div></pre></td></tr></table></figure>
<p><img src="http://poiemaweb.com/img/object_literal_prototype_chaining.png" alt="객체 리터럴로 생성한 객체의 프로토타입 체인"><br><strong>결론적으로 객체 리터럴을 사용하여 객체를 생성한 경우, 그 객체의 프로토타입 객체는 <code>Object.prototype</code>이다.</strong></p>
<h3 id="2-생성자-함수로-생성된-객체의-프로토타입-체인"><a href="#2-생성자-함수로-생성된-객체의-프로토타입-체인" class="headerlink" title="2) 생성자 함수로 생성된 객체의 프로토타입 체인"></a>2) 생성자 함수로 생성된 객체의 프로토타입 체인</h3><p>생성자 함수로 객체를 생성하기 위해서는 우선 생성자 함수를 정의하여야 한다.</p>
<p>함수를 정의하는 방식은 3가지가 있다.</p>
<ul>
<li>함수선언식(Function declaration)</li>
<li>함수표현식(Function expression)</li>
<li><code>Function()</code> 생성자 함수  </li>
</ul>
<p>함수표현식으로 함수를 정의할 때 함수 리터럴 방식을 사용한다.</p>
<p>3가지 함수 정의 방식은 결국 <code>Function()</code> 생성자 함수를 통해 함수 객체를 생성한다, 따라서 어떠한 방식으로 함수 객체를 생성하여도 모든 함수 객체의 <code>prototype</code> 객체는 <code>Function.prototype</code>이다. 생성자 함수도 함수 객체이므로 생성자 함수의 <code>prototype</code> 객체는 <code>Function.prototype</code>이다.</p>
<p>이제 객체의 관점에서 <code>prototype</code> 객체를 살펴보자. 객체를 생성하는 방식은 3가지가 있다. 3가지 객체 생성 방식에 의해 생성된 객체의 <code>prototype</code> 객체를 정리해 보면 아래와 같다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, gender</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.gender = gender;</div><div class="line">  &lt;!-- <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Hi! my name is '</span> + <span class="keyword">this</span>.name); --&gt;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = <span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Hi! my name is '</span> + <span class="keyword">this</span>.name);</div><div class="line"></div><div class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Person(<span class="string">'Lee'</span>, <span class="string">'male'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.dir(Person);</div><div class="line"><span class="built_in">console</span>.dir(foo);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(foo.__proto__ === Person.prototype);                <span class="comment">// ① true</span></div><div class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__ === <span class="built_in">Object</span>.prototype);   <span class="comment">// ② true</span></div><div class="line"><span class="built_in">console</span>.log(Person.prototype.constructor === Person);           <span class="comment">// ③ true</span></div><div class="line"><span class="built_in">console</span>.log(Person.__proto__ === <span class="built_in">Function</span>.prototype);           <span class="comment">// ④ true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// ⑤ true</span></div></pre></td></tr></table></figure>
<p><img src="http://poiemaweb.com/img/constructor_function_prototype_chaining.png" alt="Person 생성자 프로토타입 체인"></p>
<p><code>foo</code> 객체의 프로토타입 객체 <code>Person.prototype</code> 객체와 <code>Person()</code> 생성자 함수의 프로토타입 객체인 <code>Function.prototype</code>의 프로토타입 객체는 <code>Object.prototype</code> 객체이다.</p>
<p>이는 객체 리터럴 방식이나 생성자 함수 방식이나 결국은 모든 객체의 부모 객체인 <code>Object.prototype</code> 객체에서 프로토타입 체인이 끝나기 때문이다. 이때 <code>Object.prototype</code> 객체를 프로토타입 체인의 종점(End of prototype chain)이라 한다.</p>
<h2 id="5-프로토타입-객체의-확장"><a href="#5-프로토타입-객체의-확장" class="headerlink" title="5. 프로토타입 객체의 확장"></a>5. 프로토타입 객체의 확장</h2><p>프로토타입 객체도 객체이므로 일반 객체와 같이 프로퍼티를 추가/삭제할 수 있다. 그리고 이렇게 추가/삭제된 프로퍼티는 즉시 프로토타입 체인에 반영된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Person(<span class="string">'Lee'</span>);</div><div class="line"></div><div class="line">Person.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Hi! my name is '</span> + <span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">foo.sayHello();</div></pre></td></tr></table></figure>
<p>생성자 함수 <code>Person</code>은 <code>prototype</code> 프로퍼티에 연결된 프로토타입 객체 <code>Person.prototype</code>를 갖는다. <code>Person.prototype</code> 객체는 일반 객체와 같이 프로퍼티를 추가/삭제가 가능하다. 위의 예에서는 <code>Person.prototype</code> 객체에 메소드 <code>sayHello</code>를 추가하였다. 이때 <code>sayHello</code> 메소드는 프로토타입 체인에 반영된다. 따라서 생성자 함수 <code>Person</code>에 의해 생성된 모든 객체는 프로토타입 체인에 의해 부모객체인 <code>Person.prototype</code>의 메소드를 사용할 수 있게 되었다.<br><img src="http://poiemaweb.com/img/extension_prototype.png" alt="생성자"></p>
<p><br></p>
<h2 id="6-기본자료형-Primitive-data-type-의-확장"><a href="#6-기본자료형-Primitive-data-type-의-확장" class="headerlink" title="6. 기본자료형(Primitive data type)의 확장"></a>6. 기본자료형(Primitive data type)의 확장</h2><p>자바스크립트에서 기본자료형(숫자, 문자열, boolean, null, undefined)을 제외한 모든것은 객체이다. 그런데 아래 예제를 살펴보면 기본자료형인 문자열이 흡사 객체와 같이 동작한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'test'</span>; <span class="comment">//리터럴 방식으로 객체 선언</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str);                 <span class="comment">// string</span></div><div class="line"><span class="built_in">console</span>.log(str.constructor === <span class="built_in">String</span>); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.dir(str);</div><div class="line"></div><div class="line"><span class="keyword">var</span> strObj = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'test'</span>);</div><div class="line"><span class="comment">//객체인 문자열을 생성한다.</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> strObj);                 <span class="comment">// object</span></div><div class="line"><span class="built_in">console</span>.log(strObj.constructor === <span class="built_in">String</span>); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.dir(strObj);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(str.toUpperCase());    <span class="comment">// TEST</span></div><div class="line"><span class="built_in">console</span>.log(strObj.toUpperCase()); <span class="comment">// TEST</span></div></pre></td></tr></table></figure>
<ul>
<li>기본자료형과 객체의 차이:<br>기본자료형은 상속, 프로퍼티, 메서드 개념이 없다. 그저 데이터(값)그 자체이다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'test'</span>;</div><div class="line"></div><div class="line"><span class="comment">// 에러가 발생하지 않는다.</span></div><div class="line">str.myMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'str.myMethod'</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">str.myMethod(); <span class="comment">// Uncaught TypeError: str.myMethod is not a function</span></div></pre></td></tr></table></figure>
<p><code>String</code>은 래퍼객체이다. 문자열을 <code>String</code>의 객체로 선언하면 <code>String</code> 객체 내부의 메소드를 사용할 수 있다. 그런데 모든 문자열을 다룰 때, 항상 객체로 다시 선언해주기에는 큰 번거로움이 따른다. 따라서 문자열 기본자료형에 <code>.</code>을 붙이면 자동으로 자바스크립트 엔진이 래퍼 객체를 통해 일시적으로 문자열 객체로 변환해준다. 따라서 리터럴 방식으로 선언한 기본자료형 문자열도 <code>String</code>객체의 메소드를 사용할 수 있게 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'test'</span>;</div><div class="line"></div><div class="line"><span class="built_in">String</span>.prototype.myMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'myMethod'</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(str.myMethod());      <span class="comment">// myMethod</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'string'</span>.myMethod()); <span class="comment">// myMethod</span></div><div class="line"><span class="built_in">console</span>.dir(<span class="built_in">String</span>.prototype);</div></pre></td></tr></table></figure>
<p>기본자료형 문자열과 <code>String()</code> 생성자 함수로 생성한 문자열 객체의 타입은 분명이 다르다. 기본 자료형은 객체가 아니므로 프로퍼티나 메소드를 가질수 없다. 하지만 기본자료형으로 프로퍼티나 메소드를 호출할 때 기본자료형과 연관된 객체로 일시적으로 변환되어 프로토타입 객체를 공유하게 된다.</p>
<p>기본자료형은 객체가 아니므로 <code>.</code>을 통해 바로 프로퍼티나 메소드를 직접 추가할 수 없다. 기본자료형은 오직 참조만 할 수 있다.  </p>
<p>만약 기본자료형으로 메소드를 추가하고자 한다면, <code>String</code> 객체의 프로토타입 객체 <code>String.prototype</code>에 메소드를 추가하는 방법이 있다. 하지만 이는 위험 부담이 따른다.</p>
<p>앞선 방법으로 메소드를 추가하는 것은 <code>Built-in</code> 객체인 <code>String</code> 객체의 메소드들(표준)과 섞이거나 변수명의 중복으로 인해 기존 메소드가 지워지는 문제가 있을 수 있기 때문에 좋은 방식은 아니다. 이처럼 표준 이외의 메소드를 추가하는 것이 일종의 라이브러리인데, 라이브러리를 만들고자 할 때는 차라리 커스텀 객체를 따로 생성하는 것이 좋다.</p>
<p>앞서 살펴본 바와 같이 모든 객체는 프로토타입 체인에 의해 <code>Object.prototype</code> 객체의 메소드를 사용할 수 있었다. <code>Object.prototype</code> 객체는 프로토타입 체인의 종점으로 모든 객체가 사용할 수 있는 메소드를 갖는다.</p>
<p>이후 살펴보게 될 <code>Built-in object</code>(내장 객체)의 <code>Global objects</code> (Standard Built-in Objects)인 <code>String</code>, <code>Number</code>, <code>Array</code> 객체 등이 가지고 있는 표준 메소드는 프로토타입 객체인 <code>String.prototype</code>, <code>Number.prototype</code>, <code>Array.prototype</code> 등에 정의되어 있다. 이들 프로토타입 객체 또한 <code>Object.prototype</code>를 프로토타입 체인에 의해 자신의 프로토타입 객체로 연결한다.</p>
<p>자바스크립트는 표준 내장 객체의 프로토타입 객체에 개발자가 정의한 메소드의 추가를 허용한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'test'</span>;</div><div class="line"></div><div class="line"><span class="built_in">String</span>.prototype.myMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'myMethod'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(str.myMethod());</div><div class="line"><span class="built_in">console</span>.dir(<span class="built_in">String</span>.prototype);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(str.__proto__ === <span class="built_in">String</span>.prototype);                 <span class="comment">// ① true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.prototype.__proto__  === <span class="built_in">Object</span>.prototype);   <span class="comment">// ② true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.prototype.constructor === <span class="built_in">String</span>);            <span class="comment">// ③ true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.__proto__ === <span class="built_in">Function</span>.prototype);            <span class="comment">// ④ true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__  === <span class="built_in">Object</span>.prototype); <span class="comment">// ⑤ true</span></div></pre></td></tr></table></figure>
<p><img src="http://poiemaweb.com/img/string_constructor_function_prototype_chaining.png" alt=""></p>
<p><br></p>
<h2 id="7-프로토타입-객체의-변경"><a href="#7-프로토타입-객체의-변경" class="headerlink" title="7. 프로토타입 객체의 변경"></a>7. 프로토타입 객체의 변경</h2><p>객체를 생성할 때 프로토타입은 결정된다. 결정된 프로토타입 객체는 다른 임의의 객체로 변경할 수 있다. 이것은 부모 객체인 프로토타입을 동적으로 변경할 수 있다는 것을 의미한다. 이러한 특징을 활용하여 객체의 상속을 구현할 수 있다.</p>
<p>이때 주의할 것은 프로토타입 객체를 변경하면</p>
<p>프로토타입 객체 변경 시점 이전에 생성된 객체<br>기존 프로토타입 객체를 <code>[[Prototype]]</code> 프로퍼티에 바인딩한다.<br>프로토타입 객체 변경 시점 이후에 생성된 객체<br>변경된 프로토타입 객체를 <code>[[Prototype]]</code> 프로퍼티에 바인딩한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Person(<span class="string">'Lee'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 프로토타입 객체의 변경</span></div><div class="line">Person.prototype = &#123; <span class="attr">gender</span>: <span class="string">'male'</span> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Person(<span class="string">'Kim'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(foo.gender); <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(bar.gender); <span class="comment">// 'male'</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(foo.constructor); <span class="comment">// ① Person(name)</span></div><div class="line"><span class="built_in">console</span>.log(bar.constructor); <span class="comment">// ② Object()</span></div></pre></td></tr></table></figure>
<p><img src="http://poiemaweb.com/img/changing_prototype.png" alt=""></p>
<p>① constructor 프로퍼티는 <code>Person()</code> 생성자 함수를 가리킨다.</p>
<p>② 프로토타입 객체 변경 후, <code>Person()</code> 생성자 함수의 <code>Prototype</code> 프로퍼티가 가리키는 프로토타입 객체를 일반 객체로 변경하면서 <code>Person.prototype.constructor</code> 프로퍼티도 삭제되었다. 따라서 프로토타입 체인에 의해 <code>bar.constructor</code>의 값은 프로토타입 체이닝에 의해 <code>Object.prototype.constructor</code> 즉 <code>Object()</code> 생성자 함수가 된다.  </p>
<p>위 예제의 상속 방식은 물론 가능한 방식이지만, 문제점이 많기 때문에 사용하지 않는 방식이다.</p>
<p><br></p>
<h3 id="8-프로토타입-체인-동작"><a href="#8-프로토타입-체인-동작" class="headerlink" title="8. 프로토타입 체인 동작"></a>8. 프로토타입 체인 동작</h3><p>기본적인 프로토타입 체인은 참조할 때 동작한다.  프로퍼티 동적 추가에서 객체에 프로퍼티가 존재하지 않으면 프로퍼티를 추가한다. </p>
<p>객체의 프로퍼티에 값을 할당하는 경우, 프로토타입 체인이 동작하지 않는다. 이는 객체에 해당 프로퍼티가 있는 경우, 값을 재할당하고 해당 프로퍼티가 없는 경우는 해당 객체에 프로퍼티를 동적으로 추가하기 때문이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.gender = <span class="string">'male'</span>; <span class="comment">// ①</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Person(<span class="string">'Lee'</span>);</div><div class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Person(<span class="string">'Kim'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(foo.gender); <span class="comment">// ① 'male'</span></div><div class="line"><span class="built_in">console</span>.log(bar.gender); <span class="comment">// ① 'male'</span></div><div class="line"></div><div class="line"><span class="comment">// 1. foo 객체에 gender 프로퍼티가 없으면 프로퍼티 동적 추가</span></div><div class="line"><span class="comment">// 2. foo 객체에 gender 프로퍼티가 있으면 해당 프로퍼티에 값 할당</span></div><div class="line">foo.gender = <span class="string">'female'</span>;   <span class="comment">// ②</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(foo.gender); <span class="comment">// ② 'female'</span></div><div class="line"><span class="built_in">console</span>.log(bar.gender); <span class="comment">// ① 'male'</span></div></pre></td></tr></table></figure>
<blockquote>
<p>프로토 타입 체이닝은 <strong>참조할 때 위로 올라가는 것</strong>이다. <strong>프로퍼티를 추가할 때는 자기 자신에게</strong> 추가한다.</p>
</blockquote>
<hr>
<p><strong>Reference</strong>  </p>
<ul>
<li><a href="poiemaweb.com">Poiemaweb</a></li>
<li>(서적)자바스크립트 닌자 비급, 인사이트, 2014</li>
<li>(서적) 인사이드 자바스크립트, 한빛, 2016</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Prototype-프로토타입과-객체지향&quot;&gt;&lt;a href=&quot;#Prototype-프로토타입과-객체지향&quot; class=&quot;headerlink&quot; title=&quot;Prototype 프로토타입과 객체지향&quot;&gt;&lt;/a&gt;Prototype 프로토타입과 객체지향&lt;/
    
    </summary>
    
      <category term="Javascript" scheme="http://huusz.github.io/categories/Javascript/"/>
    
    
      <category term="prototype" scheme="http://huusz.github.io/tags/prototype/"/>
    
  </entry>
  
  <entry>
    <title>[JS] 객체 Object</title>
    <link href="http://huusz.github.io/2017/Javascript/Javascript/Javascript-Object/"/>
    <id>http://huusz.github.io/2017/Javascript/Javascript/Javascript-Object/</id>
    <published>2017-08-05T11:16:16.000Z</published>
    <updated>2017-08-28T14:13:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><h2 id="1-객체-Object-란"><a href="#1-객체-Object-란" class="headerlink" title="1. 객체(Object)란?"></a>1. 객체(Object)란?</h2><p>자바스크립트는 객체(Object)기반의 스크립트 언어이며 자바스크립트를 이루고 있는 거의 “모든 것”은 객체이다. <strong>기본 자료형(primitives)을 제외한</strong> 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체이다. </p>
<blockquote>
<p><strong><a href="https://developer.mozilla.org/ko/docs/Glossary/Primitive" target="_blank" rel="external">primitives</a></strong><br>프리미티브: 객체도 아니고 메소드도 아닌 데이터. string/number/boolean/null/undefined/symbol로 6개의 기본 데이터 타입이 있다.<br>null과 undefined를 제외하고 모든 프리미티브 값은 래퍼 객체를 갖는다.</p>
<ul>
<li>string을 위한 String객체</li>
<li>number를 위한 Number객체</li>
<li>boolean을 위한 Boolean객체</li>
<li>Symbol을 위한 Symbol객체</li>
</ul>
<p>모두 Bulit-in Object(자바스크립트 내장객체)이다.</p>
</blockquote>
<p>객체는 데이터와 데이터 관련 동작을 모두 포함할 수 있는 개념적 존재이다. 이름(키)과 값으로 구성된 데이터를 의미하는 프로퍼티(property)와 동작을 나타내는 메서드(method)를 포함하고 있는 독립적 주체이다. </p>
<p>객체는 흩어져있는 것들을 모은다는 관점에서 매우 유용하다. 객체 하나는 다른 객체를 포함할 수 있기 때문에 그래프나 트리와 같은 자료구조를 쉽게 표현할 수 있다.</p>
<p><br></p>
<h3 id="1-프로퍼티-property"><a href="#1-프로퍼티-property" class="headerlink" title="1) 프로퍼티(property)"></a>1) 프로퍼티(property)</h3><p>객체는 프로퍼티들을 포함하는 컨테이너라고 할 수 있다. 프로퍼티는 객체의 속성을 나타내는 접근 가능한 이름과 활용 가능한 값을 가지는 특별한 형태이다. 프로퍼티는 객체를 활용함에 있어 매우 유용한 존재이다. 특정 객체가 가진 정보에 직접적으로 접근할 수 있게 해주기 때문이다.</p>
<ul>
<li>프로퍼티 이름 명명 규칙: 빈 문자열을 포함하는 문자열과 숫자</li>
<li>프로퍼티 값: <code>undefined</code> 제외, 모든 값 가능</li>
</ul>
<p>프로퍼티는 기본적으로 이름과 값으로 구성된다. 프로퍼티에 대한 접근 연산자는 <code>.</code>이다. 이 연산자를 통해 프로퍼티에 접근할 수도 있고 프로퍼티를 추가할 수도 있다.</p>
<p><strong><em>Q. 만약 프로퍼티에 아무런 값도 할당하지 않으면 어떻게 될까?</em></strong><br>변수는 값을 할당하지 않고 선언만 할 경우 자바스크립트 엔진이 강제로 <code>undefined</code> 를 할당한다. 하지만 프로퍼티는 값이 할당되지 않는다면 존재 이유가 없다. 객체의 정보를 담고 있어야 하는 요소가 아무 정보도 갖지 않는다면 객체로써는 이 프로퍼티가 쓸모가 없기 때문이다. 그렇기 때문에 프로퍼티를 추가하면서 값을 할당하지 않으면 <code>syntax error</code> 가 발생한다. 만약 값을 비워둬야 한다면 빈문자열(<code>&#39;&#39;</code>)을 넣는 것이 바람직하다.</p>
<p><br></p>
<h3 id="2-메서드-Method"><a href="#2-메서드-Method" class="headerlink" title="2) 메서드(Method)"></a>2) 메서드(Method)</h3><p>메서드는 <strong>객체에 제한되어 있는 함수</strong>를 의미한다. 따라서 메서드 함수의 호출은 객체에 의해서만 가능하다.(=메서드를 호출하는 주체가 해당 함수를 프로퍼티로 가지고 있는 객체이다.) <em><sup>1)</sup>함수를 객체의 프로퍼티로 할당하고, 그 프로퍼티를 사용하여 참조에 의한 호출이 일어나면, 함수는 그 객체의 메서드로 호출된다.</em> 즉 <strong>프로퍼티 값이 함수일 경우</strong>, 일반 함수와 구분하기 위해 메서드라 칭한다.  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;&#125;; <span class="comment">//Object</span></div><div class="line">foo.whatever = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">//method of foo(Object)</span></div><div class="line">foo.whatever();</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="2-객체-생성-방법"><a href="#2-객체-생성-방법" class="headerlink" title="2. 객체 생성 방법"></a>2. 객체 생성 방법</h2><p>자바에서는 클래스를 사전에 정의하고 필요한 시점에 new 연산자를 사용하여 인스턴스를 생성하는 방식으로 객체를 생성한다. 하지만 자바스크립트는 클래스 개념이 없고 별도의 객체 생성 방법이 존재한다.</p>
<h3 id="1-객체-리터럴"><a href="#1-객체-리터럴" class="headerlink" title="1) 객체 리터럴"></a>1) 객체 리터럴</h3><p>가장 일반적이며 간편한 자바스크립트 객체 생성 방식이다. 중괄호(<code>{}</code>)를 이용하여 객체를 생성하는데 <code>{}</code> 내에 아무것도 기술하지 않으면 빈 객체가 생성된다. {} 내에 <strong><code>프로퍼티이름: 프로퍼티값</code></strong> 을 기술하면 해당 프로퍼티가 추가된 객체를 생성할 수 있다. 객체 리터럴 방식의 특징은 new 연산자를 사용할 필요없이 선언과 동시에 인스턴스가 생성된다는 것이다.</p>
<blockquote>
<p><code>{name:value}</code> 형태의 구성 방식을 <strong>JSON(javascript object notation) 방식</strong>이라고 한다. </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> emptyObject = &#123;&#125;;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> emptyObject); <span class="comment">// object</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">  name: <span class="string">'Lee'</span>,</div><div class="line">  gender: <span class="string">'male'</span>,</div><div class="line">  sayHello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Hi! My name is '</span> + <span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> person); <span class="comment">// object</span></div><div class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; name: 'Lee', gender: 'male', sayHello: [Function: sayHello] &#125;</span></div><div class="line"></div><div class="line">person.sayHello(); <span class="comment">// Hi! My name is Lee</span></div><div class="line"><span class="string">`</span></div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="2-Object-생성자-함수"><a href="#2-Object-생성자-함수" class="headerlink" title="2) Object() 생성자 함수"></a>2) Object() 생성자 함수</h3><p>object를 만드는 함수이다. new 연산자를 반드시 함께 사용해야 한다. new 연산자와 함께 사용하여 빈 객체를 생성할 수 있다. 우선 빈 객체를 생성하고, 이후에 프로퍼티와 메서드를 추가하여 객체를 완성하는 방법이다.</p>
<p>객체의 프로퍼티에 새로운 값을 할당하면, 프로퍼티 값은 갱신된다. 객체가 소유하고 있지 않은 프로퍼티에 값을 할당하면, 해당 객체에 프로퍼티 추가하고 값을 할당을 한다. 아래와 같은 방식으로 선언한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">// obj에는 빈 객체가 들어온다.</span></div><div class="line"><span class="comment">//프로퍼티 추가</span></div><div class="line">person.name = <span class="string">'Lee'</span>; <span class="comment">//name 프로퍼티에 'Lee'값을 할당한다.</span></div><div class="line">person.gender = <span class="string">'male'</span>;</div><div class="line">person.sayHello = <span class="string">'Hello'</span>;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>이 방식은 별로 유용하지 않아 보인다.<br>반드시 new 연산자와 Object() 생성자 함수를 사용하여 빈객체를 생성해야 하는 것은 아니다. 객체를 생성하는 방법은 객체 리터럴을 사용하는 것이 더 간편하다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;&#125;;</div><div class="line">person.name = <span class="string">'Lee'</span>;</div><div class="line">person.gender = <span class="string">'male'</span>;</div><div class="line">person.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Hi! My name is '</span> + <span class="keyword">this</span>.name);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>위와 같이 객체를 생성할 수도 있기 때문에다. 사실 이렇게 선언해도 자바스크립트 엔진은 Object 생성자를 불러서 객체를 만든다. 그러니 위와 같은 선언 방식은 shorthand인 셈이다.</p>
<blockquote>
<p>Object() 생성자는 사실 node에서 사용한다.</p>
</blockquote>
<p><br></p>
<h3 id="3-생성자-함수"><a href="#3-생성자-함수" class="headerlink" title="3) 생성자 함수"></a>3) 생성자 함수</h3><p>객체 리터럴 방식과 Object() 생성자 함수 방식으로 객체를 생성하는 것은 프로퍼티 값만 다른 여러개의 객체 생성에 불편이 있다. 동일한 프로퍼티를 갖는 객체임에도 불구하고 매번 같은 프로퍼티를 기술해야한다.<br>따라서, <strong>유사 객체를 다량 생산 해야 할때, 생성자 함수가 매우 유용하게 쓰일 수 있다.</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person1 = &#123;</div><div class="line">  name: <span class="string">'Lee'</span>,</div><div class="line">  gender: <span class="string">'male'</span>,</div><div class="line">  sayHello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Hi! My name is '</span> + <span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person2 = &#123;</div><div class="line">  name: <span class="string">'Kim'</span>,</div><div class="line">  gender: <span class="string">'female'</span>,</div><div class="line">  sayHello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Hi! My name is '</span> + <span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>생성자 함수를 사용하면 마치 객체를 생성하기 위한 탬플릿(클래스)처럼 사용하여 구성이 동일한 객체 여러개를 간편하게 생성할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 생성자 함수</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, gender</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.gender = gender;</div><div class="line">  <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Hi! My name is '</span> + <span class="keyword">this</span>.name);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 인스턴스의 생성</span></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Lee'</span>, <span class="string">'male'</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Kim'</span>, <span class="string">'female'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'person1: '</span>, <span class="keyword">typeof</span> person1);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'person2: '</span>, <span class="keyword">typeof</span> person2);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'person1: '</span>, person1);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'person2: '</span>, person2);</div><div class="line"></div><div class="line">person1.sayHello();</div><div class="line">person2.sayHello();</div></pre></td></tr></table></figure>
<blockquote>
<p>생성자는 인스턴스를 찍어내는 공장이며, 인스턴스는 실제 객체이다.</p>
</blockquote>
<p>생성자는 일반 함수로 사용하지 않고, 객체를 찍어낼 때만 사용해야 한다. 따라서 첫 문자를 대문자로 하는 관습이 있다. 생성자 함수임을 인식하는데 도움을 주기 위함이다. 따라서 생성자를 만들때는 이 관습을 지켜 네이밍하도록 한다.</p>
<p>프로퍼티 또는 메서드명 앞에 기술한 <code>this</code>는 생성자 함수로 생성될 인스턴스를 가리킨다. 따라서 <code>this</code>에 연결되어 있는 프로퍼티와 메서드는 <code>public</code>이다.</p>
<hr>
<p><br></p>
<h2 id="3-객체-프로퍼티-접근"><a href="#3-객체-프로퍼티-접근" class="headerlink" title="3. 객체 프로퍼티 접근"></a>3. 객체 프로퍼티 접근</h2><p>1) 프로퍼티 이름<br>프로퍼티 이름에는 문자열(빈 문자열 포함)과 숫자가 올 수 있다. 프로퍼티 값은 undefined을 제외한 모든 값과 표현식이 올 수 있으며 프로퍼티 값이 함수인 경우 이를 메서드라 한다.</p>
<p>프로퍼티 이름의 따옴표(‘’ 또는 ““)는 자바스크립트에서 사용할 수 있는 유효한 이름이고 예약어가 아닌 경우 생략할 수 있다. 반대로 말하면 <strong>자바스크립트에서 사용할 수 있는 유효한 이름이 아닌 경우 반드시 따옴표를 사용</strong>하여야 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">  <span class="string">'first-name'</span>: <span class="string">'Ung-mo'</span>, <span class="comment">/* 유효하지 않은 이름, 연산자가 있는 표현식 */</span></div><div class="line">  <span class="string">'last-name'</span>: <span class="string">'Lee'</span>, <span class="comment">/* 프로퍼티 이름에 따옴표를 쓰지 않으면, 연산을 수행한다. last라는 변수를 찾으려고 할 것이다. 이로 인해 에러가 발생한다. */</span></div><div class="line">  gender: <span class="string">'male'</span>,</div><div class="line">  <span class="function"><span class="keyword">function</span>: 1 /* <span class="title">OK</span>. 하지만 예약어는 사용하지 말아야 한다. */</span></div><div class="line"><span class="function">&#125;;</span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="title">console</span>.<span class="title">log</span>(<span class="params">person.function</span>);</span></div></pre></td></tr></table></figure>
<blockquote>
<p><strong>명명 규칙</strong>  </p>
</blockquote>
<ul>
<li>스네이크케이스: 공백(space) 대신 _(언더라인) 사용 (e.g. <code>first_name</code>)</li>
<li>케밥케이스: 공백 대신 - 사용 (e.g. <code>first-name</code>)</li>
<li>카멜케이스: 공백 대신 앞 문자를 대문자로 (e.g. <code>firstName</code>)</li>
</ul>
<p>또한 예약어와 키워드는 사용하면 안 된다. 사용하여도 에러를 발생시키지는 않지만, 언제 에상치 못한 에러가 발생할지 모르기 때문이다.</p>
<h3 id="2-프로퍼티-값-읽기"><a href="#2-프로퍼티-값-읽기" class="headerlink" title="2) 프로퍼티 값 읽기"></a>2) 프로퍼티 값 읽기</h3><p>객체의 프로퍼티에 접근하려면 아래 두 방법을 사용한다.</p>
<ul>
<li>마침표(.) 표기법</li>
<li>대괄호([])표기법</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">  <span class="string">'first-name'</span>: <span class="string">'Ung-mo'</span>,</div><div class="line">  <span class="string">'last-name'</span>: <span class="string">'Lee'</span>,</div><div class="line">  gender: <span class="string">'male'</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.first-name);     <span class="comment">// NaN: undefined-name, first-name은 마이너스 연산을 하려고 하기 때문에 프로퍼티에 접근하기도 전에 프로퍼티 명에서부터 NaN을 반환한다.</span></div><div class="line"><span class="built_in">console</span>.log(person[first-name]);   <span class="comment">// ReferenceError: first is not defined</span></div><div class="line"><span class="built_in">console</span>.log(person[<span class="string">'first-name'</span>]); <span class="comment">// 'Ung-mo'</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.gender);    <span class="comment">// 'male'</span></div><div class="line"><span class="built_in">console</span>.log(person[gender]);   <span class="comment">// ReferenceError: gender is not defined</span></div><div class="line"><span class="built_in">console</span>.log(person[<span class="string">'gender'</span>]); <span class="comment">// 'male'</span></div></pre></td></tr></table></figure>
<p>프로퍼티 이름이 유효한 자바스크립트 이름이고 예약어가 아닌 경우 프로퍼티 값은 마침표 표기법, 대괄호 표기법 모두 사용할 수 있다.</p>
<p>프로퍼티 이름이 유효한 자바스크립트 이름이 아니거나 예약어인 경우 프로퍼티 값은 대괄호 표기법으로 읽어야 한다. 대괄호([]) 표기법을 사용하는 경우, <strong>대괄호 내에 들어가는 프로퍼티 이름은 반드시 문자열</strong>이어야 한다.</p>
<p>객체에 존재하지 않는 프로퍼티를 참조하면 <code>undefined</code>를 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">  <span class="string">'first-name'</span>: <span class="string">'Ung-mo'</span>,</div><div class="line">  <span class="string">'last-name'</span>: <span class="string">'Lee'</span>,</div><div class="line">  gender: <span class="string">'male'</span>,</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.age); <span class="comment">// undefined</span></div><div class="line"><span class="string">`</span></div></pre></td></tr></table></figure>
<h3 id="3-프로퍼티-값-갱신"><a href="#3-프로퍼티-값-갱신" class="headerlink" title="3) 프로퍼티 값 갱신"></a>3) 프로퍼티 값 갱신</h3><p>객체가 소유하고 있는 프로퍼티에 새로운 값을 할당하면 프로퍼티 값은 새로운 값으로 갱신된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">  <span class="string">'first-name'</span>: <span class="string">'Ung-mo'</span>,</div><div class="line">  <span class="string">'last-name'</span>: <span class="string">'Lee'</span>,</div><div class="line">  gender: <span class="string">'male'</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">person[<span class="string">'first-name'</span>] = <span class="string">'Kim'</span>;</div><div class="line"><span class="built_in">console</span>.log(person[<span class="string">'first-name'</span>] ); <span class="comment">// 'Kim'</span></div></pre></td></tr></table></figure>
<h3 id="4-프로퍼티-동적-생성"><a href="#4-프로퍼티-동적-생성" class="headerlink" title="4) 프로퍼티 동적 생성"></a>4) 프로퍼티 동적 생성</h3><p>객체가 소유하고 있지 않은 프로퍼티에 값을 할당하면 하면 해당 프로퍼티를 객체에 추가하고 값을 할당한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">  <span class="string">'first-name'</span>: <span class="string">'Ung-mo'</span>,</div><div class="line">  <span class="string">'last-name'</span>: <span class="string">'Lee'</span>,</div><div class="line">  gender: <span class="string">'male'</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">person.age = <span class="number">20</span>;</div><div class="line"><span class="built_in">console</span>.log(person.age); <span class="comment">// 20</span></div></pre></td></tr></table></figure>
<h3 id="5-프로퍼티-삭제"><a href="#5-프로퍼티-삭제" class="headerlink" title="5) 프로퍼티 삭제"></a>5) 프로퍼티 삭제</h3><p><code>delete</code> 연산자를 사용하면 객체의 프로퍼티를 삭제할 수 있다. <code>delete</code> 연산자는 당연하게도, 객체가 소유하지 않는 프로퍼티에 적용할 수 없다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">  <span class="string">'first-name'</span>: <span class="string">'Ung-mo'</span>,</div><div class="line">  <span class="string">'last-name'</span>: <span class="string">'Lee'</span>,</div><div class="line">  gender: <span class="string">'male'</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">delete</span> person.gender;</div><div class="line"><span class="built_in">console</span>.log(person.gender); <span class="comment">// undefined</span></div><div class="line"></div><div class="line"><span class="keyword">delete</span> person;</div><div class="line"><span class="built_in">console</span>.log(person); <span class="comment">// Object &#123;first-name: 'Ung-mo', last-name: 'Lee'&#125;</span></div></pre></td></tr></table></figure>
<h3 id="6-for-in문"><a href="#6-for-in문" class="headerlink" title="6) for-in문"></a>6) for-in문</h3><p><code>for-in</code>문을 사용하면 객체에 포함된 모든 프로퍼티에 대해 루프를 수행할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">  <span class="string">'first-name'</span>: <span class="string">'Ung-mo'</span>,</div><div class="line">  <span class="string">'last-name'</span>: <span class="string">'Lee'</span>,</div><div class="line">  gender: <span class="string">'male'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> prop <span class="keyword">in</span> person) &#123;</div><div class="line">  <span class="built_in">console</span>.log(prop + <span class="string">': '</span> + person[prop]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">first-name: Ung-mo</span></div><div class="line"><span class="comment">last-name: Lee</span></div><div class="line"><span class="comment">gender: male</span></div><div class="line"><span class="comment">*/</span></div></pre></td></tr></table></figure>
<p>for-in문은 여러가지 이유로 사용하지 않는다. 일단, 순서가 보장되지 않는다. es6에서 이를 보완한 for ~ of문이 나와있다. </p>
<h1 id="4-Pass-by-reference"><a href="#4-Pass-by-reference" class="headerlink" title="4. Pass-by-reference"></a>4. Pass-by-reference</h1><p>기본자료형 object를 객체형 또는 참조형이라 한다. 참조형이란 객체의 모든 연산이 실제값이 아닌 참조값으로 처리됨을 의미한다.<br>이에 반해 기본자료형의 값은 값(value)으로 전달된다. 즉 복사되어 전달된다. 이를 pass-by-value라고 한다.<br>기본자료형은 값이 한번 정해지면 변경할 수 없지만(immutable), 객체는 변경 가능한 프로퍼티들의 집합이라 할 수 있다.</p>
<p>참조값을 준다는 것은 <strong>단일 객체</strong>를 사용한다는 의미이다.</p>
<p><a href="http://poiemaweb.com/js-immutability" target="_blank" rel="external">immutable</a>객체는 참조형이다. 객체에 객체를 할당했을 때, 결국 똑같은 객체를 가리킨다.</p>
<h1 id="5-Pass-by-value"><a href="#5-Pass-by-value" class="headerlink" title="5. Pass-by-value"></a>5. Pass-by-value</h1><h1 id="6-객체의-분류"><a href="#6-객체의-분류" class="headerlink" title="6. 객체의 분류"></a>6. 객체의 분류</h1><p><img src="http://poiemaweb.com/img/object.png" alt="객체의 분류"></p>
<p>Bulit-in Object(내장 객체)</p>
<ul>
<li>Standard Built-in Object(or Global Objects)</li>
</ul>
<ul>
<li>Native Object<ul>
<li>BOM(Browser Object Model): 브라우저에 대한 것을 컨트롤하기 위한 객체 (e.g. 스크롤)</li>
<li>DOM(Document Object Model): html과 css에 대한 정보를 담고 있는 객체</li>
</ul>
</li>
</ul>
<hr>
<p>[참고]<br><a href="http://poiemaweb.com/js-data-type-variable" target="_blank" rel="external">Poeima web</a><br><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript" target="_blank" rel="external">MDN ko</a><br><a href="http://insanehong.kr/post/javascript-object/" target="_blank" rel="external">blog</a><br><a href="https://hyunseob.github.io/2016/03/10/javascript-this/" target="_blank" rel="external">blog - this</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Object&quot;&gt;&lt;a href=&quot;#Object&quot; class=&quot;headerlink&quot; title=&quot;Object&quot;&gt;&lt;/a&gt;Object&lt;/h1&gt;&lt;h2 id=&quot;1-객체-Object-란&quot;&gt;&lt;a href=&quot;#1-객체-Object-란&quot; class=&quot;he
    
    </summary>
    
      <category term="Javascript" scheme="http://huusz.github.io/categories/Javascript/"/>
    
    
      <category term="object" scheme="http://huusz.github.io/tags/object/"/>
    
  </entry>
  
</feed>
